// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages_gamenotifications.steamclient.proto

#include "steammessages_gamenotifications.steamclient.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

extern PROTOBUF_INTERNAL_EXPORT_steammessages_5fgamenotifications_2esteamclient_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_CGameNotifications_GetSessionDetails_Request_RequestedSession_steammessages_5fgamenotifications_2esteamclient_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_steammessages_5fgamenotifications_2esteamclient_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_CGameNotifications_Variable_steammessages_5fgamenotifications_2esteamclient_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_steammessages_5fgamenotifications_2esteamclient_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_GameNotificationSettings_steammessages_5fgamenotifications_2esteamclient_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_steammessages_5fgamenotifications_2esteamclient_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_CGameNotifications_LocalizedText_steammessages_5fgamenotifications_2esteamclient_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_steammessages_5fgamenotifications_2esteamclient_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_CGameNotifications_UserStatus_steammessages_5fgamenotifications_2esteamclient_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_steammessages_5fgamenotifications_2esteamclient_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_CGameNotifications_Session_steammessages_5fgamenotifications_2esteamclient_2eproto;
namespace proto {
namespace steam {
class CGameNotifications_VariableDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CGameNotifications_Variable> _instance;
} _CGameNotifications_Variable_default_instance_;
class CGameNotifications_LocalizedTextDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CGameNotifications_LocalizedText> _instance;
} _CGameNotifications_LocalizedText_default_instance_;
class CGameNotifications_UserStatusDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CGameNotifications_UserStatus> _instance;
} _CGameNotifications_UserStatus_default_instance_;
class CGameNotifications_CreateSession_RequestDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CGameNotifications_CreateSession_Request> _instance;
} _CGameNotifications_CreateSession_Request_default_instance_;
class CGameNotifications_CreateSession_ResponseDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CGameNotifications_CreateSession_Response> _instance;
} _CGameNotifications_CreateSession_Response_default_instance_;
class CGameNotifications_DeleteSession_RequestDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CGameNotifications_DeleteSession_Request> _instance;
} _CGameNotifications_DeleteSession_Request_default_instance_;
class CGameNotifications_DeleteSession_ResponseDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CGameNotifications_DeleteSession_Response> _instance;
} _CGameNotifications_DeleteSession_Response_default_instance_;
class CGameNotifications_UpdateSession_RequestDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CGameNotifications_UpdateSession_Request> _instance;
} _CGameNotifications_UpdateSession_Request_default_instance_;
class CGameNotifications_UpdateSession_ResponseDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CGameNotifications_UpdateSession_Response> _instance;
} _CGameNotifications_UpdateSession_Response_default_instance_;
class CGameNotifications_EnumerateSessions_RequestDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CGameNotifications_EnumerateSessions_Request> _instance;
} _CGameNotifications_EnumerateSessions_Request_default_instance_;
class CGameNotifications_SessionDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CGameNotifications_Session> _instance;
} _CGameNotifications_Session_default_instance_;
class CGameNotifications_EnumerateSessions_ResponseDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CGameNotifications_EnumerateSessions_Response> _instance;
} _CGameNotifications_EnumerateSessions_Response_default_instance_;
class CGameNotifications_GetSessionDetails_Request_RequestedSessionDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CGameNotifications_GetSessionDetails_Request_RequestedSession> _instance;
} _CGameNotifications_GetSessionDetails_Request_RequestedSession_default_instance_;
class CGameNotifications_GetSessionDetails_RequestDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CGameNotifications_GetSessionDetails_Request> _instance;
} _CGameNotifications_GetSessionDetails_Request_default_instance_;
class CGameNotifications_GetSessionDetails_ResponseDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CGameNotifications_GetSessionDetails_Response> _instance;
} _CGameNotifications_GetSessionDetails_Response_default_instance_;
class GameNotificationSettingsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GameNotificationSettings> _instance;
} _GameNotificationSettings_default_instance_;
class CGameNotifications_UpdateNotificationSettings_RequestDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CGameNotifications_UpdateNotificationSettings_Request> _instance;
} _CGameNotifications_UpdateNotificationSettings_Request_default_instance_;
class CGameNotifications_UpdateNotificationSettings_ResponseDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CGameNotifications_UpdateNotificationSettings_Response> _instance;
} _CGameNotifications_UpdateNotificationSettings_Response_default_instance_;
class CGameNotifications_OnNotificationsRequested_NotificationDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CGameNotifications_OnNotificationsRequested_Notification> _instance;
} _CGameNotifications_OnNotificationsRequested_Notification_default_instance_;
class CGameNotifications_OnUserStatusChanged_NotificationDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CGameNotifications_OnUserStatusChanged_Notification> _instance;
} _CGameNotifications_OnUserStatusChanged_Notification_default_instance_;
}  // namespace steam
}  // namespace proto
static void InitDefaultsCGameNotifications_Variable_steammessages_5fgamenotifications_2esteamclient_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::steam::_CGameNotifications_Variable_default_instance_;
    new (ptr) ::proto::steam::CGameNotifications_Variable();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::steam::CGameNotifications_Variable::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_CGameNotifications_Variable_steammessages_5fgamenotifications_2esteamclient_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsCGameNotifications_Variable_steammessages_5fgamenotifications_2esteamclient_2eproto}, {}};

static void InitDefaultsCGameNotifications_LocalizedText_steammessages_5fgamenotifications_2esteamclient_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::steam::_CGameNotifications_LocalizedText_default_instance_;
    new (ptr) ::proto::steam::CGameNotifications_LocalizedText();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::steam::CGameNotifications_LocalizedText::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CGameNotifications_LocalizedText_steammessages_5fgamenotifications_2esteamclient_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCGameNotifications_LocalizedText_steammessages_5fgamenotifications_2esteamclient_2eproto}, {
      &scc_info_CGameNotifications_Variable_steammessages_5fgamenotifications_2esteamclient_2eproto.base,}};

static void InitDefaultsCGameNotifications_UserStatus_steammessages_5fgamenotifications_2esteamclient_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::steam::_CGameNotifications_UserStatus_default_instance_;
    new (ptr) ::proto::steam::CGameNotifications_UserStatus();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::steam::CGameNotifications_UserStatus::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CGameNotifications_UserStatus_steammessages_5fgamenotifications_2esteamclient_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCGameNotifications_UserStatus_steammessages_5fgamenotifications_2esteamclient_2eproto}, {
      &scc_info_CGameNotifications_LocalizedText_steammessages_5fgamenotifications_2esteamclient_2eproto.base,}};

static void InitDefaultsCGameNotifications_CreateSession_Request_steammessages_5fgamenotifications_2esteamclient_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::steam::_CGameNotifications_CreateSession_Request_default_instance_;
    new (ptr) ::proto::steam::CGameNotifications_CreateSession_Request();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::steam::CGameNotifications_CreateSession_Request::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_CGameNotifications_CreateSession_Request_steammessages_5fgamenotifications_2esteamclient_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsCGameNotifications_CreateSession_Request_steammessages_5fgamenotifications_2esteamclient_2eproto}, {
      &scc_info_CGameNotifications_LocalizedText_steammessages_5fgamenotifications_2esteamclient_2eproto.base,
      &scc_info_CGameNotifications_UserStatus_steammessages_5fgamenotifications_2esteamclient_2eproto.base,}};

static void InitDefaultsCGameNotifications_CreateSession_Response_steammessages_5fgamenotifications_2esteamclient_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::steam::_CGameNotifications_CreateSession_Response_default_instance_;
    new (ptr) ::proto::steam::CGameNotifications_CreateSession_Response();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::steam::CGameNotifications_CreateSession_Response::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_CGameNotifications_CreateSession_Response_steammessages_5fgamenotifications_2esteamclient_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsCGameNotifications_CreateSession_Response_steammessages_5fgamenotifications_2esteamclient_2eproto}, {}};

static void InitDefaultsCGameNotifications_DeleteSession_Request_steammessages_5fgamenotifications_2esteamclient_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::steam::_CGameNotifications_DeleteSession_Request_default_instance_;
    new (ptr) ::proto::steam::CGameNotifications_DeleteSession_Request();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::steam::CGameNotifications_DeleteSession_Request::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_CGameNotifications_DeleteSession_Request_steammessages_5fgamenotifications_2esteamclient_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsCGameNotifications_DeleteSession_Request_steammessages_5fgamenotifications_2esteamclient_2eproto}, {}};

static void InitDefaultsCGameNotifications_DeleteSession_Response_steammessages_5fgamenotifications_2esteamclient_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::steam::_CGameNotifications_DeleteSession_Response_default_instance_;
    new (ptr) ::proto::steam::CGameNotifications_DeleteSession_Response();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::steam::CGameNotifications_DeleteSession_Response::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_CGameNotifications_DeleteSession_Response_steammessages_5fgamenotifications_2esteamclient_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsCGameNotifications_DeleteSession_Response_steammessages_5fgamenotifications_2esteamclient_2eproto}, {}};

static void InitDefaultsCGameNotifications_UpdateSession_Request_steammessages_5fgamenotifications_2esteamclient_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::steam::_CGameNotifications_UpdateSession_Request_default_instance_;
    new (ptr) ::proto::steam::CGameNotifications_UpdateSession_Request();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::steam::CGameNotifications_UpdateSession_Request::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_CGameNotifications_UpdateSession_Request_steammessages_5fgamenotifications_2esteamclient_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsCGameNotifications_UpdateSession_Request_steammessages_5fgamenotifications_2esteamclient_2eproto}, {
      &scc_info_CGameNotifications_LocalizedText_steammessages_5fgamenotifications_2esteamclient_2eproto.base,
      &scc_info_CGameNotifications_UserStatus_steammessages_5fgamenotifications_2esteamclient_2eproto.base,}};

static void InitDefaultsCGameNotifications_UpdateSession_Response_steammessages_5fgamenotifications_2esteamclient_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::steam::_CGameNotifications_UpdateSession_Response_default_instance_;
    new (ptr) ::proto::steam::CGameNotifications_UpdateSession_Response();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::steam::CGameNotifications_UpdateSession_Response::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_CGameNotifications_UpdateSession_Response_steammessages_5fgamenotifications_2esteamclient_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsCGameNotifications_UpdateSession_Response_steammessages_5fgamenotifications_2esteamclient_2eproto}, {}};

static void InitDefaultsCGameNotifications_EnumerateSessions_Request_steammessages_5fgamenotifications_2esteamclient_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::steam::_CGameNotifications_EnumerateSessions_Request_default_instance_;
    new (ptr) ::proto::steam::CGameNotifications_EnumerateSessions_Request();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::steam::CGameNotifications_EnumerateSessions_Request::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_CGameNotifications_EnumerateSessions_Request_steammessages_5fgamenotifications_2esteamclient_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsCGameNotifications_EnumerateSessions_Request_steammessages_5fgamenotifications_2esteamclient_2eproto}, {}};

static void InitDefaultsCGameNotifications_Session_steammessages_5fgamenotifications_2esteamclient_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::steam::_CGameNotifications_Session_default_instance_;
    new (ptr) ::proto::steam::CGameNotifications_Session();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::steam::CGameNotifications_Session::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_CGameNotifications_Session_steammessages_5fgamenotifications_2esteamclient_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsCGameNotifications_Session_steammessages_5fgamenotifications_2esteamclient_2eproto}, {
      &scc_info_CGameNotifications_LocalizedText_steammessages_5fgamenotifications_2esteamclient_2eproto.base,
      &scc_info_CGameNotifications_UserStatus_steammessages_5fgamenotifications_2esteamclient_2eproto.base,}};

static void InitDefaultsCGameNotifications_EnumerateSessions_Response_steammessages_5fgamenotifications_2esteamclient_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::steam::_CGameNotifications_EnumerateSessions_Response_default_instance_;
    new (ptr) ::proto::steam::CGameNotifications_EnumerateSessions_Response();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::steam::CGameNotifications_EnumerateSessions_Response::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CGameNotifications_EnumerateSessions_Response_steammessages_5fgamenotifications_2esteamclient_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCGameNotifications_EnumerateSessions_Response_steammessages_5fgamenotifications_2esteamclient_2eproto}, {
      &scc_info_CGameNotifications_Session_steammessages_5fgamenotifications_2esteamclient_2eproto.base,}};

static void InitDefaultsCGameNotifications_GetSessionDetails_Request_RequestedSession_steammessages_5fgamenotifications_2esteamclient_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::steam::_CGameNotifications_GetSessionDetails_Request_RequestedSession_default_instance_;
    new (ptr) ::proto::steam::CGameNotifications_GetSessionDetails_Request_RequestedSession();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::steam::CGameNotifications_GetSessionDetails_Request_RequestedSession::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_CGameNotifications_GetSessionDetails_Request_RequestedSession_steammessages_5fgamenotifications_2esteamclient_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsCGameNotifications_GetSessionDetails_Request_RequestedSession_steammessages_5fgamenotifications_2esteamclient_2eproto}, {}};

static void InitDefaultsCGameNotifications_GetSessionDetails_Request_steammessages_5fgamenotifications_2esteamclient_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::steam::_CGameNotifications_GetSessionDetails_Request_default_instance_;
    new (ptr) ::proto::steam::CGameNotifications_GetSessionDetails_Request();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::steam::CGameNotifications_GetSessionDetails_Request::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CGameNotifications_GetSessionDetails_Request_steammessages_5fgamenotifications_2esteamclient_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCGameNotifications_GetSessionDetails_Request_steammessages_5fgamenotifications_2esteamclient_2eproto}, {
      &scc_info_CGameNotifications_GetSessionDetails_Request_RequestedSession_steammessages_5fgamenotifications_2esteamclient_2eproto.base,}};

static void InitDefaultsCGameNotifications_GetSessionDetails_Response_steammessages_5fgamenotifications_2esteamclient_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::steam::_CGameNotifications_GetSessionDetails_Response_default_instance_;
    new (ptr) ::proto::steam::CGameNotifications_GetSessionDetails_Response();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::steam::CGameNotifications_GetSessionDetails_Response::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CGameNotifications_GetSessionDetails_Response_steammessages_5fgamenotifications_2esteamclient_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCGameNotifications_GetSessionDetails_Response_steammessages_5fgamenotifications_2esteamclient_2eproto}, {
      &scc_info_CGameNotifications_Session_steammessages_5fgamenotifications_2esteamclient_2eproto.base,}};

static void InitDefaultsGameNotificationSettings_steammessages_5fgamenotifications_2esteamclient_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::steam::_GameNotificationSettings_default_instance_;
    new (ptr) ::proto::steam::GameNotificationSettings();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::steam::GameNotificationSettings::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_GameNotificationSettings_steammessages_5fgamenotifications_2esteamclient_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsGameNotificationSettings_steammessages_5fgamenotifications_2esteamclient_2eproto}, {}};

static void InitDefaultsCGameNotifications_UpdateNotificationSettings_Request_steammessages_5fgamenotifications_2esteamclient_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::steam::_CGameNotifications_UpdateNotificationSettings_Request_default_instance_;
    new (ptr) ::proto::steam::CGameNotifications_UpdateNotificationSettings_Request();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::steam::CGameNotifications_UpdateNotificationSettings_Request::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CGameNotifications_UpdateNotificationSettings_Request_steammessages_5fgamenotifications_2esteamclient_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCGameNotifications_UpdateNotificationSettings_Request_steammessages_5fgamenotifications_2esteamclient_2eproto}, {
      &scc_info_GameNotificationSettings_steammessages_5fgamenotifications_2esteamclient_2eproto.base,}};

static void InitDefaultsCGameNotifications_UpdateNotificationSettings_Response_steammessages_5fgamenotifications_2esteamclient_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::steam::_CGameNotifications_UpdateNotificationSettings_Response_default_instance_;
    new (ptr) ::proto::steam::CGameNotifications_UpdateNotificationSettings_Response();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::steam::CGameNotifications_UpdateNotificationSettings_Response::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_CGameNotifications_UpdateNotificationSettings_Response_steammessages_5fgamenotifications_2esteamclient_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsCGameNotifications_UpdateNotificationSettings_Response_steammessages_5fgamenotifications_2esteamclient_2eproto}, {}};

static void InitDefaultsCGameNotifications_OnNotificationsRequested_Notification_steammessages_5fgamenotifications_2esteamclient_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::steam::_CGameNotifications_OnNotificationsRequested_Notification_default_instance_;
    new (ptr) ::proto::steam::CGameNotifications_OnNotificationsRequested_Notification();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::steam::CGameNotifications_OnNotificationsRequested_Notification::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_CGameNotifications_OnNotificationsRequested_Notification_steammessages_5fgamenotifications_2esteamclient_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsCGameNotifications_OnNotificationsRequested_Notification_steammessages_5fgamenotifications_2esteamclient_2eproto}, {}};

static void InitDefaultsCGameNotifications_OnUserStatusChanged_Notification_steammessages_5fgamenotifications_2esteamclient_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::steam::_CGameNotifications_OnUserStatusChanged_Notification_default_instance_;
    new (ptr) ::proto::steam::CGameNotifications_OnUserStatusChanged_Notification();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::steam::CGameNotifications_OnUserStatusChanged_Notification::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CGameNotifications_OnUserStatusChanged_Notification_steammessages_5fgamenotifications_2esteamclient_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCGameNotifications_OnUserStatusChanged_Notification_steammessages_5fgamenotifications_2esteamclient_2eproto}, {
      &scc_info_CGameNotifications_UserStatus_steammessages_5fgamenotifications_2esteamclient_2eproto.base,}};

void InitDefaults_steammessages_5fgamenotifications_2esteamclient_2eproto() {
  ::google::protobuf::internal::InitSCC(&scc_info_CGameNotifications_Variable_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CGameNotifications_LocalizedText_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CGameNotifications_UserStatus_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CGameNotifications_CreateSession_Request_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CGameNotifications_CreateSession_Response_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CGameNotifications_DeleteSession_Request_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CGameNotifications_DeleteSession_Response_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CGameNotifications_UpdateSession_Request_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CGameNotifications_UpdateSession_Response_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CGameNotifications_EnumerateSessions_Request_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CGameNotifications_Session_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CGameNotifications_EnumerateSessions_Response_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CGameNotifications_GetSessionDetails_Request_RequestedSession_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CGameNotifications_GetSessionDetails_Request_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CGameNotifications_GetSessionDetails_Response_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_GameNotificationSettings_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CGameNotifications_UpdateNotificationSettings_Request_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CGameNotifications_UpdateNotificationSettings_Response_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CGameNotifications_OnNotificationsRequested_Notification_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CGameNotifications_OnUserStatusChanged_Notification_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
}

::google::protobuf::Metadata file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[20];
constexpr ::google::protobuf::EnumDescriptor const** file_level_enum_descriptors_steammessages_5fgamenotifications_2esteamclient_2eproto = nullptr;
const ::google::protobuf::ServiceDescriptor* file_level_service_descriptors_steammessages_5fgamenotifications_2esteamclient_2eproto[2];

const ::google::protobuf::uint32 TableStruct_steammessages_5fgamenotifications_2esteamclient_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_Variable, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_Variable, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_Variable, key_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_Variable, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_LocalizedText, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_LocalizedText, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_LocalizedText, token_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_LocalizedText, variables_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_LocalizedText, rendered_text_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_UserStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_UserStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_UserStatus, steamid_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_UserStatus, state_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_UserStatus, title_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_UserStatus, message_),
  3,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_CreateSession_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_CreateSession_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_CreateSession_Request, appid_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_CreateSession_Request, context_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_CreateSession_Request, title_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_CreateSession_Request, users_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_CreateSession_Request, steamid_),
  3,
  1,
  0,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_CreateSession_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_CreateSession_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_CreateSession_Response, sessionid_),
  0,
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_DeleteSession_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_DeleteSession_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_DeleteSession_Request, sessionid_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_DeleteSession_Request, appid_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_DeleteSession_Request, steamid_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_DeleteSession_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_DeleteSession_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_UpdateSession_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_UpdateSession_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_UpdateSession_Request, sessionid_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_UpdateSession_Request, appid_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_UpdateSession_Request, title_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_UpdateSession_Request, users_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_UpdateSession_Request, steamid_),
  1,
  3,
  0,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_UpdateSession_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_UpdateSession_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_EnumerateSessions_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_EnumerateSessions_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_EnumerateSessions_Request, appid_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_EnumerateSessions_Request, include_all_user_messages_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_EnumerateSessions_Request, include_auth_user_message_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_EnumerateSessions_Request, language_),
  1,
  2,
  3,
  0,
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_Session, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_Session, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_Session, sessionid_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_Session, appid_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_Session, context_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_Session, title_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_Session, time_created_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_Session, time_updated_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_Session, user_status_),
  1,
  2,
  3,
  0,
  4,
  5,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_EnumerateSessions_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_EnumerateSessions_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_EnumerateSessions_Response, sessions_),
  ~0u,
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_GetSessionDetails_Request_RequestedSession, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_GetSessionDetails_Request_RequestedSession, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_GetSessionDetails_Request_RequestedSession, sessionid_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_GetSessionDetails_Request_RequestedSession, include_auth_user_message_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_GetSessionDetails_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_GetSessionDetails_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_GetSessionDetails_Request, sessions_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_GetSessionDetails_Request, appid_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_GetSessionDetails_Request, language_),
  ~0u,
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_GetSessionDetails_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_GetSessionDetails_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_GetSessionDetails_Response, sessions_),
  ~0u,
  PROTOBUF_FIELD_OFFSET(::proto::steam::GameNotificationSettings, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::GameNotificationSettings, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::steam::GameNotificationSettings, appid_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::GameNotificationSettings, allow_notifications_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_UpdateNotificationSettings_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_UpdateNotificationSettings_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_UpdateNotificationSettings_Request, game_notification_settings_),
  ~0u,
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_UpdateNotificationSettings_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_UpdateNotificationSettings_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_OnNotificationsRequested_Notification, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_OnNotificationsRequested_Notification, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_OnNotificationsRequested_Notification, steamid_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_OnNotificationsRequested_Notification, appid_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_OnUserStatusChanged_Notification, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_OnUserStatusChanged_Notification, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_OnUserStatusChanged_Notification, steamid_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_OnUserStatusChanged_Notification, sessionid_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_OnUserStatusChanged_Notification, appid_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_OnUserStatusChanged_Notification, status_),
  PROTOBUF_FIELD_OFFSET(::proto::steam::CGameNotifications_OnUserStatusChanged_Notification, removed_),
  1,
  2,
  3,
  0,
  4,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, sizeof(::proto::steam::CGameNotifications_Variable)},
  { 9, 17, sizeof(::proto::steam::CGameNotifications_LocalizedText)},
  { 20, 29, sizeof(::proto::steam::CGameNotifications_UserStatus)},
  { 33, 43, sizeof(::proto::steam::CGameNotifications_CreateSession_Request)},
  { 48, 54, sizeof(::proto::steam::CGameNotifications_CreateSession_Response)},
  { 55, 63, sizeof(::proto::steam::CGameNotifications_DeleteSession_Request)},
  { 66, 71, sizeof(::proto::steam::CGameNotifications_DeleteSession_Response)},
  { 71, 81, sizeof(::proto::steam::CGameNotifications_UpdateSession_Request)},
  { 86, 91, sizeof(::proto::steam::CGameNotifications_UpdateSession_Response)},
  { 91, 100, sizeof(::proto::steam::CGameNotifications_EnumerateSessions_Request)},
  { 104, 116, sizeof(::proto::steam::CGameNotifications_Session)},
  { 123, 129, sizeof(::proto::steam::CGameNotifications_EnumerateSessions_Response)},
  { 130, 137, sizeof(::proto::steam::CGameNotifications_GetSessionDetails_Request_RequestedSession)},
  { 139, 147, sizeof(::proto::steam::CGameNotifications_GetSessionDetails_Request)},
  { 150, 156, sizeof(::proto::steam::CGameNotifications_GetSessionDetails_Response)},
  { 157, 164, sizeof(::proto::steam::GameNotificationSettings)},
  { 166, 172, sizeof(::proto::steam::CGameNotifications_UpdateNotificationSettings_Request)},
  { 173, 178, sizeof(::proto::steam::CGameNotifications_UpdateNotificationSettings_Response)},
  { 178, 185, sizeof(::proto::steam::CGameNotifications_OnNotificationsRequested_Notification)},
  { 187, 197, sizeof(::proto::steam::CGameNotifications_OnUserStatusChanged_Notification)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::steam::_CGameNotifications_Variable_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::steam::_CGameNotifications_LocalizedText_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::steam::_CGameNotifications_UserStatus_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::steam::_CGameNotifications_CreateSession_Request_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::steam::_CGameNotifications_CreateSession_Response_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::steam::_CGameNotifications_DeleteSession_Request_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::steam::_CGameNotifications_DeleteSession_Response_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::steam::_CGameNotifications_UpdateSession_Request_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::steam::_CGameNotifications_UpdateSession_Response_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::steam::_CGameNotifications_EnumerateSessions_Request_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::steam::_CGameNotifications_Session_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::steam::_CGameNotifications_EnumerateSessions_Response_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::steam::_CGameNotifications_GetSessionDetails_Request_RequestedSession_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::steam::_CGameNotifications_GetSessionDetails_Request_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::steam::_CGameNotifications_GetSessionDetails_Response_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::steam::_GameNotificationSettings_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::steam::_CGameNotifications_UpdateNotificationSettings_Request_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::steam::_CGameNotifications_UpdateNotificationSettings_Response_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::steam::_CGameNotifications_OnNotificationsRequested_Notification_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::steam::_CGameNotifications_OnUserStatusChanged_Notification_default_instance_),
};

::google::protobuf::internal::AssignDescriptorsTable assign_descriptors_table_steammessages_5fgamenotifications_2esteamclient_2eproto = {
  {}, AddDescriptors_steammessages_5fgamenotifications_2esteamclient_2eproto, "steammessages_gamenotifications.steamclient.proto", schemas,
  file_default_instances, TableStruct_steammessages_5fgamenotifications_2esteamclient_2eproto::offsets,
  file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto, 20, file_level_enum_descriptors_steammessages_5fgamenotifications_2esteamclient_2eproto, file_level_service_descriptors_steammessages_5fgamenotifications_2esteamclient_2eproto,
};

const char descriptor_table_protodef_steammessages_5fgamenotifications_2esteamclient_2eproto[] =
  "\n1steammessages_gamenotifications.steamc"
  "lient.proto\022\013proto.steam\032,steammessages_"
  "unified_base.steamclient.proto\"\340\002\n\033CGame"
  "Notifications_Variable\022\246\001\n\003key\030\001 \001(\tB\230\001\202"
  "\265\030\223\001The name of the variable in the loca"
  "lized text -- anywhere that %variablenam"
  "e% is found within the text it will be s"
  "ubstituded with the given value\022\227\001\n\005valu"
  "e\030\002 \001(\tB\207\001\202\265\030\202\001The value of the variable"
  " to substitute in the localized text in "
  "place of the given variable.  Can itself"
  " be a localization token.\"\221\003\n CGameNotif"
  "ications_LocalizedText\022H\n\005token\030\001 \001(\tB9\202"
  "\265\0305A localization token that maps to the"
  " desired string.\022\231\001\n\tvariables\030\002 \003(\0132(.p"
  "roto.steam.CGameNotifications_VariableB\\"
  "\202\265\030XA list of variables values to substi"
  "tute in any variables found in the local"
  "ized string.\022\206\001\n\rrendered_text\030\003 \001(\tBo\202\265"
  "\030kText rendered in the requested languag"
  "e, complete with variable substitutions,"
  " if a language was specified.\"\255\004\n\035CGameN"
  "otifications_UserStatus\0221\n\007steamid\030\001 \001(\006"
  "B \202\265\030\034The specific user\'s steamid.\022\244\001\n\005s"
  "tate\030\002 \001(\tB\224\001\202\265\030\217\001The user\'s state.  rea"
  "dy -- the user is ready to play.  waitin"
  "g -- The game is waiting on an action fr"
  "om the user. completed, the game is over"
  ".\022\220\001\n\005title\030\003 \001(\0132-.proto.steam.CGameNot"
  "ifications_LocalizedTextBR\202\265\030NTitle of t"
  "he session to display to this user in th"
  "eir list of active sessions.\022\236\001\n\007message"
  "\030\004 \001(\0132-.proto.steam.CGameNotifications_"
  "LocalizedTextB^\202\265\030ZSubtitle of the sessi"
  "on to display to this user user within t"
  "heir list of active sessions.\"\253\005\n(CGameN"
  "otifications_CreateSession_Request\0227\n\005ap"
  "pid\030\001 \001(\rB(\202\265\030$The appid to create the s"
  "ession for.\022\177\n\007context\030\002 \001(\004Bn\202\265\030jGame-s"
  "pecified context value the game can used"
  " to associate the session with some obje"
  "ct on their backend.\022\217\001\n\005title\030\003 \001(\0132-.p"
  "roto.steam.CGameNotifications_LocalizedT"
  "extBQ\202\265\030MThe title of the session to be "
  "displayed within each user\'s list of ses"
  "sions.\022m\n\005users\030\004 \003(\0132*.proto.steam.CGam"
  "eNotifications_UserStatusB2\202\265\030.The initi"
  "al state of all users in the session.\022\303\001"
  "\n\007steamid\030\005 \001(\006B\261\001\202\265\030\254\001(Optional) steami"
  "d to make the request on behalf of -- if"
  " specified, the user must be in the sess"
  "ion and all users being added to the ses"
  "sion must be friends with the user.\"i\n)C"
  "GameNotifications_CreateSession_Response"
  "\022<\n\tsessionid\030\001 \001(\004B)\202\265\030%The sessionid o"
  "f the created session.\"\217\002\n(CGameNotifica"
  "tions_DeleteSession_Request\022/\n\tsessionid"
  "\030\001 \001(\004B\034\202\265\030\030The sessionid to delete.\0226\n\005"
  "appid\030\002 \001(\rB\'\202\265\030#The appid of the sessio"
  "n to delete.\022z\n\007steamid\030\003 \001(\006Bi\202\265\030e(Opti"
  "onal) steamid to make the request on beh"
  "alf of -- if specified, the user must be"
  " in the session.\"+\n)CGameNotifications_D"
  "eleteSession_Response\"\325\005\n(CGameNotificat"
  "ions_UpdateSession_Request\022/\n\tsessionid\030"
  "\001 \001(\004B\034\202\265\030\030The sessionid to update.\0226\n\005a"
  "ppid\030\002 \001(\rB\'\202\265\030#The appid of the session"
  " to update.\022\234\001\n\005title\030\003 \001(\0132-.proto.stea"
  "m.CGameNotifications_LocalizedTextB^\202\265\030Z"
  "(Optional) The new title of the session."
  "  If not specified, the title will not b"
  "e changed.\022\332\001\n\005users\030\004 \003(\0132*.proto.steam"
  ".CGameNotifications_UserStatusB\236\001\202\265\030\231\001(O"
  "ptional) A list of users whose state wil"
  "l be updated to reflect the given state."
  " If the users are not already in the ses"
  "sion, they will be added to it.\022\303\001\n\007stea"
  "mid\030\006 \001(\006B\261\001\202\265\030\254\001(Optional) steamid to m"
  "ake the request on behalf of -- if speci"
  "fied, the user must be in the session an"
  "d all users being added to the session m"
  "ust be friends with the user.\"+\n)CGameNo"
  "tifications_UpdateSession_Response\"\241\004\n,C"
  "GameNotifications_EnumerateSessions_Requ"
  "est\022~\n\005appid\030\001 \001(\rBo\202\265\030kThe sessionid to"
  " request details for. Optional. If not s"
  "pecified, all the user\'s sessions will b"
  "e returned.\022\216\001\n\031include_all_user_message"
  "s\030\003 \001(\010Bk\202\265\030g(Optional) Boolean determin"
  "ing whether the message for all users sh"
  "ould be included. Defaults to false.\022\233\001\n"
  "\031include_auth_user_message\030\004 \001(\010Bx\202\265\030t(O"
  "ptional) Boolean determining whether the"
  " message for the authenticated user shou"
  "ld be included. Defaults to false.\022B\n\010la"
  "nguage\030\005 \001(\tB0\202\265\030,(Optional) Language to"
  " localize the text in.\"\333\004\n\032CGameNotifica"
  "tions_Session\0226\n\tsessionid\030\001 \001(\004B#\202\265\030\037Th"
  "e sessionid for this session.\022-\n\005appid\030\002"
  " \001(\004B\036\202\265\030\032The appid for the session.\022\177\n\007"
  "context\030\003 \001(\004Bn\202\265\030jGame-specified contex"
  "t value the game can used to associate t"
  "he session with some object on their bac"
  "kend.\022d\n\005title\030\004 \001(\0132-.proto.steam.CGame"
  "Notifications_LocalizedTextB&\202\265\030\"The cur"
  "rent title for the session.\022;\n\014time_crea"
  "ted\030\005 \001(\rB%\202\265\030!The time the session was "
  "created.\022@\n\014time_updated\030\006 \001(\rB*\202\265\030&The "
  "last time the session was updated.\022p\n\013us"
  "er_status\030\007 \003(\0132*.proto.steam.CGameNotif"
  "ications_UserStatusB/\202\265\030+The status of a"
  "ll the users in the session.\"\216\001\n-CGameNo"
  "tifications_EnumerateSessions_Response\022]"
  "\n\010sessions\030\001 \003(\0132\'.proto.steam.CGameNoti"
  "fications_SessionB\"\202\265\030\036A list of the use"
  "r\'s sessions.\"\342\003\n,CGameNotifications_Get"
  "SessionDetails_Request\022\\\n\010sessions\030\001 \003(\013"
  "2J.proto.steam.CGameNotifications_GetSes"
  "sionDetails_Request.RequestedSession\022.\n\005"
  "appid\030\002 \001(\rB\037\202\265\030\033The appid for the sessi"
  "ons.\0227\n\010language\030\003 \001(\tB%\202\265\030!Language to "
  "localize the text in.\032\352\001\n\020RequestedSessi"
  "on\0228\n\tsessionid\030\001 \001(\004B%\202\265\030!The sessionid"
  " to get details for.\022\233\001\n\031include_auth_us"
  "er_message\030\003 \001(\010Bx\202\265\030t(Optional) Boolean"
  " determining whether the message for the"
  " authenticated user should be included. "
  "Defaults to false.\"\213\001\n-CGameNotification"
  "s_GetSessionDetails_Response\022Z\n\010sessions"
  "\030\001 \003(\0132\'.proto.steam.CGameNotifications_"
  "SessionB\037\202\265\030\033The details of the session."
  "\"\250\001\n\030GameNotificationSettings\0227\n\005appid\030\001"
  " \001(\rB(\202\265\030$The appid to create the sessio"
  "n for.\022S\n\023allow_notifications\030\002 \001(\010B6\202\265\030"
  "2Whether the user allows notification fo"
  "r this app.\"\202\001\n5CGameNotifications_Updat"
  "eNotificationSettings_Request\022I\n\032game_no"
  "tification_settings\030\001 \003(\0132%.proto.steam."
  "GameNotificationSettings\"8\n6CGameNotific"
  "ations_UpdateNotificationSettings_Respon"
  "se\"\306\001\n8CGameNotifications_OnNotification"
  "sRequested_Notification\022N\n\007steamid\030\001 \001(\006"
  "B=\202\265\0309steamid of the user who notificati"
  "ons were requested for.\022:\n\005appid\030\002 \001(\rB+"
  "\202\265\030\'The appid that requested notificatio"
  "ns.\"\312\003\n3CGameNotifications_OnUserStatusC"
  "hanged_Notification\022>\n\007steamid\030\001 \001(\006B-\202\265"
  "\030)steamid of the user whose status chang"
  "ed.\022X\n\tsessionid\030\002 \001(\004BE\202\265\030AThe sessioni"
  "d of the session where the user\'s status"
  " was changed.\022L\n\005appid\030\003 \001(\rB=\202\265\0309The ap"
  "pid of the session where the user\'s stat"
  "us changed.\022b\n\006status\030\004 \001(\0132*.proto.stea"
  "m.CGameNotifications_UserStatusB&\202\265\030\"(Op"
  "tional) New status of the user.\022G\n\007remov"
  "ed\030\005 \001(\010B6\202\265\0302(Optional) User has been r"
  "emoved from the session.2\266\t\n\021GameNotific"
  "ations\022\245\001\n\021UserCreateSession\0225.proto.ste"
  "am.CGameNotifications_CreateSession_Requ"
  "est\0326.proto.steam.CGameNotifications_Cre"
  "ateSession_Response\"!\202\265\030\035Creates an asyn"
  "c game session\022\245\001\n\021UserDeleteSession\0225.p"
  "roto.steam.CGameNotifications_DeleteSess"
  "ion_Request\0326.proto.steam.CGameNotificat"
  "ions_DeleteSession_Response\"!\202\265\030\035Deletes"
  " an async game session\022\245\001\n\021UserUpdateSes"
  "sion\0225.proto.steam.CGameNotifications_Up"
  "dateSession_Request\0326.proto.steam.CGameN"
  "otifications_UpdateSession_Response\"!\202\265\030"
  "\035Updates an async game session\022\254\001\n\021Enume"
  "rateSessions\0229.proto.steam.CGameNotifica"
  "tions_EnumerateSessions_Request\032:.proto."
  "steam.CGameNotifications_EnumerateSessio"
  "ns_Response\" \202\265\030\034Enumerates a user\'s ses"
  "sions\022\266\001\n\021GetSessionDetails\0229.proto.stea"
  "m.CGameNotifications_GetSessionDetails_R"
  "equest\032:.proto.steam.CGameNotifications_"
  "GetSessionDetails_Response\"*\202\265\030&Get the "
  "details for a specific session\022\356\001\n\032Updat"
  "eNotificationSettings\022B.proto.steam.CGam"
  "eNotifications_UpdateNotificationSetting"
  "s_Request\032C.proto.steam.CGameNotificatio"
  "ns_UpdateNotificationSettings_Response\"G"
  "\202\265\030CUpdates whether a user allows game n"
  "otifications for a specific app\032P\202\265\030LA s"
  "ervice for functions related to the asyn"
  "cronous game notification server.2\217\003\n\027Ga"
  "meNotificationsClient\022\255\001\n\030OnNotification"
  "sRequested\022E.proto.steam.CGameNotificati"
  "ons_OnNotificationsRequested_Notificatio"
  "n\032\027.proto.steam.NoResponse\"1\202\265\030-Requests"
  " that the user opt into notifications\022\245\001"
  "\n\023OnUserStatusChanged\022@.proto.steam.CGam"
  "eNotifications_OnUserStatusChanged_Notif"
  "ication\032\027.proto.steam.NoResponse\"3\202\265\030/No"
  "tification that the user\'s status has ch"
  "anged\032\034\202\265\030\024Client notifications\300\265\030\002B\003\200\001\001"
  ;
::google::protobuf::internal::DescriptorTable descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto = {
  false, InitDefaults_steammessages_5fgamenotifications_2esteamclient_2eproto, 
  descriptor_table_protodef_steammessages_5fgamenotifications_2esteamclient_2eproto,
  "steammessages_gamenotifications.steamclient.proto", &assign_descriptors_table_steammessages_5fgamenotifications_2esteamclient_2eproto, 7880,
};

void AddDescriptors_steammessages_5fgamenotifications_2esteamclient_2eproto() {
  static constexpr ::google::protobuf::internal::InitFunc deps[1] =
  {
    ::AddDescriptors_steammessages_5funified_5fbase_2esteamclient_2eproto,
  };
 ::google::protobuf::internal::AddDescriptors(&descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto, deps, 1);
}

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_steammessages_5fgamenotifications_2esteamclient_2eproto = []() { AddDescriptors_steammessages_5fgamenotifications_2esteamclient_2eproto(); return true; }();
namespace proto {
namespace steam {

// ===================================================================

void CGameNotifications_Variable::InitAsDefaultInstance() {
}
class CGameNotifications_Variable::HasBitSetters {
 public:
  static void set_has_key(CGameNotifications_Variable* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_value(CGameNotifications_Variable* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CGameNotifications_Variable::kKeyFieldNumber;
const int CGameNotifications_Variable::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CGameNotifications_Variable::CGameNotifications_Variable()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.steam.CGameNotifications_Variable)
}
CGameNotifications_Variable::CGameNotifications_Variable(const CGameNotifications_Variable& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_key()) {
    key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
  }
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_value()) {
    value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
  }
  // @@protoc_insertion_point(copy_constructor:proto.steam.CGameNotifications_Variable)
}

void CGameNotifications_Variable::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CGameNotifications_Variable_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

CGameNotifications_Variable::~CGameNotifications_Variable() {
  // @@protoc_insertion_point(destructor:proto.steam.CGameNotifications_Variable)
  SharedDtor();
}

void CGameNotifications_Variable::SharedDtor() {
  key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void CGameNotifications_Variable::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CGameNotifications_Variable& CGameNotifications_Variable::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CGameNotifications_Variable_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  return *internal_default_instance();
}


void CGameNotifications_Variable::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.steam.CGameNotifications_Variable)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      key_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      value_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CGameNotifications_Variable::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CGameNotifications_Variable*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional string key = 1 [(.proto.steam.description) = "The name of the variable in the localized text -- anywhere that %variablename% is found within the text it will be substituded with the given value"];
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("proto.steam.CGameNotifications_Variable.key");
        object = msg->mutable_key();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional string value = 2 [(.proto.steam.description) = "The value of the variable to substitute in the localized text in place of the given variable.  Can itself be a localization token."];
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("proto.steam.CGameNotifications_Variable.value");
        object = msg->mutable_value();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CGameNotifications_Variable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.steam.CGameNotifications_Variable)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string key = 1 [(.proto.steam.description) = "The name of the variable in the localized text -- anywhere that %variablename% is found within the text it will be substituded with the given value"];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->key().data(), static_cast<int>(this->key().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "proto.steam.CGameNotifications_Variable.key");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string value = 2 [(.proto.steam.description) = "The value of the variable to substitute in the localized text in place of the given variable.  Can itself be a localization token."];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), static_cast<int>(this->value().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "proto.steam.CGameNotifications_Variable.value");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.steam.CGameNotifications_Variable)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.steam.CGameNotifications_Variable)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CGameNotifications_Variable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.steam.CGameNotifications_Variable)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string key = 1 [(.proto.steam.description) = "The name of the variable in the localized text -- anywhere that %variablename% is found within the text it will be substituded with the given value"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->key().data(), static_cast<int>(this->key().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "proto.steam.CGameNotifications_Variable.key");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->key(), output);
  }

  // optional string value = 2 [(.proto.steam.description) = "The value of the variable to substitute in the localized text in place of the given variable.  Can itself be a localization token."];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), static_cast<int>(this->value().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "proto.steam.CGameNotifications_Variable.value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->value(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.steam.CGameNotifications_Variable)
}

::google::protobuf::uint8* CGameNotifications_Variable::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.steam.CGameNotifications_Variable)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string key = 1 [(.proto.steam.description) = "The name of the variable in the localized text -- anywhere that %variablename% is found within the text it will be substituded with the given value"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->key().data(), static_cast<int>(this->key().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "proto.steam.CGameNotifications_Variable.key");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->key(), target);
  }

  // optional string value = 2 [(.proto.steam.description) = "The value of the variable to substitute in the localized text in place of the given variable.  Can itself be a localization token."];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), static_cast<int>(this->value().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "proto.steam.CGameNotifications_Variable.value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->value(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.steam.CGameNotifications_Variable)
  return target;
}

size_t CGameNotifications_Variable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.steam.CGameNotifications_Variable)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string key = 1 [(.proto.steam.description) = "The name of the variable in the localized text -- anywhere that %variablename% is found within the text it will be substituded with the given value"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }

    // optional string value = 2 [(.proto.steam.description) = "The value of the variable to substitute in the localized text in place of the given variable.  Can itself be a localization token."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGameNotifications_Variable::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.steam.CGameNotifications_Variable)
  GOOGLE_DCHECK_NE(&from, this);
  const CGameNotifications_Variable* source =
      ::google::protobuf::DynamicCastToGenerated<CGameNotifications_Variable>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.steam.CGameNotifications_Variable)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.steam.CGameNotifications_Variable)
    MergeFrom(*source);
  }
}

void CGameNotifications_Variable::MergeFrom(const CGameNotifications_Variable& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.steam.CGameNotifications_Variable)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
  }
}

void CGameNotifications_Variable::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.steam.CGameNotifications_Variable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CGameNotifications_Variable::CopyFrom(const CGameNotifications_Variable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.steam.CGameNotifications_Variable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_Variable::IsInitialized() const {
  return true;
}

void CGameNotifications_Variable::Swap(CGameNotifications_Variable* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CGameNotifications_Variable::InternalSwap(CGameNotifications_Variable* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  key_.Swap(&other->key_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  value_.Swap(&other->value_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata CGameNotifications_Variable::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_steammessages_5fgamenotifications_2esteamclient_2eproto);
  return ::file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CGameNotifications_LocalizedText::InitAsDefaultInstance() {
}
class CGameNotifications_LocalizedText::HasBitSetters {
 public:
  static void set_has_token(CGameNotifications_LocalizedText* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_rendered_text(CGameNotifications_LocalizedText* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CGameNotifications_LocalizedText::kTokenFieldNumber;
const int CGameNotifications_LocalizedText::kVariablesFieldNumber;
const int CGameNotifications_LocalizedText::kRenderedTextFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CGameNotifications_LocalizedText::CGameNotifications_LocalizedText()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.steam.CGameNotifications_LocalizedText)
}
CGameNotifications_LocalizedText::CGameNotifications_LocalizedText(const CGameNotifications_LocalizedText& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      variables_(from.variables_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_token()) {
    token_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.token_);
  }
  rendered_text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_rendered_text()) {
    rendered_text_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.rendered_text_);
  }
  // @@protoc_insertion_point(copy_constructor:proto.steam.CGameNotifications_LocalizedText)
}

void CGameNotifications_LocalizedText::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CGameNotifications_LocalizedText_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  rendered_text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

CGameNotifications_LocalizedText::~CGameNotifications_LocalizedText() {
  // @@protoc_insertion_point(destructor:proto.steam.CGameNotifications_LocalizedText)
  SharedDtor();
}

void CGameNotifications_LocalizedText::SharedDtor() {
  token_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  rendered_text_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void CGameNotifications_LocalizedText::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CGameNotifications_LocalizedText& CGameNotifications_LocalizedText::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CGameNotifications_LocalizedText_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  return *internal_default_instance();
}


void CGameNotifications_LocalizedText::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.steam.CGameNotifications_LocalizedText)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  variables_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      token_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      rendered_text_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CGameNotifications_LocalizedText::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CGameNotifications_LocalizedText*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional string token = 1 [(.proto.steam.description) = "A localization token that maps to the desired string."];
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("proto.steam.CGameNotifications_LocalizedText.token");
        object = msg->mutable_token();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // repeated .proto.steam.CGameNotifications_Variable variables = 2 [(.proto.steam.description) = "A list of variables values to substitute in any variables found in the localized string."];
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::proto::steam::CGameNotifications_Variable::_InternalParse;
          object = msg->add_variables();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      // optional string rendered_text = 3 [(.proto.steam.description) = "Text rendered in the requested language, complete with variable substitutions, if a language was specified."];
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("proto.steam.CGameNotifications_LocalizedText.rendered_text");
        object = msg->mutable_rendered_text();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CGameNotifications_LocalizedText::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.steam.CGameNotifications_LocalizedText)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string token = 1 [(.proto.steam.description) = "A localization token that maps to the desired string."];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_token()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->token().data(), static_cast<int>(this->token().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "proto.steam.CGameNotifications_LocalizedText.token");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .proto.steam.CGameNotifications_Variable variables = 2 [(.proto.steam.description) = "A list of variables values to substitute in any variables found in the localized string."];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_variables()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string rendered_text = 3 [(.proto.steam.description) = "Text rendered in the requested language, complete with variable substitutions, if a language was specified."];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_rendered_text()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->rendered_text().data(), static_cast<int>(this->rendered_text().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "proto.steam.CGameNotifications_LocalizedText.rendered_text");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.steam.CGameNotifications_LocalizedText)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.steam.CGameNotifications_LocalizedText)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CGameNotifications_LocalizedText::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.steam.CGameNotifications_LocalizedText)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string token = 1 [(.proto.steam.description) = "A localization token that maps to the desired string."];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->token().data(), static_cast<int>(this->token().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "proto.steam.CGameNotifications_LocalizedText.token");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->token(), output);
  }

  // repeated .proto.steam.CGameNotifications_Variable variables = 2 [(.proto.steam.description) = "A list of variables values to substitute in any variables found in the localized string."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->variables_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->variables(static_cast<int>(i)),
      output);
  }

  // optional string rendered_text = 3 [(.proto.steam.description) = "Text rendered in the requested language, complete with variable substitutions, if a language was specified."];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->rendered_text().data(), static_cast<int>(this->rendered_text().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "proto.steam.CGameNotifications_LocalizedText.rendered_text");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->rendered_text(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.steam.CGameNotifications_LocalizedText)
}

::google::protobuf::uint8* CGameNotifications_LocalizedText::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.steam.CGameNotifications_LocalizedText)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string token = 1 [(.proto.steam.description) = "A localization token that maps to the desired string."];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->token().data(), static_cast<int>(this->token().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "proto.steam.CGameNotifications_LocalizedText.token");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->token(), target);
  }

  // repeated .proto.steam.CGameNotifications_Variable variables = 2 [(.proto.steam.description) = "A list of variables values to substitute in any variables found in the localized string."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->variables_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->variables(static_cast<int>(i)), target);
  }

  // optional string rendered_text = 3 [(.proto.steam.description) = "Text rendered in the requested language, complete with variable substitutions, if a language was specified."];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->rendered_text().data(), static_cast<int>(this->rendered_text().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "proto.steam.CGameNotifications_LocalizedText.rendered_text");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->rendered_text(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.steam.CGameNotifications_LocalizedText)
  return target;
}

size_t CGameNotifications_LocalizedText::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.steam.CGameNotifications_LocalizedText)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.steam.CGameNotifications_Variable variables = 2 [(.proto.steam.description) = "A list of variables values to substitute in any variables found in the localized string."];
  {
    unsigned int count = static_cast<unsigned int>(this->variables_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->variables(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string token = 1 [(.proto.steam.description) = "A localization token that maps to the desired string."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->token());
    }

    // optional string rendered_text = 3 [(.proto.steam.description) = "Text rendered in the requested language, complete with variable substitutions, if a language was specified."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->rendered_text());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGameNotifications_LocalizedText::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.steam.CGameNotifications_LocalizedText)
  GOOGLE_DCHECK_NE(&from, this);
  const CGameNotifications_LocalizedText* source =
      ::google::protobuf::DynamicCastToGenerated<CGameNotifications_LocalizedText>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.steam.CGameNotifications_LocalizedText)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.steam.CGameNotifications_LocalizedText)
    MergeFrom(*source);
  }
}

void CGameNotifications_LocalizedText::MergeFrom(const CGameNotifications_LocalizedText& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.steam.CGameNotifications_LocalizedText)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  variables_.MergeFrom(from.variables_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      token_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.token_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      rendered_text_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.rendered_text_);
    }
  }
}

void CGameNotifications_LocalizedText::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.steam.CGameNotifications_LocalizedText)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CGameNotifications_LocalizedText::CopyFrom(const CGameNotifications_LocalizedText& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.steam.CGameNotifications_LocalizedText)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_LocalizedText::IsInitialized() const {
  return true;
}

void CGameNotifications_LocalizedText::Swap(CGameNotifications_LocalizedText* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CGameNotifications_LocalizedText::InternalSwap(CGameNotifications_LocalizedText* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&variables_)->InternalSwap(CastToBase(&other->variables_));
  token_.Swap(&other->token_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  rendered_text_.Swap(&other->rendered_text_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata CGameNotifications_LocalizedText::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_steammessages_5fgamenotifications_2esteamclient_2eproto);
  return ::file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CGameNotifications_UserStatus::InitAsDefaultInstance() {
  ::proto::steam::_CGameNotifications_UserStatus_default_instance_._instance.get_mutable()->title_ = const_cast< ::proto::steam::CGameNotifications_LocalizedText*>(
      ::proto::steam::CGameNotifications_LocalizedText::internal_default_instance());
  ::proto::steam::_CGameNotifications_UserStatus_default_instance_._instance.get_mutable()->message_ = const_cast< ::proto::steam::CGameNotifications_LocalizedText*>(
      ::proto::steam::CGameNotifications_LocalizedText::internal_default_instance());
}
class CGameNotifications_UserStatus::HasBitSetters {
 public:
  static void set_has_steamid(CGameNotifications_UserStatus* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_state(CGameNotifications_UserStatus* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::proto::steam::CGameNotifications_LocalizedText& title(const CGameNotifications_UserStatus* msg);
  static void set_has_title(CGameNotifications_UserStatus* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::proto::steam::CGameNotifications_LocalizedText& message(const CGameNotifications_UserStatus* msg);
  static void set_has_message(CGameNotifications_UserStatus* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

const ::proto::steam::CGameNotifications_LocalizedText&
CGameNotifications_UserStatus::HasBitSetters::title(const CGameNotifications_UserStatus* msg) {
  return *msg->title_;
}
const ::proto::steam::CGameNotifications_LocalizedText&
CGameNotifications_UserStatus::HasBitSetters::message(const CGameNotifications_UserStatus* msg) {
  return *msg->message_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CGameNotifications_UserStatus::kSteamidFieldNumber;
const int CGameNotifications_UserStatus::kStateFieldNumber;
const int CGameNotifications_UserStatus::kTitleFieldNumber;
const int CGameNotifications_UserStatus::kMessageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CGameNotifications_UserStatus::CGameNotifications_UserStatus()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.steam.CGameNotifications_UserStatus)
}
CGameNotifications_UserStatus::CGameNotifications_UserStatus(const CGameNotifications_UserStatus& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  state_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_state()) {
    state_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.state_);
  }
  if (from.has_title()) {
    title_ = new ::proto::steam::CGameNotifications_LocalizedText(*from.title_);
  } else {
    title_ = nullptr;
  }
  if (from.has_message()) {
    message_ = new ::proto::steam::CGameNotifications_LocalizedText(*from.message_);
  } else {
    message_ = nullptr;
  }
  steamid_ = from.steamid_;
  // @@protoc_insertion_point(copy_constructor:proto.steam.CGameNotifications_UserStatus)
}

void CGameNotifications_UserStatus::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CGameNotifications_UserStatus_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  state_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&title_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&steamid_) -
      reinterpret_cast<char*>(&title_)) + sizeof(steamid_));
}

CGameNotifications_UserStatus::~CGameNotifications_UserStatus() {
  // @@protoc_insertion_point(destructor:proto.steam.CGameNotifications_UserStatus)
  SharedDtor();
}

void CGameNotifications_UserStatus::SharedDtor() {
  state_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete title_;
  if (this != internal_default_instance()) delete message_;
}

void CGameNotifications_UserStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CGameNotifications_UserStatus& CGameNotifications_UserStatus::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CGameNotifications_UserStatus_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  return *internal_default_instance();
}


void CGameNotifications_UserStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.steam.CGameNotifications_UserStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      state_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(title_ != nullptr);
      title_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(message_ != nullptr);
      message_->Clear();
    }
  }
  steamid_ = PROTOBUF_ULONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CGameNotifications_UserStatus::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CGameNotifications_UserStatus*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional fixed64 steamid = 1 [(.proto.steam.description) = "The specific user\'s steamid."];
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_steamid(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr));
        ptr += sizeof(::google::protobuf::uint64);
        break;
      }
      // optional string state = 2 [(.proto.steam.description) = "The user\'s state.  ready -- the user is ready to play.  waiting -- The game is waiting on an action from the user. completed, the game is over."];
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("proto.steam.CGameNotifications_UserStatus.state");
        object = msg->mutable_state();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional .proto.steam.CGameNotifications_LocalizedText title = 3 [(.proto.steam.description) = "Title of the session to display to this user in their list of active sessions."];
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::steam::CGameNotifications_LocalizedText::_InternalParse;
        object = msg->mutable_title();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.steam.CGameNotifications_LocalizedText message = 4 [(.proto.steam.description) = "Subtitle of the session to display to this user user within their list of active sessions."];
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::steam::CGameNotifications_LocalizedText::_InternalParse;
        object = msg->mutable_message();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CGameNotifications_UserStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.steam.CGameNotifications_UserStatus)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional fixed64 steamid = 1 [(.proto.steam.description) = "The specific user\'s steamid."];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          HasBitSetters::set_has_steamid(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &steamid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string state = 2 [(.proto.steam.description) = "The user\'s state.  ready -- the user is ready to play.  waiting -- The game is waiting on an action from the user. completed, the game is over."];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_state()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->state().data(), static_cast<int>(this->state().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "proto.steam.CGameNotifications_UserStatus.state");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.steam.CGameNotifications_LocalizedText title = 3 [(.proto.steam.description) = "Title of the session to display to this user in their list of active sessions."];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_title()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.steam.CGameNotifications_LocalizedText message = 4 [(.proto.steam.description) = "Subtitle of the session to display to this user user within their list of active sessions."];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.steam.CGameNotifications_UserStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.steam.CGameNotifications_UserStatus)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CGameNotifications_UserStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.steam.CGameNotifications_UserStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 steamid = 1 [(.proto.steam.description) = "The specific user\'s steamid."];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(1, this->steamid(), output);
  }

  // optional string state = 2 [(.proto.steam.description) = "The user\'s state.  ready -- the user is ready to play.  waiting -- The game is waiting on an action from the user. completed, the game is over."];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->state().data(), static_cast<int>(this->state().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "proto.steam.CGameNotifications_UserStatus.state");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->state(), output);
  }

  // optional .proto.steam.CGameNotifications_LocalizedText title = 3 [(.proto.steam.description) = "Title of the session to display to this user in their list of active sessions."];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::title(this), output);
  }

  // optional .proto.steam.CGameNotifications_LocalizedText message = 4 [(.proto.steam.description) = "Subtitle of the session to display to this user user within their list of active sessions."];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::message(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.steam.CGameNotifications_UserStatus)
}

::google::protobuf::uint8* CGameNotifications_UserStatus::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.steam.CGameNotifications_UserStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 steamid = 1 [(.proto.steam.description) = "The specific user\'s steamid."];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(1, this->steamid(), target);
  }

  // optional string state = 2 [(.proto.steam.description) = "The user\'s state.  ready -- the user is ready to play.  waiting -- The game is waiting on an action from the user. completed, the game is over."];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->state().data(), static_cast<int>(this->state().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "proto.steam.CGameNotifications_UserStatus.state");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->state(), target);
  }

  // optional .proto.steam.CGameNotifications_LocalizedText title = 3 [(.proto.steam.description) = "Title of the session to display to this user in their list of active sessions."];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::title(this), target);
  }

  // optional .proto.steam.CGameNotifications_LocalizedText message = 4 [(.proto.steam.description) = "Subtitle of the session to display to this user user within their list of active sessions."];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::message(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.steam.CGameNotifications_UserStatus)
  return target;
}

size_t CGameNotifications_UserStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.steam.CGameNotifications_UserStatus)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string state = 2 [(.proto.steam.description) = "The user\'s state.  ready -- the user is ready to play.  waiting -- The game is waiting on an action from the user. completed, the game is over."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->state());
    }

    // optional .proto.steam.CGameNotifications_LocalizedText title = 3 [(.proto.steam.description) = "Title of the session to display to this user in their list of active sessions."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *title_);
    }

    // optional .proto.steam.CGameNotifications_LocalizedText message = 4 [(.proto.steam.description) = "Subtitle of the session to display to this user user within their list of active sessions."];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *message_);
    }

    // optional fixed64 steamid = 1 [(.proto.steam.description) = "The specific user\'s steamid."];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGameNotifications_UserStatus::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.steam.CGameNotifications_UserStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const CGameNotifications_UserStatus* source =
      ::google::protobuf::DynamicCastToGenerated<CGameNotifications_UserStatus>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.steam.CGameNotifications_UserStatus)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.steam.CGameNotifications_UserStatus)
    MergeFrom(*source);
  }
}

void CGameNotifications_UserStatus::MergeFrom(const CGameNotifications_UserStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.steam.CGameNotifications_UserStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      state_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.state_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_title()->::proto::steam::CGameNotifications_LocalizedText::MergeFrom(from.title());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_message()->::proto::steam::CGameNotifications_LocalizedText::MergeFrom(from.message());
    }
    if (cached_has_bits & 0x00000008u) {
      steamid_ = from.steamid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CGameNotifications_UserStatus::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.steam.CGameNotifications_UserStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CGameNotifications_UserStatus::CopyFrom(const CGameNotifications_UserStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.steam.CGameNotifications_UserStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_UserStatus::IsInitialized() const {
  return true;
}

void CGameNotifications_UserStatus::Swap(CGameNotifications_UserStatus* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CGameNotifications_UserStatus::InternalSwap(CGameNotifications_UserStatus* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  state_.Swap(&other->state_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(title_, other->title_);
  swap(message_, other->message_);
  swap(steamid_, other->steamid_);
}

::google::protobuf::Metadata CGameNotifications_UserStatus::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_steammessages_5fgamenotifications_2esteamclient_2eproto);
  return ::file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CGameNotifications_CreateSession_Request::InitAsDefaultInstance() {
  ::proto::steam::_CGameNotifications_CreateSession_Request_default_instance_._instance.get_mutable()->title_ = const_cast< ::proto::steam::CGameNotifications_LocalizedText*>(
      ::proto::steam::CGameNotifications_LocalizedText::internal_default_instance());
}
class CGameNotifications_CreateSession_Request::HasBitSetters {
 public:
  static void set_has_appid(CGameNotifications_CreateSession_Request* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_context(CGameNotifications_CreateSession_Request* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::proto::steam::CGameNotifications_LocalizedText& title(const CGameNotifications_CreateSession_Request* msg);
  static void set_has_title(CGameNotifications_CreateSession_Request* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_steamid(CGameNotifications_CreateSession_Request* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

const ::proto::steam::CGameNotifications_LocalizedText&
CGameNotifications_CreateSession_Request::HasBitSetters::title(const CGameNotifications_CreateSession_Request* msg) {
  return *msg->title_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CGameNotifications_CreateSession_Request::kAppidFieldNumber;
const int CGameNotifications_CreateSession_Request::kContextFieldNumber;
const int CGameNotifications_CreateSession_Request::kTitleFieldNumber;
const int CGameNotifications_CreateSession_Request::kUsersFieldNumber;
const int CGameNotifications_CreateSession_Request::kSteamidFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CGameNotifications_CreateSession_Request::CGameNotifications_CreateSession_Request()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.steam.CGameNotifications_CreateSession_Request)
}
CGameNotifications_CreateSession_Request::CGameNotifications_CreateSession_Request(const CGameNotifications_CreateSession_Request& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      users_(from.users_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_title()) {
    title_ = new ::proto::steam::CGameNotifications_LocalizedText(*from.title_);
  } else {
    title_ = nullptr;
  }
  ::memcpy(&context_, &from.context_,
    static_cast<size_t>(reinterpret_cast<char*>(&appid_) -
    reinterpret_cast<char*>(&context_)) + sizeof(appid_));
  // @@protoc_insertion_point(copy_constructor:proto.steam.CGameNotifications_CreateSession_Request)
}

void CGameNotifications_CreateSession_Request::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CGameNotifications_CreateSession_Request_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  ::memset(&title_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&appid_) -
      reinterpret_cast<char*>(&title_)) + sizeof(appid_));
}

CGameNotifications_CreateSession_Request::~CGameNotifications_CreateSession_Request() {
  // @@protoc_insertion_point(destructor:proto.steam.CGameNotifications_CreateSession_Request)
  SharedDtor();
}

void CGameNotifications_CreateSession_Request::SharedDtor() {
  if (this != internal_default_instance()) delete title_;
}

void CGameNotifications_CreateSession_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CGameNotifications_CreateSession_Request& CGameNotifications_CreateSession_Request::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CGameNotifications_CreateSession_Request_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  return *internal_default_instance();
}


void CGameNotifications_CreateSession_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.steam.CGameNotifications_CreateSession_Request)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  users_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(title_ != nullptr);
    title_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&context_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&appid_) -
        reinterpret_cast<char*>(&context_)) + sizeof(appid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CGameNotifications_CreateSession_Request::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CGameNotifications_CreateSession_Request*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional uint32 appid = 1 [(.proto.steam.description) = "The appid to create the session for."];
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_appid(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 context = 2 [(.proto.steam.description) = "Game-specified context value the game can used to associate the session with some object on their backend."];
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_context(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .proto.steam.CGameNotifications_LocalizedText title = 3 [(.proto.steam.description) = "The title of the session to be displayed within each user\'s list of sessions."];
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::steam::CGameNotifications_LocalizedText::_InternalParse;
        object = msg->mutable_title();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // repeated .proto.steam.CGameNotifications_UserStatus users = 4 [(.proto.steam.description) = "The initial state of all users in the session."];
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::proto::steam::CGameNotifications_UserStatus::_InternalParse;
          object = msg->add_users();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 34 && (ptr += 1));
        break;
      }
      // optional fixed64 steamid = 5 [(.proto.steam.description) = "(Optional) steamid to make the request on behalf of -- if specified, the user must be in the session and all users being added to the session must be friends with the user."];
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 41) goto handle_unusual;
        msg->set_steamid(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr));
        ptr += sizeof(::google::protobuf::uint64);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CGameNotifications_CreateSession_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.steam.CGameNotifications_CreateSession_Request)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 appid = 1 [(.proto.steam.description) = "The appid to create the session for."];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_appid(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &appid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 context = 2 [(.proto.steam.description) = "Game-specified context value the game can used to associate the session with some object on their backend."];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_context(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &context_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.steam.CGameNotifications_LocalizedText title = 3 [(.proto.steam.description) = "The title of the session to be displayed within each user\'s list of sessions."];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_title()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .proto.steam.CGameNotifications_UserStatus users = 4 [(.proto.steam.description) = "The initial state of all users in the session."];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_users()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed64 steamid = 5 [(.proto.steam.description) = "(Optional) steamid to make the request on behalf of -- if specified, the user must be in the session and all users being added to the session must be friends with the user."];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (41 & 0xFF)) {
          HasBitSetters::set_has_steamid(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &steamid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.steam.CGameNotifications_CreateSession_Request)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.steam.CGameNotifications_CreateSession_Request)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CGameNotifications_CreateSession_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.steam.CGameNotifications_CreateSession_Request)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1 [(.proto.steam.description) = "The appid to create the session for."];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->appid(), output);
  }

  // optional uint64 context = 2 [(.proto.steam.description) = "Game-specified context value the game can used to associate the session with some object on their backend."];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->context(), output);
  }

  // optional .proto.steam.CGameNotifications_LocalizedText title = 3 [(.proto.steam.description) = "The title of the session to be displayed within each user\'s list of sessions."];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::title(this), output);
  }

  // repeated .proto.steam.CGameNotifications_UserStatus users = 4 [(.proto.steam.description) = "The initial state of all users in the session."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->users_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4,
      this->users(static_cast<int>(i)),
      output);
  }

  // optional fixed64 steamid = 5 [(.proto.steam.description) = "(Optional) steamid to make the request on behalf of -- if specified, the user must be in the session and all users being added to the session must be friends with the user."];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(5, this->steamid(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.steam.CGameNotifications_CreateSession_Request)
}

::google::protobuf::uint8* CGameNotifications_CreateSession_Request::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.steam.CGameNotifications_CreateSession_Request)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1 [(.proto.steam.description) = "The appid to create the session for."];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->appid(), target);
  }

  // optional uint64 context = 2 [(.proto.steam.description) = "Game-specified context value the game can used to associate the session with some object on their backend."];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->context(), target);
  }

  // optional .proto.steam.CGameNotifications_LocalizedText title = 3 [(.proto.steam.description) = "The title of the session to be displayed within each user\'s list of sessions."];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::title(this), target);
  }

  // repeated .proto.steam.CGameNotifications_UserStatus users = 4 [(.proto.steam.description) = "The initial state of all users in the session."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->users_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, this->users(static_cast<int>(i)), target);
  }

  // optional fixed64 steamid = 5 [(.proto.steam.description) = "(Optional) steamid to make the request on behalf of -- if specified, the user must be in the session and all users being added to the session must be friends with the user."];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(5, this->steamid(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.steam.CGameNotifications_CreateSession_Request)
  return target;
}

size_t CGameNotifications_CreateSession_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.steam.CGameNotifications_CreateSession_Request)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.steam.CGameNotifications_UserStatus users = 4 [(.proto.steam.description) = "The initial state of all users in the session."];
  {
    unsigned int count = static_cast<unsigned int>(this->users_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->users(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .proto.steam.CGameNotifications_LocalizedText title = 3 [(.proto.steam.description) = "The title of the session to be displayed within each user\'s list of sessions."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *title_);
    }

    // optional uint64 context = 2 [(.proto.steam.description) = "Game-specified context value the game can used to associate the session with some object on their backend."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->context());
    }

    // optional fixed64 steamid = 5 [(.proto.steam.description) = "(Optional) steamid to make the request on behalf of -- if specified, the user must be in the session and all users being added to the session must be friends with the user."];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional uint32 appid = 1 [(.proto.steam.description) = "The appid to create the session for."];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->appid());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGameNotifications_CreateSession_Request::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.steam.CGameNotifications_CreateSession_Request)
  GOOGLE_DCHECK_NE(&from, this);
  const CGameNotifications_CreateSession_Request* source =
      ::google::protobuf::DynamicCastToGenerated<CGameNotifications_CreateSession_Request>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.steam.CGameNotifications_CreateSession_Request)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.steam.CGameNotifications_CreateSession_Request)
    MergeFrom(*source);
  }
}

void CGameNotifications_CreateSession_Request::MergeFrom(const CGameNotifications_CreateSession_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.steam.CGameNotifications_CreateSession_Request)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  users_.MergeFrom(from.users_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_title()->::proto::steam::CGameNotifications_LocalizedText::MergeFrom(from.title());
    }
    if (cached_has_bits & 0x00000002u) {
      context_ = from.context_;
    }
    if (cached_has_bits & 0x00000004u) {
      steamid_ = from.steamid_;
    }
    if (cached_has_bits & 0x00000008u) {
      appid_ = from.appid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CGameNotifications_CreateSession_Request::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.steam.CGameNotifications_CreateSession_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CGameNotifications_CreateSession_Request::CopyFrom(const CGameNotifications_CreateSession_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.steam.CGameNotifications_CreateSession_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_CreateSession_Request::IsInitialized() const {
  return true;
}

void CGameNotifications_CreateSession_Request::Swap(CGameNotifications_CreateSession_Request* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CGameNotifications_CreateSession_Request::InternalSwap(CGameNotifications_CreateSession_Request* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&users_)->InternalSwap(CastToBase(&other->users_));
  swap(title_, other->title_);
  swap(context_, other->context_);
  swap(steamid_, other->steamid_);
  swap(appid_, other->appid_);
}

::google::protobuf::Metadata CGameNotifications_CreateSession_Request::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_steammessages_5fgamenotifications_2esteamclient_2eproto);
  return ::file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CGameNotifications_CreateSession_Response::InitAsDefaultInstance() {
}
class CGameNotifications_CreateSession_Response::HasBitSetters {
 public:
  static void set_has_sessionid(CGameNotifications_CreateSession_Response* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CGameNotifications_CreateSession_Response::kSessionidFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CGameNotifications_CreateSession_Response::CGameNotifications_CreateSession_Response()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.steam.CGameNotifications_CreateSession_Response)
}
CGameNotifications_CreateSession_Response::CGameNotifications_CreateSession_Response(const CGameNotifications_CreateSession_Response& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  sessionid_ = from.sessionid_;
  // @@protoc_insertion_point(copy_constructor:proto.steam.CGameNotifications_CreateSession_Response)
}

void CGameNotifications_CreateSession_Response::SharedCtor() {
  sessionid_ = PROTOBUF_ULONGLONG(0);
}

CGameNotifications_CreateSession_Response::~CGameNotifications_CreateSession_Response() {
  // @@protoc_insertion_point(destructor:proto.steam.CGameNotifications_CreateSession_Response)
  SharedDtor();
}

void CGameNotifications_CreateSession_Response::SharedDtor() {
}

void CGameNotifications_CreateSession_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CGameNotifications_CreateSession_Response& CGameNotifications_CreateSession_Response::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CGameNotifications_CreateSession_Response_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  return *internal_default_instance();
}


void CGameNotifications_CreateSession_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.steam.CGameNotifications_CreateSession_Response)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sessionid_ = PROTOBUF_ULONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CGameNotifications_CreateSession_Response::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CGameNotifications_CreateSession_Response*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid of the created session."];
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_sessionid(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CGameNotifications_CreateSession_Response::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.steam.CGameNotifications_CreateSession_Response)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid of the created session."];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_sessionid(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &sessionid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.steam.CGameNotifications_CreateSession_Response)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.steam.CGameNotifications_CreateSession_Response)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CGameNotifications_CreateSession_Response::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.steam.CGameNotifications_CreateSession_Response)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid of the created session."];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->sessionid(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.steam.CGameNotifications_CreateSession_Response)
}

::google::protobuf::uint8* CGameNotifications_CreateSession_Response::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.steam.CGameNotifications_CreateSession_Response)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid of the created session."];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->sessionid(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.steam.CGameNotifications_CreateSession_Response)
  return target;
}

size_t CGameNotifications_CreateSession_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.steam.CGameNotifications_CreateSession_Response)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid of the created session."];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->sessionid());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGameNotifications_CreateSession_Response::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.steam.CGameNotifications_CreateSession_Response)
  GOOGLE_DCHECK_NE(&from, this);
  const CGameNotifications_CreateSession_Response* source =
      ::google::protobuf::DynamicCastToGenerated<CGameNotifications_CreateSession_Response>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.steam.CGameNotifications_CreateSession_Response)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.steam.CGameNotifications_CreateSession_Response)
    MergeFrom(*source);
  }
}

void CGameNotifications_CreateSession_Response::MergeFrom(const CGameNotifications_CreateSession_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.steam.CGameNotifications_CreateSession_Response)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_sessionid()) {
    set_sessionid(from.sessionid());
  }
}

void CGameNotifications_CreateSession_Response::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.steam.CGameNotifications_CreateSession_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CGameNotifications_CreateSession_Response::CopyFrom(const CGameNotifications_CreateSession_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.steam.CGameNotifications_CreateSession_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_CreateSession_Response::IsInitialized() const {
  return true;
}

void CGameNotifications_CreateSession_Response::Swap(CGameNotifications_CreateSession_Response* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CGameNotifications_CreateSession_Response::InternalSwap(CGameNotifications_CreateSession_Response* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(sessionid_, other->sessionid_);
}

::google::protobuf::Metadata CGameNotifications_CreateSession_Response::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_steammessages_5fgamenotifications_2esteamclient_2eproto);
  return ::file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CGameNotifications_DeleteSession_Request::InitAsDefaultInstance() {
}
class CGameNotifications_DeleteSession_Request::HasBitSetters {
 public:
  static void set_has_sessionid(CGameNotifications_DeleteSession_Request* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_appid(CGameNotifications_DeleteSession_Request* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_steamid(CGameNotifications_DeleteSession_Request* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CGameNotifications_DeleteSession_Request::kSessionidFieldNumber;
const int CGameNotifications_DeleteSession_Request::kAppidFieldNumber;
const int CGameNotifications_DeleteSession_Request::kSteamidFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CGameNotifications_DeleteSession_Request::CGameNotifications_DeleteSession_Request()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.steam.CGameNotifications_DeleteSession_Request)
}
CGameNotifications_DeleteSession_Request::CGameNotifications_DeleteSession_Request(const CGameNotifications_DeleteSession_Request& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&sessionid_, &from.sessionid_,
    static_cast<size_t>(reinterpret_cast<char*>(&appid_) -
    reinterpret_cast<char*>(&sessionid_)) + sizeof(appid_));
  // @@protoc_insertion_point(copy_constructor:proto.steam.CGameNotifications_DeleteSession_Request)
}

void CGameNotifications_DeleteSession_Request::SharedCtor() {
  ::memset(&sessionid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&appid_) -
      reinterpret_cast<char*>(&sessionid_)) + sizeof(appid_));
}

CGameNotifications_DeleteSession_Request::~CGameNotifications_DeleteSession_Request() {
  // @@protoc_insertion_point(destructor:proto.steam.CGameNotifications_DeleteSession_Request)
  SharedDtor();
}

void CGameNotifications_DeleteSession_Request::SharedDtor() {
}

void CGameNotifications_DeleteSession_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CGameNotifications_DeleteSession_Request& CGameNotifications_DeleteSession_Request::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CGameNotifications_DeleteSession_Request_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  return *internal_default_instance();
}


void CGameNotifications_DeleteSession_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.steam.CGameNotifications_DeleteSession_Request)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&sessionid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&appid_) -
        reinterpret_cast<char*>(&sessionid_)) + sizeof(appid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CGameNotifications_DeleteSession_Request::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CGameNotifications_DeleteSession_Request*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid to delete."];
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_sessionid(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 appid = 2 [(.proto.steam.description) = "The appid of the session to delete."];
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_appid(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional fixed64 steamid = 3 [(.proto.steam.description) = "(Optional) steamid to make the request on behalf of -- if specified, the user must be in the session."];
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        msg->set_steamid(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr));
        ptr += sizeof(::google::protobuf::uint64);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CGameNotifications_DeleteSession_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.steam.CGameNotifications_DeleteSession_Request)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid to delete."];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_sessionid(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &sessionid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 appid = 2 [(.proto.steam.description) = "The appid of the session to delete."];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_appid(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &appid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed64 steamid = 3 [(.proto.steam.description) = "(Optional) steamid to make the request on behalf of -- if specified, the user must be in the session."];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {
          HasBitSetters::set_has_steamid(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &steamid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.steam.CGameNotifications_DeleteSession_Request)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.steam.CGameNotifications_DeleteSession_Request)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CGameNotifications_DeleteSession_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.steam.CGameNotifications_DeleteSession_Request)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid to delete."];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->sessionid(), output);
  }

  // optional uint32 appid = 2 [(.proto.steam.description) = "The appid of the session to delete."];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->appid(), output);
  }

  // optional fixed64 steamid = 3 [(.proto.steam.description) = "(Optional) steamid to make the request on behalf of -- if specified, the user must be in the session."];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(3, this->steamid(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.steam.CGameNotifications_DeleteSession_Request)
}

::google::protobuf::uint8* CGameNotifications_DeleteSession_Request::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.steam.CGameNotifications_DeleteSession_Request)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid to delete."];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->sessionid(), target);
  }

  // optional uint32 appid = 2 [(.proto.steam.description) = "The appid of the session to delete."];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->appid(), target);
  }

  // optional fixed64 steamid = 3 [(.proto.steam.description) = "(Optional) steamid to make the request on behalf of -- if specified, the user must be in the session."];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(3, this->steamid(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.steam.CGameNotifications_DeleteSession_Request)
  return target;
}

size_t CGameNotifications_DeleteSession_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.steam.CGameNotifications_DeleteSession_Request)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid to delete."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->sessionid());
    }

    // optional fixed64 steamid = 3 [(.proto.steam.description) = "(Optional) steamid to make the request on behalf of -- if specified, the user must be in the session."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 appid = 2 [(.proto.steam.description) = "The appid of the session to delete."];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->appid());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGameNotifications_DeleteSession_Request::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.steam.CGameNotifications_DeleteSession_Request)
  GOOGLE_DCHECK_NE(&from, this);
  const CGameNotifications_DeleteSession_Request* source =
      ::google::protobuf::DynamicCastToGenerated<CGameNotifications_DeleteSession_Request>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.steam.CGameNotifications_DeleteSession_Request)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.steam.CGameNotifications_DeleteSession_Request)
    MergeFrom(*source);
  }
}

void CGameNotifications_DeleteSession_Request::MergeFrom(const CGameNotifications_DeleteSession_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.steam.CGameNotifications_DeleteSession_Request)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      sessionid_ = from.sessionid_;
    }
    if (cached_has_bits & 0x00000002u) {
      steamid_ = from.steamid_;
    }
    if (cached_has_bits & 0x00000004u) {
      appid_ = from.appid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CGameNotifications_DeleteSession_Request::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.steam.CGameNotifications_DeleteSession_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CGameNotifications_DeleteSession_Request::CopyFrom(const CGameNotifications_DeleteSession_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.steam.CGameNotifications_DeleteSession_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_DeleteSession_Request::IsInitialized() const {
  return true;
}

void CGameNotifications_DeleteSession_Request::Swap(CGameNotifications_DeleteSession_Request* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CGameNotifications_DeleteSession_Request::InternalSwap(CGameNotifications_DeleteSession_Request* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(sessionid_, other->sessionid_);
  swap(steamid_, other->steamid_);
  swap(appid_, other->appid_);
}

::google::protobuf::Metadata CGameNotifications_DeleteSession_Request::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_steammessages_5fgamenotifications_2esteamclient_2eproto);
  return ::file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CGameNotifications_DeleteSession_Response::InitAsDefaultInstance() {
}
class CGameNotifications_DeleteSession_Response::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CGameNotifications_DeleteSession_Response::CGameNotifications_DeleteSession_Response()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.steam.CGameNotifications_DeleteSession_Response)
}
CGameNotifications_DeleteSession_Response::CGameNotifications_DeleteSession_Response(const CGameNotifications_DeleteSession_Response& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.steam.CGameNotifications_DeleteSession_Response)
}

void CGameNotifications_DeleteSession_Response::SharedCtor() {
}

CGameNotifications_DeleteSession_Response::~CGameNotifications_DeleteSession_Response() {
  // @@protoc_insertion_point(destructor:proto.steam.CGameNotifications_DeleteSession_Response)
  SharedDtor();
}

void CGameNotifications_DeleteSession_Response::SharedDtor() {
}

void CGameNotifications_DeleteSession_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CGameNotifications_DeleteSession_Response& CGameNotifications_DeleteSession_Response::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CGameNotifications_DeleteSession_Response_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  return *internal_default_instance();
}


void CGameNotifications_DeleteSession_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.steam.CGameNotifications_DeleteSession_Response)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CGameNotifications_DeleteSession_Response::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CGameNotifications_DeleteSession_Response*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      default: {
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CGameNotifications_DeleteSession_Response::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.steam.CGameNotifications_DeleteSession_Response)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, _internal_metadata_.mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:proto.steam.CGameNotifications_DeleteSession_Response)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.steam.CGameNotifications_DeleteSession_Response)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CGameNotifications_DeleteSession_Response::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.steam.CGameNotifications_DeleteSession_Response)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.steam.CGameNotifications_DeleteSession_Response)
}

::google::protobuf::uint8* CGameNotifications_DeleteSession_Response::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.steam.CGameNotifications_DeleteSession_Response)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.steam.CGameNotifications_DeleteSession_Response)
  return target;
}

size_t CGameNotifications_DeleteSession_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.steam.CGameNotifications_DeleteSession_Response)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGameNotifications_DeleteSession_Response::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.steam.CGameNotifications_DeleteSession_Response)
  GOOGLE_DCHECK_NE(&from, this);
  const CGameNotifications_DeleteSession_Response* source =
      ::google::protobuf::DynamicCastToGenerated<CGameNotifications_DeleteSession_Response>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.steam.CGameNotifications_DeleteSession_Response)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.steam.CGameNotifications_DeleteSession_Response)
    MergeFrom(*source);
  }
}

void CGameNotifications_DeleteSession_Response::MergeFrom(const CGameNotifications_DeleteSession_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.steam.CGameNotifications_DeleteSession_Response)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void CGameNotifications_DeleteSession_Response::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.steam.CGameNotifications_DeleteSession_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CGameNotifications_DeleteSession_Response::CopyFrom(const CGameNotifications_DeleteSession_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.steam.CGameNotifications_DeleteSession_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_DeleteSession_Response::IsInitialized() const {
  return true;
}

void CGameNotifications_DeleteSession_Response::Swap(CGameNotifications_DeleteSession_Response* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CGameNotifications_DeleteSession_Response::InternalSwap(CGameNotifications_DeleteSession_Response* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
}

::google::protobuf::Metadata CGameNotifications_DeleteSession_Response::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_steammessages_5fgamenotifications_2esteamclient_2eproto);
  return ::file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CGameNotifications_UpdateSession_Request::InitAsDefaultInstance() {
  ::proto::steam::_CGameNotifications_UpdateSession_Request_default_instance_._instance.get_mutable()->title_ = const_cast< ::proto::steam::CGameNotifications_LocalizedText*>(
      ::proto::steam::CGameNotifications_LocalizedText::internal_default_instance());
}
class CGameNotifications_UpdateSession_Request::HasBitSetters {
 public:
  static void set_has_sessionid(CGameNotifications_UpdateSession_Request* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_appid(CGameNotifications_UpdateSession_Request* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static const ::proto::steam::CGameNotifications_LocalizedText& title(const CGameNotifications_UpdateSession_Request* msg);
  static void set_has_title(CGameNotifications_UpdateSession_Request* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_steamid(CGameNotifications_UpdateSession_Request* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

const ::proto::steam::CGameNotifications_LocalizedText&
CGameNotifications_UpdateSession_Request::HasBitSetters::title(const CGameNotifications_UpdateSession_Request* msg) {
  return *msg->title_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CGameNotifications_UpdateSession_Request::kSessionidFieldNumber;
const int CGameNotifications_UpdateSession_Request::kAppidFieldNumber;
const int CGameNotifications_UpdateSession_Request::kTitleFieldNumber;
const int CGameNotifications_UpdateSession_Request::kUsersFieldNumber;
const int CGameNotifications_UpdateSession_Request::kSteamidFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CGameNotifications_UpdateSession_Request::CGameNotifications_UpdateSession_Request()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.steam.CGameNotifications_UpdateSession_Request)
}
CGameNotifications_UpdateSession_Request::CGameNotifications_UpdateSession_Request(const CGameNotifications_UpdateSession_Request& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      users_(from.users_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_title()) {
    title_ = new ::proto::steam::CGameNotifications_LocalizedText(*from.title_);
  } else {
    title_ = nullptr;
  }
  ::memcpy(&sessionid_, &from.sessionid_,
    static_cast<size_t>(reinterpret_cast<char*>(&appid_) -
    reinterpret_cast<char*>(&sessionid_)) + sizeof(appid_));
  // @@protoc_insertion_point(copy_constructor:proto.steam.CGameNotifications_UpdateSession_Request)
}

void CGameNotifications_UpdateSession_Request::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CGameNotifications_UpdateSession_Request_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  ::memset(&title_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&appid_) -
      reinterpret_cast<char*>(&title_)) + sizeof(appid_));
}

CGameNotifications_UpdateSession_Request::~CGameNotifications_UpdateSession_Request() {
  // @@protoc_insertion_point(destructor:proto.steam.CGameNotifications_UpdateSession_Request)
  SharedDtor();
}

void CGameNotifications_UpdateSession_Request::SharedDtor() {
  if (this != internal_default_instance()) delete title_;
}

void CGameNotifications_UpdateSession_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CGameNotifications_UpdateSession_Request& CGameNotifications_UpdateSession_Request::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CGameNotifications_UpdateSession_Request_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  return *internal_default_instance();
}


void CGameNotifications_UpdateSession_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.steam.CGameNotifications_UpdateSession_Request)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  users_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(title_ != nullptr);
    title_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&sessionid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&appid_) -
        reinterpret_cast<char*>(&sessionid_)) + sizeof(appid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CGameNotifications_UpdateSession_Request::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CGameNotifications_UpdateSession_Request*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid to update."];
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_sessionid(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 appid = 2 [(.proto.steam.description) = "The appid of the session to update."];
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_appid(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .proto.steam.CGameNotifications_LocalizedText title = 3 [(.proto.steam.description) = "(Optional) The new title of the session.  If not specified, the title will not be changed."];
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::steam::CGameNotifications_LocalizedText::_InternalParse;
        object = msg->mutable_title();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // repeated .proto.steam.CGameNotifications_UserStatus users = 4 [(.proto.steam.description) = "(Optional) A list of users whose state will be updated to reflect the given state. If the users are not already in the session, they will be added to it."];
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::proto::steam::CGameNotifications_UserStatus::_InternalParse;
          object = msg->add_users();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 34 && (ptr += 1));
        break;
      }
      // optional fixed64 steamid = 6 [(.proto.steam.description) = "(Optional) steamid to make the request on behalf of -- if specified, the user must be in the session and all users being added to the session must be friends with the user."];
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 49) goto handle_unusual;
        msg->set_steamid(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr));
        ptr += sizeof(::google::protobuf::uint64);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CGameNotifications_UpdateSession_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.steam.CGameNotifications_UpdateSession_Request)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid to update."];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_sessionid(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &sessionid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 appid = 2 [(.proto.steam.description) = "The appid of the session to update."];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_appid(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &appid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.steam.CGameNotifications_LocalizedText title = 3 [(.proto.steam.description) = "(Optional) The new title of the session.  If not specified, the title will not be changed."];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_title()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .proto.steam.CGameNotifications_UserStatus users = 4 [(.proto.steam.description) = "(Optional) A list of users whose state will be updated to reflect the given state. If the users are not already in the session, they will be added to it."];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_users()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed64 steamid = 6 [(.proto.steam.description) = "(Optional) steamid to make the request on behalf of -- if specified, the user must be in the session and all users being added to the session must be friends with the user."];
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (49 & 0xFF)) {
          HasBitSetters::set_has_steamid(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &steamid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.steam.CGameNotifications_UpdateSession_Request)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.steam.CGameNotifications_UpdateSession_Request)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CGameNotifications_UpdateSession_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.steam.CGameNotifications_UpdateSession_Request)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid to update."];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->sessionid(), output);
  }

  // optional uint32 appid = 2 [(.proto.steam.description) = "The appid of the session to update."];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->appid(), output);
  }

  // optional .proto.steam.CGameNotifications_LocalizedText title = 3 [(.proto.steam.description) = "(Optional) The new title of the session.  If not specified, the title will not be changed."];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::title(this), output);
  }

  // repeated .proto.steam.CGameNotifications_UserStatus users = 4 [(.proto.steam.description) = "(Optional) A list of users whose state will be updated to reflect the given state. If the users are not already in the session, they will be added to it."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->users_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4,
      this->users(static_cast<int>(i)),
      output);
  }

  // optional fixed64 steamid = 6 [(.proto.steam.description) = "(Optional) steamid to make the request on behalf of -- if specified, the user must be in the session and all users being added to the session must be friends with the user."];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(6, this->steamid(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.steam.CGameNotifications_UpdateSession_Request)
}

::google::protobuf::uint8* CGameNotifications_UpdateSession_Request::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.steam.CGameNotifications_UpdateSession_Request)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid to update."];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->sessionid(), target);
  }

  // optional uint32 appid = 2 [(.proto.steam.description) = "The appid of the session to update."];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->appid(), target);
  }

  // optional .proto.steam.CGameNotifications_LocalizedText title = 3 [(.proto.steam.description) = "(Optional) The new title of the session.  If not specified, the title will not be changed."];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::title(this), target);
  }

  // repeated .proto.steam.CGameNotifications_UserStatus users = 4 [(.proto.steam.description) = "(Optional) A list of users whose state will be updated to reflect the given state. If the users are not already in the session, they will be added to it."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->users_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, this->users(static_cast<int>(i)), target);
  }

  // optional fixed64 steamid = 6 [(.proto.steam.description) = "(Optional) steamid to make the request on behalf of -- if specified, the user must be in the session and all users being added to the session must be friends with the user."];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(6, this->steamid(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.steam.CGameNotifications_UpdateSession_Request)
  return target;
}

size_t CGameNotifications_UpdateSession_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.steam.CGameNotifications_UpdateSession_Request)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.steam.CGameNotifications_UserStatus users = 4 [(.proto.steam.description) = "(Optional) A list of users whose state will be updated to reflect the given state. If the users are not already in the session, they will be added to it."];
  {
    unsigned int count = static_cast<unsigned int>(this->users_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->users(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .proto.steam.CGameNotifications_LocalizedText title = 3 [(.proto.steam.description) = "(Optional) The new title of the session.  If not specified, the title will not be changed."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *title_);
    }

    // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid to update."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->sessionid());
    }

    // optional fixed64 steamid = 6 [(.proto.steam.description) = "(Optional) steamid to make the request on behalf of -- if specified, the user must be in the session and all users being added to the session must be friends with the user."];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional uint32 appid = 2 [(.proto.steam.description) = "The appid of the session to update."];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->appid());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGameNotifications_UpdateSession_Request::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.steam.CGameNotifications_UpdateSession_Request)
  GOOGLE_DCHECK_NE(&from, this);
  const CGameNotifications_UpdateSession_Request* source =
      ::google::protobuf::DynamicCastToGenerated<CGameNotifications_UpdateSession_Request>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.steam.CGameNotifications_UpdateSession_Request)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.steam.CGameNotifications_UpdateSession_Request)
    MergeFrom(*source);
  }
}

void CGameNotifications_UpdateSession_Request::MergeFrom(const CGameNotifications_UpdateSession_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.steam.CGameNotifications_UpdateSession_Request)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  users_.MergeFrom(from.users_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_title()->::proto::steam::CGameNotifications_LocalizedText::MergeFrom(from.title());
    }
    if (cached_has_bits & 0x00000002u) {
      sessionid_ = from.sessionid_;
    }
    if (cached_has_bits & 0x00000004u) {
      steamid_ = from.steamid_;
    }
    if (cached_has_bits & 0x00000008u) {
      appid_ = from.appid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CGameNotifications_UpdateSession_Request::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.steam.CGameNotifications_UpdateSession_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CGameNotifications_UpdateSession_Request::CopyFrom(const CGameNotifications_UpdateSession_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.steam.CGameNotifications_UpdateSession_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_UpdateSession_Request::IsInitialized() const {
  return true;
}

void CGameNotifications_UpdateSession_Request::Swap(CGameNotifications_UpdateSession_Request* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CGameNotifications_UpdateSession_Request::InternalSwap(CGameNotifications_UpdateSession_Request* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&users_)->InternalSwap(CastToBase(&other->users_));
  swap(title_, other->title_);
  swap(sessionid_, other->sessionid_);
  swap(steamid_, other->steamid_);
  swap(appid_, other->appid_);
}

::google::protobuf::Metadata CGameNotifications_UpdateSession_Request::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_steammessages_5fgamenotifications_2esteamclient_2eproto);
  return ::file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CGameNotifications_UpdateSession_Response::InitAsDefaultInstance() {
}
class CGameNotifications_UpdateSession_Response::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CGameNotifications_UpdateSession_Response::CGameNotifications_UpdateSession_Response()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.steam.CGameNotifications_UpdateSession_Response)
}
CGameNotifications_UpdateSession_Response::CGameNotifications_UpdateSession_Response(const CGameNotifications_UpdateSession_Response& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.steam.CGameNotifications_UpdateSession_Response)
}

void CGameNotifications_UpdateSession_Response::SharedCtor() {
}

CGameNotifications_UpdateSession_Response::~CGameNotifications_UpdateSession_Response() {
  // @@protoc_insertion_point(destructor:proto.steam.CGameNotifications_UpdateSession_Response)
  SharedDtor();
}

void CGameNotifications_UpdateSession_Response::SharedDtor() {
}

void CGameNotifications_UpdateSession_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CGameNotifications_UpdateSession_Response& CGameNotifications_UpdateSession_Response::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CGameNotifications_UpdateSession_Response_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  return *internal_default_instance();
}


void CGameNotifications_UpdateSession_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.steam.CGameNotifications_UpdateSession_Response)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CGameNotifications_UpdateSession_Response::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CGameNotifications_UpdateSession_Response*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      default: {
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CGameNotifications_UpdateSession_Response::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.steam.CGameNotifications_UpdateSession_Response)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, _internal_metadata_.mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:proto.steam.CGameNotifications_UpdateSession_Response)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.steam.CGameNotifications_UpdateSession_Response)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CGameNotifications_UpdateSession_Response::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.steam.CGameNotifications_UpdateSession_Response)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.steam.CGameNotifications_UpdateSession_Response)
}

::google::protobuf::uint8* CGameNotifications_UpdateSession_Response::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.steam.CGameNotifications_UpdateSession_Response)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.steam.CGameNotifications_UpdateSession_Response)
  return target;
}

size_t CGameNotifications_UpdateSession_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.steam.CGameNotifications_UpdateSession_Response)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGameNotifications_UpdateSession_Response::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.steam.CGameNotifications_UpdateSession_Response)
  GOOGLE_DCHECK_NE(&from, this);
  const CGameNotifications_UpdateSession_Response* source =
      ::google::protobuf::DynamicCastToGenerated<CGameNotifications_UpdateSession_Response>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.steam.CGameNotifications_UpdateSession_Response)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.steam.CGameNotifications_UpdateSession_Response)
    MergeFrom(*source);
  }
}

void CGameNotifications_UpdateSession_Response::MergeFrom(const CGameNotifications_UpdateSession_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.steam.CGameNotifications_UpdateSession_Response)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void CGameNotifications_UpdateSession_Response::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.steam.CGameNotifications_UpdateSession_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CGameNotifications_UpdateSession_Response::CopyFrom(const CGameNotifications_UpdateSession_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.steam.CGameNotifications_UpdateSession_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_UpdateSession_Response::IsInitialized() const {
  return true;
}

void CGameNotifications_UpdateSession_Response::Swap(CGameNotifications_UpdateSession_Response* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CGameNotifications_UpdateSession_Response::InternalSwap(CGameNotifications_UpdateSession_Response* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
}

::google::protobuf::Metadata CGameNotifications_UpdateSession_Response::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_steammessages_5fgamenotifications_2esteamclient_2eproto);
  return ::file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CGameNotifications_EnumerateSessions_Request::InitAsDefaultInstance() {
}
class CGameNotifications_EnumerateSessions_Request::HasBitSetters {
 public:
  static void set_has_appid(CGameNotifications_EnumerateSessions_Request* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_include_all_user_messages(CGameNotifications_EnumerateSessions_Request* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_include_auth_user_message(CGameNotifications_EnumerateSessions_Request* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_language(CGameNotifications_EnumerateSessions_Request* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CGameNotifications_EnumerateSessions_Request::kAppidFieldNumber;
const int CGameNotifications_EnumerateSessions_Request::kIncludeAllUserMessagesFieldNumber;
const int CGameNotifications_EnumerateSessions_Request::kIncludeAuthUserMessageFieldNumber;
const int CGameNotifications_EnumerateSessions_Request::kLanguageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CGameNotifications_EnumerateSessions_Request::CGameNotifications_EnumerateSessions_Request()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.steam.CGameNotifications_EnumerateSessions_Request)
}
CGameNotifications_EnumerateSessions_Request::CGameNotifications_EnumerateSessions_Request(const CGameNotifications_EnumerateSessions_Request& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  language_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_language()) {
    language_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.language_);
  }
  ::memcpy(&appid_, &from.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&include_auth_user_message_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(include_auth_user_message_));
  // @@protoc_insertion_point(copy_constructor:proto.steam.CGameNotifications_EnumerateSessions_Request)
}

void CGameNotifications_EnumerateSessions_Request::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CGameNotifications_EnumerateSessions_Request_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  language_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&appid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&include_auth_user_message_) -
      reinterpret_cast<char*>(&appid_)) + sizeof(include_auth_user_message_));
}

CGameNotifications_EnumerateSessions_Request::~CGameNotifications_EnumerateSessions_Request() {
  // @@protoc_insertion_point(destructor:proto.steam.CGameNotifications_EnumerateSessions_Request)
  SharedDtor();
}

void CGameNotifications_EnumerateSessions_Request::SharedDtor() {
  language_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void CGameNotifications_EnumerateSessions_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CGameNotifications_EnumerateSessions_Request& CGameNotifications_EnumerateSessions_Request::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CGameNotifications_EnumerateSessions_Request_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  return *internal_default_instance();
}


void CGameNotifications_EnumerateSessions_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.steam.CGameNotifications_EnumerateSessions_Request)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    language_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&include_auth_user_message_) -
        reinterpret_cast<char*>(&appid_)) + sizeof(include_auth_user_message_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CGameNotifications_EnumerateSessions_Request::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CGameNotifications_EnumerateSessions_Request*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional uint32 appid = 1 [(.proto.steam.description) = "The sessionid to request details for. Optional. If not specified, all the user\'s sessions will be returned."];
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_appid(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool include_all_user_messages = 3 [(.proto.steam.description) = "(Optional) Boolean determining whether the message for all users should be included. Defaults to false."];
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_include_all_user_messages(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool include_auth_user_message = 4 [(.proto.steam.description) = "(Optional) Boolean determining whether the message for the authenticated user should be included. Defaults to false."];
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_include_auth_user_message(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional string language = 5 [(.proto.steam.description) = "(Optional) Language to localize the text in."];
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("proto.steam.CGameNotifications_EnumerateSessions_Request.language");
        object = msg->mutable_language();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CGameNotifications_EnumerateSessions_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.steam.CGameNotifications_EnumerateSessions_Request)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 appid = 1 [(.proto.steam.description) = "The sessionid to request details for. Optional. If not specified, all the user\'s sessions will be returned."];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_appid(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &appid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool include_all_user_messages = 3 [(.proto.steam.description) = "(Optional) Boolean determining whether the message for all users should be included. Defaults to false."];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_include_all_user_messages(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &include_all_user_messages_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool include_auth_user_message = 4 [(.proto.steam.description) = "(Optional) Boolean determining whether the message for the authenticated user should be included. Defaults to false."];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_include_auth_user_message(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &include_auth_user_message_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string language = 5 [(.proto.steam.description) = "(Optional) Language to localize the text in."];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_language()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->language().data(), static_cast<int>(this->language().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "proto.steam.CGameNotifications_EnumerateSessions_Request.language");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.steam.CGameNotifications_EnumerateSessions_Request)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.steam.CGameNotifications_EnumerateSessions_Request)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CGameNotifications_EnumerateSessions_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.steam.CGameNotifications_EnumerateSessions_Request)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1 [(.proto.steam.description) = "The sessionid to request details for. Optional. If not specified, all the user\'s sessions will be returned."];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->appid(), output);
  }

  // optional bool include_all_user_messages = 3 [(.proto.steam.description) = "(Optional) Boolean determining whether the message for all users should be included. Defaults to false."];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->include_all_user_messages(), output);
  }

  // optional bool include_auth_user_message = 4 [(.proto.steam.description) = "(Optional) Boolean determining whether the message for the authenticated user should be included. Defaults to false."];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->include_auth_user_message(), output);
  }

  // optional string language = 5 [(.proto.steam.description) = "(Optional) Language to localize the text in."];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->language().data(), static_cast<int>(this->language().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "proto.steam.CGameNotifications_EnumerateSessions_Request.language");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->language(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.steam.CGameNotifications_EnumerateSessions_Request)
}

::google::protobuf::uint8* CGameNotifications_EnumerateSessions_Request::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.steam.CGameNotifications_EnumerateSessions_Request)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1 [(.proto.steam.description) = "The sessionid to request details for. Optional. If not specified, all the user\'s sessions will be returned."];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->appid(), target);
  }

  // optional bool include_all_user_messages = 3 [(.proto.steam.description) = "(Optional) Boolean determining whether the message for all users should be included. Defaults to false."];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->include_all_user_messages(), target);
  }

  // optional bool include_auth_user_message = 4 [(.proto.steam.description) = "(Optional) Boolean determining whether the message for the authenticated user should be included. Defaults to false."];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->include_auth_user_message(), target);
  }

  // optional string language = 5 [(.proto.steam.description) = "(Optional) Language to localize the text in."];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->language().data(), static_cast<int>(this->language().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "proto.steam.CGameNotifications_EnumerateSessions_Request.language");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->language(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.steam.CGameNotifications_EnumerateSessions_Request)
  return target;
}

size_t CGameNotifications_EnumerateSessions_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.steam.CGameNotifications_EnumerateSessions_Request)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string language = 5 [(.proto.steam.description) = "(Optional) Language to localize the text in."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->language());
    }

    // optional uint32 appid = 1 [(.proto.steam.description) = "The sessionid to request details for. Optional. If not specified, all the user\'s sessions will be returned."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->appid());
    }

    // optional bool include_all_user_messages = 3 [(.proto.steam.description) = "(Optional) Boolean determining whether the message for all users should be included. Defaults to false."];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool include_auth_user_message = 4 [(.proto.steam.description) = "(Optional) Boolean determining whether the message for the authenticated user should be included. Defaults to false."];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGameNotifications_EnumerateSessions_Request::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.steam.CGameNotifications_EnumerateSessions_Request)
  GOOGLE_DCHECK_NE(&from, this);
  const CGameNotifications_EnumerateSessions_Request* source =
      ::google::protobuf::DynamicCastToGenerated<CGameNotifications_EnumerateSessions_Request>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.steam.CGameNotifications_EnumerateSessions_Request)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.steam.CGameNotifications_EnumerateSessions_Request)
    MergeFrom(*source);
  }
}

void CGameNotifications_EnumerateSessions_Request::MergeFrom(const CGameNotifications_EnumerateSessions_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.steam.CGameNotifications_EnumerateSessions_Request)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      language_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.language_);
    }
    if (cached_has_bits & 0x00000002u) {
      appid_ = from.appid_;
    }
    if (cached_has_bits & 0x00000004u) {
      include_all_user_messages_ = from.include_all_user_messages_;
    }
    if (cached_has_bits & 0x00000008u) {
      include_auth_user_message_ = from.include_auth_user_message_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CGameNotifications_EnumerateSessions_Request::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.steam.CGameNotifications_EnumerateSessions_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CGameNotifications_EnumerateSessions_Request::CopyFrom(const CGameNotifications_EnumerateSessions_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.steam.CGameNotifications_EnumerateSessions_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_EnumerateSessions_Request::IsInitialized() const {
  return true;
}

void CGameNotifications_EnumerateSessions_Request::Swap(CGameNotifications_EnumerateSessions_Request* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CGameNotifications_EnumerateSessions_Request::InternalSwap(CGameNotifications_EnumerateSessions_Request* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  language_.Swap(&other->language_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(appid_, other->appid_);
  swap(include_all_user_messages_, other->include_all_user_messages_);
  swap(include_auth_user_message_, other->include_auth_user_message_);
}

::google::protobuf::Metadata CGameNotifications_EnumerateSessions_Request::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_steammessages_5fgamenotifications_2esteamclient_2eproto);
  return ::file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CGameNotifications_Session::InitAsDefaultInstance() {
  ::proto::steam::_CGameNotifications_Session_default_instance_._instance.get_mutable()->title_ = const_cast< ::proto::steam::CGameNotifications_LocalizedText*>(
      ::proto::steam::CGameNotifications_LocalizedText::internal_default_instance());
}
class CGameNotifications_Session::HasBitSetters {
 public:
  static void set_has_sessionid(CGameNotifications_Session* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_appid(CGameNotifications_Session* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_context(CGameNotifications_Session* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static const ::proto::steam::CGameNotifications_LocalizedText& title(const CGameNotifications_Session* msg);
  static void set_has_title(CGameNotifications_Session* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_time_created(CGameNotifications_Session* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_time_updated(CGameNotifications_Session* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
};

const ::proto::steam::CGameNotifications_LocalizedText&
CGameNotifications_Session::HasBitSetters::title(const CGameNotifications_Session* msg) {
  return *msg->title_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CGameNotifications_Session::kSessionidFieldNumber;
const int CGameNotifications_Session::kAppidFieldNumber;
const int CGameNotifications_Session::kContextFieldNumber;
const int CGameNotifications_Session::kTitleFieldNumber;
const int CGameNotifications_Session::kTimeCreatedFieldNumber;
const int CGameNotifications_Session::kTimeUpdatedFieldNumber;
const int CGameNotifications_Session::kUserStatusFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CGameNotifications_Session::CGameNotifications_Session()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.steam.CGameNotifications_Session)
}
CGameNotifications_Session::CGameNotifications_Session(const CGameNotifications_Session& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      user_status_(from.user_status_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_title()) {
    title_ = new ::proto::steam::CGameNotifications_LocalizedText(*from.title_);
  } else {
    title_ = nullptr;
  }
  ::memcpy(&sessionid_, &from.sessionid_,
    static_cast<size_t>(reinterpret_cast<char*>(&time_updated_) -
    reinterpret_cast<char*>(&sessionid_)) + sizeof(time_updated_));
  // @@protoc_insertion_point(copy_constructor:proto.steam.CGameNotifications_Session)
}

void CGameNotifications_Session::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CGameNotifications_Session_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  ::memset(&title_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&time_updated_) -
      reinterpret_cast<char*>(&title_)) + sizeof(time_updated_));
}

CGameNotifications_Session::~CGameNotifications_Session() {
  // @@protoc_insertion_point(destructor:proto.steam.CGameNotifications_Session)
  SharedDtor();
}

void CGameNotifications_Session::SharedDtor() {
  if (this != internal_default_instance()) delete title_;
}

void CGameNotifications_Session::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CGameNotifications_Session& CGameNotifications_Session::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CGameNotifications_Session_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  return *internal_default_instance();
}


void CGameNotifications_Session::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.steam.CGameNotifications_Session)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_status_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(title_ != nullptr);
    title_->Clear();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&sessionid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&time_updated_) -
        reinterpret_cast<char*>(&sessionid_)) + sizeof(time_updated_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CGameNotifications_Session::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CGameNotifications_Session*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid for this session."];
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_sessionid(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 appid = 2 [(.proto.steam.description) = "The appid for the session."];
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_appid(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 context = 3 [(.proto.steam.description) = "Game-specified context value the game can used to associate the session with some object on their backend."];
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_context(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .proto.steam.CGameNotifications_LocalizedText title = 4 [(.proto.steam.description) = "The current title for the session."];
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::steam::CGameNotifications_LocalizedText::_InternalParse;
        object = msg->mutable_title();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional uint32 time_created = 5 [(.proto.steam.description) = "The time the session was created."];
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_time_created(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 time_updated = 6 [(.proto.steam.description) = "The last time the session was updated."];
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        msg->set_time_updated(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated .proto.steam.CGameNotifications_UserStatus user_status = 7 [(.proto.steam.description) = "The status of all the users in the session."];
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::proto::steam::CGameNotifications_UserStatus::_InternalParse;
          object = msg->add_user_status();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 58 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CGameNotifications_Session::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.steam.CGameNotifications_Session)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid for this session."];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_sessionid(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &sessionid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 appid = 2 [(.proto.steam.description) = "The appid for the session."];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_appid(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &appid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 context = 3 [(.proto.steam.description) = "Game-specified context value the game can used to associate the session with some object on their backend."];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_context(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &context_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.steam.CGameNotifications_LocalizedText title = 4 [(.proto.steam.description) = "The current title for the session."];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_title()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 time_created = 5 [(.proto.steam.description) = "The time the session was created."];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_time_created(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_created_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 time_updated = 6 [(.proto.steam.description) = "The last time the session was updated."];
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_time_updated(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_updated_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .proto.steam.CGameNotifications_UserStatus user_status = 7 [(.proto.steam.description) = "The status of all the users in the session."];
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_user_status()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.steam.CGameNotifications_Session)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.steam.CGameNotifications_Session)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CGameNotifications_Session::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.steam.CGameNotifications_Session)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid for this session."];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->sessionid(), output);
  }

  // optional uint64 appid = 2 [(.proto.steam.description) = "The appid for the session."];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->appid(), output);
  }

  // optional uint64 context = 3 [(.proto.steam.description) = "Game-specified context value the game can used to associate the session with some object on their backend."];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->context(), output);
  }

  // optional .proto.steam.CGameNotifications_LocalizedText title = 4 [(.proto.steam.description) = "The current title for the session."];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::title(this), output);
  }

  // optional uint32 time_created = 5 [(.proto.steam.description) = "The time the session was created."];
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->time_created(), output);
  }

  // optional uint32 time_updated = 6 [(.proto.steam.description) = "The last time the session was updated."];
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->time_updated(), output);
  }

  // repeated .proto.steam.CGameNotifications_UserStatus user_status = 7 [(.proto.steam.description) = "The status of all the users in the session."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->user_status_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7,
      this->user_status(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.steam.CGameNotifications_Session)
}

::google::protobuf::uint8* CGameNotifications_Session::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.steam.CGameNotifications_Session)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid for this session."];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->sessionid(), target);
  }

  // optional uint64 appid = 2 [(.proto.steam.description) = "The appid for the session."];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->appid(), target);
  }

  // optional uint64 context = 3 [(.proto.steam.description) = "Game-specified context value the game can used to associate the session with some object on their backend."];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->context(), target);
  }

  // optional .proto.steam.CGameNotifications_LocalizedText title = 4 [(.proto.steam.description) = "The current title for the session."];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::title(this), target);
  }

  // optional uint32 time_created = 5 [(.proto.steam.description) = "The time the session was created."];
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->time_created(), target);
  }

  // optional uint32 time_updated = 6 [(.proto.steam.description) = "The last time the session was updated."];
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->time_updated(), target);
  }

  // repeated .proto.steam.CGameNotifications_UserStatus user_status = 7 [(.proto.steam.description) = "The status of all the users in the session."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->user_status_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, this->user_status(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.steam.CGameNotifications_Session)
  return target;
}

size_t CGameNotifications_Session::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.steam.CGameNotifications_Session)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.steam.CGameNotifications_UserStatus user_status = 7 [(.proto.steam.description) = "The status of all the users in the session."];
  {
    unsigned int count = static_cast<unsigned int>(this->user_status_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->user_status(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .proto.steam.CGameNotifications_LocalizedText title = 4 [(.proto.steam.description) = "The current title for the session."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *title_);
    }

    // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid for this session."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->sessionid());
    }

    // optional uint64 appid = 2 [(.proto.steam.description) = "The appid for the session."];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->appid());
    }

    // optional uint64 context = 3 [(.proto.steam.description) = "Game-specified context value the game can used to associate the session with some object on their backend."];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->context());
    }

    // optional uint32 time_created = 5 [(.proto.steam.description) = "The time the session was created."];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_created());
    }

    // optional uint32 time_updated = 6 [(.proto.steam.description) = "The last time the session was updated."];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_updated());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGameNotifications_Session::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.steam.CGameNotifications_Session)
  GOOGLE_DCHECK_NE(&from, this);
  const CGameNotifications_Session* source =
      ::google::protobuf::DynamicCastToGenerated<CGameNotifications_Session>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.steam.CGameNotifications_Session)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.steam.CGameNotifications_Session)
    MergeFrom(*source);
  }
}

void CGameNotifications_Session::MergeFrom(const CGameNotifications_Session& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.steam.CGameNotifications_Session)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  user_status_.MergeFrom(from.user_status_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_title()->::proto::steam::CGameNotifications_LocalizedText::MergeFrom(from.title());
    }
    if (cached_has_bits & 0x00000002u) {
      sessionid_ = from.sessionid_;
    }
    if (cached_has_bits & 0x00000004u) {
      appid_ = from.appid_;
    }
    if (cached_has_bits & 0x00000008u) {
      context_ = from.context_;
    }
    if (cached_has_bits & 0x00000010u) {
      time_created_ = from.time_created_;
    }
    if (cached_has_bits & 0x00000020u) {
      time_updated_ = from.time_updated_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CGameNotifications_Session::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.steam.CGameNotifications_Session)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CGameNotifications_Session::CopyFrom(const CGameNotifications_Session& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.steam.CGameNotifications_Session)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_Session::IsInitialized() const {
  return true;
}

void CGameNotifications_Session::Swap(CGameNotifications_Session* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CGameNotifications_Session::InternalSwap(CGameNotifications_Session* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&user_status_)->InternalSwap(CastToBase(&other->user_status_));
  swap(title_, other->title_);
  swap(sessionid_, other->sessionid_);
  swap(appid_, other->appid_);
  swap(context_, other->context_);
  swap(time_created_, other->time_created_);
  swap(time_updated_, other->time_updated_);
}

::google::protobuf::Metadata CGameNotifications_Session::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_steammessages_5fgamenotifications_2esteamclient_2eproto);
  return ::file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CGameNotifications_EnumerateSessions_Response::InitAsDefaultInstance() {
}
class CGameNotifications_EnumerateSessions_Response::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CGameNotifications_EnumerateSessions_Response::kSessionsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CGameNotifications_EnumerateSessions_Response::CGameNotifications_EnumerateSessions_Response()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.steam.CGameNotifications_EnumerateSessions_Response)
}
CGameNotifications_EnumerateSessions_Response::CGameNotifications_EnumerateSessions_Response(const CGameNotifications_EnumerateSessions_Response& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      sessions_(from.sessions_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.steam.CGameNotifications_EnumerateSessions_Response)
}

void CGameNotifications_EnumerateSessions_Response::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CGameNotifications_EnumerateSessions_Response_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
}

CGameNotifications_EnumerateSessions_Response::~CGameNotifications_EnumerateSessions_Response() {
  // @@protoc_insertion_point(destructor:proto.steam.CGameNotifications_EnumerateSessions_Response)
  SharedDtor();
}

void CGameNotifications_EnumerateSessions_Response::SharedDtor() {
}

void CGameNotifications_EnumerateSessions_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CGameNotifications_EnumerateSessions_Response& CGameNotifications_EnumerateSessions_Response::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CGameNotifications_EnumerateSessions_Response_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  return *internal_default_instance();
}


void CGameNotifications_EnumerateSessions_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.steam.CGameNotifications_EnumerateSessions_Response)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sessions_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CGameNotifications_EnumerateSessions_Response::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CGameNotifications_EnumerateSessions_Response*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .proto.steam.CGameNotifications_Session sessions = 1 [(.proto.steam.description) = "A list of the user\'s sessions."];
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::proto::steam::CGameNotifications_Session::_InternalParse;
          object = msg->add_sessions();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CGameNotifications_EnumerateSessions_Response::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.steam.CGameNotifications_EnumerateSessions_Response)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .proto.steam.CGameNotifications_Session sessions = 1 [(.proto.steam.description) = "A list of the user\'s sessions."];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_sessions()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.steam.CGameNotifications_EnumerateSessions_Response)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.steam.CGameNotifications_EnumerateSessions_Response)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CGameNotifications_EnumerateSessions_Response::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.steam.CGameNotifications_EnumerateSessions_Response)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.steam.CGameNotifications_Session sessions = 1 [(.proto.steam.description) = "A list of the user\'s sessions."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->sessions_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->sessions(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.steam.CGameNotifications_EnumerateSessions_Response)
}

::google::protobuf::uint8* CGameNotifications_EnumerateSessions_Response::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.steam.CGameNotifications_EnumerateSessions_Response)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.steam.CGameNotifications_Session sessions = 1 [(.proto.steam.description) = "A list of the user\'s sessions."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->sessions_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->sessions(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.steam.CGameNotifications_EnumerateSessions_Response)
  return target;
}

size_t CGameNotifications_EnumerateSessions_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.steam.CGameNotifications_EnumerateSessions_Response)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.steam.CGameNotifications_Session sessions = 1 [(.proto.steam.description) = "A list of the user\'s sessions."];
  {
    unsigned int count = static_cast<unsigned int>(this->sessions_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->sessions(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGameNotifications_EnumerateSessions_Response::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.steam.CGameNotifications_EnumerateSessions_Response)
  GOOGLE_DCHECK_NE(&from, this);
  const CGameNotifications_EnumerateSessions_Response* source =
      ::google::protobuf::DynamicCastToGenerated<CGameNotifications_EnumerateSessions_Response>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.steam.CGameNotifications_EnumerateSessions_Response)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.steam.CGameNotifications_EnumerateSessions_Response)
    MergeFrom(*source);
  }
}

void CGameNotifications_EnumerateSessions_Response::MergeFrom(const CGameNotifications_EnumerateSessions_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.steam.CGameNotifications_EnumerateSessions_Response)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  sessions_.MergeFrom(from.sessions_);
}

void CGameNotifications_EnumerateSessions_Response::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.steam.CGameNotifications_EnumerateSessions_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CGameNotifications_EnumerateSessions_Response::CopyFrom(const CGameNotifications_EnumerateSessions_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.steam.CGameNotifications_EnumerateSessions_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_EnumerateSessions_Response::IsInitialized() const {
  return true;
}

void CGameNotifications_EnumerateSessions_Response::Swap(CGameNotifications_EnumerateSessions_Response* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CGameNotifications_EnumerateSessions_Response::InternalSwap(CGameNotifications_EnumerateSessions_Response* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&sessions_)->InternalSwap(CastToBase(&other->sessions_));
}

::google::protobuf::Metadata CGameNotifications_EnumerateSessions_Response::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_steammessages_5fgamenotifications_2esteamclient_2eproto);
  return ::file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CGameNotifications_GetSessionDetails_Request_RequestedSession::InitAsDefaultInstance() {
}
class CGameNotifications_GetSessionDetails_Request_RequestedSession::HasBitSetters {
 public:
  static void set_has_sessionid(CGameNotifications_GetSessionDetails_Request_RequestedSession* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_include_auth_user_message(CGameNotifications_GetSessionDetails_Request_RequestedSession* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CGameNotifications_GetSessionDetails_Request_RequestedSession::kSessionidFieldNumber;
const int CGameNotifications_GetSessionDetails_Request_RequestedSession::kIncludeAuthUserMessageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CGameNotifications_GetSessionDetails_Request_RequestedSession::CGameNotifications_GetSessionDetails_Request_RequestedSession()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.steam.CGameNotifications_GetSessionDetails_Request.RequestedSession)
}
CGameNotifications_GetSessionDetails_Request_RequestedSession::CGameNotifications_GetSessionDetails_Request_RequestedSession(const CGameNotifications_GetSessionDetails_Request_RequestedSession& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&sessionid_, &from.sessionid_,
    static_cast<size_t>(reinterpret_cast<char*>(&include_auth_user_message_) -
    reinterpret_cast<char*>(&sessionid_)) + sizeof(include_auth_user_message_));
  // @@protoc_insertion_point(copy_constructor:proto.steam.CGameNotifications_GetSessionDetails_Request.RequestedSession)
}

void CGameNotifications_GetSessionDetails_Request_RequestedSession::SharedCtor() {
  ::memset(&sessionid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&include_auth_user_message_) -
      reinterpret_cast<char*>(&sessionid_)) + sizeof(include_auth_user_message_));
}

CGameNotifications_GetSessionDetails_Request_RequestedSession::~CGameNotifications_GetSessionDetails_Request_RequestedSession() {
  // @@protoc_insertion_point(destructor:proto.steam.CGameNotifications_GetSessionDetails_Request.RequestedSession)
  SharedDtor();
}

void CGameNotifications_GetSessionDetails_Request_RequestedSession::SharedDtor() {
}

void CGameNotifications_GetSessionDetails_Request_RequestedSession::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CGameNotifications_GetSessionDetails_Request_RequestedSession& CGameNotifications_GetSessionDetails_Request_RequestedSession::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CGameNotifications_GetSessionDetails_Request_RequestedSession_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  return *internal_default_instance();
}


void CGameNotifications_GetSessionDetails_Request_RequestedSession::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.steam.CGameNotifications_GetSessionDetails_Request.RequestedSession)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&sessionid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&include_auth_user_message_) -
        reinterpret_cast<char*>(&sessionid_)) + sizeof(include_auth_user_message_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CGameNotifications_GetSessionDetails_Request_RequestedSession::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CGameNotifications_GetSessionDetails_Request_RequestedSession*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid to get details for."];
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_sessionid(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool include_auth_user_message = 3 [(.proto.steam.description) = "(Optional) Boolean determining whether the message for the authenticated user should be included. Defaults to false."];
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_include_auth_user_message(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CGameNotifications_GetSessionDetails_Request_RequestedSession::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.steam.CGameNotifications_GetSessionDetails_Request.RequestedSession)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid to get details for."];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_sessionid(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &sessionid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool include_auth_user_message = 3 [(.proto.steam.description) = "(Optional) Boolean determining whether the message for the authenticated user should be included. Defaults to false."];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_include_auth_user_message(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &include_auth_user_message_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.steam.CGameNotifications_GetSessionDetails_Request.RequestedSession)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.steam.CGameNotifications_GetSessionDetails_Request.RequestedSession)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CGameNotifications_GetSessionDetails_Request_RequestedSession::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.steam.CGameNotifications_GetSessionDetails_Request.RequestedSession)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid to get details for."];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->sessionid(), output);
  }

  // optional bool include_auth_user_message = 3 [(.proto.steam.description) = "(Optional) Boolean determining whether the message for the authenticated user should be included. Defaults to false."];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->include_auth_user_message(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.steam.CGameNotifications_GetSessionDetails_Request.RequestedSession)
}

::google::protobuf::uint8* CGameNotifications_GetSessionDetails_Request_RequestedSession::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.steam.CGameNotifications_GetSessionDetails_Request.RequestedSession)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid to get details for."];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->sessionid(), target);
  }

  // optional bool include_auth_user_message = 3 [(.proto.steam.description) = "(Optional) Boolean determining whether the message for the authenticated user should be included. Defaults to false."];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->include_auth_user_message(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.steam.CGameNotifications_GetSessionDetails_Request.RequestedSession)
  return target;
}

size_t CGameNotifications_GetSessionDetails_Request_RequestedSession::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.steam.CGameNotifications_GetSessionDetails_Request.RequestedSession)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 sessionid = 1 [(.proto.steam.description) = "The sessionid to get details for."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->sessionid());
    }

    // optional bool include_auth_user_message = 3 [(.proto.steam.description) = "(Optional) Boolean determining whether the message for the authenticated user should be included. Defaults to false."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGameNotifications_GetSessionDetails_Request_RequestedSession::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.steam.CGameNotifications_GetSessionDetails_Request.RequestedSession)
  GOOGLE_DCHECK_NE(&from, this);
  const CGameNotifications_GetSessionDetails_Request_RequestedSession* source =
      ::google::protobuf::DynamicCastToGenerated<CGameNotifications_GetSessionDetails_Request_RequestedSession>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.steam.CGameNotifications_GetSessionDetails_Request.RequestedSession)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.steam.CGameNotifications_GetSessionDetails_Request.RequestedSession)
    MergeFrom(*source);
  }
}

void CGameNotifications_GetSessionDetails_Request_RequestedSession::MergeFrom(const CGameNotifications_GetSessionDetails_Request_RequestedSession& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.steam.CGameNotifications_GetSessionDetails_Request.RequestedSession)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sessionid_ = from.sessionid_;
    }
    if (cached_has_bits & 0x00000002u) {
      include_auth_user_message_ = from.include_auth_user_message_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CGameNotifications_GetSessionDetails_Request_RequestedSession::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.steam.CGameNotifications_GetSessionDetails_Request.RequestedSession)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CGameNotifications_GetSessionDetails_Request_RequestedSession::CopyFrom(const CGameNotifications_GetSessionDetails_Request_RequestedSession& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.steam.CGameNotifications_GetSessionDetails_Request.RequestedSession)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_GetSessionDetails_Request_RequestedSession::IsInitialized() const {
  return true;
}

void CGameNotifications_GetSessionDetails_Request_RequestedSession::Swap(CGameNotifications_GetSessionDetails_Request_RequestedSession* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CGameNotifications_GetSessionDetails_Request_RequestedSession::InternalSwap(CGameNotifications_GetSessionDetails_Request_RequestedSession* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(sessionid_, other->sessionid_);
  swap(include_auth_user_message_, other->include_auth_user_message_);
}

::google::protobuf::Metadata CGameNotifications_GetSessionDetails_Request_RequestedSession::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_steammessages_5fgamenotifications_2esteamclient_2eproto);
  return ::file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CGameNotifications_GetSessionDetails_Request::InitAsDefaultInstance() {
}
class CGameNotifications_GetSessionDetails_Request::HasBitSetters {
 public:
  static void set_has_appid(CGameNotifications_GetSessionDetails_Request* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_language(CGameNotifications_GetSessionDetails_Request* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CGameNotifications_GetSessionDetails_Request::kSessionsFieldNumber;
const int CGameNotifications_GetSessionDetails_Request::kAppidFieldNumber;
const int CGameNotifications_GetSessionDetails_Request::kLanguageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CGameNotifications_GetSessionDetails_Request::CGameNotifications_GetSessionDetails_Request()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.steam.CGameNotifications_GetSessionDetails_Request)
}
CGameNotifications_GetSessionDetails_Request::CGameNotifications_GetSessionDetails_Request(const CGameNotifications_GetSessionDetails_Request& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      sessions_(from.sessions_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  language_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_language()) {
    language_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.language_);
  }
  appid_ = from.appid_;
  // @@protoc_insertion_point(copy_constructor:proto.steam.CGameNotifications_GetSessionDetails_Request)
}

void CGameNotifications_GetSessionDetails_Request::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CGameNotifications_GetSessionDetails_Request_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  language_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  appid_ = 0u;
}

CGameNotifications_GetSessionDetails_Request::~CGameNotifications_GetSessionDetails_Request() {
  // @@protoc_insertion_point(destructor:proto.steam.CGameNotifications_GetSessionDetails_Request)
  SharedDtor();
}

void CGameNotifications_GetSessionDetails_Request::SharedDtor() {
  language_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void CGameNotifications_GetSessionDetails_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CGameNotifications_GetSessionDetails_Request& CGameNotifications_GetSessionDetails_Request::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CGameNotifications_GetSessionDetails_Request_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  return *internal_default_instance();
}


void CGameNotifications_GetSessionDetails_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.steam.CGameNotifications_GetSessionDetails_Request)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sessions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    language_.ClearNonDefaultToEmptyNoArena();
  }
  appid_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CGameNotifications_GetSessionDetails_Request::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CGameNotifications_GetSessionDetails_Request*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .proto.steam.CGameNotifications_GetSessionDetails_Request.RequestedSession sessions = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::proto::steam::CGameNotifications_GetSessionDetails_Request_RequestedSession::_InternalParse;
          object = msg->add_sessions();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      // optional uint32 appid = 2 [(.proto.steam.description) = "The appid for the sessions."];
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_appid(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional string language = 3 [(.proto.steam.description) = "Language to localize the text in."];
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("proto.steam.CGameNotifications_GetSessionDetails_Request.language");
        object = msg->mutable_language();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParserUTF8Verify;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheckUTF8Verify(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CGameNotifications_GetSessionDetails_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.steam.CGameNotifications_GetSessionDetails_Request)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .proto.steam.CGameNotifications_GetSessionDetails_Request.RequestedSession sessions = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_sessions()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 appid = 2 [(.proto.steam.description) = "The appid for the sessions."];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_appid(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &appid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string language = 3 [(.proto.steam.description) = "Language to localize the text in."];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_language()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->language().data(), static_cast<int>(this->language().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "proto.steam.CGameNotifications_GetSessionDetails_Request.language");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.steam.CGameNotifications_GetSessionDetails_Request)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.steam.CGameNotifications_GetSessionDetails_Request)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CGameNotifications_GetSessionDetails_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.steam.CGameNotifications_GetSessionDetails_Request)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.steam.CGameNotifications_GetSessionDetails_Request.RequestedSession sessions = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->sessions_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->sessions(static_cast<int>(i)),
      output);
  }

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 2 [(.proto.steam.description) = "The appid for the sessions."];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->appid(), output);
  }

  // optional string language = 3 [(.proto.steam.description) = "Language to localize the text in."];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->language().data(), static_cast<int>(this->language().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "proto.steam.CGameNotifications_GetSessionDetails_Request.language");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->language(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.steam.CGameNotifications_GetSessionDetails_Request)
}

::google::protobuf::uint8* CGameNotifications_GetSessionDetails_Request::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.steam.CGameNotifications_GetSessionDetails_Request)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.steam.CGameNotifications_GetSessionDetails_Request.RequestedSession sessions = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->sessions_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->sessions(static_cast<int>(i)), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 2 [(.proto.steam.description) = "The appid for the sessions."];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->appid(), target);
  }

  // optional string language = 3 [(.proto.steam.description) = "Language to localize the text in."];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->language().data(), static_cast<int>(this->language().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "proto.steam.CGameNotifications_GetSessionDetails_Request.language");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->language(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.steam.CGameNotifications_GetSessionDetails_Request)
  return target;
}

size_t CGameNotifications_GetSessionDetails_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.steam.CGameNotifications_GetSessionDetails_Request)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.steam.CGameNotifications_GetSessionDetails_Request.RequestedSession sessions = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->sessions_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->sessions(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string language = 3 [(.proto.steam.description) = "Language to localize the text in."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->language());
    }

    // optional uint32 appid = 2 [(.proto.steam.description) = "The appid for the sessions."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->appid());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGameNotifications_GetSessionDetails_Request::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.steam.CGameNotifications_GetSessionDetails_Request)
  GOOGLE_DCHECK_NE(&from, this);
  const CGameNotifications_GetSessionDetails_Request* source =
      ::google::protobuf::DynamicCastToGenerated<CGameNotifications_GetSessionDetails_Request>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.steam.CGameNotifications_GetSessionDetails_Request)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.steam.CGameNotifications_GetSessionDetails_Request)
    MergeFrom(*source);
  }
}

void CGameNotifications_GetSessionDetails_Request::MergeFrom(const CGameNotifications_GetSessionDetails_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.steam.CGameNotifications_GetSessionDetails_Request)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  sessions_.MergeFrom(from.sessions_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      language_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.language_);
    }
    if (cached_has_bits & 0x00000002u) {
      appid_ = from.appid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CGameNotifications_GetSessionDetails_Request::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.steam.CGameNotifications_GetSessionDetails_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CGameNotifications_GetSessionDetails_Request::CopyFrom(const CGameNotifications_GetSessionDetails_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.steam.CGameNotifications_GetSessionDetails_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_GetSessionDetails_Request::IsInitialized() const {
  return true;
}

void CGameNotifications_GetSessionDetails_Request::Swap(CGameNotifications_GetSessionDetails_Request* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CGameNotifications_GetSessionDetails_Request::InternalSwap(CGameNotifications_GetSessionDetails_Request* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&sessions_)->InternalSwap(CastToBase(&other->sessions_));
  language_.Swap(&other->language_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(appid_, other->appid_);
}

::google::protobuf::Metadata CGameNotifications_GetSessionDetails_Request::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_steammessages_5fgamenotifications_2esteamclient_2eproto);
  return ::file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CGameNotifications_GetSessionDetails_Response::InitAsDefaultInstance() {
}
class CGameNotifications_GetSessionDetails_Response::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CGameNotifications_GetSessionDetails_Response::kSessionsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CGameNotifications_GetSessionDetails_Response::CGameNotifications_GetSessionDetails_Response()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.steam.CGameNotifications_GetSessionDetails_Response)
}
CGameNotifications_GetSessionDetails_Response::CGameNotifications_GetSessionDetails_Response(const CGameNotifications_GetSessionDetails_Response& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      sessions_(from.sessions_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.steam.CGameNotifications_GetSessionDetails_Response)
}

void CGameNotifications_GetSessionDetails_Response::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CGameNotifications_GetSessionDetails_Response_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
}

CGameNotifications_GetSessionDetails_Response::~CGameNotifications_GetSessionDetails_Response() {
  // @@protoc_insertion_point(destructor:proto.steam.CGameNotifications_GetSessionDetails_Response)
  SharedDtor();
}

void CGameNotifications_GetSessionDetails_Response::SharedDtor() {
}

void CGameNotifications_GetSessionDetails_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CGameNotifications_GetSessionDetails_Response& CGameNotifications_GetSessionDetails_Response::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CGameNotifications_GetSessionDetails_Response_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  return *internal_default_instance();
}


void CGameNotifications_GetSessionDetails_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.steam.CGameNotifications_GetSessionDetails_Response)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sessions_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CGameNotifications_GetSessionDetails_Response::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CGameNotifications_GetSessionDetails_Response*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .proto.steam.CGameNotifications_Session sessions = 1 [(.proto.steam.description) = "The details of the session."];
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::proto::steam::CGameNotifications_Session::_InternalParse;
          object = msg->add_sessions();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CGameNotifications_GetSessionDetails_Response::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.steam.CGameNotifications_GetSessionDetails_Response)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .proto.steam.CGameNotifications_Session sessions = 1 [(.proto.steam.description) = "The details of the session."];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_sessions()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.steam.CGameNotifications_GetSessionDetails_Response)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.steam.CGameNotifications_GetSessionDetails_Response)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CGameNotifications_GetSessionDetails_Response::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.steam.CGameNotifications_GetSessionDetails_Response)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.steam.CGameNotifications_Session sessions = 1 [(.proto.steam.description) = "The details of the session."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->sessions_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->sessions(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.steam.CGameNotifications_GetSessionDetails_Response)
}

::google::protobuf::uint8* CGameNotifications_GetSessionDetails_Response::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.steam.CGameNotifications_GetSessionDetails_Response)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.steam.CGameNotifications_Session sessions = 1 [(.proto.steam.description) = "The details of the session."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->sessions_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->sessions(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.steam.CGameNotifications_GetSessionDetails_Response)
  return target;
}

size_t CGameNotifications_GetSessionDetails_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.steam.CGameNotifications_GetSessionDetails_Response)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.steam.CGameNotifications_Session sessions = 1 [(.proto.steam.description) = "The details of the session."];
  {
    unsigned int count = static_cast<unsigned int>(this->sessions_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->sessions(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGameNotifications_GetSessionDetails_Response::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.steam.CGameNotifications_GetSessionDetails_Response)
  GOOGLE_DCHECK_NE(&from, this);
  const CGameNotifications_GetSessionDetails_Response* source =
      ::google::protobuf::DynamicCastToGenerated<CGameNotifications_GetSessionDetails_Response>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.steam.CGameNotifications_GetSessionDetails_Response)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.steam.CGameNotifications_GetSessionDetails_Response)
    MergeFrom(*source);
  }
}

void CGameNotifications_GetSessionDetails_Response::MergeFrom(const CGameNotifications_GetSessionDetails_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.steam.CGameNotifications_GetSessionDetails_Response)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  sessions_.MergeFrom(from.sessions_);
}

void CGameNotifications_GetSessionDetails_Response::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.steam.CGameNotifications_GetSessionDetails_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CGameNotifications_GetSessionDetails_Response::CopyFrom(const CGameNotifications_GetSessionDetails_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.steam.CGameNotifications_GetSessionDetails_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_GetSessionDetails_Response::IsInitialized() const {
  return true;
}

void CGameNotifications_GetSessionDetails_Response::Swap(CGameNotifications_GetSessionDetails_Response* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CGameNotifications_GetSessionDetails_Response::InternalSwap(CGameNotifications_GetSessionDetails_Response* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&sessions_)->InternalSwap(CastToBase(&other->sessions_));
}

::google::protobuf::Metadata CGameNotifications_GetSessionDetails_Response::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_steammessages_5fgamenotifications_2esteamclient_2eproto);
  return ::file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[kIndexInFileMessages];
}


// ===================================================================

void GameNotificationSettings::InitAsDefaultInstance() {
}
class GameNotificationSettings::HasBitSetters {
 public:
  static void set_has_appid(GameNotificationSettings* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_allow_notifications(GameNotificationSettings* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GameNotificationSettings::kAppidFieldNumber;
const int GameNotificationSettings::kAllowNotificationsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GameNotificationSettings::GameNotificationSettings()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.steam.GameNotificationSettings)
}
GameNotificationSettings::GameNotificationSettings(const GameNotificationSettings& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&appid_, &from.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&allow_notifications_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(allow_notifications_));
  // @@protoc_insertion_point(copy_constructor:proto.steam.GameNotificationSettings)
}

void GameNotificationSettings::SharedCtor() {
  ::memset(&appid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&allow_notifications_) -
      reinterpret_cast<char*>(&appid_)) + sizeof(allow_notifications_));
}

GameNotificationSettings::~GameNotificationSettings() {
  // @@protoc_insertion_point(destructor:proto.steam.GameNotificationSettings)
  SharedDtor();
}

void GameNotificationSettings::SharedDtor() {
}

void GameNotificationSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GameNotificationSettings& GameNotificationSettings::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GameNotificationSettings_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  return *internal_default_instance();
}


void GameNotificationSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.steam.GameNotificationSettings)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&allow_notifications_) -
        reinterpret_cast<char*>(&appid_)) + sizeof(allow_notifications_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GameNotificationSettings::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GameNotificationSettings*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional uint32 appid = 1 [(.proto.steam.description) = "The appid to create the session for."];
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_appid(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool allow_notifications = 2 [(.proto.steam.description) = "Whether the user allows notification for this app."];
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_allow_notifications(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GameNotificationSettings::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.steam.GameNotificationSettings)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 appid = 1 [(.proto.steam.description) = "The appid to create the session for."];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_appid(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &appid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool allow_notifications = 2 [(.proto.steam.description) = "Whether the user allows notification for this app."];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_allow_notifications(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &allow_notifications_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.steam.GameNotificationSettings)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.steam.GameNotificationSettings)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GameNotificationSettings::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.steam.GameNotificationSettings)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1 [(.proto.steam.description) = "The appid to create the session for."];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->appid(), output);
  }

  // optional bool allow_notifications = 2 [(.proto.steam.description) = "Whether the user allows notification for this app."];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->allow_notifications(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.steam.GameNotificationSettings)
}

::google::protobuf::uint8* GameNotificationSettings::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.steam.GameNotificationSettings)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1 [(.proto.steam.description) = "The appid to create the session for."];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->appid(), target);
  }

  // optional bool allow_notifications = 2 [(.proto.steam.description) = "Whether the user allows notification for this app."];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->allow_notifications(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.steam.GameNotificationSettings)
  return target;
}

size_t GameNotificationSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.steam.GameNotificationSettings)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 appid = 1 [(.proto.steam.description) = "The appid to create the session for."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->appid());
    }

    // optional bool allow_notifications = 2 [(.proto.steam.description) = "Whether the user allows notification for this app."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameNotificationSettings::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.steam.GameNotificationSettings)
  GOOGLE_DCHECK_NE(&from, this);
  const GameNotificationSettings* source =
      ::google::protobuf::DynamicCastToGenerated<GameNotificationSettings>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.steam.GameNotificationSettings)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.steam.GameNotificationSettings)
    MergeFrom(*source);
  }
}

void GameNotificationSettings::MergeFrom(const GameNotificationSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.steam.GameNotificationSettings)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      appid_ = from.appid_;
    }
    if (cached_has_bits & 0x00000002u) {
      allow_notifications_ = from.allow_notifications_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void GameNotificationSettings::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.steam.GameNotificationSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameNotificationSettings::CopyFrom(const GameNotificationSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.steam.GameNotificationSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameNotificationSettings::IsInitialized() const {
  return true;
}

void GameNotificationSettings::Swap(GameNotificationSettings* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GameNotificationSettings::InternalSwap(GameNotificationSettings* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(appid_, other->appid_);
  swap(allow_notifications_, other->allow_notifications_);
}

::google::protobuf::Metadata GameNotificationSettings::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_steammessages_5fgamenotifications_2esteamclient_2eproto);
  return ::file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CGameNotifications_UpdateNotificationSettings_Request::InitAsDefaultInstance() {
}
class CGameNotifications_UpdateNotificationSettings_Request::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CGameNotifications_UpdateNotificationSettings_Request::kGameNotificationSettingsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CGameNotifications_UpdateNotificationSettings_Request::CGameNotifications_UpdateNotificationSettings_Request()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.steam.CGameNotifications_UpdateNotificationSettings_Request)
}
CGameNotifications_UpdateNotificationSettings_Request::CGameNotifications_UpdateNotificationSettings_Request(const CGameNotifications_UpdateNotificationSettings_Request& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      game_notification_settings_(from.game_notification_settings_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.steam.CGameNotifications_UpdateNotificationSettings_Request)
}

void CGameNotifications_UpdateNotificationSettings_Request::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CGameNotifications_UpdateNotificationSettings_Request_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
}

CGameNotifications_UpdateNotificationSettings_Request::~CGameNotifications_UpdateNotificationSettings_Request() {
  // @@protoc_insertion_point(destructor:proto.steam.CGameNotifications_UpdateNotificationSettings_Request)
  SharedDtor();
}

void CGameNotifications_UpdateNotificationSettings_Request::SharedDtor() {
}

void CGameNotifications_UpdateNotificationSettings_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CGameNotifications_UpdateNotificationSettings_Request& CGameNotifications_UpdateNotificationSettings_Request::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CGameNotifications_UpdateNotificationSettings_Request_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  return *internal_default_instance();
}


void CGameNotifications_UpdateNotificationSettings_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.steam.CGameNotifications_UpdateNotificationSettings_Request)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  game_notification_settings_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CGameNotifications_UpdateNotificationSettings_Request::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CGameNotifications_UpdateNotificationSettings_Request*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .proto.steam.GameNotificationSettings game_notification_settings = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::proto::steam::GameNotificationSettings::_InternalParse;
          object = msg->add_game_notification_settings();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CGameNotifications_UpdateNotificationSettings_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.steam.CGameNotifications_UpdateNotificationSettings_Request)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .proto.steam.GameNotificationSettings game_notification_settings = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_game_notification_settings()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.steam.CGameNotifications_UpdateNotificationSettings_Request)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.steam.CGameNotifications_UpdateNotificationSettings_Request)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CGameNotifications_UpdateNotificationSettings_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.steam.CGameNotifications_UpdateNotificationSettings_Request)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.steam.GameNotificationSettings game_notification_settings = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->game_notification_settings_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->game_notification_settings(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.steam.CGameNotifications_UpdateNotificationSettings_Request)
}

::google::protobuf::uint8* CGameNotifications_UpdateNotificationSettings_Request::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.steam.CGameNotifications_UpdateNotificationSettings_Request)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .proto.steam.GameNotificationSettings game_notification_settings = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->game_notification_settings_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->game_notification_settings(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.steam.CGameNotifications_UpdateNotificationSettings_Request)
  return target;
}

size_t CGameNotifications_UpdateNotificationSettings_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.steam.CGameNotifications_UpdateNotificationSettings_Request)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .proto.steam.GameNotificationSettings game_notification_settings = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->game_notification_settings_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->game_notification_settings(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGameNotifications_UpdateNotificationSettings_Request::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.steam.CGameNotifications_UpdateNotificationSettings_Request)
  GOOGLE_DCHECK_NE(&from, this);
  const CGameNotifications_UpdateNotificationSettings_Request* source =
      ::google::protobuf::DynamicCastToGenerated<CGameNotifications_UpdateNotificationSettings_Request>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.steam.CGameNotifications_UpdateNotificationSettings_Request)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.steam.CGameNotifications_UpdateNotificationSettings_Request)
    MergeFrom(*source);
  }
}

void CGameNotifications_UpdateNotificationSettings_Request::MergeFrom(const CGameNotifications_UpdateNotificationSettings_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.steam.CGameNotifications_UpdateNotificationSettings_Request)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  game_notification_settings_.MergeFrom(from.game_notification_settings_);
}

void CGameNotifications_UpdateNotificationSettings_Request::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.steam.CGameNotifications_UpdateNotificationSettings_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CGameNotifications_UpdateNotificationSettings_Request::CopyFrom(const CGameNotifications_UpdateNotificationSettings_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.steam.CGameNotifications_UpdateNotificationSettings_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_UpdateNotificationSettings_Request::IsInitialized() const {
  return true;
}

void CGameNotifications_UpdateNotificationSettings_Request::Swap(CGameNotifications_UpdateNotificationSettings_Request* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CGameNotifications_UpdateNotificationSettings_Request::InternalSwap(CGameNotifications_UpdateNotificationSettings_Request* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&game_notification_settings_)->InternalSwap(CastToBase(&other->game_notification_settings_));
}

::google::protobuf::Metadata CGameNotifications_UpdateNotificationSettings_Request::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_steammessages_5fgamenotifications_2esteamclient_2eproto);
  return ::file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CGameNotifications_UpdateNotificationSettings_Response::InitAsDefaultInstance() {
}
class CGameNotifications_UpdateNotificationSettings_Response::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CGameNotifications_UpdateNotificationSettings_Response::CGameNotifications_UpdateNotificationSettings_Response()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.steam.CGameNotifications_UpdateNotificationSettings_Response)
}
CGameNotifications_UpdateNotificationSettings_Response::CGameNotifications_UpdateNotificationSettings_Response(const CGameNotifications_UpdateNotificationSettings_Response& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:proto.steam.CGameNotifications_UpdateNotificationSettings_Response)
}

void CGameNotifications_UpdateNotificationSettings_Response::SharedCtor() {
}

CGameNotifications_UpdateNotificationSettings_Response::~CGameNotifications_UpdateNotificationSettings_Response() {
  // @@protoc_insertion_point(destructor:proto.steam.CGameNotifications_UpdateNotificationSettings_Response)
  SharedDtor();
}

void CGameNotifications_UpdateNotificationSettings_Response::SharedDtor() {
}

void CGameNotifications_UpdateNotificationSettings_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CGameNotifications_UpdateNotificationSettings_Response& CGameNotifications_UpdateNotificationSettings_Response::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CGameNotifications_UpdateNotificationSettings_Response_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  return *internal_default_instance();
}


void CGameNotifications_UpdateNotificationSettings_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.steam.CGameNotifications_UpdateNotificationSettings_Response)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CGameNotifications_UpdateNotificationSettings_Response::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CGameNotifications_UpdateNotificationSettings_Response*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      default: {
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CGameNotifications_UpdateNotificationSettings_Response::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.steam.CGameNotifications_UpdateNotificationSettings_Response)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, _internal_metadata_.mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:proto.steam.CGameNotifications_UpdateNotificationSettings_Response)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.steam.CGameNotifications_UpdateNotificationSettings_Response)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CGameNotifications_UpdateNotificationSettings_Response::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.steam.CGameNotifications_UpdateNotificationSettings_Response)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.steam.CGameNotifications_UpdateNotificationSettings_Response)
}

::google::protobuf::uint8* CGameNotifications_UpdateNotificationSettings_Response::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.steam.CGameNotifications_UpdateNotificationSettings_Response)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.steam.CGameNotifications_UpdateNotificationSettings_Response)
  return target;
}

size_t CGameNotifications_UpdateNotificationSettings_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.steam.CGameNotifications_UpdateNotificationSettings_Response)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGameNotifications_UpdateNotificationSettings_Response::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.steam.CGameNotifications_UpdateNotificationSettings_Response)
  GOOGLE_DCHECK_NE(&from, this);
  const CGameNotifications_UpdateNotificationSettings_Response* source =
      ::google::protobuf::DynamicCastToGenerated<CGameNotifications_UpdateNotificationSettings_Response>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.steam.CGameNotifications_UpdateNotificationSettings_Response)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.steam.CGameNotifications_UpdateNotificationSettings_Response)
    MergeFrom(*source);
  }
}

void CGameNotifications_UpdateNotificationSettings_Response::MergeFrom(const CGameNotifications_UpdateNotificationSettings_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.steam.CGameNotifications_UpdateNotificationSettings_Response)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void CGameNotifications_UpdateNotificationSettings_Response::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.steam.CGameNotifications_UpdateNotificationSettings_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CGameNotifications_UpdateNotificationSettings_Response::CopyFrom(const CGameNotifications_UpdateNotificationSettings_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.steam.CGameNotifications_UpdateNotificationSettings_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_UpdateNotificationSettings_Response::IsInitialized() const {
  return true;
}

void CGameNotifications_UpdateNotificationSettings_Response::Swap(CGameNotifications_UpdateNotificationSettings_Response* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CGameNotifications_UpdateNotificationSettings_Response::InternalSwap(CGameNotifications_UpdateNotificationSettings_Response* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
}

::google::protobuf::Metadata CGameNotifications_UpdateNotificationSettings_Response::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_steammessages_5fgamenotifications_2esteamclient_2eproto);
  return ::file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CGameNotifications_OnNotificationsRequested_Notification::InitAsDefaultInstance() {
}
class CGameNotifications_OnNotificationsRequested_Notification::HasBitSetters {
 public:
  static void set_has_steamid(CGameNotifications_OnNotificationsRequested_Notification* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_appid(CGameNotifications_OnNotificationsRequested_Notification* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CGameNotifications_OnNotificationsRequested_Notification::kSteamidFieldNumber;
const int CGameNotifications_OnNotificationsRequested_Notification::kAppidFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CGameNotifications_OnNotificationsRequested_Notification::CGameNotifications_OnNotificationsRequested_Notification()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.steam.CGameNotifications_OnNotificationsRequested_Notification)
}
CGameNotifications_OnNotificationsRequested_Notification::CGameNotifications_OnNotificationsRequested_Notification(const CGameNotifications_OnNotificationsRequested_Notification& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&steamid_, &from.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&appid_) -
    reinterpret_cast<char*>(&steamid_)) + sizeof(appid_));
  // @@protoc_insertion_point(copy_constructor:proto.steam.CGameNotifications_OnNotificationsRequested_Notification)
}

void CGameNotifications_OnNotificationsRequested_Notification::SharedCtor() {
  ::memset(&steamid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&appid_) -
      reinterpret_cast<char*>(&steamid_)) + sizeof(appid_));
}

CGameNotifications_OnNotificationsRequested_Notification::~CGameNotifications_OnNotificationsRequested_Notification() {
  // @@protoc_insertion_point(destructor:proto.steam.CGameNotifications_OnNotificationsRequested_Notification)
  SharedDtor();
}

void CGameNotifications_OnNotificationsRequested_Notification::SharedDtor() {
}

void CGameNotifications_OnNotificationsRequested_Notification::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CGameNotifications_OnNotificationsRequested_Notification& CGameNotifications_OnNotificationsRequested_Notification::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CGameNotifications_OnNotificationsRequested_Notification_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  return *internal_default_instance();
}


void CGameNotifications_OnNotificationsRequested_Notification::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.steam.CGameNotifications_OnNotificationsRequested_Notification)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&appid_) -
        reinterpret_cast<char*>(&steamid_)) + sizeof(appid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CGameNotifications_OnNotificationsRequested_Notification::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CGameNotifications_OnNotificationsRequested_Notification*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional fixed64 steamid = 1 [(.proto.steam.description) = "steamid of the user who notifications were requested for."];
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_steamid(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr));
        ptr += sizeof(::google::protobuf::uint64);
        break;
      }
      // optional uint32 appid = 2 [(.proto.steam.description) = "The appid that requested notifications."];
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_appid(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CGameNotifications_OnNotificationsRequested_Notification::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.steam.CGameNotifications_OnNotificationsRequested_Notification)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional fixed64 steamid = 1 [(.proto.steam.description) = "steamid of the user who notifications were requested for."];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          HasBitSetters::set_has_steamid(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &steamid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 appid = 2 [(.proto.steam.description) = "The appid that requested notifications."];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_appid(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &appid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.steam.CGameNotifications_OnNotificationsRequested_Notification)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.steam.CGameNotifications_OnNotificationsRequested_Notification)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CGameNotifications_OnNotificationsRequested_Notification::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.steam.CGameNotifications_OnNotificationsRequested_Notification)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 steamid = 1 [(.proto.steam.description) = "steamid of the user who notifications were requested for."];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(1, this->steamid(), output);
  }

  // optional uint32 appid = 2 [(.proto.steam.description) = "The appid that requested notifications."];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->appid(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.steam.CGameNotifications_OnNotificationsRequested_Notification)
}

::google::protobuf::uint8* CGameNotifications_OnNotificationsRequested_Notification::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.steam.CGameNotifications_OnNotificationsRequested_Notification)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 steamid = 1 [(.proto.steam.description) = "steamid of the user who notifications were requested for."];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(1, this->steamid(), target);
  }

  // optional uint32 appid = 2 [(.proto.steam.description) = "The appid that requested notifications."];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->appid(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.steam.CGameNotifications_OnNotificationsRequested_Notification)
  return target;
}

size_t CGameNotifications_OnNotificationsRequested_Notification::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.steam.CGameNotifications_OnNotificationsRequested_Notification)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional fixed64 steamid = 1 [(.proto.steam.description) = "steamid of the user who notifications were requested for."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional uint32 appid = 2 [(.proto.steam.description) = "The appid that requested notifications."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->appid());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGameNotifications_OnNotificationsRequested_Notification::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.steam.CGameNotifications_OnNotificationsRequested_Notification)
  GOOGLE_DCHECK_NE(&from, this);
  const CGameNotifications_OnNotificationsRequested_Notification* source =
      ::google::protobuf::DynamicCastToGenerated<CGameNotifications_OnNotificationsRequested_Notification>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.steam.CGameNotifications_OnNotificationsRequested_Notification)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.steam.CGameNotifications_OnNotificationsRequested_Notification)
    MergeFrom(*source);
  }
}

void CGameNotifications_OnNotificationsRequested_Notification::MergeFrom(const CGameNotifications_OnNotificationsRequested_Notification& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.steam.CGameNotifications_OnNotificationsRequested_Notification)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      steamid_ = from.steamid_;
    }
    if (cached_has_bits & 0x00000002u) {
      appid_ = from.appid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CGameNotifications_OnNotificationsRequested_Notification::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.steam.CGameNotifications_OnNotificationsRequested_Notification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CGameNotifications_OnNotificationsRequested_Notification::CopyFrom(const CGameNotifications_OnNotificationsRequested_Notification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.steam.CGameNotifications_OnNotificationsRequested_Notification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_OnNotificationsRequested_Notification::IsInitialized() const {
  return true;
}

void CGameNotifications_OnNotificationsRequested_Notification::Swap(CGameNotifications_OnNotificationsRequested_Notification* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CGameNotifications_OnNotificationsRequested_Notification::InternalSwap(CGameNotifications_OnNotificationsRequested_Notification* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(steamid_, other->steamid_);
  swap(appid_, other->appid_);
}

::google::protobuf::Metadata CGameNotifications_OnNotificationsRequested_Notification::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_steammessages_5fgamenotifications_2esteamclient_2eproto);
  return ::file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CGameNotifications_OnUserStatusChanged_Notification::InitAsDefaultInstance() {
  ::proto::steam::_CGameNotifications_OnUserStatusChanged_Notification_default_instance_._instance.get_mutable()->status_ = const_cast< ::proto::steam::CGameNotifications_UserStatus*>(
      ::proto::steam::CGameNotifications_UserStatus::internal_default_instance());
}
class CGameNotifications_OnUserStatusChanged_Notification::HasBitSetters {
 public:
  static void set_has_steamid(CGameNotifications_OnUserStatusChanged_Notification* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_sessionid(CGameNotifications_OnUserStatusChanged_Notification* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_appid(CGameNotifications_OnUserStatusChanged_Notification* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static const ::proto::steam::CGameNotifications_UserStatus& status(const CGameNotifications_OnUserStatusChanged_Notification* msg);
  static void set_has_status(CGameNotifications_OnUserStatusChanged_Notification* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_removed(CGameNotifications_OnUserStatusChanged_Notification* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

const ::proto::steam::CGameNotifications_UserStatus&
CGameNotifications_OnUserStatusChanged_Notification::HasBitSetters::status(const CGameNotifications_OnUserStatusChanged_Notification* msg) {
  return *msg->status_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CGameNotifications_OnUserStatusChanged_Notification::kSteamidFieldNumber;
const int CGameNotifications_OnUserStatusChanged_Notification::kSessionidFieldNumber;
const int CGameNotifications_OnUserStatusChanged_Notification::kAppidFieldNumber;
const int CGameNotifications_OnUserStatusChanged_Notification::kStatusFieldNumber;
const int CGameNotifications_OnUserStatusChanged_Notification::kRemovedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CGameNotifications_OnUserStatusChanged_Notification::CGameNotifications_OnUserStatusChanged_Notification()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.steam.CGameNotifications_OnUserStatusChanged_Notification)
}
CGameNotifications_OnUserStatusChanged_Notification::CGameNotifications_OnUserStatusChanged_Notification(const CGameNotifications_OnUserStatusChanged_Notification& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_status()) {
    status_ = new ::proto::steam::CGameNotifications_UserStatus(*from.status_);
  } else {
    status_ = nullptr;
  }
  ::memcpy(&steamid_, &from.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&removed_) -
    reinterpret_cast<char*>(&steamid_)) + sizeof(removed_));
  // @@protoc_insertion_point(copy_constructor:proto.steam.CGameNotifications_OnUserStatusChanged_Notification)
}

void CGameNotifications_OnUserStatusChanged_Notification::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CGameNotifications_OnUserStatusChanged_Notification_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  ::memset(&status_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&removed_) -
      reinterpret_cast<char*>(&status_)) + sizeof(removed_));
}

CGameNotifications_OnUserStatusChanged_Notification::~CGameNotifications_OnUserStatusChanged_Notification() {
  // @@protoc_insertion_point(destructor:proto.steam.CGameNotifications_OnUserStatusChanged_Notification)
  SharedDtor();
}

void CGameNotifications_OnUserStatusChanged_Notification::SharedDtor() {
  if (this != internal_default_instance()) delete status_;
}

void CGameNotifications_OnUserStatusChanged_Notification::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CGameNotifications_OnUserStatusChanged_Notification& CGameNotifications_OnUserStatusChanged_Notification::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CGameNotifications_OnUserStatusChanged_Notification_steammessages_5fgamenotifications_2esteamclient_2eproto.base);
  return *internal_default_instance();
}


void CGameNotifications_OnUserStatusChanged_Notification::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.steam.CGameNotifications_OnUserStatusChanged_Notification)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(status_ != nullptr);
    status_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&removed_) -
        reinterpret_cast<char*>(&steamid_)) + sizeof(removed_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CGameNotifications_OnUserStatusChanged_Notification::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CGameNotifications_OnUserStatusChanged_Notification*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional fixed64 steamid = 1 [(.proto.steam.description) = "steamid of the user whose status changed."];
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_steamid(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr));
        ptr += sizeof(::google::protobuf::uint64);
        break;
      }
      // optional uint64 sessionid = 2 [(.proto.steam.description) = "The sessionid of the session where the user\'s status was changed."];
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_sessionid(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 appid = 3 [(.proto.steam.description) = "The appid of the session where the user\'s status changed."];
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_appid(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .proto.steam.CGameNotifications_UserStatus status = 4 [(.proto.steam.description) = "(Optional) New status of the user."];
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::steam::CGameNotifications_UserStatus::_InternalParse;
        object = msg->mutable_status();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional bool removed = 5 [(.proto.steam.description) = "(Optional) User has been removed from the session."];
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_removed(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CGameNotifications_OnUserStatusChanged_Notification::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.steam.CGameNotifications_OnUserStatusChanged_Notification)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional fixed64 steamid = 1 [(.proto.steam.description) = "steamid of the user whose status changed."];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          HasBitSetters::set_has_steamid(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &steamid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 sessionid = 2 [(.proto.steam.description) = "The sessionid of the session where the user\'s status was changed."];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_sessionid(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &sessionid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 appid = 3 [(.proto.steam.description) = "The appid of the session where the user\'s status changed."];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_appid(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &appid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.steam.CGameNotifications_UserStatus status = 4 [(.proto.steam.description) = "(Optional) New status of the user."];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_status()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool removed = 5 [(.proto.steam.description) = "(Optional) User has been removed from the session."];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_removed(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &removed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.steam.CGameNotifications_OnUserStatusChanged_Notification)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.steam.CGameNotifications_OnUserStatusChanged_Notification)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CGameNotifications_OnUserStatusChanged_Notification::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.steam.CGameNotifications_OnUserStatusChanged_Notification)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 steamid = 1 [(.proto.steam.description) = "steamid of the user whose status changed."];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(1, this->steamid(), output);
  }

  // optional uint64 sessionid = 2 [(.proto.steam.description) = "The sessionid of the session where the user\'s status was changed."];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->sessionid(), output);
  }

  // optional uint32 appid = 3 [(.proto.steam.description) = "The appid of the session where the user\'s status changed."];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->appid(), output);
  }

  // optional .proto.steam.CGameNotifications_UserStatus status = 4 [(.proto.steam.description) = "(Optional) New status of the user."];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::status(this), output);
  }

  // optional bool removed = 5 [(.proto.steam.description) = "(Optional) User has been removed from the session."];
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->removed(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.steam.CGameNotifications_OnUserStatusChanged_Notification)
}

::google::protobuf::uint8* CGameNotifications_OnUserStatusChanged_Notification::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.steam.CGameNotifications_OnUserStatusChanged_Notification)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 steamid = 1 [(.proto.steam.description) = "steamid of the user whose status changed."];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(1, this->steamid(), target);
  }

  // optional uint64 sessionid = 2 [(.proto.steam.description) = "The sessionid of the session where the user\'s status was changed."];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->sessionid(), target);
  }

  // optional uint32 appid = 3 [(.proto.steam.description) = "The appid of the session where the user\'s status changed."];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->appid(), target);
  }

  // optional .proto.steam.CGameNotifications_UserStatus status = 4 [(.proto.steam.description) = "(Optional) New status of the user."];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::status(this), target);
  }

  // optional bool removed = 5 [(.proto.steam.description) = "(Optional) User has been removed from the session."];
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->removed(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.steam.CGameNotifications_OnUserStatusChanged_Notification)
  return target;
}

size_t CGameNotifications_OnUserStatusChanged_Notification::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.steam.CGameNotifications_OnUserStatusChanged_Notification)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .proto.steam.CGameNotifications_UserStatus status = 4 [(.proto.steam.description) = "(Optional) New status of the user."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *status_);
    }

    // optional fixed64 steamid = 1 [(.proto.steam.description) = "steamid of the user whose status changed."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint64 sessionid = 2 [(.proto.steam.description) = "The sessionid of the session where the user\'s status was changed."];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->sessionid());
    }

    // optional uint32 appid = 3 [(.proto.steam.description) = "The appid of the session where the user\'s status changed."];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->appid());
    }

    // optional bool removed = 5 [(.proto.steam.description) = "(Optional) User has been removed from the session."];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CGameNotifications_OnUserStatusChanged_Notification::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.steam.CGameNotifications_OnUserStatusChanged_Notification)
  GOOGLE_DCHECK_NE(&from, this);
  const CGameNotifications_OnUserStatusChanged_Notification* source =
      ::google::protobuf::DynamicCastToGenerated<CGameNotifications_OnUserStatusChanged_Notification>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.steam.CGameNotifications_OnUserStatusChanged_Notification)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.steam.CGameNotifications_OnUserStatusChanged_Notification)
    MergeFrom(*source);
  }
}

void CGameNotifications_OnUserStatusChanged_Notification::MergeFrom(const CGameNotifications_OnUserStatusChanged_Notification& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.steam.CGameNotifications_OnUserStatusChanged_Notification)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_status()->::proto::steam::CGameNotifications_UserStatus::MergeFrom(from.status());
    }
    if (cached_has_bits & 0x00000002u) {
      steamid_ = from.steamid_;
    }
    if (cached_has_bits & 0x00000004u) {
      sessionid_ = from.sessionid_;
    }
    if (cached_has_bits & 0x00000008u) {
      appid_ = from.appid_;
    }
    if (cached_has_bits & 0x00000010u) {
      removed_ = from.removed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CGameNotifications_OnUserStatusChanged_Notification::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.steam.CGameNotifications_OnUserStatusChanged_Notification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CGameNotifications_OnUserStatusChanged_Notification::CopyFrom(const CGameNotifications_OnUserStatusChanged_Notification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.steam.CGameNotifications_OnUserStatusChanged_Notification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_OnUserStatusChanged_Notification::IsInitialized() const {
  return true;
}

void CGameNotifications_OnUserStatusChanged_Notification::Swap(CGameNotifications_OnUserStatusChanged_Notification* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CGameNotifications_OnUserStatusChanged_Notification::InternalSwap(CGameNotifications_OnUserStatusChanged_Notification* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(status_, other->status_);
  swap(steamid_, other->steamid_);
  swap(sessionid_, other->sessionid_);
  swap(appid_, other->appid_);
  swap(removed_, other->removed_);
}

::google::protobuf::Metadata CGameNotifications_OnUserStatusChanged_Notification::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_steammessages_5fgamenotifications_2esteamclient_2eproto);
  return ::file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[kIndexInFileMessages];
}


// ===================================================================

GameNotifications::~GameNotifications() {}

const ::google::protobuf::ServiceDescriptor* GameNotifications::descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_steammessages_5fgamenotifications_2esteamclient_2eproto);
  return file_level_service_descriptors_steammessages_5fgamenotifications_2esteamclient_2eproto[0];
}

const ::google::protobuf::ServiceDescriptor* GameNotifications::GetDescriptor() {
  return descriptor();
}

void GameNotifications::UserCreateSession(::google::protobuf::RpcController* controller,
                         const ::proto::steam::CGameNotifications_CreateSession_Request*,
                         ::proto::steam::CGameNotifications_CreateSession_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method UserCreateSession() not implemented.");
  done->Run();
}

void GameNotifications::UserDeleteSession(::google::protobuf::RpcController* controller,
                         const ::proto::steam::CGameNotifications_DeleteSession_Request*,
                         ::proto::steam::CGameNotifications_DeleteSession_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method UserDeleteSession() not implemented.");
  done->Run();
}

void GameNotifications::UserUpdateSession(::google::protobuf::RpcController* controller,
                         const ::proto::steam::CGameNotifications_UpdateSession_Request*,
                         ::proto::steam::CGameNotifications_UpdateSession_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method UserUpdateSession() not implemented.");
  done->Run();
}

void GameNotifications::EnumerateSessions(::google::protobuf::RpcController* controller,
                         const ::proto::steam::CGameNotifications_EnumerateSessions_Request*,
                         ::proto::steam::CGameNotifications_EnumerateSessions_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method EnumerateSessions() not implemented.");
  done->Run();
}

void GameNotifications::GetSessionDetails(::google::protobuf::RpcController* controller,
                         const ::proto::steam::CGameNotifications_GetSessionDetails_Request*,
                         ::proto::steam::CGameNotifications_GetSessionDetails_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetSessionDetails() not implemented.");
  done->Run();
}

void GameNotifications::UpdateNotificationSettings(::google::protobuf::RpcController* controller,
                         const ::proto::steam::CGameNotifications_UpdateNotificationSettings_Request*,
                         ::proto::steam::CGameNotifications_UpdateNotificationSettings_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method UpdateNotificationSettings() not implemented.");
  done->Run();
}

void GameNotifications::CallMethod(const ::google::protobuf::MethodDescriptor* method,
                             ::google::protobuf::RpcController* controller,
                             const ::google::protobuf::Message* request,
                             ::google::protobuf::Message* response,
                             ::google::protobuf::Closure* done) {
  GOOGLE_DCHECK_EQ(method->service(), file_level_service_descriptors_steammessages_5fgamenotifications_2esteamclient_2eproto[0]);
  switch(method->index()) {
    case 0:
      UserCreateSession(controller,
             ::google::protobuf::down_cast<const ::proto::steam::CGameNotifications_CreateSession_Request*>(request),
             ::google::protobuf::down_cast< ::proto::steam::CGameNotifications_CreateSession_Response*>(response),
             done);
      break;
    case 1:
      UserDeleteSession(controller,
             ::google::protobuf::down_cast<const ::proto::steam::CGameNotifications_DeleteSession_Request*>(request),
             ::google::protobuf::down_cast< ::proto::steam::CGameNotifications_DeleteSession_Response*>(response),
             done);
      break;
    case 2:
      UserUpdateSession(controller,
             ::google::protobuf::down_cast<const ::proto::steam::CGameNotifications_UpdateSession_Request*>(request),
             ::google::protobuf::down_cast< ::proto::steam::CGameNotifications_UpdateSession_Response*>(response),
             done);
      break;
    case 3:
      EnumerateSessions(controller,
             ::google::protobuf::down_cast<const ::proto::steam::CGameNotifications_EnumerateSessions_Request*>(request),
             ::google::protobuf::down_cast< ::proto::steam::CGameNotifications_EnumerateSessions_Response*>(response),
             done);
      break;
    case 4:
      GetSessionDetails(controller,
             ::google::protobuf::down_cast<const ::proto::steam::CGameNotifications_GetSessionDetails_Request*>(request),
             ::google::protobuf::down_cast< ::proto::steam::CGameNotifications_GetSessionDetails_Response*>(response),
             done);
      break;
    case 5:
      UpdateNotificationSettings(controller,
             ::google::protobuf::down_cast<const ::proto::steam::CGameNotifications_UpdateNotificationSettings_Request*>(request),
             ::google::protobuf::down_cast< ::proto::steam::CGameNotifications_UpdateNotificationSettings_Response*>(response),
             done);
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::google::protobuf::Message& GameNotifications::GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::proto::steam::CGameNotifications_CreateSession_Request::default_instance();
    case 1:
      return ::proto::steam::CGameNotifications_DeleteSession_Request::default_instance();
    case 2:
      return ::proto::steam::CGameNotifications_UpdateSession_Request::default_instance();
    case 3:
      return ::proto::steam::CGameNotifications_EnumerateSessions_Request::default_instance();
    case 4:
      return ::proto::steam::CGameNotifications_GetSessionDetails_Request::default_instance();
    case 5:
      return ::proto::steam::CGameNotifications_UpdateNotificationSettings_Request::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::google::protobuf::MessageFactory::generated_factory()
          ->GetPrototype(method->input_type());
  }
}

const ::google::protobuf::Message& GameNotifications::GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::proto::steam::CGameNotifications_CreateSession_Response::default_instance();
    case 1:
      return ::proto::steam::CGameNotifications_DeleteSession_Response::default_instance();
    case 2:
      return ::proto::steam::CGameNotifications_UpdateSession_Response::default_instance();
    case 3:
      return ::proto::steam::CGameNotifications_EnumerateSessions_Response::default_instance();
    case 4:
      return ::proto::steam::CGameNotifications_GetSessionDetails_Response::default_instance();
    case 5:
      return ::proto::steam::CGameNotifications_UpdateNotificationSettings_Response::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::google::protobuf::MessageFactory::generated_factory()
          ->GetPrototype(method->output_type());
  }
}

GameNotifications_Stub::GameNotifications_Stub(::google::protobuf::RpcChannel* channel)
  : channel_(channel), owns_channel_(false) {}
GameNotifications_Stub::GameNotifications_Stub(
    ::google::protobuf::RpcChannel* channel,
    ::google::protobuf::Service::ChannelOwnership ownership)
  : channel_(channel),
    owns_channel_(ownership == ::google::protobuf::Service::STUB_OWNS_CHANNEL) {}
GameNotifications_Stub::~GameNotifications_Stub() {
  if (owns_channel_) delete channel_;
}

void GameNotifications_Stub::UserCreateSession(::google::protobuf::RpcController* controller,
                              const ::proto::steam::CGameNotifications_CreateSession_Request* request,
                              ::proto::steam::CGameNotifications_CreateSession_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(0),
                       controller, request, response, done);
}
void GameNotifications_Stub::UserDeleteSession(::google::protobuf::RpcController* controller,
                              const ::proto::steam::CGameNotifications_DeleteSession_Request* request,
                              ::proto::steam::CGameNotifications_DeleteSession_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(1),
                       controller, request, response, done);
}
void GameNotifications_Stub::UserUpdateSession(::google::protobuf::RpcController* controller,
                              const ::proto::steam::CGameNotifications_UpdateSession_Request* request,
                              ::proto::steam::CGameNotifications_UpdateSession_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(2),
                       controller, request, response, done);
}
void GameNotifications_Stub::EnumerateSessions(::google::protobuf::RpcController* controller,
                              const ::proto::steam::CGameNotifications_EnumerateSessions_Request* request,
                              ::proto::steam::CGameNotifications_EnumerateSessions_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(3),
                       controller, request, response, done);
}
void GameNotifications_Stub::GetSessionDetails(::google::protobuf::RpcController* controller,
                              const ::proto::steam::CGameNotifications_GetSessionDetails_Request* request,
                              ::proto::steam::CGameNotifications_GetSessionDetails_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(4),
                       controller, request, response, done);
}
void GameNotifications_Stub::UpdateNotificationSettings(::google::protobuf::RpcController* controller,
                              const ::proto::steam::CGameNotifications_UpdateNotificationSettings_Request* request,
                              ::proto::steam::CGameNotifications_UpdateNotificationSettings_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(5),
                       controller, request, response, done);
}
// ===================================================================

GameNotificationsClient::~GameNotificationsClient() {}

const ::google::protobuf::ServiceDescriptor* GameNotificationsClient::descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_steammessages_5fgamenotifications_2esteamclient_2eproto);
  return file_level_service_descriptors_steammessages_5fgamenotifications_2esteamclient_2eproto[1];
}

const ::google::protobuf::ServiceDescriptor* GameNotificationsClient::GetDescriptor() {
  return descriptor();
}

void GameNotificationsClient::OnNotificationsRequested(::google::protobuf::RpcController* controller,
                         const ::proto::steam::CGameNotifications_OnNotificationsRequested_Notification*,
                         ::proto::steam::NoResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method OnNotificationsRequested() not implemented.");
  done->Run();
}

void GameNotificationsClient::OnUserStatusChanged(::google::protobuf::RpcController* controller,
                         const ::proto::steam::CGameNotifications_OnUserStatusChanged_Notification*,
                         ::proto::steam::NoResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method OnUserStatusChanged() not implemented.");
  done->Run();
}

void GameNotificationsClient::CallMethod(const ::google::protobuf::MethodDescriptor* method,
                             ::google::protobuf::RpcController* controller,
                             const ::google::protobuf::Message* request,
                             ::google::protobuf::Message* response,
                             ::google::protobuf::Closure* done) {
  GOOGLE_DCHECK_EQ(method->service(), file_level_service_descriptors_steammessages_5fgamenotifications_2esteamclient_2eproto[1]);
  switch(method->index()) {
    case 0:
      OnNotificationsRequested(controller,
             ::google::protobuf::down_cast<const ::proto::steam::CGameNotifications_OnNotificationsRequested_Notification*>(request),
             ::google::protobuf::down_cast< ::proto::steam::NoResponse*>(response),
             done);
      break;
    case 1:
      OnUserStatusChanged(controller,
             ::google::protobuf::down_cast<const ::proto::steam::CGameNotifications_OnUserStatusChanged_Notification*>(request),
             ::google::protobuf::down_cast< ::proto::steam::NoResponse*>(response),
             done);
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::google::protobuf::Message& GameNotificationsClient::GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::proto::steam::CGameNotifications_OnNotificationsRequested_Notification::default_instance();
    case 1:
      return ::proto::steam::CGameNotifications_OnUserStatusChanged_Notification::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::google::protobuf::MessageFactory::generated_factory()
          ->GetPrototype(method->input_type());
  }
}

const ::google::protobuf::Message& GameNotificationsClient::GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::proto::steam::NoResponse::default_instance();
    case 1:
      return ::proto::steam::NoResponse::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::google::protobuf::MessageFactory::generated_factory()
          ->GetPrototype(method->output_type());
  }
}

GameNotificationsClient_Stub::GameNotificationsClient_Stub(::google::protobuf::RpcChannel* channel)
  : channel_(channel), owns_channel_(false) {}
GameNotificationsClient_Stub::GameNotificationsClient_Stub(
    ::google::protobuf::RpcChannel* channel,
    ::google::protobuf::Service::ChannelOwnership ownership)
  : channel_(channel),
    owns_channel_(ownership == ::google::protobuf::Service::STUB_OWNS_CHANNEL) {}
GameNotificationsClient_Stub::~GameNotificationsClient_Stub() {
  if (owns_channel_) delete channel_;
}

void GameNotificationsClient_Stub::OnNotificationsRequested(::google::protobuf::RpcController* controller,
                              const ::proto::steam::CGameNotifications_OnNotificationsRequested_Notification* request,
                              ::proto::steam::NoResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(0),
                       controller, request, response, done);
}
void GameNotificationsClient_Stub::OnUserStatusChanged(::google::protobuf::RpcController* controller,
                              const ::proto::steam::CGameNotifications_OnUserStatusChanged_Notification* request,
                              ::proto::steam::NoResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(1),
                       controller, request, response, done);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace steam
}  // namespace proto
namespace google {
namespace protobuf {
template<> PROTOBUF_NOINLINE ::proto::steam::CGameNotifications_Variable* Arena::CreateMaybeMessage< ::proto::steam::CGameNotifications_Variable >(Arena* arena) {
  return Arena::CreateInternal< ::proto::steam::CGameNotifications_Variable >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::steam::CGameNotifications_LocalizedText* Arena::CreateMaybeMessage< ::proto::steam::CGameNotifications_LocalizedText >(Arena* arena) {
  return Arena::CreateInternal< ::proto::steam::CGameNotifications_LocalizedText >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::steam::CGameNotifications_UserStatus* Arena::CreateMaybeMessage< ::proto::steam::CGameNotifications_UserStatus >(Arena* arena) {
  return Arena::CreateInternal< ::proto::steam::CGameNotifications_UserStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::steam::CGameNotifications_CreateSession_Request* Arena::CreateMaybeMessage< ::proto::steam::CGameNotifications_CreateSession_Request >(Arena* arena) {
  return Arena::CreateInternal< ::proto::steam::CGameNotifications_CreateSession_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::steam::CGameNotifications_CreateSession_Response* Arena::CreateMaybeMessage< ::proto::steam::CGameNotifications_CreateSession_Response >(Arena* arena) {
  return Arena::CreateInternal< ::proto::steam::CGameNotifications_CreateSession_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::steam::CGameNotifications_DeleteSession_Request* Arena::CreateMaybeMessage< ::proto::steam::CGameNotifications_DeleteSession_Request >(Arena* arena) {
  return Arena::CreateInternal< ::proto::steam::CGameNotifications_DeleteSession_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::steam::CGameNotifications_DeleteSession_Response* Arena::CreateMaybeMessage< ::proto::steam::CGameNotifications_DeleteSession_Response >(Arena* arena) {
  return Arena::CreateInternal< ::proto::steam::CGameNotifications_DeleteSession_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::steam::CGameNotifications_UpdateSession_Request* Arena::CreateMaybeMessage< ::proto::steam::CGameNotifications_UpdateSession_Request >(Arena* arena) {
  return Arena::CreateInternal< ::proto::steam::CGameNotifications_UpdateSession_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::steam::CGameNotifications_UpdateSession_Response* Arena::CreateMaybeMessage< ::proto::steam::CGameNotifications_UpdateSession_Response >(Arena* arena) {
  return Arena::CreateInternal< ::proto::steam::CGameNotifications_UpdateSession_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::steam::CGameNotifications_EnumerateSessions_Request* Arena::CreateMaybeMessage< ::proto::steam::CGameNotifications_EnumerateSessions_Request >(Arena* arena) {
  return Arena::CreateInternal< ::proto::steam::CGameNotifications_EnumerateSessions_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::steam::CGameNotifications_Session* Arena::CreateMaybeMessage< ::proto::steam::CGameNotifications_Session >(Arena* arena) {
  return Arena::CreateInternal< ::proto::steam::CGameNotifications_Session >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::steam::CGameNotifications_EnumerateSessions_Response* Arena::CreateMaybeMessage< ::proto::steam::CGameNotifications_EnumerateSessions_Response >(Arena* arena) {
  return Arena::CreateInternal< ::proto::steam::CGameNotifications_EnumerateSessions_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::steam::CGameNotifications_GetSessionDetails_Request_RequestedSession* Arena::CreateMaybeMessage< ::proto::steam::CGameNotifications_GetSessionDetails_Request_RequestedSession >(Arena* arena) {
  return Arena::CreateInternal< ::proto::steam::CGameNotifications_GetSessionDetails_Request_RequestedSession >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::steam::CGameNotifications_GetSessionDetails_Request* Arena::CreateMaybeMessage< ::proto::steam::CGameNotifications_GetSessionDetails_Request >(Arena* arena) {
  return Arena::CreateInternal< ::proto::steam::CGameNotifications_GetSessionDetails_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::steam::CGameNotifications_GetSessionDetails_Response* Arena::CreateMaybeMessage< ::proto::steam::CGameNotifications_GetSessionDetails_Response >(Arena* arena) {
  return Arena::CreateInternal< ::proto::steam::CGameNotifications_GetSessionDetails_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::steam::GameNotificationSettings* Arena::CreateMaybeMessage< ::proto::steam::GameNotificationSettings >(Arena* arena) {
  return Arena::CreateInternal< ::proto::steam::GameNotificationSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::steam::CGameNotifications_UpdateNotificationSettings_Request* Arena::CreateMaybeMessage< ::proto::steam::CGameNotifications_UpdateNotificationSettings_Request >(Arena* arena) {
  return Arena::CreateInternal< ::proto::steam::CGameNotifications_UpdateNotificationSettings_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::steam::CGameNotifications_UpdateNotificationSettings_Response* Arena::CreateMaybeMessage< ::proto::steam::CGameNotifications_UpdateNotificationSettings_Response >(Arena* arena) {
  return Arena::CreateInternal< ::proto::steam::CGameNotifications_UpdateNotificationSettings_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::steam::CGameNotifications_OnNotificationsRequested_Notification* Arena::CreateMaybeMessage< ::proto::steam::CGameNotifications_OnNotificationsRequested_Notification >(Arena* arena) {
  return Arena::CreateInternal< ::proto::steam::CGameNotifications_OnNotificationsRequested_Notification >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::steam::CGameNotifications_OnUserStatusChanged_Notification* Arena::CreateMaybeMessage< ::proto::steam::CGameNotifications_OnUserStatusChanged_Notification >(Arena* arena) {
  return Arena::CreateInternal< ::proto::steam::CGameNotifications_OnUserStatusChanged_Notification >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
