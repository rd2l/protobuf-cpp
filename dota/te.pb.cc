// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: te.proto

#include "te.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

extern PROTOBUF_INTERNAL_EXPORT_networkbasetypes_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_CMsgQAngle_networkbasetypes_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_networkbasetypes_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_CMsgVector_networkbasetypes_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_te_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_CMsgTEBaseBeam_te_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_te_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_CMsgEffectData_te_2eproto;
namespace proto {
namespace dota {
class CMsgTEArmorRicochetDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEArmorRicochet> _instance;
} _CMsgTEArmorRicochet_default_instance_;
class CMsgTEBaseBeamDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEBaseBeam> _instance;
} _CMsgTEBaseBeam_default_instance_;
class CMsgTEBeamEntPointDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEBeamEntPoint> _instance;
} _CMsgTEBeamEntPoint_default_instance_;
class CMsgTEBeamEntsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEBeamEnts> _instance;
} _CMsgTEBeamEnts_default_instance_;
class CMsgTEBeamPointsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEBeamPoints> _instance;
} _CMsgTEBeamPoints_default_instance_;
class CMsgTEBeamRingDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEBeamRing> _instance;
} _CMsgTEBeamRing_default_instance_;
class CMsgTEBreakModelDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEBreakModel> _instance;
} _CMsgTEBreakModel_default_instance_;
class CMsgTEBSPDecalDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEBSPDecal> _instance;
} _CMsgTEBSPDecal_default_instance_;
class CMsgTEBubblesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEBubbles> _instance;
} _CMsgTEBubbles_default_instance_;
class CMsgTEBubbleTrailDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEBubbleTrail> _instance;
} _CMsgTEBubbleTrail_default_instance_;
class CMsgTEDecalDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEDecal> _instance;
} _CMsgTEDecal_default_instance_;
class CMsgEffectDataDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgEffectData> _instance;
} _CMsgEffectData_default_instance_;
class CMsgTEEffectDispatchDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEEffectDispatch> _instance;
} _CMsgTEEffectDispatch_default_instance_;
class CMsgTEEnergySplashDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEEnergySplash> _instance;
} _CMsgTEEnergySplash_default_instance_;
class CMsgTEFizzDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEFizz> _instance;
} _CMsgTEFizz_default_instance_;
class CMsgTEShatterSurfaceDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEShatterSurface> _instance;
} _CMsgTEShatterSurface_default_instance_;
class CMsgTEGlowSpriteDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEGlowSprite> _instance;
} _CMsgTEGlowSprite_default_instance_;
class CMsgTEImpactDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEImpact> _instance;
} _CMsgTEImpact_default_instance_;
class CMsgTEMuzzleFlashDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEMuzzleFlash> _instance;
} _CMsgTEMuzzleFlash_default_instance_;
class CMsgTEBloodStreamDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEBloodStream> _instance;
} _CMsgTEBloodStream_default_instance_;
class CMsgTEExplosionDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEExplosion> _instance;
} _CMsgTEExplosion_default_instance_;
class CMsgTEDustDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEDust> _instance;
} _CMsgTEDust_default_instance_;
class CMsgTELargeFunnelDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTELargeFunnel> _instance;
} _CMsgTELargeFunnel_default_instance_;
class CMsgTESparksDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTESparks> _instance;
} _CMsgTESparks_default_instance_;
class CMsgTEPhysicsPropDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEPhysicsProp> _instance;
} _CMsgTEPhysicsProp_default_instance_;
class CMsgTEPlayerDecalDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEPlayerDecal> _instance;
} _CMsgTEPlayerDecal_default_instance_;
class CMsgTEProjectedDecalDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEProjectedDecal> _instance;
} _CMsgTEProjectedDecal_default_instance_;
class CMsgTESmokeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTESmoke> _instance;
} _CMsgTESmoke_default_instance_;
class CMsgTEWorldDecalDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CMsgTEWorldDecal> _instance;
} _CMsgTEWorldDecal_default_instance_;
}  // namespace dota
}  // namespace proto
static void InitDefaultsCMsgTEArmorRicochet_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEArmorRicochet_default_instance_;
    new (ptr) ::proto::dota::CMsgTEArmorRicochet();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEArmorRicochet::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CMsgTEArmorRicochet_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCMsgTEArmorRicochet_te_2eproto}, {
      &scc_info_CMsgVector_networkbasetypes_2eproto.base,}};

static void InitDefaultsCMsgTEBaseBeam_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEBaseBeam_default_instance_;
    new (ptr) ::proto::dota::CMsgTEBaseBeam();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEBaseBeam::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_CMsgTEBaseBeam_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsCMsgTEBaseBeam_te_2eproto}, {}};

static void InitDefaultsCMsgTEBeamEntPoint_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEBeamEntPoint_default_instance_;
    new (ptr) ::proto::dota::CMsgTEBeamEntPoint();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEBeamEntPoint::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_CMsgTEBeamEntPoint_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsCMsgTEBeamEntPoint_te_2eproto}, {
      &scc_info_CMsgTEBaseBeam_te_2eproto.base,
      &scc_info_CMsgVector_networkbasetypes_2eproto.base,}};

static void InitDefaultsCMsgTEBeamEnts_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEBeamEnts_default_instance_;
    new (ptr) ::proto::dota::CMsgTEBeamEnts();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEBeamEnts::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CMsgTEBeamEnts_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCMsgTEBeamEnts_te_2eproto}, {
      &scc_info_CMsgTEBaseBeam_te_2eproto.base,}};

static void InitDefaultsCMsgTEBeamPoints_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEBeamPoints_default_instance_;
    new (ptr) ::proto::dota::CMsgTEBeamPoints();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEBeamPoints::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_CMsgTEBeamPoints_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsCMsgTEBeamPoints_te_2eproto}, {
      &scc_info_CMsgTEBaseBeam_te_2eproto.base,
      &scc_info_CMsgVector_networkbasetypes_2eproto.base,}};

static void InitDefaultsCMsgTEBeamRing_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEBeamRing_default_instance_;
    new (ptr) ::proto::dota::CMsgTEBeamRing();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEBeamRing::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CMsgTEBeamRing_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCMsgTEBeamRing_te_2eproto}, {
      &scc_info_CMsgTEBaseBeam_te_2eproto.base,}};

static void InitDefaultsCMsgTEBreakModel_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEBreakModel_default_instance_;
    new (ptr) ::proto::dota::CMsgTEBreakModel();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEBreakModel::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_CMsgTEBreakModel_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsCMsgTEBreakModel_te_2eproto}, {
      &scc_info_CMsgVector_networkbasetypes_2eproto.base,
      &scc_info_CMsgQAngle_networkbasetypes_2eproto.base,}};

static void InitDefaultsCMsgTEBSPDecal_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEBSPDecal_default_instance_;
    new (ptr) ::proto::dota::CMsgTEBSPDecal();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEBSPDecal::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CMsgTEBSPDecal_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCMsgTEBSPDecal_te_2eproto}, {
      &scc_info_CMsgVector_networkbasetypes_2eproto.base,}};

static void InitDefaultsCMsgTEBubbles_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEBubbles_default_instance_;
    new (ptr) ::proto::dota::CMsgTEBubbles();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEBubbles::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CMsgTEBubbles_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCMsgTEBubbles_te_2eproto}, {
      &scc_info_CMsgVector_networkbasetypes_2eproto.base,}};

static void InitDefaultsCMsgTEBubbleTrail_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEBubbleTrail_default_instance_;
    new (ptr) ::proto::dota::CMsgTEBubbleTrail();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEBubbleTrail::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CMsgTEBubbleTrail_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCMsgTEBubbleTrail_te_2eproto}, {
      &scc_info_CMsgVector_networkbasetypes_2eproto.base,}};

static void InitDefaultsCMsgTEDecal_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEDecal_default_instance_;
    new (ptr) ::proto::dota::CMsgTEDecal();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEDecal::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CMsgTEDecal_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCMsgTEDecal_te_2eproto}, {
      &scc_info_CMsgVector_networkbasetypes_2eproto.base,}};

static void InitDefaultsCMsgEffectData_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgEffectData_default_instance_;
    new (ptr) ::proto::dota::CMsgEffectData();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgEffectData::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_CMsgEffectData_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsCMsgEffectData_te_2eproto}, {
      &scc_info_CMsgVector_networkbasetypes_2eproto.base,
      &scc_info_CMsgQAngle_networkbasetypes_2eproto.base,}};

static void InitDefaultsCMsgTEEffectDispatch_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEEffectDispatch_default_instance_;
    new (ptr) ::proto::dota::CMsgTEEffectDispatch();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEEffectDispatch::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CMsgTEEffectDispatch_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCMsgTEEffectDispatch_te_2eproto}, {
      &scc_info_CMsgEffectData_te_2eproto.base,}};

static void InitDefaultsCMsgTEEnergySplash_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEEnergySplash_default_instance_;
    new (ptr) ::proto::dota::CMsgTEEnergySplash();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEEnergySplash::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CMsgTEEnergySplash_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCMsgTEEnergySplash_te_2eproto}, {
      &scc_info_CMsgVector_networkbasetypes_2eproto.base,}};

static void InitDefaultsCMsgTEFizz_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEFizz_default_instance_;
    new (ptr) ::proto::dota::CMsgTEFizz();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEFizz::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_CMsgTEFizz_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsCMsgTEFizz_te_2eproto}, {}};

static void InitDefaultsCMsgTEShatterSurface_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEShatterSurface_default_instance_;
    new (ptr) ::proto::dota::CMsgTEShatterSurface();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEShatterSurface::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_CMsgTEShatterSurface_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsCMsgTEShatterSurface_te_2eproto}, {
      &scc_info_CMsgVector_networkbasetypes_2eproto.base,
      &scc_info_CMsgQAngle_networkbasetypes_2eproto.base,}};

static void InitDefaultsCMsgTEGlowSprite_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEGlowSprite_default_instance_;
    new (ptr) ::proto::dota::CMsgTEGlowSprite();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEGlowSprite::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CMsgTEGlowSprite_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCMsgTEGlowSprite_te_2eproto}, {
      &scc_info_CMsgVector_networkbasetypes_2eproto.base,}};

static void InitDefaultsCMsgTEImpact_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEImpact_default_instance_;
    new (ptr) ::proto::dota::CMsgTEImpact();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEImpact::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CMsgTEImpact_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCMsgTEImpact_te_2eproto}, {
      &scc_info_CMsgVector_networkbasetypes_2eproto.base,}};

static void InitDefaultsCMsgTEMuzzleFlash_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEMuzzleFlash_default_instance_;
    new (ptr) ::proto::dota::CMsgTEMuzzleFlash();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEMuzzleFlash::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_CMsgTEMuzzleFlash_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsCMsgTEMuzzleFlash_te_2eproto}, {
      &scc_info_CMsgVector_networkbasetypes_2eproto.base,
      &scc_info_CMsgQAngle_networkbasetypes_2eproto.base,}};

static void InitDefaultsCMsgTEBloodStream_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEBloodStream_default_instance_;
    new (ptr) ::proto::dota::CMsgTEBloodStream();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEBloodStream::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CMsgTEBloodStream_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCMsgTEBloodStream_te_2eproto}, {
      &scc_info_CMsgVector_networkbasetypes_2eproto.base,}};

static void InitDefaultsCMsgTEExplosion_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEExplosion_default_instance_;
    new (ptr) ::proto::dota::CMsgTEExplosion();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEExplosion::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CMsgTEExplosion_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCMsgTEExplosion_te_2eproto}, {
      &scc_info_CMsgVector_networkbasetypes_2eproto.base,}};

static void InitDefaultsCMsgTEDust_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEDust_default_instance_;
    new (ptr) ::proto::dota::CMsgTEDust();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEDust::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CMsgTEDust_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCMsgTEDust_te_2eproto}, {
      &scc_info_CMsgVector_networkbasetypes_2eproto.base,}};

static void InitDefaultsCMsgTELargeFunnel_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTELargeFunnel_default_instance_;
    new (ptr) ::proto::dota::CMsgTELargeFunnel();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTELargeFunnel::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CMsgTELargeFunnel_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCMsgTELargeFunnel_te_2eproto}, {
      &scc_info_CMsgVector_networkbasetypes_2eproto.base,}};

static void InitDefaultsCMsgTESparks_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTESparks_default_instance_;
    new (ptr) ::proto::dota::CMsgTESparks();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTESparks::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CMsgTESparks_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCMsgTESparks_te_2eproto}, {
      &scc_info_CMsgVector_networkbasetypes_2eproto.base,}};

static void InitDefaultsCMsgTEPhysicsProp_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEPhysicsProp_default_instance_;
    new (ptr) ::proto::dota::CMsgTEPhysicsProp();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEPhysicsProp::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_CMsgTEPhysicsProp_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsCMsgTEPhysicsProp_te_2eproto}, {
      &scc_info_CMsgVector_networkbasetypes_2eproto.base,
      &scc_info_CMsgQAngle_networkbasetypes_2eproto.base,}};

static void InitDefaultsCMsgTEPlayerDecal_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEPlayerDecal_default_instance_;
    new (ptr) ::proto::dota::CMsgTEPlayerDecal();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEPlayerDecal::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CMsgTEPlayerDecal_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCMsgTEPlayerDecal_te_2eproto}, {
      &scc_info_CMsgVector_networkbasetypes_2eproto.base,}};

static void InitDefaultsCMsgTEProjectedDecal_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEProjectedDecal_default_instance_;
    new (ptr) ::proto::dota::CMsgTEProjectedDecal();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEProjectedDecal::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_CMsgTEProjectedDecal_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsCMsgTEProjectedDecal_te_2eproto}, {
      &scc_info_CMsgVector_networkbasetypes_2eproto.base,
      &scc_info_CMsgQAngle_networkbasetypes_2eproto.base,}};

static void InitDefaultsCMsgTESmoke_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTESmoke_default_instance_;
    new (ptr) ::proto::dota::CMsgTESmoke();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTESmoke::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CMsgTESmoke_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCMsgTESmoke_te_2eproto}, {
      &scc_info_CMsgVector_networkbasetypes_2eproto.base,}};

static void InitDefaultsCMsgTEWorldDecal_te_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::proto::dota::_CMsgTEWorldDecal_default_instance_;
    new (ptr) ::proto::dota::CMsgTEWorldDecal();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::proto::dota::CMsgTEWorldDecal::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CMsgTEWorldDecal_te_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCMsgTEWorldDecal_te_2eproto}, {
      &scc_info_CMsgVector_networkbasetypes_2eproto.base,}};

void InitDefaults_te_2eproto() {
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEArmorRicochet_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEBaseBeam_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEBeamEntPoint_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEBeamEnts_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEBeamPoints_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEBeamRing_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEBreakModel_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEBSPDecal_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEBubbles_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEBubbleTrail_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEDecal_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgEffectData_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEEffectDispatch_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEEnergySplash_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEFizz_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEShatterSurface_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEGlowSprite_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEImpact_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEMuzzleFlash_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEBloodStream_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEExplosion_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEDust_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTELargeFunnel_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTESparks_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEPhysicsProp_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEPlayerDecal_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEProjectedDecal_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTESmoke_te_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CMsgTEWorldDecal_te_2eproto.base);
}

::google::protobuf::Metadata file_level_metadata_te_2eproto[29];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors_te_2eproto[1];
constexpr ::google::protobuf::ServiceDescriptor const** file_level_service_descriptors_te_2eproto = nullptr;

const ::google::protobuf::uint32 TableStruct_te_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEArmorRicochet, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEArmorRicochet, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEArmorRicochet, pos_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEArmorRicochet, dir_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBaseBeam, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBaseBeam, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBaseBeam, modelindex_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBaseBeam, haloindex_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBaseBeam, startframe_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBaseBeam, framerate_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBaseBeam, life_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBaseBeam, width_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBaseBeam, endwidth_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBaseBeam, fadelength_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBaseBeam, amplitude_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBaseBeam, color_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBaseBeam, speed_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBaseBeam, flags_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBeamEntPoint, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBeamEntPoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBeamEntPoint, base_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBeamEntPoint, startentity_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBeamEntPoint, endentity_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBeamEntPoint, start_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBeamEntPoint, end_),
  0,
  3,
  4,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBeamEnts, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBeamEnts, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBeamEnts, base_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBeamEnts, startentity_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBeamEnts, endentity_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBeamPoints, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBeamPoints, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBeamPoints, base_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBeamPoints, start_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBeamPoints, end_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBeamRing, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBeamRing, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBeamRing, base_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBeamRing, startentity_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBeamRing, endentity_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBreakModel, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBreakModel, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBreakModel, origin_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBreakModel, angles_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBreakModel, size_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBreakModel, velocity_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBreakModel, randomization_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBreakModel, modelindex_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBreakModel, count_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBreakModel, time_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBreakModel, flags_),
  0,
  1,
  2,
  3,
  5,
  4,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBSPDecal, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBSPDecal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBSPDecal, origin_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBSPDecal, normal_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBSPDecal, saxis_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBSPDecal, entity_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBSPDecal, index_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBubbles, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBubbles, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBubbles, mins_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBubbles, maxs_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBubbles, height_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBubbles, count_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBubbles, speed_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBubbleTrail, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBubbleTrail, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBubbleTrail, mins_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBubbleTrail, maxs_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBubbleTrail, waterz_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBubbleTrail, count_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBubbleTrail, speed_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEDecal, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEDecal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEDecal, origin_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEDecal, start_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEDecal, entity_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEDecal, hitbox_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEDecal, index_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgEffectData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgEffectData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgEffectData, origin_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgEffectData, start_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgEffectData, normal_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgEffectData, angles_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgEffectData, entity_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgEffectData, otherentity_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgEffectData, scale_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgEffectData, magnitude_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgEffectData, radius_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgEffectData, surfaceprop_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgEffectData, effectindex_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgEffectData, damagetype_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgEffectData, material_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgEffectData, hitbox_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgEffectData, color_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgEffectData, flags_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgEffectData, attachmentindex_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgEffectData, effectname_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgEffectData, attachmentname_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEEffectDispatch, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEEffectDispatch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEEffectDispatch, effectdata_),
  0,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEEnergySplash, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEEnergySplash, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEEnergySplash, pos_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEEnergySplash, dir_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEEnergySplash, explosive_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEFizz, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEFizz, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEFizz, entity_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEFizz, density_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEFizz, current_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEShatterSurface, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEShatterSurface, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEShatterSurface, origin_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEShatterSurface, angles_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEShatterSurface, force_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEShatterSurface, forcepos_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEShatterSurface, width_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEShatterSurface, height_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEShatterSurface, shardsize_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEShatterSurface, surfacetype_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEShatterSurface, frontcolor_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEShatterSurface, backcolor_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEGlowSprite, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEGlowSprite, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEGlowSprite, origin_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEGlowSprite, scale_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEGlowSprite, life_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEGlowSprite, brightness_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEImpact, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEImpact, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEImpact, origin_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEImpact, normal_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEImpact, type_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEMuzzleFlash, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEMuzzleFlash, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEMuzzleFlash, origin_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEMuzzleFlash, angles_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEMuzzleFlash, scale_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEMuzzleFlash, type_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBloodStream, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBloodStream, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBloodStream, origin_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBloodStream, direction_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBloodStream, color_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEBloodStream, amount_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEExplosion, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEExplosion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEExplosion, origin_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEExplosion, framerate_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEExplosion, flags_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEExplosion, normal_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEExplosion, materialtype_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEExplosion, radius_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEExplosion, magnitude_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEExplosion, scale_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEExplosion, affect_ragdolls_),
  0,
  2,
  3,
  1,
  4,
  5,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEDust, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEDust, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEDust, origin_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEDust, size_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEDust, speed_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEDust, direction_),
  0,
  2,
  3,
  1,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTELargeFunnel, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTELargeFunnel, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTELargeFunnel, origin_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTELargeFunnel, reversed_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTESparks, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTESparks, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTESparks, origin_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTESparks, magnitude_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTESparks, length_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTESparks, direction_),
  0,
  2,
  3,
  1,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEPhysicsProp, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEPhysicsProp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEPhysicsProp, origin_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEPhysicsProp, velocity_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEPhysicsProp, angles_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEPhysicsProp, skin_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEPhysicsProp, flags_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEPhysicsProp, effects_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEPhysicsProp, color_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEPhysicsProp, modelindex_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEPhysicsProp, unused_breakmodelsnottomake_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEPhysicsProp, scale_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEPlayerDecal, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEPlayerDecal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEPlayerDecal, origin_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEPlayerDecal, player_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEPlayerDecal, entity_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEProjectedDecal, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEProjectedDecal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEProjectedDecal, origin_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEProjectedDecal, angles_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEProjectedDecal, index_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEProjectedDecal, distance_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTESmoke, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTESmoke, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTESmoke, origin_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTESmoke, scale_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEWorldDecal, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEWorldDecal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEWorldDecal, origin_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEWorldDecal, normal_),
  PROTOBUF_FIELD_OFFSET(::proto::dota::CMsgTEWorldDecal, index_),
  0,
  1,
  2,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, sizeof(::proto::dota::CMsgTEArmorRicochet)},
  { 9, 26, sizeof(::proto::dota::CMsgTEBaseBeam)},
  { 38, 48, sizeof(::proto::dota::CMsgTEBeamEntPoint)},
  { 53, 61, sizeof(::proto::dota::CMsgTEBeamEnts)},
  { 64, 72, sizeof(::proto::dota::CMsgTEBeamPoints)},
  { 75, 83, sizeof(::proto::dota::CMsgTEBeamRing)},
  { 86, 100, sizeof(::proto::dota::CMsgTEBreakModel)},
  { 109, 119, sizeof(::proto::dota::CMsgTEBSPDecal)},
  { 124, 134, sizeof(::proto::dota::CMsgTEBubbles)},
  { 139, 149, sizeof(::proto::dota::CMsgTEBubbleTrail)},
  { 154, 164, sizeof(::proto::dota::CMsgTEDecal)},
  { 169, 193, sizeof(::proto::dota::CMsgEffectData)},
  { 212, 218, sizeof(::proto::dota::CMsgTEEffectDispatch)},
  { 219, 227, sizeof(::proto::dota::CMsgTEEnergySplash)},
  { 230, 238, sizeof(::proto::dota::CMsgTEFizz)},
  { 241, 256, sizeof(::proto::dota::CMsgTEShatterSurface)},
  { 266, 275, sizeof(::proto::dota::CMsgTEGlowSprite)},
  { 279, 287, sizeof(::proto::dota::CMsgTEImpact)},
  { 290, 299, sizeof(::proto::dota::CMsgTEMuzzleFlash)},
  { 303, 312, sizeof(::proto::dota::CMsgTEBloodStream)},
  { 316, 330, sizeof(::proto::dota::CMsgTEExplosion)},
  { 339, 348, sizeof(::proto::dota::CMsgTEDust)},
  { 352, 359, sizeof(::proto::dota::CMsgTELargeFunnel)},
  { 361, 370, sizeof(::proto::dota::CMsgTESparks)},
  { 374, 389, sizeof(::proto::dota::CMsgTEPhysicsProp)},
  { 399, 407, sizeof(::proto::dota::CMsgTEPlayerDecal)},
  { 410, 419, sizeof(::proto::dota::CMsgTEProjectedDecal)},
  { 423, 430, sizeof(::proto::dota::CMsgTESmoke)},
  { 432, 440, sizeof(::proto::dota::CMsgTEWorldDecal)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEArmorRicochet_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEBaseBeam_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEBeamEntPoint_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEBeamEnts_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEBeamPoints_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEBeamRing_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEBreakModel_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEBSPDecal_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEBubbles_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEBubbleTrail_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEDecal_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgEffectData_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEEffectDispatch_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEEnergySplash_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEFizz_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEShatterSurface_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEGlowSprite_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEImpact_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEMuzzleFlash_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEBloodStream_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEExplosion_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEDust_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTELargeFunnel_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTESparks_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEPhysicsProp_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEPlayerDecal_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEProjectedDecal_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTESmoke_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::proto::dota::_CMsgTEWorldDecal_default_instance_),
};

::google::protobuf::internal::AssignDescriptorsTable assign_descriptors_table_te_2eproto = {
  {}, AddDescriptors_te_2eproto, "te.proto", schemas,
  file_default_instances, TableStruct_te_2eproto::offsets,
  file_level_metadata_te_2eproto, 29, file_level_enum_descriptors_te_2eproto, file_level_service_descriptors_te_2eproto,
};

const char descriptor_table_protodef_te_2eproto[] =
  "\n\010te.proto\022\nproto.dota\032\026networkbasetypes"
  ".proto\"_\n\023CMsgTEArmorRicochet\022#\n\003pos\030\001 \001"
  "(\0132\026.proto.dota.CMsgVector\022#\n\003dir\030\002 \001(\0132"
  "\026.proto.dota.CMsgVector\"\341\001\n\016CMsgTEBaseBe"
  "am\022\022\n\nmodelindex\030\001 \001(\006\022\021\n\thaloindex\030\002 \001("
  "\006\022\022\n\nstartframe\030\003 \001(\r\022\021\n\tframerate\030\004 \001(\r"
  "\022\014\n\004life\030\005 \001(\002\022\r\n\005width\030\006 \001(\002\022\020\n\010endwidt"
  "h\030\007 \001(\002\022\022\n\nfadelength\030\010 \001(\r\022\021\n\tamplitude"
  "\030\t \001(\002\022\r\n\005color\030\n \001(\007\022\r\n\005speed\030\013 \001(\r\022\r\n\005"
  "flags\030\014 \001(\r\"\262\001\n\022CMsgTEBeamEntPoint\022(\n\004ba"
  "se\030\001 \001(\0132\032.proto.dota.CMsgTEBaseBeam\022\023\n\013"
  "startentity\030\002 \001(\r\022\021\n\tendentity\030\003 \001(\r\022%\n\005"
  "start\030\004 \001(\0132\026.proto.dota.CMsgVector\022#\n\003e"
  "nd\030\005 \001(\0132\026.proto.dota.CMsgVector\"b\n\016CMsg"
  "TEBeamEnts\022(\n\004base\030\001 \001(\0132\032.proto.dota.CM"
  "sgTEBaseBeam\022\023\n\013startentity\030\002 \001(\r\022\021\n\tend"
  "entity\030\003 \001(\r\"\210\001\n\020CMsgTEBeamPoints\022(\n\004bas"
  "e\030\001 \001(\0132\032.proto.dota.CMsgTEBaseBeam\022%\n\005s"
  "tart\030\002 \001(\0132\026.proto.dota.CMsgVector\022#\n\003en"
  "d\030\003 \001(\0132\026.proto.dota.CMsgVector\"b\n\016CMsgT"
  "EBeamRing\022(\n\004base\030\001 \001(\0132\032.proto.dota.CMs"
  "gTEBaseBeam\022\023\n\013startentity\030\002 \001(\r\022\021\n\tende"
  "ntity\030\003 \001(\r\"\211\002\n\020CMsgTEBreakModel\022&\n\006orig"
  "in\030\001 \001(\0132\026.proto.dota.CMsgVector\022&\n\006angl"
  "es\030\002 \001(\0132\026.proto.dota.CMsgQAngle\022$\n\004size"
  "\030\003 \001(\0132\026.proto.dota.CMsgVector\022(\n\010veloci"
  "ty\030\004 \001(\0132\026.proto.dota.CMsgVector\022\025\n\rrand"
  "omization\030\005 \001(\r\022\022\n\nmodelindex\030\006 \001(\006\022\r\n\005c"
  "ount\030\007 \001(\r\022\014\n\004time\030\010 \001(\002\022\r\n\005flags\030\t \001(\r\""
  "\246\001\n\016CMsgTEBSPDecal\022&\n\006origin\030\001 \001(\0132\026.pro"
  "to.dota.CMsgVector\022&\n\006normal\030\002 \001(\0132\026.pro"
  "to.dota.CMsgVector\022%\n\005saxis\030\003 \001(\0132\026.prot"
  "o.dota.CMsgVector\022\016\n\006entity\030\004 \001(\r\022\r\n\005ind"
  "ex\030\005 \001(\r\"\211\001\n\rCMsgTEBubbles\022$\n\004mins\030\001 \001(\013"
  "2\026.proto.dota.CMsgVector\022$\n\004maxs\030\002 \001(\0132\026"
  ".proto.dota.CMsgVector\022\016\n\006height\030\003 \001(\002\022\r"
  "\n\005count\030\004 \001(\r\022\r\n\005speed\030\005 \001(\002\"\215\001\n\021CMsgTEB"
  "ubbleTrail\022$\n\004mins\030\001 \001(\0132\026.proto.dota.CM"
  "sgVector\022$\n\004maxs\030\002 \001(\0132\026.proto.dota.CMsg"
  "Vector\022\016\n\006waterz\030\003 \001(\002\022\r\n\005count\030\004 \001(\r\022\r\n"
  "\005speed\030\005 \001(\002\"\213\001\n\013CMsgTEDecal\022&\n\006origin\030\001"
  " \001(\0132\026.proto.dota.CMsgVector\022%\n\005start\030\002 "
  "\001(\0132\026.proto.dota.CMsgVector\022\016\n\006entity\030\003 "
  "\001(\r\022\016\n\006hitbox\030\004 \001(\r\022\r\n\005index\030\005 \001(\r\"\311\003\n\016C"
  "MsgEffectData\022&\n\006origin\030\001 \001(\0132\026.proto.do"
  "ta.CMsgVector\022%\n\005start\030\002 \001(\0132\026.proto.dot"
  "a.CMsgVector\022&\n\006normal\030\003 \001(\0132\026.proto.dot"
  "a.CMsgVector\022&\n\006angles\030\004 \001(\0132\026.proto.dot"
  "a.CMsgQAngle\022\016\n\006entity\030\005 \001(\007\022\023\n\013otherent"
  "ity\030\006 \001(\007\022\r\n\005scale\030\007 \001(\002\022\021\n\tmagnitude\030\010 "
  "\001(\002\022\016\n\006radius\030\t \001(\002\022\023\n\013surfaceprop\030\n \001(\007"
  "\022\023\n\013effectindex\030\013 \001(\006\022\022\n\ndamagetype\030\014 \001("
  "\r\022\020\n\010material\030\r \001(\r\022\016\n\006hitbox\030\016 \001(\r\022\r\n\005c"
  "olor\030\017 \001(\r\022\r\n\005flags\030\020 \001(\r\022\027\n\017attachmenti"
  "ndex\030\021 \001(\005\022\022\n\neffectname\030\022 \001(\r\022\026\n\016attach"
  "mentname\030\023 \001(\r\"F\n\024CMsgTEEffectDispatch\022."
  "\n\neffectdata\030\001 \001(\0132\032.proto.dota.CMsgEffe"
  "ctData\"q\n\022CMsgTEEnergySplash\022#\n\003pos\030\001 \001("
  "\0132\026.proto.dota.CMsgVector\022#\n\003dir\030\002 \001(\0132\026"
  ".proto.dota.CMsgVector\022\021\n\texplosive\030\003 \001("
  "\010\">\n\nCMsgTEFizz\022\016\n\006entity\030\001 \001(\r\022\017\n\007densi"
  "ty\030\002 \001(\r\022\017\n\007current\030\003 \001(\005\"\245\002\n\024CMsgTEShat"
  "terSurface\022&\n\006origin\030\001 \001(\0132\026.proto.dota."
  "CMsgVector\022&\n\006angles\030\002 \001(\0132\026.proto.dota."
  "CMsgQAngle\022%\n\005force\030\003 \001(\0132\026.proto.dota.C"
  "MsgVector\022(\n\010forcepos\030\004 \001(\0132\026.proto.dota"
  ".CMsgVector\022\r\n\005width\030\005 \001(\002\022\016\n\006height\030\006 \001"
  "(\002\022\021\n\tshardsize\030\007 \001(\002\022\023\n\013surfacetype\030\010 \001"
  "(\r\022\022\n\nfrontcolor\030\t \001(\007\022\021\n\tbackcolor\030\n \001("
  "\007\"k\n\020CMsgTEGlowSprite\022&\n\006origin\030\001 \001(\0132\026."
  "proto.dota.CMsgVector\022\r\n\005scale\030\002 \001(\002\022\014\n\004"
  "life\030\003 \001(\002\022\022\n\nbrightness\030\004 \001(\r\"l\n\014CMsgTE"
  "Impact\022&\n\006origin\030\001 \001(\0132\026.proto.dota.CMsg"
  "Vector\022&\n\006normal\030\002 \001(\0132\026.proto.dota.CMsg"
  "Vector\022\014\n\004type\030\003 \001(\r\"\200\001\n\021CMsgTEMuzzleFla"
  "sh\022&\n\006origin\030\001 \001(\0132\026.proto.dota.CMsgVect"
  "or\022&\n\006angles\030\002 \001(\0132\026.proto.dota.CMsgQAng"
  "le\022\r\n\005scale\030\003 \001(\002\022\014\n\004type\030\004 \001(\r\"\205\001\n\021CMsg"
  "TEBloodStream\022&\n\006origin\030\001 \001(\0132\026.proto.do"
  "ta.CMsgVector\022)\n\tdirection\030\002 \001(\0132\026.proto"
  ".dota.CMsgVector\022\r\n\005color\030\003 \001(\007\022\016\n\006amoun"
  "t\030\004 \001(\r\"\344\001\n\017CMsgTEExplosion\022&\n\006origin\030\001 "
  "\001(\0132\026.proto.dota.CMsgVector\022\021\n\tframerate"
  "\030\002 \001(\r\022\r\n\005flags\030\003 \001(\r\022&\n\006normal\030\004 \001(\0132\026."
  "proto.dota.CMsgVector\022\024\n\014materialtype\030\005 "
  "\001(\r\022\016\n\006radius\030\006 \001(\r\022\021\n\tmagnitude\030\007 \001(\r\022\r"
  "\n\005scale\030\010 \001(\002\022\027\n\017affect_ragdolls\030\t \001(\010\"|"
  "\n\nCMsgTEDust\022&\n\006origin\030\001 \001(\0132\026.proto.dot"
  "a.CMsgVector\022\014\n\004size\030\002 \001(\002\022\r\n\005speed\030\003 \001("
  "\002\022)\n\tdirection\030\004 \001(\0132\026.proto.dota.CMsgVe"
  "ctor\"M\n\021CMsgTELargeFunnel\022&\n\006origin\030\001 \001("
  "\0132\026.proto.dota.CMsgVector\022\020\n\010reversed\030\002 "
  "\001(\r\"\204\001\n\014CMsgTESparks\022&\n\006origin\030\001 \001(\0132\026.p"
  "roto.dota.CMsgVector\022\021\n\tmagnitude\030\002 \001(\r\022"
  "\016\n\006length\030\003 \001(\r\022)\n\tdirection\030\004 \001(\0132\026.pro"
  "to.dota.CMsgVector\"\222\002\n\021CMsgTEPhysicsProp"
  "\022&\n\006origin\030\001 \001(\0132\026.proto.dota.CMsgVector"
  "\022(\n\010velocity\030\002 \001(\0132\026.proto.dota.CMsgVect"
  "or\022&\n\006angles\030\003 \001(\0132\026.proto.dota.CMsgQAng"
  "le\022\014\n\004skin\030\004 \001(\007\022\r\n\005flags\030\005 \001(\r\022\017\n\007effec"
  "ts\030\006 \001(\r\022\r\n\005color\030\007 \001(\007\022\022\n\nmodelindex\030\010 "
  "\001(\006\022#\n\033unused_breakmodelsnottomake\030\t \001(\r"
  "\022\r\n\005scale\030\n \001(\002\"[\n\021CMsgTEPlayerDecal\022&\n\006"
  "origin\030\001 \001(\0132\026.proto.dota.CMsgVector\022\016\n\006"
  "player\030\002 \001(\r\022\016\n\006entity\030\003 \001(\r\"\207\001\n\024CMsgTEP"
  "rojectedDecal\022&\n\006origin\030\001 \001(\0132\026.proto.do"
  "ta.CMsgVector\022&\n\006angles\030\002 \001(\0132\026.proto.do"
  "ta.CMsgQAngle\022\r\n\005index\030\003 \001(\r\022\020\n\010distance"
  "\030\004 \001(\002\"D\n\013CMsgTESmoke\022&\n\006origin\030\001 \001(\0132\026."
  "proto.dota.CMsgVector\022\r\n\005scale\030\002 \001(\002\"q\n\020"
  "CMsgTEWorldDecal\022&\n\006origin\030\001 \001(\0132\026.proto"
  ".dota.CMsgVector\022&\n\006normal\030\002 \001(\0132\026.proto"
  ".dota.CMsgVector\022\r\n\005index\030\003 \001(\r*\323\004\n\016ETEP"
  "rotobufIds\022\030\n\023TE_EffectDispatchId\020\220\003\022\027\n\022"
  "TE_ArmorRicochetId\020\221\003\022\026\n\021TE_BeamEntPoint"
  "Id\020\222\003\022\022\n\rTE_BeamEntsId\020\223\003\022\024\n\017TE_BeamPoin"
  "tsId\020\224\003\022\022\n\rTE_BeamRingId\020\225\003\022\024\n\017TE_BreakM"
  "odelId\020\226\003\022\022\n\rTE_BSPDecalId\020\227\003\022\021\n\014TE_Bubb"
  "lesId\020\230\003\022\025\n\020TE_BubbleTrailId\020\231\003\022\017\n\nTE_De"
  "calId\020\232\003\022\024\n\017TE_WorldDecalId\020\233\003\022\026\n\021TE_Ene"
  "rgySplashId\020\234\003\022\016\n\tTE_FizzId\020\235\003\022\030\n\023TE_Sha"
  "tterSurfaceId\020\236\003\022\024\n\017TE_GlowSpriteId\020\237\003\022\020"
  "\n\013TE_ImpactId\020\240\003\022\025\n\020TE_MuzzleFlashId\020\241\003\022"
  "\025\n\020TE_BloodStreamId\020\242\003\022\023\n\016TE_ExplosionId"
  "\020\243\003\022\016\n\tTE_DustId\020\244\003\022\025\n\020TE_LargeFunnelId\020"
  "\245\003\022\020\n\013TE_SparksId\020\246\003\022\025\n\020TE_PhysicsPropId"
  "\020\247\003\022\025\n\020TE_PlayerDecalId\020\250\003\022\030\n\023TE_Project"
  "edDecalId\020\251\003\022\017\n\nTE_SmokeId\020\252\003B\005H\001\200\001\000"
  ;
::google::protobuf::internal::DescriptorTable descriptor_table_te_2eproto = {
  false, InitDefaults_te_2eproto, 
  descriptor_table_protodef_te_2eproto,
  "te.proto", &assign_descriptors_table_te_2eproto, 5116,
};

void AddDescriptors_te_2eproto() {
  static constexpr ::google::protobuf::internal::InitFunc deps[1] =
  {
    ::AddDescriptors_networkbasetypes_2eproto,
  };
 ::google::protobuf::internal::AddDescriptors(&descriptor_table_te_2eproto, deps, 1);
}

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_te_2eproto = []() { AddDescriptors_te_2eproto(); return true; }();
namespace proto {
namespace dota {
const ::google::protobuf::EnumDescriptor* ETEProtobufIds_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_te_2eproto);
  return file_level_enum_descriptors_te_2eproto[0];
}
bool ETEProtobufIds_IsValid(int value) {
  switch (value) {
    case 400:
    case 401:
    case 402:
    case 403:
    case 404:
    case 405:
    case 406:
    case 407:
    case 408:
    case 409:
    case 410:
    case 411:
    case 412:
    case 413:
    case 414:
    case 415:
    case 416:
    case 417:
    case 418:
    case 419:
    case 420:
    case 421:
    case 422:
    case 423:
    case 424:
    case 425:
    case 426:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void CMsgTEArmorRicochet::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTEArmorRicochet_default_instance_._instance.get_mutable()->pos_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgTEArmorRicochet_default_instance_._instance.get_mutable()->dir_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
}
class CMsgTEArmorRicochet::HasBitSetters {
 public:
  static const ::proto::dota::CMsgVector& pos(const CMsgTEArmorRicochet* msg);
  static void set_has_pos(CMsgTEArmorRicochet* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::proto::dota::CMsgVector& dir(const CMsgTEArmorRicochet* msg);
  static void set_has_dir(CMsgTEArmorRicochet* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

const ::proto::dota::CMsgVector&
CMsgTEArmorRicochet::HasBitSetters::pos(const CMsgTEArmorRicochet* msg) {
  return *msg->pos_;
}
const ::proto::dota::CMsgVector&
CMsgTEArmorRicochet::HasBitSetters::dir(const CMsgTEArmorRicochet* msg) {
  return *msg->dir_;
}
void CMsgTEArmorRicochet::clear_pos() {
  if (pos_ != nullptr) pos_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEArmorRicochet::clear_dir() {
  if (dir_ != nullptr) dir_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEArmorRicochet::kPosFieldNumber;
const int CMsgTEArmorRicochet::kDirFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEArmorRicochet::CMsgTEArmorRicochet()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEArmorRicochet)
}
CMsgTEArmorRicochet::CMsgTEArmorRicochet(const CMsgTEArmorRicochet& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_pos()) {
    pos_ = new ::proto::dota::CMsgVector(*from.pos_);
  } else {
    pos_ = nullptr;
  }
  if (from.has_dir()) {
    dir_ = new ::proto::dota::CMsgVector(*from.dir_);
  } else {
    dir_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEArmorRicochet)
}

void CMsgTEArmorRicochet::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTEArmorRicochet_te_2eproto.base);
  ::memset(&pos_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&dir_) -
      reinterpret_cast<char*>(&pos_)) + sizeof(dir_));
}

CMsgTEArmorRicochet::~CMsgTEArmorRicochet() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEArmorRicochet)
  SharedDtor();
}

void CMsgTEArmorRicochet::SharedDtor() {
  if (this != internal_default_instance()) delete pos_;
  if (this != internal_default_instance()) delete dir_;
}

void CMsgTEArmorRicochet::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEArmorRicochet& CMsgTEArmorRicochet::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEArmorRicochet_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEArmorRicochet::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEArmorRicochet)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(pos_ != nullptr);
      pos_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(dir_ != nullptr);
      dir_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEArmorRicochet::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEArmorRicochet*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgVector pos = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_pos();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgVector dir = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_dir();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEArmorRicochet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEArmorRicochet)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgVector pos = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_pos()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgVector dir = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_dir()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEArmorRicochet)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEArmorRicochet)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEArmorRicochet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEArmorRicochet)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector pos = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::pos(this), output);
  }

  // optional .proto.dota.CMsgVector dir = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::dir(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEArmorRicochet)
}

::google::protobuf::uint8* CMsgTEArmorRicochet::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEArmorRicochet)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector pos = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::pos(this), target);
  }

  // optional .proto.dota.CMsgVector dir = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::dir(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEArmorRicochet)
  return target;
}

size_t CMsgTEArmorRicochet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEArmorRicochet)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .proto.dota.CMsgVector pos = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *pos_);
    }

    // optional .proto.dota.CMsgVector dir = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *dir_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEArmorRicochet::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEArmorRicochet)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEArmorRicochet* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEArmorRicochet>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEArmorRicochet)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEArmorRicochet)
    MergeFrom(*source);
  }
}

void CMsgTEArmorRicochet::MergeFrom(const CMsgTEArmorRicochet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEArmorRicochet)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_pos()->::proto::dota::CMsgVector::MergeFrom(from.pos());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_dir()->::proto::dota::CMsgVector::MergeFrom(from.dir());
    }
  }
}

void CMsgTEArmorRicochet::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEArmorRicochet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEArmorRicochet::CopyFrom(const CMsgTEArmorRicochet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEArmorRicochet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEArmorRicochet::IsInitialized() const {
  return true;
}

void CMsgTEArmorRicochet::Swap(CMsgTEArmorRicochet* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEArmorRicochet::InternalSwap(CMsgTEArmorRicochet* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(pos_, other->pos_);
  swap(dir_, other->dir_);
}

::google::protobuf::Metadata CMsgTEArmorRicochet::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTEBaseBeam::InitAsDefaultInstance() {
}
class CMsgTEBaseBeam::HasBitSetters {
 public:
  static void set_has_modelindex(CMsgTEBaseBeam* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_haloindex(CMsgTEBaseBeam* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_startframe(CMsgTEBaseBeam* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_framerate(CMsgTEBaseBeam* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_life(CMsgTEBaseBeam* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_width(CMsgTEBaseBeam* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_endwidth(CMsgTEBaseBeam* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_fadelength(CMsgTEBaseBeam* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_amplitude(CMsgTEBaseBeam* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static void set_has_color(CMsgTEBaseBeam* msg) {
    msg->_has_bits_[0] |= 0x00000200u;
  }
  static void set_has_speed(CMsgTEBaseBeam* msg) {
    msg->_has_bits_[0] |= 0x00000400u;
  }
  static void set_has_flags(CMsgTEBaseBeam* msg) {
    msg->_has_bits_[0] |= 0x00000800u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEBaseBeam::kModelindexFieldNumber;
const int CMsgTEBaseBeam::kHaloindexFieldNumber;
const int CMsgTEBaseBeam::kStartframeFieldNumber;
const int CMsgTEBaseBeam::kFramerateFieldNumber;
const int CMsgTEBaseBeam::kLifeFieldNumber;
const int CMsgTEBaseBeam::kWidthFieldNumber;
const int CMsgTEBaseBeam::kEndwidthFieldNumber;
const int CMsgTEBaseBeam::kFadelengthFieldNumber;
const int CMsgTEBaseBeam::kAmplitudeFieldNumber;
const int CMsgTEBaseBeam::kColorFieldNumber;
const int CMsgTEBaseBeam::kSpeedFieldNumber;
const int CMsgTEBaseBeam::kFlagsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEBaseBeam::CMsgTEBaseBeam()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEBaseBeam)
}
CMsgTEBaseBeam::CMsgTEBaseBeam(const CMsgTEBaseBeam& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&modelindex_, &from.modelindex_,
    static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&modelindex_)) + sizeof(flags_));
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEBaseBeam)
}

void CMsgTEBaseBeam::SharedCtor() {
  ::memset(&modelindex_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&flags_) -
      reinterpret_cast<char*>(&modelindex_)) + sizeof(flags_));
}

CMsgTEBaseBeam::~CMsgTEBaseBeam() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEBaseBeam)
  SharedDtor();
}

void CMsgTEBaseBeam::SharedDtor() {
}

void CMsgTEBaseBeam::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEBaseBeam& CMsgTEBaseBeam::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEBaseBeam_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEBaseBeam::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEBaseBeam)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&modelindex_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&fadelength_) -
        reinterpret_cast<char*>(&modelindex_)) + sizeof(fadelength_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&amplitude_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flags_) -
        reinterpret_cast<char*>(&amplitude_)) + sizeof(flags_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEBaseBeam::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEBaseBeam*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional fixed64 modelindex = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        msg->set_modelindex(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr));
        ptr += sizeof(::google::protobuf::uint64);
        break;
      }
      // optional fixed64 haloindex = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        msg->set_haloindex(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr));
        ptr += sizeof(::google::protobuf::uint64);
        break;
      }
      // optional uint32 startframe = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_startframe(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 framerate = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_framerate(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional float life = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 45) goto handle_unusual;
        msg->set_life(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float width = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 53) goto handle_unusual;
        msg->set_width(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float endwidth = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 61) goto handle_unusual;
        msg->set_endwidth(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional uint32 fadelength = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 64) goto handle_unusual;
        msg->set_fadelength(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional float amplitude = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 77) goto handle_unusual;
        msg->set_amplitude(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional fixed32 color = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 85) goto handle_unusual;
        msg->set_color(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint32>(ptr));
        ptr += sizeof(::google::protobuf::uint32);
        break;
      }
      // optional uint32 speed = 11;
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 88) goto handle_unusual;
        msg->set_speed(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 flags = 12;
      case 12: {
        if (static_cast<::google::protobuf::uint8>(tag) != 96) goto handle_unusual;
        msg->set_flags(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEBaseBeam::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEBaseBeam)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional fixed64 modelindex = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          HasBitSetters::set_has_modelindex(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &modelindex_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed64 haloindex = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          HasBitSetters::set_has_haloindex(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &haloindex_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 startframe = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_startframe(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &startframe_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 framerate = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_framerate(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &framerate_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float life = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (45 & 0xFF)) {
          HasBitSetters::set_has_life(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &life_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float width = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (53 & 0xFF)) {
          HasBitSetters::set_has_width(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &width_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float endwidth = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (61 & 0xFF)) {
          HasBitSetters::set_has_endwidth(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &endwidth_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 fadelength = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_fadelength(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fadelength_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float amplitude = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (77 & 0xFF)) {
          HasBitSetters::set_has_amplitude(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &amplitude_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed32 color = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (85 & 0xFF)) {
          HasBitSetters::set_has_color(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &color_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 speed = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (88 & 0xFF)) {
          HasBitSetters::set_has_speed(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &speed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 flags = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (96 & 0xFF)) {
          HasBitSetters::set_has_flags(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEBaseBeam)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEBaseBeam)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEBaseBeam::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEBaseBeam)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 modelindex = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(1, this->modelindex(), output);
  }

  // optional fixed64 haloindex = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(2, this->haloindex(), output);
  }

  // optional uint32 startframe = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->startframe(), output);
  }

  // optional uint32 framerate = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->framerate(), output);
  }

  // optional float life = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->life(), output);
  }

  // optional float width = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->width(), output);
  }

  // optional float endwidth = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->endwidth(), output);
  }

  // optional uint32 fadelength = 8;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->fadelength(), output);
  }

  // optional float amplitude = 9;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->amplitude(), output);
  }

  // optional fixed32 color = 10;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(10, this->color(), output);
  }

  // optional uint32 speed = 11;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->speed(), output);
  }

  // optional uint32 flags = 12;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->flags(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEBaseBeam)
}

::google::protobuf::uint8* CMsgTEBaseBeam::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEBaseBeam)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 modelindex = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(1, this->modelindex(), target);
  }

  // optional fixed64 haloindex = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(2, this->haloindex(), target);
  }

  // optional uint32 startframe = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->startframe(), target);
  }

  // optional uint32 framerate = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->framerate(), target);
  }

  // optional float life = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->life(), target);
  }

  // optional float width = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->width(), target);
  }

  // optional float endwidth = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->endwidth(), target);
  }

  // optional uint32 fadelength = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->fadelength(), target);
  }

  // optional float amplitude = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->amplitude(), target);
  }

  // optional fixed32 color = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(10, this->color(), target);
  }

  // optional uint32 speed = 11;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->speed(), target);
  }

  // optional uint32 flags = 12;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->flags(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEBaseBeam)
  return target;
}

size_t CMsgTEBaseBeam::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEBaseBeam)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional fixed64 modelindex = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional fixed64 haloindex = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 startframe = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->startframe());
    }

    // optional uint32 framerate = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->framerate());
    }

    // optional float life = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float width = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float endwidth = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional uint32 fadelength = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fadelength());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional float amplitude = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional fixed32 color = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional uint32 speed = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->speed());
    }

    // optional uint32 flags = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEBaseBeam::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEBaseBeam)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEBaseBeam* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEBaseBeam>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEBaseBeam)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEBaseBeam)
    MergeFrom(*source);
  }
}

void CMsgTEBaseBeam::MergeFrom(const CMsgTEBaseBeam& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEBaseBeam)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      modelindex_ = from.modelindex_;
    }
    if (cached_has_bits & 0x00000002u) {
      haloindex_ = from.haloindex_;
    }
    if (cached_has_bits & 0x00000004u) {
      startframe_ = from.startframe_;
    }
    if (cached_has_bits & 0x00000008u) {
      framerate_ = from.framerate_;
    }
    if (cached_has_bits & 0x00000010u) {
      life_ = from.life_;
    }
    if (cached_has_bits & 0x00000020u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000040u) {
      endwidth_ = from.endwidth_;
    }
    if (cached_has_bits & 0x00000080u) {
      fadelength_ = from.fadelength_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      amplitude_ = from.amplitude_;
    }
    if (cached_has_bits & 0x00000200u) {
      color_ = from.color_;
    }
    if (cached_has_bits & 0x00000400u) {
      speed_ = from.speed_;
    }
    if (cached_has_bits & 0x00000800u) {
      flags_ = from.flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEBaseBeam::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEBaseBeam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBaseBeam::CopyFrom(const CMsgTEBaseBeam& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEBaseBeam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBaseBeam::IsInitialized() const {
  return true;
}

void CMsgTEBaseBeam::Swap(CMsgTEBaseBeam* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEBaseBeam::InternalSwap(CMsgTEBaseBeam* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(modelindex_, other->modelindex_);
  swap(haloindex_, other->haloindex_);
  swap(startframe_, other->startframe_);
  swap(framerate_, other->framerate_);
  swap(life_, other->life_);
  swap(width_, other->width_);
  swap(endwidth_, other->endwidth_);
  swap(fadelength_, other->fadelength_);
  swap(amplitude_, other->amplitude_);
  swap(color_, other->color_);
  swap(speed_, other->speed_);
  swap(flags_, other->flags_);
}

::google::protobuf::Metadata CMsgTEBaseBeam::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTEBeamEntPoint::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTEBeamEntPoint_default_instance_._instance.get_mutable()->base_ = const_cast< ::proto::dota::CMsgTEBaseBeam*>(
      ::proto::dota::CMsgTEBaseBeam::internal_default_instance());
  ::proto::dota::_CMsgTEBeamEntPoint_default_instance_._instance.get_mutable()->start_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgTEBeamEntPoint_default_instance_._instance.get_mutable()->end_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
}
class CMsgTEBeamEntPoint::HasBitSetters {
 public:
  static const ::proto::dota::CMsgTEBaseBeam& base(const CMsgTEBeamEntPoint* msg);
  static void set_has_base(CMsgTEBeamEntPoint* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_startentity(CMsgTEBeamEntPoint* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_endentity(CMsgTEBeamEntPoint* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static const ::proto::dota::CMsgVector& start(const CMsgTEBeamEntPoint* msg);
  static void set_has_start(CMsgTEBeamEntPoint* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::proto::dota::CMsgVector& end(const CMsgTEBeamEntPoint* msg);
  static void set_has_end(CMsgTEBeamEntPoint* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

const ::proto::dota::CMsgTEBaseBeam&
CMsgTEBeamEntPoint::HasBitSetters::base(const CMsgTEBeamEntPoint* msg) {
  return *msg->base_;
}
const ::proto::dota::CMsgVector&
CMsgTEBeamEntPoint::HasBitSetters::start(const CMsgTEBeamEntPoint* msg) {
  return *msg->start_;
}
const ::proto::dota::CMsgVector&
CMsgTEBeamEntPoint::HasBitSetters::end(const CMsgTEBeamEntPoint* msg) {
  return *msg->end_;
}
void CMsgTEBeamEntPoint::clear_start() {
  if (start_ != nullptr) start_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEBeamEntPoint::clear_end() {
  if (end_ != nullptr) end_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEBeamEntPoint::kBaseFieldNumber;
const int CMsgTEBeamEntPoint::kStartentityFieldNumber;
const int CMsgTEBeamEntPoint::kEndentityFieldNumber;
const int CMsgTEBeamEntPoint::kStartFieldNumber;
const int CMsgTEBeamEntPoint::kEndFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEBeamEntPoint::CMsgTEBeamEntPoint()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEBeamEntPoint)
}
CMsgTEBeamEntPoint::CMsgTEBeamEntPoint(const CMsgTEBeamEntPoint& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_base()) {
    base_ = new ::proto::dota::CMsgTEBaseBeam(*from.base_);
  } else {
    base_ = nullptr;
  }
  if (from.has_start()) {
    start_ = new ::proto::dota::CMsgVector(*from.start_);
  } else {
    start_ = nullptr;
  }
  if (from.has_end()) {
    end_ = new ::proto::dota::CMsgVector(*from.end_);
  } else {
    end_ = nullptr;
  }
  ::memcpy(&startentity_, &from.startentity_,
    static_cast<size_t>(reinterpret_cast<char*>(&endentity_) -
    reinterpret_cast<char*>(&startentity_)) + sizeof(endentity_));
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEBeamEntPoint)
}

void CMsgTEBeamEntPoint::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTEBeamEntPoint_te_2eproto.base);
  ::memset(&base_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&endentity_) -
      reinterpret_cast<char*>(&base_)) + sizeof(endentity_));
}

CMsgTEBeamEntPoint::~CMsgTEBeamEntPoint() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEBeamEntPoint)
  SharedDtor();
}

void CMsgTEBeamEntPoint::SharedDtor() {
  if (this != internal_default_instance()) delete base_;
  if (this != internal_default_instance()) delete start_;
  if (this != internal_default_instance()) delete end_;
}

void CMsgTEBeamEntPoint::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEBeamEntPoint& CMsgTEBeamEntPoint::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEBeamEntPoint_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEBeamEntPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEBeamEntPoint)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(base_ != nullptr);
      base_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(start_ != nullptr);
      start_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(end_ != nullptr);
      end_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&startentity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&endentity_) -
        reinterpret_cast<char*>(&startentity_)) + sizeof(endentity_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEBeamEntPoint::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEBeamEntPoint*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgTEBaseBeam base = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgTEBaseBeam::_InternalParse;
        object = msg->mutable_base();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional uint32 startentity = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_startentity(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 endentity = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_endentity(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .proto.dota.CMsgVector start = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_start();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgVector end = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_end();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEBeamEntPoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEBeamEntPoint)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgTEBaseBeam base = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_base()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 startentity = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_startentity(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &startentity_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 endentity = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_endentity(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &endentity_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgVector start = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_start()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgVector end = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_end()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEBeamEntPoint)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEBeamEntPoint)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEBeamEntPoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEBeamEntPoint)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgTEBaseBeam base = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::base(this), output);
  }

  // optional uint32 startentity = 2;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->startentity(), output);
  }

  // optional uint32 endentity = 3;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->endentity(), output);
  }

  // optional .proto.dota.CMsgVector start = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::start(this), output);
  }

  // optional .proto.dota.CMsgVector end = 5;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, HasBitSetters::end(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEBeamEntPoint)
}

::google::protobuf::uint8* CMsgTEBeamEntPoint::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEBeamEntPoint)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgTEBaseBeam base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::base(this), target);
  }

  // optional uint32 startentity = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->startentity(), target);
  }

  // optional uint32 endentity = 3;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->endentity(), target);
  }

  // optional .proto.dota.CMsgVector start = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::start(this), target);
  }

  // optional .proto.dota.CMsgVector end = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, HasBitSetters::end(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEBeamEntPoint)
  return target;
}

size_t CMsgTEBeamEntPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEBeamEntPoint)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .proto.dota.CMsgTEBaseBeam base = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *base_);
    }

    // optional .proto.dota.CMsgVector start = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *start_);
    }

    // optional .proto.dota.CMsgVector end = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *end_);
    }

    // optional uint32 startentity = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->startentity());
    }

    // optional uint32 endentity = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->endentity());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEBeamEntPoint::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEBeamEntPoint)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEBeamEntPoint* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEBeamEntPoint>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEBeamEntPoint)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEBeamEntPoint)
    MergeFrom(*source);
  }
}

void CMsgTEBeamEntPoint::MergeFrom(const CMsgTEBeamEntPoint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEBeamEntPoint)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_base()->::proto::dota::CMsgTEBaseBeam::MergeFrom(from.base());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_start()->::proto::dota::CMsgVector::MergeFrom(from.start());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_end()->::proto::dota::CMsgVector::MergeFrom(from.end());
    }
    if (cached_has_bits & 0x00000008u) {
      startentity_ = from.startentity_;
    }
    if (cached_has_bits & 0x00000010u) {
      endentity_ = from.endentity_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEBeamEntPoint::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEBeamEntPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBeamEntPoint::CopyFrom(const CMsgTEBeamEntPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEBeamEntPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBeamEntPoint::IsInitialized() const {
  return true;
}

void CMsgTEBeamEntPoint::Swap(CMsgTEBeamEntPoint* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEBeamEntPoint::InternalSwap(CMsgTEBeamEntPoint* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(base_, other->base_);
  swap(start_, other->start_);
  swap(end_, other->end_);
  swap(startentity_, other->startentity_);
  swap(endentity_, other->endentity_);
}

::google::protobuf::Metadata CMsgTEBeamEntPoint::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTEBeamEnts::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTEBeamEnts_default_instance_._instance.get_mutable()->base_ = const_cast< ::proto::dota::CMsgTEBaseBeam*>(
      ::proto::dota::CMsgTEBaseBeam::internal_default_instance());
}
class CMsgTEBeamEnts::HasBitSetters {
 public:
  static const ::proto::dota::CMsgTEBaseBeam& base(const CMsgTEBeamEnts* msg);
  static void set_has_base(CMsgTEBeamEnts* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_startentity(CMsgTEBeamEnts* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_endentity(CMsgTEBeamEnts* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

const ::proto::dota::CMsgTEBaseBeam&
CMsgTEBeamEnts::HasBitSetters::base(const CMsgTEBeamEnts* msg) {
  return *msg->base_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEBeamEnts::kBaseFieldNumber;
const int CMsgTEBeamEnts::kStartentityFieldNumber;
const int CMsgTEBeamEnts::kEndentityFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEBeamEnts::CMsgTEBeamEnts()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEBeamEnts)
}
CMsgTEBeamEnts::CMsgTEBeamEnts(const CMsgTEBeamEnts& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_base()) {
    base_ = new ::proto::dota::CMsgTEBaseBeam(*from.base_);
  } else {
    base_ = nullptr;
  }
  ::memcpy(&startentity_, &from.startentity_,
    static_cast<size_t>(reinterpret_cast<char*>(&endentity_) -
    reinterpret_cast<char*>(&startentity_)) + sizeof(endentity_));
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEBeamEnts)
}

void CMsgTEBeamEnts::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTEBeamEnts_te_2eproto.base);
  ::memset(&base_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&endentity_) -
      reinterpret_cast<char*>(&base_)) + sizeof(endentity_));
}

CMsgTEBeamEnts::~CMsgTEBeamEnts() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEBeamEnts)
  SharedDtor();
}

void CMsgTEBeamEnts::SharedDtor() {
  if (this != internal_default_instance()) delete base_;
}

void CMsgTEBeamEnts::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEBeamEnts& CMsgTEBeamEnts::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEBeamEnts_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEBeamEnts::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEBeamEnts)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(base_ != nullptr);
    base_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&startentity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&endentity_) -
        reinterpret_cast<char*>(&startentity_)) + sizeof(endentity_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEBeamEnts::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEBeamEnts*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgTEBaseBeam base = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgTEBaseBeam::_InternalParse;
        object = msg->mutable_base();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional uint32 startentity = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_startentity(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 endentity = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_endentity(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEBeamEnts::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEBeamEnts)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgTEBaseBeam base = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_base()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 startentity = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_startentity(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &startentity_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 endentity = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_endentity(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &endentity_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEBeamEnts)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEBeamEnts)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEBeamEnts::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEBeamEnts)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgTEBaseBeam base = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::base(this), output);
  }

  // optional uint32 startentity = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->startentity(), output);
  }

  // optional uint32 endentity = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->endentity(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEBeamEnts)
}

::google::protobuf::uint8* CMsgTEBeamEnts::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEBeamEnts)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgTEBaseBeam base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::base(this), target);
  }

  // optional uint32 startentity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->startentity(), target);
  }

  // optional uint32 endentity = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->endentity(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEBeamEnts)
  return target;
}

size_t CMsgTEBeamEnts::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEBeamEnts)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .proto.dota.CMsgTEBaseBeam base = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *base_);
    }

    // optional uint32 startentity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->startentity());
    }

    // optional uint32 endentity = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->endentity());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEBeamEnts::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEBeamEnts)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEBeamEnts* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEBeamEnts>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEBeamEnts)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEBeamEnts)
    MergeFrom(*source);
  }
}

void CMsgTEBeamEnts::MergeFrom(const CMsgTEBeamEnts& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEBeamEnts)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_base()->::proto::dota::CMsgTEBaseBeam::MergeFrom(from.base());
    }
    if (cached_has_bits & 0x00000002u) {
      startentity_ = from.startentity_;
    }
    if (cached_has_bits & 0x00000004u) {
      endentity_ = from.endentity_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEBeamEnts::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEBeamEnts)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBeamEnts::CopyFrom(const CMsgTEBeamEnts& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEBeamEnts)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBeamEnts::IsInitialized() const {
  return true;
}

void CMsgTEBeamEnts::Swap(CMsgTEBeamEnts* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEBeamEnts::InternalSwap(CMsgTEBeamEnts* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(base_, other->base_);
  swap(startentity_, other->startentity_);
  swap(endentity_, other->endentity_);
}

::google::protobuf::Metadata CMsgTEBeamEnts::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTEBeamPoints::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTEBeamPoints_default_instance_._instance.get_mutable()->base_ = const_cast< ::proto::dota::CMsgTEBaseBeam*>(
      ::proto::dota::CMsgTEBaseBeam::internal_default_instance());
  ::proto::dota::_CMsgTEBeamPoints_default_instance_._instance.get_mutable()->start_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgTEBeamPoints_default_instance_._instance.get_mutable()->end_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
}
class CMsgTEBeamPoints::HasBitSetters {
 public:
  static const ::proto::dota::CMsgTEBaseBeam& base(const CMsgTEBeamPoints* msg);
  static void set_has_base(CMsgTEBeamPoints* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::proto::dota::CMsgVector& start(const CMsgTEBeamPoints* msg);
  static void set_has_start(CMsgTEBeamPoints* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::proto::dota::CMsgVector& end(const CMsgTEBeamPoints* msg);
  static void set_has_end(CMsgTEBeamPoints* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

const ::proto::dota::CMsgTEBaseBeam&
CMsgTEBeamPoints::HasBitSetters::base(const CMsgTEBeamPoints* msg) {
  return *msg->base_;
}
const ::proto::dota::CMsgVector&
CMsgTEBeamPoints::HasBitSetters::start(const CMsgTEBeamPoints* msg) {
  return *msg->start_;
}
const ::proto::dota::CMsgVector&
CMsgTEBeamPoints::HasBitSetters::end(const CMsgTEBeamPoints* msg) {
  return *msg->end_;
}
void CMsgTEBeamPoints::clear_start() {
  if (start_ != nullptr) start_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEBeamPoints::clear_end() {
  if (end_ != nullptr) end_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEBeamPoints::kBaseFieldNumber;
const int CMsgTEBeamPoints::kStartFieldNumber;
const int CMsgTEBeamPoints::kEndFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEBeamPoints::CMsgTEBeamPoints()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEBeamPoints)
}
CMsgTEBeamPoints::CMsgTEBeamPoints(const CMsgTEBeamPoints& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_base()) {
    base_ = new ::proto::dota::CMsgTEBaseBeam(*from.base_);
  } else {
    base_ = nullptr;
  }
  if (from.has_start()) {
    start_ = new ::proto::dota::CMsgVector(*from.start_);
  } else {
    start_ = nullptr;
  }
  if (from.has_end()) {
    end_ = new ::proto::dota::CMsgVector(*from.end_);
  } else {
    end_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEBeamPoints)
}

void CMsgTEBeamPoints::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTEBeamPoints_te_2eproto.base);
  ::memset(&base_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&end_) -
      reinterpret_cast<char*>(&base_)) + sizeof(end_));
}

CMsgTEBeamPoints::~CMsgTEBeamPoints() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEBeamPoints)
  SharedDtor();
}

void CMsgTEBeamPoints::SharedDtor() {
  if (this != internal_default_instance()) delete base_;
  if (this != internal_default_instance()) delete start_;
  if (this != internal_default_instance()) delete end_;
}

void CMsgTEBeamPoints::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEBeamPoints& CMsgTEBeamPoints::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEBeamPoints_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEBeamPoints::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEBeamPoints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(base_ != nullptr);
      base_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(start_ != nullptr);
      start_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(end_ != nullptr);
      end_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEBeamPoints::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEBeamPoints*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgTEBaseBeam base = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgTEBaseBeam::_InternalParse;
        object = msg->mutable_base();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgVector start = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_start();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgVector end = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_end();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEBeamPoints::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEBeamPoints)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgTEBaseBeam base = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_base()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgVector start = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_start()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgVector end = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_end()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEBeamPoints)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEBeamPoints)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEBeamPoints::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEBeamPoints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgTEBaseBeam base = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::base(this), output);
  }

  // optional .proto.dota.CMsgVector start = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::start(this), output);
  }

  // optional .proto.dota.CMsgVector end = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::end(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEBeamPoints)
}

::google::protobuf::uint8* CMsgTEBeamPoints::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEBeamPoints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgTEBaseBeam base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::base(this), target);
  }

  // optional .proto.dota.CMsgVector start = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::start(this), target);
  }

  // optional .proto.dota.CMsgVector end = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::end(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEBeamPoints)
  return target;
}

size_t CMsgTEBeamPoints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEBeamPoints)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .proto.dota.CMsgTEBaseBeam base = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *base_);
    }

    // optional .proto.dota.CMsgVector start = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *start_);
    }

    // optional .proto.dota.CMsgVector end = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *end_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEBeamPoints::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEBeamPoints)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEBeamPoints* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEBeamPoints>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEBeamPoints)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEBeamPoints)
    MergeFrom(*source);
  }
}

void CMsgTEBeamPoints::MergeFrom(const CMsgTEBeamPoints& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEBeamPoints)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_base()->::proto::dota::CMsgTEBaseBeam::MergeFrom(from.base());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_start()->::proto::dota::CMsgVector::MergeFrom(from.start());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_end()->::proto::dota::CMsgVector::MergeFrom(from.end());
    }
  }
}

void CMsgTEBeamPoints::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEBeamPoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBeamPoints::CopyFrom(const CMsgTEBeamPoints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEBeamPoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBeamPoints::IsInitialized() const {
  return true;
}

void CMsgTEBeamPoints::Swap(CMsgTEBeamPoints* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEBeamPoints::InternalSwap(CMsgTEBeamPoints* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(base_, other->base_);
  swap(start_, other->start_);
  swap(end_, other->end_);
}

::google::protobuf::Metadata CMsgTEBeamPoints::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTEBeamRing::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTEBeamRing_default_instance_._instance.get_mutable()->base_ = const_cast< ::proto::dota::CMsgTEBaseBeam*>(
      ::proto::dota::CMsgTEBaseBeam::internal_default_instance());
}
class CMsgTEBeamRing::HasBitSetters {
 public:
  static const ::proto::dota::CMsgTEBaseBeam& base(const CMsgTEBeamRing* msg);
  static void set_has_base(CMsgTEBeamRing* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_startentity(CMsgTEBeamRing* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_endentity(CMsgTEBeamRing* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

const ::proto::dota::CMsgTEBaseBeam&
CMsgTEBeamRing::HasBitSetters::base(const CMsgTEBeamRing* msg) {
  return *msg->base_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEBeamRing::kBaseFieldNumber;
const int CMsgTEBeamRing::kStartentityFieldNumber;
const int CMsgTEBeamRing::kEndentityFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEBeamRing::CMsgTEBeamRing()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEBeamRing)
}
CMsgTEBeamRing::CMsgTEBeamRing(const CMsgTEBeamRing& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_base()) {
    base_ = new ::proto::dota::CMsgTEBaseBeam(*from.base_);
  } else {
    base_ = nullptr;
  }
  ::memcpy(&startentity_, &from.startentity_,
    static_cast<size_t>(reinterpret_cast<char*>(&endentity_) -
    reinterpret_cast<char*>(&startentity_)) + sizeof(endentity_));
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEBeamRing)
}

void CMsgTEBeamRing::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTEBeamRing_te_2eproto.base);
  ::memset(&base_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&endentity_) -
      reinterpret_cast<char*>(&base_)) + sizeof(endentity_));
}

CMsgTEBeamRing::~CMsgTEBeamRing() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEBeamRing)
  SharedDtor();
}

void CMsgTEBeamRing::SharedDtor() {
  if (this != internal_default_instance()) delete base_;
}

void CMsgTEBeamRing::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEBeamRing& CMsgTEBeamRing::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEBeamRing_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEBeamRing::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEBeamRing)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(base_ != nullptr);
    base_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&startentity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&endentity_) -
        reinterpret_cast<char*>(&startentity_)) + sizeof(endentity_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEBeamRing::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEBeamRing*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgTEBaseBeam base = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgTEBaseBeam::_InternalParse;
        object = msg->mutable_base();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional uint32 startentity = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_startentity(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 endentity = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_endentity(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEBeamRing::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEBeamRing)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgTEBaseBeam base = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_base()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 startentity = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_startentity(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &startentity_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 endentity = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_endentity(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &endentity_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEBeamRing)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEBeamRing)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEBeamRing::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEBeamRing)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgTEBaseBeam base = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::base(this), output);
  }

  // optional uint32 startentity = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->startentity(), output);
  }

  // optional uint32 endentity = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->endentity(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEBeamRing)
}

::google::protobuf::uint8* CMsgTEBeamRing::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEBeamRing)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgTEBaseBeam base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::base(this), target);
  }

  // optional uint32 startentity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->startentity(), target);
  }

  // optional uint32 endentity = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->endentity(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEBeamRing)
  return target;
}

size_t CMsgTEBeamRing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEBeamRing)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .proto.dota.CMsgTEBaseBeam base = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *base_);
    }

    // optional uint32 startentity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->startentity());
    }

    // optional uint32 endentity = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->endentity());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEBeamRing::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEBeamRing)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEBeamRing* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEBeamRing>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEBeamRing)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEBeamRing)
    MergeFrom(*source);
  }
}

void CMsgTEBeamRing::MergeFrom(const CMsgTEBeamRing& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEBeamRing)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_base()->::proto::dota::CMsgTEBaseBeam::MergeFrom(from.base());
    }
    if (cached_has_bits & 0x00000002u) {
      startentity_ = from.startentity_;
    }
    if (cached_has_bits & 0x00000004u) {
      endentity_ = from.endentity_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEBeamRing::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEBeamRing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBeamRing::CopyFrom(const CMsgTEBeamRing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEBeamRing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBeamRing::IsInitialized() const {
  return true;
}

void CMsgTEBeamRing::Swap(CMsgTEBeamRing* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEBeamRing::InternalSwap(CMsgTEBeamRing* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(base_, other->base_);
  swap(startentity_, other->startentity_);
  swap(endentity_, other->endentity_);
}

::google::protobuf::Metadata CMsgTEBeamRing::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTEBreakModel::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTEBreakModel_default_instance_._instance.get_mutable()->origin_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgTEBreakModel_default_instance_._instance.get_mutable()->angles_ = const_cast< ::proto::dota::CMsgQAngle*>(
      ::proto::dota::CMsgQAngle::internal_default_instance());
  ::proto::dota::_CMsgTEBreakModel_default_instance_._instance.get_mutable()->size_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgTEBreakModel_default_instance_._instance.get_mutable()->velocity_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
}
class CMsgTEBreakModel::HasBitSetters {
 public:
  static const ::proto::dota::CMsgVector& origin(const CMsgTEBreakModel* msg);
  static void set_has_origin(CMsgTEBreakModel* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::proto::dota::CMsgQAngle& angles(const CMsgTEBreakModel* msg);
  static void set_has_angles(CMsgTEBreakModel* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::proto::dota::CMsgVector& size(const CMsgTEBreakModel* msg);
  static void set_has_size(CMsgTEBreakModel* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static const ::proto::dota::CMsgVector& velocity(const CMsgTEBreakModel* msg);
  static void set_has_velocity(CMsgTEBreakModel* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_randomization(CMsgTEBreakModel* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_modelindex(CMsgTEBreakModel* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_count(CMsgTEBreakModel* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_time(CMsgTEBreakModel* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_flags(CMsgTEBreakModel* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
};

const ::proto::dota::CMsgVector&
CMsgTEBreakModel::HasBitSetters::origin(const CMsgTEBreakModel* msg) {
  return *msg->origin_;
}
const ::proto::dota::CMsgQAngle&
CMsgTEBreakModel::HasBitSetters::angles(const CMsgTEBreakModel* msg) {
  return *msg->angles_;
}
const ::proto::dota::CMsgVector&
CMsgTEBreakModel::HasBitSetters::size(const CMsgTEBreakModel* msg) {
  return *msg->size_;
}
const ::proto::dota::CMsgVector&
CMsgTEBreakModel::HasBitSetters::velocity(const CMsgTEBreakModel* msg) {
  return *msg->velocity_;
}
void CMsgTEBreakModel::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBreakModel::clear_angles() {
  if (angles_ != nullptr) angles_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEBreakModel::clear_size() {
  if (size_ != nullptr) size_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEBreakModel::clear_velocity() {
  if (velocity_ != nullptr) velocity_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEBreakModel::kOriginFieldNumber;
const int CMsgTEBreakModel::kAnglesFieldNumber;
const int CMsgTEBreakModel::kSizeFieldNumber;
const int CMsgTEBreakModel::kVelocityFieldNumber;
const int CMsgTEBreakModel::kRandomizationFieldNumber;
const int CMsgTEBreakModel::kModelindexFieldNumber;
const int CMsgTEBreakModel::kCountFieldNumber;
const int CMsgTEBreakModel::kTimeFieldNumber;
const int CMsgTEBreakModel::kFlagsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEBreakModel::CMsgTEBreakModel()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEBreakModel)
}
CMsgTEBreakModel::CMsgTEBreakModel(const CMsgTEBreakModel& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_origin()) {
    origin_ = new ::proto::dota::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from.has_angles()) {
    angles_ = new ::proto::dota::CMsgQAngle(*from.angles_);
  } else {
    angles_ = nullptr;
  }
  if (from.has_size()) {
    size_ = new ::proto::dota::CMsgVector(*from.size_);
  } else {
    size_ = nullptr;
  }
  if (from.has_velocity()) {
    velocity_ = new ::proto::dota::CMsgVector(*from.velocity_);
  } else {
    velocity_ = nullptr;
  }
  ::memcpy(&modelindex_, &from.modelindex_,
    static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&modelindex_)) + sizeof(flags_));
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEBreakModel)
}

void CMsgTEBreakModel::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTEBreakModel_te_2eproto.base);
  ::memset(&origin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&flags_) -
      reinterpret_cast<char*>(&origin_)) + sizeof(flags_));
}

CMsgTEBreakModel::~CMsgTEBreakModel() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEBreakModel)
  SharedDtor();
}

void CMsgTEBreakModel::SharedDtor() {
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete angles_;
  if (this != internal_default_instance()) delete size_;
  if (this != internal_default_instance()) delete velocity_;
}

void CMsgTEBreakModel::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEBreakModel& CMsgTEBreakModel::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEBreakModel_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEBreakModel::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEBreakModel)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(angles_ != nullptr);
      angles_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(size_ != nullptr);
      size_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(velocity_ != nullptr);
      velocity_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&modelindex_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&time_) -
        reinterpret_cast<char*>(&modelindex_)) + sizeof(time_));
  }
  flags_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEBreakModel::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEBreakModel*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_origin();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgQAngle angles = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgQAngle::_InternalParse;
        object = msg->mutable_angles();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgVector size = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_size();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgVector velocity = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_velocity();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional uint32 randomization = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_randomization(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional fixed64 modelindex = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 49) goto handle_unusual;
        msg->set_modelindex(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr));
        ptr += sizeof(::google::protobuf::uint64);
        break;
      }
      // optional uint32 count = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        msg->set_count(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional float time = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 69) goto handle_unusual;
        msg->set_time(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional uint32 flags = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 72) goto handle_unusual;
        msg->set_flags(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEBreakModel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEBreakModel)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgQAngle angles = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_angles()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgVector size = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_size()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgVector velocity = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_velocity()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 randomization = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_randomization(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &randomization_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed64 modelindex = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (49 & 0xFF)) {
          HasBitSetters::set_has_modelindex(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &modelindex_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 count = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_count(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float time = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (69 & 0xFF)) {
          HasBitSetters::set_has_time(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &time_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 flags = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_flags(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEBreakModel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEBreakModel)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEBreakModel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEBreakModel)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::origin(this), output);
  }

  // optional .proto.dota.CMsgQAngle angles = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::angles(this), output);
  }

  // optional .proto.dota.CMsgVector size = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::size(this), output);
  }

  // optional .proto.dota.CMsgVector velocity = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::velocity(this), output);
  }

  // optional uint32 randomization = 5;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->randomization(), output);
  }

  // optional fixed64 modelindex = 6;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(6, this->modelindex(), output);
  }

  // optional uint32 count = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->count(), output);
  }

  // optional float time = 8;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->time(), output);
  }

  // optional uint32 flags = 9;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->flags(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEBreakModel)
}

::google::protobuf::uint8* CMsgTEBreakModel::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEBreakModel)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::origin(this), target);
  }

  // optional .proto.dota.CMsgQAngle angles = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::angles(this), target);
  }

  // optional .proto.dota.CMsgVector size = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::size(this), target);
  }

  // optional .proto.dota.CMsgVector velocity = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::velocity(this), target);
  }

  // optional uint32 randomization = 5;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->randomization(), target);
  }

  // optional fixed64 modelindex = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(6, this->modelindex(), target);
  }

  // optional uint32 count = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->count(), target);
  }

  // optional float time = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->time(), target);
  }

  // optional uint32 flags = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->flags(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEBreakModel)
  return target;
}

size_t CMsgTEBreakModel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEBreakModel)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .proto.dota.CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .proto.dota.CMsgQAngle angles = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *angles_);
    }

    // optional .proto.dota.CMsgVector size = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *size_);
    }

    // optional .proto.dota.CMsgVector velocity = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *velocity_);
    }

    // optional fixed64 modelindex = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional uint32 randomization = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->randomization());
    }

    // optional uint32 count = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

    // optional float time = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  // optional uint32 flags = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->flags());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEBreakModel::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEBreakModel)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEBreakModel* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEBreakModel>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEBreakModel)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEBreakModel)
    MergeFrom(*source);
  }
}

void CMsgTEBreakModel::MergeFrom(const CMsgTEBreakModel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEBreakModel)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_origin()->::proto::dota::CMsgVector::MergeFrom(from.origin());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_angles()->::proto::dota::CMsgQAngle::MergeFrom(from.angles());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_size()->::proto::dota::CMsgVector::MergeFrom(from.size());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_velocity()->::proto::dota::CMsgVector::MergeFrom(from.velocity());
    }
    if (cached_has_bits & 0x00000010u) {
      modelindex_ = from.modelindex_;
    }
    if (cached_has_bits & 0x00000020u) {
      randomization_ = from.randomization_;
    }
    if (cached_has_bits & 0x00000040u) {
      count_ = from.count_;
    }
    if (cached_has_bits & 0x00000080u) {
      time_ = from.time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    set_flags(from.flags());
  }
}

void CMsgTEBreakModel::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEBreakModel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBreakModel::CopyFrom(const CMsgTEBreakModel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEBreakModel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBreakModel::IsInitialized() const {
  return true;
}

void CMsgTEBreakModel::Swap(CMsgTEBreakModel* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEBreakModel::InternalSwap(CMsgTEBreakModel* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(origin_, other->origin_);
  swap(angles_, other->angles_);
  swap(size_, other->size_);
  swap(velocity_, other->velocity_);
  swap(modelindex_, other->modelindex_);
  swap(randomization_, other->randomization_);
  swap(count_, other->count_);
  swap(time_, other->time_);
  swap(flags_, other->flags_);
}

::google::protobuf::Metadata CMsgTEBreakModel::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTEBSPDecal::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTEBSPDecal_default_instance_._instance.get_mutable()->origin_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgTEBSPDecal_default_instance_._instance.get_mutable()->normal_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgTEBSPDecal_default_instance_._instance.get_mutable()->saxis_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
}
class CMsgTEBSPDecal::HasBitSetters {
 public:
  static const ::proto::dota::CMsgVector& origin(const CMsgTEBSPDecal* msg);
  static void set_has_origin(CMsgTEBSPDecal* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::proto::dota::CMsgVector& normal(const CMsgTEBSPDecal* msg);
  static void set_has_normal(CMsgTEBSPDecal* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::proto::dota::CMsgVector& saxis(const CMsgTEBSPDecal* msg);
  static void set_has_saxis(CMsgTEBSPDecal* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_entity(CMsgTEBSPDecal* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_index(CMsgTEBSPDecal* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

const ::proto::dota::CMsgVector&
CMsgTEBSPDecal::HasBitSetters::origin(const CMsgTEBSPDecal* msg) {
  return *msg->origin_;
}
const ::proto::dota::CMsgVector&
CMsgTEBSPDecal::HasBitSetters::normal(const CMsgTEBSPDecal* msg) {
  return *msg->normal_;
}
const ::proto::dota::CMsgVector&
CMsgTEBSPDecal::HasBitSetters::saxis(const CMsgTEBSPDecal* msg) {
  return *msg->saxis_;
}
void CMsgTEBSPDecal::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBSPDecal::clear_normal() {
  if (normal_ != nullptr) normal_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEBSPDecal::clear_saxis() {
  if (saxis_ != nullptr) saxis_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEBSPDecal::kOriginFieldNumber;
const int CMsgTEBSPDecal::kNormalFieldNumber;
const int CMsgTEBSPDecal::kSaxisFieldNumber;
const int CMsgTEBSPDecal::kEntityFieldNumber;
const int CMsgTEBSPDecal::kIndexFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEBSPDecal::CMsgTEBSPDecal()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEBSPDecal)
}
CMsgTEBSPDecal::CMsgTEBSPDecal(const CMsgTEBSPDecal& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_origin()) {
    origin_ = new ::proto::dota::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from.has_normal()) {
    normal_ = new ::proto::dota::CMsgVector(*from.normal_);
  } else {
    normal_ = nullptr;
  }
  if (from.has_saxis()) {
    saxis_ = new ::proto::dota::CMsgVector(*from.saxis_);
  } else {
    saxis_ = nullptr;
  }
  ::memcpy(&entity_, &from.entity_,
    static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&entity_)) + sizeof(index_));
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEBSPDecal)
}

void CMsgTEBSPDecal::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTEBSPDecal_te_2eproto.base);
  ::memset(&origin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&index_) -
      reinterpret_cast<char*>(&origin_)) + sizeof(index_));
}

CMsgTEBSPDecal::~CMsgTEBSPDecal() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEBSPDecal)
  SharedDtor();
}

void CMsgTEBSPDecal::SharedDtor() {
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete normal_;
  if (this != internal_default_instance()) delete saxis_;
}

void CMsgTEBSPDecal::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEBSPDecal& CMsgTEBSPDecal::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEBSPDecal_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEBSPDecal::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEBSPDecal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(normal_ != nullptr);
      normal_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(saxis_ != nullptr);
      saxis_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&entity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&index_) -
        reinterpret_cast<char*>(&entity_)) + sizeof(index_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEBSPDecal::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEBSPDecal*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_origin();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgVector normal = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_normal();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgVector saxis = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_saxis();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional uint32 entity = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_entity(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 index = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_index(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEBSPDecal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEBSPDecal)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgVector normal = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_normal()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgVector saxis = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_saxis()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 entity = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_entity(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &entity_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 index = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_index(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEBSPDecal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEBSPDecal)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEBSPDecal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEBSPDecal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::origin(this), output);
  }

  // optional .proto.dota.CMsgVector normal = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::normal(this), output);
  }

  // optional .proto.dota.CMsgVector saxis = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::saxis(this), output);
  }

  // optional uint32 entity = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->entity(), output);
  }

  // optional uint32 index = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->index(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEBSPDecal)
}

::google::protobuf::uint8* CMsgTEBSPDecal::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEBSPDecal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::origin(this), target);
  }

  // optional .proto.dota.CMsgVector normal = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::normal(this), target);
  }

  // optional .proto.dota.CMsgVector saxis = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::saxis(this), target);
  }

  // optional uint32 entity = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->entity(), target);
  }

  // optional uint32 index = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->index(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEBSPDecal)
  return target;
}

size_t CMsgTEBSPDecal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEBSPDecal)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .proto.dota.CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .proto.dota.CMsgVector normal = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *normal_);
    }

    // optional .proto.dota.CMsgVector saxis = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *saxis_);
    }

    // optional uint32 entity = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->entity());
    }

    // optional uint32 index = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEBSPDecal::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEBSPDecal)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEBSPDecal* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEBSPDecal>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEBSPDecal)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEBSPDecal)
    MergeFrom(*source);
  }
}

void CMsgTEBSPDecal::MergeFrom(const CMsgTEBSPDecal& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEBSPDecal)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_origin()->::proto::dota::CMsgVector::MergeFrom(from.origin());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_normal()->::proto::dota::CMsgVector::MergeFrom(from.normal());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_saxis()->::proto::dota::CMsgVector::MergeFrom(from.saxis());
    }
    if (cached_has_bits & 0x00000008u) {
      entity_ = from.entity_;
    }
    if (cached_has_bits & 0x00000010u) {
      index_ = from.index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEBSPDecal::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEBSPDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBSPDecal::CopyFrom(const CMsgTEBSPDecal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEBSPDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBSPDecal::IsInitialized() const {
  return true;
}

void CMsgTEBSPDecal::Swap(CMsgTEBSPDecal* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEBSPDecal::InternalSwap(CMsgTEBSPDecal* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(origin_, other->origin_);
  swap(normal_, other->normal_);
  swap(saxis_, other->saxis_);
  swap(entity_, other->entity_);
  swap(index_, other->index_);
}

::google::protobuf::Metadata CMsgTEBSPDecal::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTEBubbles::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTEBubbles_default_instance_._instance.get_mutable()->mins_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgTEBubbles_default_instance_._instance.get_mutable()->maxs_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
}
class CMsgTEBubbles::HasBitSetters {
 public:
  static const ::proto::dota::CMsgVector& mins(const CMsgTEBubbles* msg);
  static void set_has_mins(CMsgTEBubbles* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::proto::dota::CMsgVector& maxs(const CMsgTEBubbles* msg);
  static void set_has_maxs(CMsgTEBubbles* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_height(CMsgTEBubbles* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_count(CMsgTEBubbles* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_speed(CMsgTEBubbles* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

const ::proto::dota::CMsgVector&
CMsgTEBubbles::HasBitSetters::mins(const CMsgTEBubbles* msg) {
  return *msg->mins_;
}
const ::proto::dota::CMsgVector&
CMsgTEBubbles::HasBitSetters::maxs(const CMsgTEBubbles* msg) {
  return *msg->maxs_;
}
void CMsgTEBubbles::clear_mins() {
  if (mins_ != nullptr) mins_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBubbles::clear_maxs() {
  if (maxs_ != nullptr) maxs_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEBubbles::kMinsFieldNumber;
const int CMsgTEBubbles::kMaxsFieldNumber;
const int CMsgTEBubbles::kHeightFieldNumber;
const int CMsgTEBubbles::kCountFieldNumber;
const int CMsgTEBubbles::kSpeedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEBubbles::CMsgTEBubbles()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEBubbles)
}
CMsgTEBubbles::CMsgTEBubbles(const CMsgTEBubbles& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_mins()) {
    mins_ = new ::proto::dota::CMsgVector(*from.mins_);
  } else {
    mins_ = nullptr;
  }
  if (from.has_maxs()) {
    maxs_ = new ::proto::dota::CMsgVector(*from.maxs_);
  } else {
    maxs_ = nullptr;
  }
  ::memcpy(&height_, &from.height_,
    static_cast<size_t>(reinterpret_cast<char*>(&speed_) -
    reinterpret_cast<char*>(&height_)) + sizeof(speed_));
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEBubbles)
}

void CMsgTEBubbles::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTEBubbles_te_2eproto.base);
  ::memset(&mins_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&speed_) -
      reinterpret_cast<char*>(&mins_)) + sizeof(speed_));
}

CMsgTEBubbles::~CMsgTEBubbles() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEBubbles)
  SharedDtor();
}

void CMsgTEBubbles::SharedDtor() {
  if (this != internal_default_instance()) delete mins_;
  if (this != internal_default_instance()) delete maxs_;
}

void CMsgTEBubbles::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEBubbles& CMsgTEBubbles::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEBubbles_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEBubbles::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEBubbles)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(mins_ != nullptr);
      mins_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(maxs_ != nullptr);
      maxs_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&height_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&speed_) -
        reinterpret_cast<char*>(&height_)) + sizeof(speed_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEBubbles::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEBubbles*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgVector mins = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_mins();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgVector maxs = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_maxs();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional float height = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        msg->set_height(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional uint32 count = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_count(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional float speed = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 45) goto handle_unusual;
        msg->set_speed(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEBubbles::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEBubbles)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgVector mins = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_mins()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgVector maxs = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_maxs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float height = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_height(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &height_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 count = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_count(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float speed = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (45 & 0xFF)) {
          HasBitSetters::set_has_speed(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &speed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEBubbles)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEBubbles)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEBubbles::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEBubbles)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector mins = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::mins(this), output);
  }

  // optional .proto.dota.CMsgVector maxs = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::maxs(this), output);
  }

  // optional float height = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->height(), output);
  }

  // optional uint32 count = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->count(), output);
  }

  // optional float speed = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->speed(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEBubbles)
}

::google::protobuf::uint8* CMsgTEBubbles::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEBubbles)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector mins = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::mins(this), target);
  }

  // optional .proto.dota.CMsgVector maxs = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::maxs(this), target);
  }

  // optional float height = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->height(), target);
  }

  // optional uint32 count = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->count(), target);
  }

  // optional float speed = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->speed(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEBubbles)
  return target;
}

size_t CMsgTEBubbles::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEBubbles)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .proto.dota.CMsgVector mins = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *mins_);
    }

    // optional .proto.dota.CMsgVector maxs = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *maxs_);
    }

    // optional float height = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

    // optional float speed = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEBubbles::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEBubbles)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEBubbles* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEBubbles>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEBubbles)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEBubbles)
    MergeFrom(*source);
  }
}

void CMsgTEBubbles::MergeFrom(const CMsgTEBubbles& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEBubbles)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_mins()->::proto::dota::CMsgVector::MergeFrom(from.mins());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_maxs()->::proto::dota::CMsgVector::MergeFrom(from.maxs());
    }
    if (cached_has_bits & 0x00000004u) {
      height_ = from.height_;
    }
    if (cached_has_bits & 0x00000008u) {
      count_ = from.count_;
    }
    if (cached_has_bits & 0x00000010u) {
      speed_ = from.speed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEBubbles::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEBubbles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBubbles::CopyFrom(const CMsgTEBubbles& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEBubbles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBubbles::IsInitialized() const {
  return true;
}

void CMsgTEBubbles::Swap(CMsgTEBubbles* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEBubbles::InternalSwap(CMsgTEBubbles* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(mins_, other->mins_);
  swap(maxs_, other->maxs_);
  swap(height_, other->height_);
  swap(count_, other->count_);
  swap(speed_, other->speed_);
}

::google::protobuf::Metadata CMsgTEBubbles::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTEBubbleTrail::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTEBubbleTrail_default_instance_._instance.get_mutable()->mins_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgTEBubbleTrail_default_instance_._instance.get_mutable()->maxs_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
}
class CMsgTEBubbleTrail::HasBitSetters {
 public:
  static const ::proto::dota::CMsgVector& mins(const CMsgTEBubbleTrail* msg);
  static void set_has_mins(CMsgTEBubbleTrail* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::proto::dota::CMsgVector& maxs(const CMsgTEBubbleTrail* msg);
  static void set_has_maxs(CMsgTEBubbleTrail* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_waterz(CMsgTEBubbleTrail* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_count(CMsgTEBubbleTrail* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_speed(CMsgTEBubbleTrail* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

const ::proto::dota::CMsgVector&
CMsgTEBubbleTrail::HasBitSetters::mins(const CMsgTEBubbleTrail* msg) {
  return *msg->mins_;
}
const ::proto::dota::CMsgVector&
CMsgTEBubbleTrail::HasBitSetters::maxs(const CMsgTEBubbleTrail* msg) {
  return *msg->maxs_;
}
void CMsgTEBubbleTrail::clear_mins() {
  if (mins_ != nullptr) mins_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBubbleTrail::clear_maxs() {
  if (maxs_ != nullptr) maxs_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEBubbleTrail::kMinsFieldNumber;
const int CMsgTEBubbleTrail::kMaxsFieldNumber;
const int CMsgTEBubbleTrail::kWaterzFieldNumber;
const int CMsgTEBubbleTrail::kCountFieldNumber;
const int CMsgTEBubbleTrail::kSpeedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEBubbleTrail::CMsgTEBubbleTrail()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEBubbleTrail)
}
CMsgTEBubbleTrail::CMsgTEBubbleTrail(const CMsgTEBubbleTrail& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_mins()) {
    mins_ = new ::proto::dota::CMsgVector(*from.mins_);
  } else {
    mins_ = nullptr;
  }
  if (from.has_maxs()) {
    maxs_ = new ::proto::dota::CMsgVector(*from.maxs_);
  } else {
    maxs_ = nullptr;
  }
  ::memcpy(&waterz_, &from.waterz_,
    static_cast<size_t>(reinterpret_cast<char*>(&speed_) -
    reinterpret_cast<char*>(&waterz_)) + sizeof(speed_));
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEBubbleTrail)
}

void CMsgTEBubbleTrail::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTEBubbleTrail_te_2eproto.base);
  ::memset(&mins_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&speed_) -
      reinterpret_cast<char*>(&mins_)) + sizeof(speed_));
}

CMsgTEBubbleTrail::~CMsgTEBubbleTrail() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEBubbleTrail)
  SharedDtor();
}

void CMsgTEBubbleTrail::SharedDtor() {
  if (this != internal_default_instance()) delete mins_;
  if (this != internal_default_instance()) delete maxs_;
}

void CMsgTEBubbleTrail::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEBubbleTrail& CMsgTEBubbleTrail::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEBubbleTrail_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEBubbleTrail::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEBubbleTrail)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(mins_ != nullptr);
      mins_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(maxs_ != nullptr);
      maxs_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&waterz_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&speed_) -
        reinterpret_cast<char*>(&waterz_)) + sizeof(speed_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEBubbleTrail::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEBubbleTrail*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgVector mins = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_mins();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgVector maxs = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_maxs();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional float waterz = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        msg->set_waterz(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional uint32 count = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_count(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional float speed = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 45) goto handle_unusual;
        msg->set_speed(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEBubbleTrail::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEBubbleTrail)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgVector mins = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_mins()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgVector maxs = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_maxs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float waterz = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_waterz(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &waterz_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 count = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_count(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float speed = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (45 & 0xFF)) {
          HasBitSetters::set_has_speed(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &speed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEBubbleTrail)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEBubbleTrail)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEBubbleTrail::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEBubbleTrail)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector mins = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::mins(this), output);
  }

  // optional .proto.dota.CMsgVector maxs = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::maxs(this), output);
  }

  // optional float waterz = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->waterz(), output);
  }

  // optional uint32 count = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->count(), output);
  }

  // optional float speed = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->speed(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEBubbleTrail)
}

::google::protobuf::uint8* CMsgTEBubbleTrail::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEBubbleTrail)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector mins = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::mins(this), target);
  }

  // optional .proto.dota.CMsgVector maxs = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::maxs(this), target);
  }

  // optional float waterz = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->waterz(), target);
  }

  // optional uint32 count = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->count(), target);
  }

  // optional float speed = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->speed(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEBubbleTrail)
  return target;
}

size_t CMsgTEBubbleTrail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEBubbleTrail)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .proto.dota.CMsgVector mins = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *mins_);
    }

    // optional .proto.dota.CMsgVector maxs = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *maxs_);
    }

    // optional float waterz = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

    // optional float speed = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEBubbleTrail::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEBubbleTrail)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEBubbleTrail* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEBubbleTrail>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEBubbleTrail)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEBubbleTrail)
    MergeFrom(*source);
  }
}

void CMsgTEBubbleTrail::MergeFrom(const CMsgTEBubbleTrail& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEBubbleTrail)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_mins()->::proto::dota::CMsgVector::MergeFrom(from.mins());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_maxs()->::proto::dota::CMsgVector::MergeFrom(from.maxs());
    }
    if (cached_has_bits & 0x00000004u) {
      waterz_ = from.waterz_;
    }
    if (cached_has_bits & 0x00000008u) {
      count_ = from.count_;
    }
    if (cached_has_bits & 0x00000010u) {
      speed_ = from.speed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEBubbleTrail::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEBubbleTrail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBubbleTrail::CopyFrom(const CMsgTEBubbleTrail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEBubbleTrail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBubbleTrail::IsInitialized() const {
  return true;
}

void CMsgTEBubbleTrail::Swap(CMsgTEBubbleTrail* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEBubbleTrail::InternalSwap(CMsgTEBubbleTrail* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(mins_, other->mins_);
  swap(maxs_, other->maxs_);
  swap(waterz_, other->waterz_);
  swap(count_, other->count_);
  swap(speed_, other->speed_);
}

::google::protobuf::Metadata CMsgTEBubbleTrail::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTEDecal::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTEDecal_default_instance_._instance.get_mutable()->origin_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgTEDecal_default_instance_._instance.get_mutable()->start_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
}
class CMsgTEDecal::HasBitSetters {
 public:
  static const ::proto::dota::CMsgVector& origin(const CMsgTEDecal* msg);
  static void set_has_origin(CMsgTEDecal* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::proto::dota::CMsgVector& start(const CMsgTEDecal* msg);
  static void set_has_start(CMsgTEDecal* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_entity(CMsgTEDecal* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_hitbox(CMsgTEDecal* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_index(CMsgTEDecal* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
};

const ::proto::dota::CMsgVector&
CMsgTEDecal::HasBitSetters::origin(const CMsgTEDecal* msg) {
  return *msg->origin_;
}
const ::proto::dota::CMsgVector&
CMsgTEDecal::HasBitSetters::start(const CMsgTEDecal* msg) {
  return *msg->start_;
}
void CMsgTEDecal::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEDecal::clear_start() {
  if (start_ != nullptr) start_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEDecal::kOriginFieldNumber;
const int CMsgTEDecal::kStartFieldNumber;
const int CMsgTEDecal::kEntityFieldNumber;
const int CMsgTEDecal::kHitboxFieldNumber;
const int CMsgTEDecal::kIndexFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEDecal::CMsgTEDecal()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEDecal)
}
CMsgTEDecal::CMsgTEDecal(const CMsgTEDecal& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_origin()) {
    origin_ = new ::proto::dota::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from.has_start()) {
    start_ = new ::proto::dota::CMsgVector(*from.start_);
  } else {
    start_ = nullptr;
  }
  ::memcpy(&entity_, &from.entity_,
    static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&entity_)) + sizeof(index_));
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEDecal)
}

void CMsgTEDecal::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTEDecal_te_2eproto.base);
  ::memset(&origin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&index_) -
      reinterpret_cast<char*>(&origin_)) + sizeof(index_));
}

CMsgTEDecal::~CMsgTEDecal() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEDecal)
  SharedDtor();
}

void CMsgTEDecal::SharedDtor() {
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete start_;
}

void CMsgTEDecal::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEDecal& CMsgTEDecal::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEDecal_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEDecal::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEDecal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(start_ != nullptr);
      start_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&entity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&index_) -
        reinterpret_cast<char*>(&entity_)) + sizeof(index_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEDecal::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEDecal*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_origin();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgVector start = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_start();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional uint32 entity = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_entity(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 hitbox = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_hitbox(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 index = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_index(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEDecal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEDecal)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgVector start = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_start()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 entity = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_entity(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &entity_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 hitbox = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_hitbox(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hitbox_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 index = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_index(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEDecal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEDecal)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEDecal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEDecal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::origin(this), output);
  }

  // optional .proto.dota.CMsgVector start = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::start(this), output);
  }

  // optional uint32 entity = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->entity(), output);
  }

  // optional uint32 hitbox = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->hitbox(), output);
  }

  // optional uint32 index = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->index(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEDecal)
}

::google::protobuf::uint8* CMsgTEDecal::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEDecal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::origin(this), target);
  }

  // optional .proto.dota.CMsgVector start = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::start(this), target);
  }

  // optional uint32 entity = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->entity(), target);
  }

  // optional uint32 hitbox = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->hitbox(), target);
  }

  // optional uint32 index = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->index(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEDecal)
  return target;
}

size_t CMsgTEDecal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEDecal)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .proto.dota.CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .proto.dota.CMsgVector start = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *start_);
    }

    // optional uint32 entity = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->entity());
    }

    // optional uint32 hitbox = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->hitbox());
    }

    // optional uint32 index = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEDecal::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEDecal)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEDecal* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEDecal>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEDecal)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEDecal)
    MergeFrom(*source);
  }
}

void CMsgTEDecal::MergeFrom(const CMsgTEDecal& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEDecal)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_origin()->::proto::dota::CMsgVector::MergeFrom(from.origin());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_start()->::proto::dota::CMsgVector::MergeFrom(from.start());
    }
    if (cached_has_bits & 0x00000004u) {
      entity_ = from.entity_;
    }
    if (cached_has_bits & 0x00000008u) {
      hitbox_ = from.hitbox_;
    }
    if (cached_has_bits & 0x00000010u) {
      index_ = from.index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEDecal::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEDecal::CopyFrom(const CMsgTEDecal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEDecal::IsInitialized() const {
  return true;
}

void CMsgTEDecal::Swap(CMsgTEDecal* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEDecal::InternalSwap(CMsgTEDecal* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(origin_, other->origin_);
  swap(start_, other->start_);
  swap(entity_, other->entity_);
  swap(hitbox_, other->hitbox_);
  swap(index_, other->index_);
}

::google::protobuf::Metadata CMsgTEDecal::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgEffectData::InitAsDefaultInstance() {
  ::proto::dota::_CMsgEffectData_default_instance_._instance.get_mutable()->origin_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgEffectData_default_instance_._instance.get_mutable()->start_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgEffectData_default_instance_._instance.get_mutable()->normal_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgEffectData_default_instance_._instance.get_mutable()->angles_ = const_cast< ::proto::dota::CMsgQAngle*>(
      ::proto::dota::CMsgQAngle::internal_default_instance());
}
class CMsgEffectData::HasBitSetters {
 public:
  static const ::proto::dota::CMsgVector& origin(const CMsgEffectData* msg);
  static void set_has_origin(CMsgEffectData* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::proto::dota::CMsgVector& start(const CMsgEffectData* msg);
  static void set_has_start(CMsgEffectData* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::proto::dota::CMsgVector& normal(const CMsgEffectData* msg);
  static void set_has_normal(CMsgEffectData* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static const ::proto::dota::CMsgQAngle& angles(const CMsgEffectData* msg);
  static void set_has_angles(CMsgEffectData* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_entity(CMsgEffectData* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_otherentity(CMsgEffectData* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_scale(CMsgEffectData* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_magnitude(CMsgEffectData* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_radius(CMsgEffectData* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static void set_has_surfaceprop(CMsgEffectData* msg) {
    msg->_has_bits_[0] |= 0x00000200u;
  }
  static void set_has_effectindex(CMsgEffectData* msg) {
    msg->_has_bits_[0] |= 0x00000400u;
  }
  static void set_has_damagetype(CMsgEffectData* msg) {
    msg->_has_bits_[0] |= 0x00000800u;
  }
  static void set_has_material(CMsgEffectData* msg) {
    msg->_has_bits_[0] |= 0x00001000u;
  }
  static void set_has_hitbox(CMsgEffectData* msg) {
    msg->_has_bits_[0] |= 0x00002000u;
  }
  static void set_has_color(CMsgEffectData* msg) {
    msg->_has_bits_[0] |= 0x00004000u;
  }
  static void set_has_flags(CMsgEffectData* msg) {
    msg->_has_bits_[0] |= 0x00008000u;
  }
  static void set_has_attachmentindex(CMsgEffectData* msg) {
    msg->_has_bits_[0] |= 0x00010000u;
  }
  static void set_has_effectname(CMsgEffectData* msg) {
    msg->_has_bits_[0] |= 0x00020000u;
  }
  static void set_has_attachmentname(CMsgEffectData* msg) {
    msg->_has_bits_[0] |= 0x00040000u;
  }
};

const ::proto::dota::CMsgVector&
CMsgEffectData::HasBitSetters::origin(const CMsgEffectData* msg) {
  return *msg->origin_;
}
const ::proto::dota::CMsgVector&
CMsgEffectData::HasBitSetters::start(const CMsgEffectData* msg) {
  return *msg->start_;
}
const ::proto::dota::CMsgVector&
CMsgEffectData::HasBitSetters::normal(const CMsgEffectData* msg) {
  return *msg->normal_;
}
const ::proto::dota::CMsgQAngle&
CMsgEffectData::HasBitSetters::angles(const CMsgEffectData* msg) {
  return *msg->angles_;
}
void CMsgEffectData::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgEffectData::clear_start() {
  if (start_ != nullptr) start_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgEffectData::clear_normal() {
  if (normal_ != nullptr) normal_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgEffectData::clear_angles() {
  if (angles_ != nullptr) angles_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgEffectData::kOriginFieldNumber;
const int CMsgEffectData::kStartFieldNumber;
const int CMsgEffectData::kNormalFieldNumber;
const int CMsgEffectData::kAnglesFieldNumber;
const int CMsgEffectData::kEntityFieldNumber;
const int CMsgEffectData::kOtherentityFieldNumber;
const int CMsgEffectData::kScaleFieldNumber;
const int CMsgEffectData::kMagnitudeFieldNumber;
const int CMsgEffectData::kRadiusFieldNumber;
const int CMsgEffectData::kSurfacepropFieldNumber;
const int CMsgEffectData::kEffectindexFieldNumber;
const int CMsgEffectData::kDamagetypeFieldNumber;
const int CMsgEffectData::kMaterialFieldNumber;
const int CMsgEffectData::kHitboxFieldNumber;
const int CMsgEffectData::kColorFieldNumber;
const int CMsgEffectData::kFlagsFieldNumber;
const int CMsgEffectData::kAttachmentindexFieldNumber;
const int CMsgEffectData::kEffectnameFieldNumber;
const int CMsgEffectData::kAttachmentnameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgEffectData::CMsgEffectData()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgEffectData)
}
CMsgEffectData::CMsgEffectData(const CMsgEffectData& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_origin()) {
    origin_ = new ::proto::dota::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from.has_start()) {
    start_ = new ::proto::dota::CMsgVector(*from.start_);
  } else {
    start_ = nullptr;
  }
  if (from.has_normal()) {
    normal_ = new ::proto::dota::CMsgVector(*from.normal_);
  } else {
    normal_ = nullptr;
  }
  if (from.has_angles()) {
    angles_ = new ::proto::dota::CMsgQAngle(*from.angles_);
  } else {
    angles_ = nullptr;
  }
  ::memcpy(&entity_, &from.entity_,
    static_cast<size_t>(reinterpret_cast<char*>(&attachmentname_) -
    reinterpret_cast<char*>(&entity_)) + sizeof(attachmentname_));
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgEffectData)
}

void CMsgEffectData::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgEffectData_te_2eproto.base);
  ::memset(&origin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&attachmentname_) -
      reinterpret_cast<char*>(&origin_)) + sizeof(attachmentname_));
}

CMsgEffectData::~CMsgEffectData() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgEffectData)
  SharedDtor();
}

void CMsgEffectData::SharedDtor() {
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete start_;
  if (this != internal_default_instance()) delete normal_;
  if (this != internal_default_instance()) delete angles_;
}

void CMsgEffectData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgEffectData& CMsgEffectData::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgEffectData_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgEffectData::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgEffectData)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(start_ != nullptr);
      start_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(normal_ != nullptr);
      normal_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(angles_ != nullptr);
      angles_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&entity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&magnitude_) -
        reinterpret_cast<char*>(&entity_)) + sizeof(magnitude_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&radius_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flags_) -
        reinterpret_cast<char*>(&radius_)) + sizeof(flags_));
  }
  if (cached_has_bits & 0x00070000u) {
    ::memset(&attachmentindex_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&attachmentname_) -
        reinterpret_cast<char*>(&attachmentindex_)) + sizeof(attachmentname_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgEffectData::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgEffectData*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_origin();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgVector start = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_start();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgVector normal = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_normal();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgQAngle angles = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgQAngle::_InternalParse;
        object = msg->mutable_angles();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional fixed32 entity = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 45) goto handle_unusual;
        msg->set_entity(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint32>(ptr));
        ptr += sizeof(::google::protobuf::uint32);
        break;
      }
      // optional fixed32 otherentity = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 53) goto handle_unusual;
        msg->set_otherentity(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint32>(ptr));
        ptr += sizeof(::google::protobuf::uint32);
        break;
      }
      // optional float scale = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 61) goto handle_unusual;
        msg->set_scale(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float magnitude = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 69) goto handle_unusual;
        msg->set_magnitude(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float radius = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 77) goto handle_unusual;
        msg->set_radius(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional fixed32 surfaceprop = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 85) goto handle_unusual;
        msg->set_surfaceprop(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint32>(ptr));
        ptr += sizeof(::google::protobuf::uint32);
        break;
      }
      // optional fixed64 effectindex = 11;
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 89) goto handle_unusual;
        msg->set_effectindex(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr));
        ptr += sizeof(::google::protobuf::uint64);
        break;
      }
      // optional uint32 damagetype = 12;
      case 12: {
        if (static_cast<::google::protobuf::uint8>(tag) != 96) goto handle_unusual;
        msg->set_damagetype(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 material = 13;
      case 13: {
        if (static_cast<::google::protobuf::uint8>(tag) != 104) goto handle_unusual;
        msg->set_material(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 hitbox = 14;
      case 14: {
        if (static_cast<::google::protobuf::uint8>(tag) != 112) goto handle_unusual;
        msg->set_hitbox(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 color = 15;
      case 15: {
        if (static_cast<::google::protobuf::uint8>(tag) != 120) goto handle_unusual;
        msg->set_color(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 flags = 16;
      case 16: {
        if (static_cast<::google::protobuf::uint8>(tag) != 128) goto handle_unusual;
        msg->set_flags(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 attachmentindex = 17;
      case 17: {
        if (static_cast<::google::protobuf::uint8>(tag) != 136) goto handle_unusual;
        msg->set_attachmentindex(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 effectname = 18;
      case 18: {
        if (static_cast<::google::protobuf::uint8>(tag) != 144) goto handle_unusual;
        msg->set_effectname(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 attachmentname = 19;
      case 19: {
        if (static_cast<::google::protobuf::uint8>(tag) != 152) goto handle_unusual;
        msg->set_attachmentname(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgEffectData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgEffectData)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgVector start = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_start()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgVector normal = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_normal()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgQAngle angles = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_angles()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed32 entity = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (45 & 0xFF)) {
          HasBitSetters::set_has_entity(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &entity_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed32 otherentity = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (53 & 0xFF)) {
          HasBitSetters::set_has_otherentity(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &otherentity_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float scale = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (61 & 0xFF)) {
          HasBitSetters::set_has_scale(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &scale_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float magnitude = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (69 & 0xFF)) {
          HasBitSetters::set_has_magnitude(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &magnitude_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float radius = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (77 & 0xFF)) {
          HasBitSetters::set_has_radius(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &radius_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed32 surfaceprop = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (85 & 0xFF)) {
          HasBitSetters::set_has_surfaceprop(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &surfaceprop_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed64 effectindex = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (89 & 0xFF)) {
          HasBitSetters::set_has_effectindex(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &effectindex_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 damagetype = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (96 & 0xFF)) {
          HasBitSetters::set_has_damagetype(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &damagetype_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 material = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (104 & 0xFF)) {
          HasBitSetters::set_has_material(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &material_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 hitbox = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (112 & 0xFF)) {
          HasBitSetters::set_has_hitbox(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hitbox_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 color = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (120 & 0xFF)) {
          HasBitSetters::set_has_color(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &color_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 flags = 16;
      case 16: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (128 & 0xFF)) {
          HasBitSetters::set_has_flags(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 attachmentindex = 17;
      case 17: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (136 & 0xFF)) {
          HasBitSetters::set_has_attachmentindex(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &attachmentindex_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 effectname = 18;
      case 18: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (144 & 0xFF)) {
          HasBitSetters::set_has_effectname(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &effectname_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 attachmentname = 19;
      case 19: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (152 & 0xFF)) {
          HasBitSetters::set_has_attachmentname(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &attachmentname_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgEffectData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgEffectData)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgEffectData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgEffectData)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::origin(this), output);
  }

  // optional .proto.dota.CMsgVector start = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::start(this), output);
  }

  // optional .proto.dota.CMsgVector normal = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::normal(this), output);
  }

  // optional .proto.dota.CMsgQAngle angles = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::angles(this), output);
  }

  // optional fixed32 entity = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(5, this->entity(), output);
  }

  // optional fixed32 otherentity = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(6, this->otherentity(), output);
  }

  // optional float scale = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->scale(), output);
  }

  // optional float magnitude = 8;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->magnitude(), output);
  }

  // optional float radius = 9;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->radius(), output);
  }

  // optional fixed32 surfaceprop = 10;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(10, this->surfaceprop(), output);
  }

  // optional fixed64 effectindex = 11;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(11, this->effectindex(), output);
  }

  // optional uint32 damagetype = 12;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->damagetype(), output);
  }

  // optional uint32 material = 13;
  if (cached_has_bits & 0x00001000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(13, this->material(), output);
  }

  // optional uint32 hitbox = 14;
  if (cached_has_bits & 0x00002000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(14, this->hitbox(), output);
  }

  // optional uint32 color = 15;
  if (cached_has_bits & 0x00004000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(15, this->color(), output);
  }

  // optional uint32 flags = 16;
  if (cached_has_bits & 0x00008000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(16, this->flags(), output);
  }

  // optional int32 attachmentindex = 17;
  if (cached_has_bits & 0x00010000u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(17, this->attachmentindex(), output);
  }

  // optional uint32 effectname = 18;
  if (cached_has_bits & 0x00020000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(18, this->effectname(), output);
  }

  // optional uint32 attachmentname = 19;
  if (cached_has_bits & 0x00040000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(19, this->attachmentname(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgEffectData)
}

::google::protobuf::uint8* CMsgEffectData::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgEffectData)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::origin(this), target);
  }

  // optional .proto.dota.CMsgVector start = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::start(this), target);
  }

  // optional .proto.dota.CMsgVector normal = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::normal(this), target);
  }

  // optional .proto.dota.CMsgQAngle angles = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::angles(this), target);
  }

  // optional fixed32 entity = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(5, this->entity(), target);
  }

  // optional fixed32 otherentity = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(6, this->otherentity(), target);
  }

  // optional float scale = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->scale(), target);
  }

  // optional float magnitude = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->magnitude(), target);
  }

  // optional float radius = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->radius(), target);
  }

  // optional fixed32 surfaceprop = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(10, this->surfaceprop(), target);
  }

  // optional fixed64 effectindex = 11;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(11, this->effectindex(), target);
  }

  // optional uint32 damagetype = 12;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->damagetype(), target);
  }

  // optional uint32 material = 13;
  if (cached_has_bits & 0x00001000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(13, this->material(), target);
  }

  // optional uint32 hitbox = 14;
  if (cached_has_bits & 0x00002000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(14, this->hitbox(), target);
  }

  // optional uint32 color = 15;
  if (cached_has_bits & 0x00004000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(15, this->color(), target);
  }

  // optional uint32 flags = 16;
  if (cached_has_bits & 0x00008000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(16, this->flags(), target);
  }

  // optional int32 attachmentindex = 17;
  if (cached_has_bits & 0x00010000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(17, this->attachmentindex(), target);
  }

  // optional uint32 effectname = 18;
  if (cached_has_bits & 0x00020000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(18, this->effectname(), target);
  }

  // optional uint32 attachmentname = 19;
  if (cached_has_bits & 0x00040000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(19, this->attachmentname(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgEffectData)
  return target;
}

size_t CMsgEffectData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgEffectData)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .proto.dota.CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .proto.dota.CMsgVector start = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *start_);
    }

    // optional .proto.dota.CMsgVector normal = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *normal_);
    }

    // optional .proto.dota.CMsgQAngle angles = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *angles_);
    }

    // optional fixed32 entity = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional fixed32 otherentity = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float scale = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float magnitude = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional float radius = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional fixed32 surfaceprop = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional fixed64 effectindex = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 8;
    }

    // optional uint32 damagetype = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->damagetype());
    }

    // optional uint32 material = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->material());
    }

    // optional uint32 hitbox = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->hitbox());
    }

    // optional uint32 color = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->color());
    }

    // optional uint32 flags = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

  }
  if (cached_has_bits & 0x00070000u) {
    // optional int32 attachmentindex = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->attachmentindex());
    }

    // optional uint32 effectname = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->effectname());
    }

    // optional uint32 attachmentname = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->attachmentname());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgEffectData::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgEffectData)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgEffectData* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgEffectData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgEffectData)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgEffectData)
    MergeFrom(*source);
  }
}

void CMsgEffectData::MergeFrom(const CMsgEffectData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgEffectData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_origin()->::proto::dota::CMsgVector::MergeFrom(from.origin());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_start()->::proto::dota::CMsgVector::MergeFrom(from.start());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_normal()->::proto::dota::CMsgVector::MergeFrom(from.normal());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_angles()->::proto::dota::CMsgQAngle::MergeFrom(from.angles());
    }
    if (cached_has_bits & 0x00000010u) {
      entity_ = from.entity_;
    }
    if (cached_has_bits & 0x00000020u) {
      otherentity_ = from.otherentity_;
    }
    if (cached_has_bits & 0x00000040u) {
      scale_ = from.scale_;
    }
    if (cached_has_bits & 0x00000080u) {
      magnitude_ = from.magnitude_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      radius_ = from.radius_;
    }
    if (cached_has_bits & 0x00000200u) {
      surfaceprop_ = from.surfaceprop_;
    }
    if (cached_has_bits & 0x00000400u) {
      effectindex_ = from.effectindex_;
    }
    if (cached_has_bits & 0x00000800u) {
      damagetype_ = from.damagetype_;
    }
    if (cached_has_bits & 0x00001000u) {
      material_ = from.material_;
    }
    if (cached_has_bits & 0x00002000u) {
      hitbox_ = from.hitbox_;
    }
    if (cached_has_bits & 0x00004000u) {
      color_ = from.color_;
    }
    if (cached_has_bits & 0x00008000u) {
      flags_ = from.flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00070000u) {
    if (cached_has_bits & 0x00010000u) {
      attachmentindex_ = from.attachmentindex_;
    }
    if (cached_has_bits & 0x00020000u) {
      effectname_ = from.effectname_;
    }
    if (cached_has_bits & 0x00040000u) {
      attachmentname_ = from.attachmentname_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgEffectData::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgEffectData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgEffectData::CopyFrom(const CMsgEffectData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgEffectData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgEffectData::IsInitialized() const {
  return true;
}

void CMsgEffectData::Swap(CMsgEffectData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgEffectData::InternalSwap(CMsgEffectData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(origin_, other->origin_);
  swap(start_, other->start_);
  swap(normal_, other->normal_);
  swap(angles_, other->angles_);
  swap(entity_, other->entity_);
  swap(otherentity_, other->otherentity_);
  swap(scale_, other->scale_);
  swap(magnitude_, other->magnitude_);
  swap(radius_, other->radius_);
  swap(surfaceprop_, other->surfaceprop_);
  swap(effectindex_, other->effectindex_);
  swap(damagetype_, other->damagetype_);
  swap(material_, other->material_);
  swap(hitbox_, other->hitbox_);
  swap(color_, other->color_);
  swap(flags_, other->flags_);
  swap(attachmentindex_, other->attachmentindex_);
  swap(effectname_, other->effectname_);
  swap(attachmentname_, other->attachmentname_);
}

::google::protobuf::Metadata CMsgEffectData::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTEEffectDispatch::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTEEffectDispatch_default_instance_._instance.get_mutable()->effectdata_ = const_cast< ::proto::dota::CMsgEffectData*>(
      ::proto::dota::CMsgEffectData::internal_default_instance());
}
class CMsgTEEffectDispatch::HasBitSetters {
 public:
  static const ::proto::dota::CMsgEffectData& effectdata(const CMsgTEEffectDispatch* msg);
  static void set_has_effectdata(CMsgTEEffectDispatch* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

const ::proto::dota::CMsgEffectData&
CMsgTEEffectDispatch::HasBitSetters::effectdata(const CMsgTEEffectDispatch* msg) {
  return *msg->effectdata_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEEffectDispatch::kEffectdataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEEffectDispatch::CMsgTEEffectDispatch()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEEffectDispatch)
}
CMsgTEEffectDispatch::CMsgTEEffectDispatch(const CMsgTEEffectDispatch& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_effectdata()) {
    effectdata_ = new ::proto::dota::CMsgEffectData(*from.effectdata_);
  } else {
    effectdata_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEEffectDispatch)
}

void CMsgTEEffectDispatch::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTEEffectDispatch_te_2eproto.base);
  effectdata_ = nullptr;
}

CMsgTEEffectDispatch::~CMsgTEEffectDispatch() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEEffectDispatch)
  SharedDtor();
}

void CMsgTEEffectDispatch::SharedDtor() {
  if (this != internal_default_instance()) delete effectdata_;
}

void CMsgTEEffectDispatch::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEEffectDispatch& CMsgTEEffectDispatch::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEEffectDispatch_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEEffectDispatch::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEEffectDispatch)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(effectdata_ != nullptr);
    effectdata_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEEffectDispatch::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEEffectDispatch*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgEffectData effectdata = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgEffectData::_InternalParse;
        object = msg->mutable_effectdata();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEEffectDispatch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEEffectDispatch)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgEffectData effectdata = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_effectdata()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEEffectDispatch)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEEffectDispatch)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEEffectDispatch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEEffectDispatch)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgEffectData effectdata = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::effectdata(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEEffectDispatch)
}

::google::protobuf::uint8* CMsgTEEffectDispatch::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEEffectDispatch)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgEffectData effectdata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::effectdata(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEEffectDispatch)
  return target;
}

size_t CMsgTEEffectDispatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEEffectDispatch)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .proto.dota.CMsgEffectData effectdata = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *effectdata_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEEffectDispatch::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEEffectDispatch)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEEffectDispatch* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEEffectDispatch>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEEffectDispatch)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEEffectDispatch)
    MergeFrom(*source);
  }
}

void CMsgTEEffectDispatch::MergeFrom(const CMsgTEEffectDispatch& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEEffectDispatch)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_effectdata()) {
    mutable_effectdata()->::proto::dota::CMsgEffectData::MergeFrom(from.effectdata());
  }
}

void CMsgTEEffectDispatch::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEEffectDispatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEEffectDispatch::CopyFrom(const CMsgTEEffectDispatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEEffectDispatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEEffectDispatch::IsInitialized() const {
  return true;
}

void CMsgTEEffectDispatch::Swap(CMsgTEEffectDispatch* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEEffectDispatch::InternalSwap(CMsgTEEffectDispatch* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(effectdata_, other->effectdata_);
}

::google::protobuf::Metadata CMsgTEEffectDispatch::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTEEnergySplash::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTEEnergySplash_default_instance_._instance.get_mutable()->pos_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgTEEnergySplash_default_instance_._instance.get_mutable()->dir_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
}
class CMsgTEEnergySplash::HasBitSetters {
 public:
  static const ::proto::dota::CMsgVector& pos(const CMsgTEEnergySplash* msg);
  static void set_has_pos(CMsgTEEnergySplash* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::proto::dota::CMsgVector& dir(const CMsgTEEnergySplash* msg);
  static void set_has_dir(CMsgTEEnergySplash* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_explosive(CMsgTEEnergySplash* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

const ::proto::dota::CMsgVector&
CMsgTEEnergySplash::HasBitSetters::pos(const CMsgTEEnergySplash* msg) {
  return *msg->pos_;
}
const ::proto::dota::CMsgVector&
CMsgTEEnergySplash::HasBitSetters::dir(const CMsgTEEnergySplash* msg) {
  return *msg->dir_;
}
void CMsgTEEnergySplash::clear_pos() {
  if (pos_ != nullptr) pos_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEEnergySplash::clear_dir() {
  if (dir_ != nullptr) dir_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEEnergySplash::kPosFieldNumber;
const int CMsgTEEnergySplash::kDirFieldNumber;
const int CMsgTEEnergySplash::kExplosiveFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEEnergySplash::CMsgTEEnergySplash()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEEnergySplash)
}
CMsgTEEnergySplash::CMsgTEEnergySplash(const CMsgTEEnergySplash& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_pos()) {
    pos_ = new ::proto::dota::CMsgVector(*from.pos_);
  } else {
    pos_ = nullptr;
  }
  if (from.has_dir()) {
    dir_ = new ::proto::dota::CMsgVector(*from.dir_);
  } else {
    dir_ = nullptr;
  }
  explosive_ = from.explosive_;
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEEnergySplash)
}

void CMsgTEEnergySplash::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTEEnergySplash_te_2eproto.base);
  ::memset(&pos_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&explosive_) -
      reinterpret_cast<char*>(&pos_)) + sizeof(explosive_));
}

CMsgTEEnergySplash::~CMsgTEEnergySplash() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEEnergySplash)
  SharedDtor();
}

void CMsgTEEnergySplash::SharedDtor() {
  if (this != internal_default_instance()) delete pos_;
  if (this != internal_default_instance()) delete dir_;
}

void CMsgTEEnergySplash::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEEnergySplash& CMsgTEEnergySplash::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEEnergySplash_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEEnergySplash::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEEnergySplash)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(pos_ != nullptr);
      pos_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(dir_ != nullptr);
      dir_->Clear();
    }
  }
  explosive_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEEnergySplash::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEEnergySplash*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgVector pos = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_pos();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgVector dir = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_dir();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional bool explosive = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_explosive(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEEnergySplash::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEEnergySplash)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgVector pos = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_pos()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgVector dir = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_dir()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool explosive = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_explosive(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &explosive_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEEnergySplash)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEEnergySplash)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEEnergySplash::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEEnergySplash)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector pos = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::pos(this), output);
  }

  // optional .proto.dota.CMsgVector dir = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::dir(this), output);
  }

  // optional bool explosive = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->explosive(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEEnergySplash)
}

::google::protobuf::uint8* CMsgTEEnergySplash::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEEnergySplash)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector pos = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::pos(this), target);
  }

  // optional .proto.dota.CMsgVector dir = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::dir(this), target);
  }

  // optional bool explosive = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->explosive(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEEnergySplash)
  return target;
}

size_t CMsgTEEnergySplash::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEEnergySplash)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .proto.dota.CMsgVector pos = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *pos_);
    }

    // optional .proto.dota.CMsgVector dir = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *dir_);
    }

    // optional bool explosive = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEEnergySplash::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEEnergySplash)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEEnergySplash* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEEnergySplash>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEEnergySplash)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEEnergySplash)
    MergeFrom(*source);
  }
}

void CMsgTEEnergySplash::MergeFrom(const CMsgTEEnergySplash& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEEnergySplash)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_pos()->::proto::dota::CMsgVector::MergeFrom(from.pos());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_dir()->::proto::dota::CMsgVector::MergeFrom(from.dir());
    }
    if (cached_has_bits & 0x00000004u) {
      explosive_ = from.explosive_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEEnergySplash::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEEnergySplash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEEnergySplash::CopyFrom(const CMsgTEEnergySplash& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEEnergySplash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEEnergySplash::IsInitialized() const {
  return true;
}

void CMsgTEEnergySplash::Swap(CMsgTEEnergySplash* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEEnergySplash::InternalSwap(CMsgTEEnergySplash* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(pos_, other->pos_);
  swap(dir_, other->dir_);
  swap(explosive_, other->explosive_);
}

::google::protobuf::Metadata CMsgTEEnergySplash::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTEFizz::InitAsDefaultInstance() {
}
class CMsgTEFizz::HasBitSetters {
 public:
  static void set_has_entity(CMsgTEFizz* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_density(CMsgTEFizz* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_current(CMsgTEFizz* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEFizz::kEntityFieldNumber;
const int CMsgTEFizz::kDensityFieldNumber;
const int CMsgTEFizz::kCurrentFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEFizz::CMsgTEFizz()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEFizz)
}
CMsgTEFizz::CMsgTEFizz(const CMsgTEFizz& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&entity_, &from.entity_,
    static_cast<size_t>(reinterpret_cast<char*>(&current_) -
    reinterpret_cast<char*>(&entity_)) + sizeof(current_));
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEFizz)
}

void CMsgTEFizz::SharedCtor() {
  ::memset(&entity_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&current_) -
      reinterpret_cast<char*>(&entity_)) + sizeof(current_));
}

CMsgTEFizz::~CMsgTEFizz() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEFizz)
  SharedDtor();
}

void CMsgTEFizz::SharedDtor() {
}

void CMsgTEFizz::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEFizz& CMsgTEFizz::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEFizz_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEFizz::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEFizz)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&entity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&current_) -
        reinterpret_cast<char*>(&entity_)) + sizeof(current_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEFizz::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEFizz*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional uint32 entity = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_entity(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 density = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_density(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int32 current = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_current(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEFizz::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEFizz)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 entity = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_entity(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &entity_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 density = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_density(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &density_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 current = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_current(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &current_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEFizz)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEFizz)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEFizz::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEFizz)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 entity = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->entity(), output);
  }

  // optional uint32 density = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->density(), output);
  }

  // optional int32 current = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->current(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEFizz)
}

::google::protobuf::uint8* CMsgTEFizz::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEFizz)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 entity = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->entity(), target);
  }

  // optional uint32 density = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->density(), target);
  }

  // optional int32 current = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->current(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEFizz)
  return target;
}

size_t CMsgTEFizz::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEFizz)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 entity = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->entity());
    }

    // optional uint32 density = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->density());
    }

    // optional int32 current = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->current());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEFizz::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEFizz)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEFizz* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEFizz>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEFizz)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEFizz)
    MergeFrom(*source);
  }
}

void CMsgTEFizz::MergeFrom(const CMsgTEFizz& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEFizz)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      entity_ = from.entity_;
    }
    if (cached_has_bits & 0x00000002u) {
      density_ = from.density_;
    }
    if (cached_has_bits & 0x00000004u) {
      current_ = from.current_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEFizz::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEFizz)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEFizz::CopyFrom(const CMsgTEFizz& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEFizz)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEFizz::IsInitialized() const {
  return true;
}

void CMsgTEFizz::Swap(CMsgTEFizz* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEFizz::InternalSwap(CMsgTEFizz* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(entity_, other->entity_);
  swap(density_, other->density_);
  swap(current_, other->current_);
}

::google::protobuf::Metadata CMsgTEFizz::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTEShatterSurface::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTEShatterSurface_default_instance_._instance.get_mutable()->origin_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgTEShatterSurface_default_instance_._instance.get_mutable()->angles_ = const_cast< ::proto::dota::CMsgQAngle*>(
      ::proto::dota::CMsgQAngle::internal_default_instance());
  ::proto::dota::_CMsgTEShatterSurface_default_instance_._instance.get_mutable()->force_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgTEShatterSurface_default_instance_._instance.get_mutable()->forcepos_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
}
class CMsgTEShatterSurface::HasBitSetters {
 public:
  static const ::proto::dota::CMsgVector& origin(const CMsgTEShatterSurface* msg);
  static void set_has_origin(CMsgTEShatterSurface* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::proto::dota::CMsgQAngle& angles(const CMsgTEShatterSurface* msg);
  static void set_has_angles(CMsgTEShatterSurface* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::proto::dota::CMsgVector& force(const CMsgTEShatterSurface* msg);
  static void set_has_force(CMsgTEShatterSurface* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static const ::proto::dota::CMsgVector& forcepos(const CMsgTEShatterSurface* msg);
  static void set_has_forcepos(CMsgTEShatterSurface* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_width(CMsgTEShatterSurface* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_height(CMsgTEShatterSurface* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_shardsize(CMsgTEShatterSurface* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_surfacetype(CMsgTEShatterSurface* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_frontcolor(CMsgTEShatterSurface* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static void set_has_backcolor(CMsgTEShatterSurface* msg) {
    msg->_has_bits_[0] |= 0x00000200u;
  }
};

const ::proto::dota::CMsgVector&
CMsgTEShatterSurface::HasBitSetters::origin(const CMsgTEShatterSurface* msg) {
  return *msg->origin_;
}
const ::proto::dota::CMsgQAngle&
CMsgTEShatterSurface::HasBitSetters::angles(const CMsgTEShatterSurface* msg) {
  return *msg->angles_;
}
const ::proto::dota::CMsgVector&
CMsgTEShatterSurface::HasBitSetters::force(const CMsgTEShatterSurface* msg) {
  return *msg->force_;
}
const ::proto::dota::CMsgVector&
CMsgTEShatterSurface::HasBitSetters::forcepos(const CMsgTEShatterSurface* msg) {
  return *msg->forcepos_;
}
void CMsgTEShatterSurface::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEShatterSurface::clear_angles() {
  if (angles_ != nullptr) angles_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEShatterSurface::clear_force() {
  if (force_ != nullptr) force_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEShatterSurface::clear_forcepos() {
  if (forcepos_ != nullptr) forcepos_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEShatterSurface::kOriginFieldNumber;
const int CMsgTEShatterSurface::kAnglesFieldNumber;
const int CMsgTEShatterSurface::kForceFieldNumber;
const int CMsgTEShatterSurface::kForceposFieldNumber;
const int CMsgTEShatterSurface::kWidthFieldNumber;
const int CMsgTEShatterSurface::kHeightFieldNumber;
const int CMsgTEShatterSurface::kShardsizeFieldNumber;
const int CMsgTEShatterSurface::kSurfacetypeFieldNumber;
const int CMsgTEShatterSurface::kFrontcolorFieldNumber;
const int CMsgTEShatterSurface::kBackcolorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEShatterSurface::CMsgTEShatterSurface()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEShatterSurface)
}
CMsgTEShatterSurface::CMsgTEShatterSurface(const CMsgTEShatterSurface& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_origin()) {
    origin_ = new ::proto::dota::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from.has_angles()) {
    angles_ = new ::proto::dota::CMsgQAngle(*from.angles_);
  } else {
    angles_ = nullptr;
  }
  if (from.has_force()) {
    force_ = new ::proto::dota::CMsgVector(*from.force_);
  } else {
    force_ = nullptr;
  }
  if (from.has_forcepos()) {
    forcepos_ = new ::proto::dota::CMsgVector(*from.forcepos_);
  } else {
    forcepos_ = nullptr;
  }
  ::memcpy(&width_, &from.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&backcolor_) -
    reinterpret_cast<char*>(&width_)) + sizeof(backcolor_));
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEShatterSurface)
}

void CMsgTEShatterSurface::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTEShatterSurface_te_2eproto.base);
  ::memset(&origin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&backcolor_) -
      reinterpret_cast<char*>(&origin_)) + sizeof(backcolor_));
}

CMsgTEShatterSurface::~CMsgTEShatterSurface() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEShatterSurface)
  SharedDtor();
}

void CMsgTEShatterSurface::SharedDtor() {
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete angles_;
  if (this != internal_default_instance()) delete force_;
  if (this != internal_default_instance()) delete forcepos_;
}

void CMsgTEShatterSurface::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEShatterSurface& CMsgTEShatterSurface::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEShatterSurface_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEShatterSurface::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEShatterSurface)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(angles_ != nullptr);
      angles_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(force_ != nullptr);
      force_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(forcepos_ != nullptr);
      forcepos_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&surfacetype_) -
        reinterpret_cast<char*>(&width_)) + sizeof(surfacetype_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&frontcolor_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&backcolor_) -
        reinterpret_cast<char*>(&frontcolor_)) + sizeof(backcolor_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEShatterSurface::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEShatterSurface*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_origin();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgQAngle angles = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgQAngle::_InternalParse;
        object = msg->mutable_angles();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgVector force = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_force();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgVector forcepos = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_forcepos();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional float width = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 45) goto handle_unusual;
        msg->set_width(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float height = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 53) goto handle_unusual;
        msg->set_height(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float shardsize = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 61) goto handle_unusual;
        msg->set_shardsize(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional uint32 surfacetype = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 64) goto handle_unusual;
        msg->set_surfacetype(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional fixed32 frontcolor = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 77) goto handle_unusual;
        msg->set_frontcolor(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint32>(ptr));
        ptr += sizeof(::google::protobuf::uint32);
        break;
      }
      // optional fixed32 backcolor = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 85) goto handle_unusual;
        msg->set_backcolor(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint32>(ptr));
        ptr += sizeof(::google::protobuf::uint32);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEShatterSurface::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEShatterSurface)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgQAngle angles = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_angles()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgVector force = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_force()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgVector forcepos = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_forcepos()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float width = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (45 & 0xFF)) {
          HasBitSetters::set_has_width(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &width_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float height = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (53 & 0xFF)) {
          HasBitSetters::set_has_height(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &height_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float shardsize = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (61 & 0xFF)) {
          HasBitSetters::set_has_shardsize(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &shardsize_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 surfacetype = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_surfacetype(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &surfacetype_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed32 frontcolor = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (77 & 0xFF)) {
          HasBitSetters::set_has_frontcolor(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &frontcolor_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed32 backcolor = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (85 & 0xFF)) {
          HasBitSetters::set_has_backcolor(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &backcolor_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEShatterSurface)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEShatterSurface)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEShatterSurface::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEShatterSurface)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::origin(this), output);
  }

  // optional .proto.dota.CMsgQAngle angles = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::angles(this), output);
  }

  // optional .proto.dota.CMsgVector force = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::force(this), output);
  }

  // optional .proto.dota.CMsgVector forcepos = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::forcepos(this), output);
  }

  // optional float width = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->width(), output);
  }

  // optional float height = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->height(), output);
  }

  // optional float shardsize = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->shardsize(), output);
  }

  // optional uint32 surfacetype = 8;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->surfacetype(), output);
  }

  // optional fixed32 frontcolor = 9;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(9, this->frontcolor(), output);
  }

  // optional fixed32 backcolor = 10;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(10, this->backcolor(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEShatterSurface)
}

::google::protobuf::uint8* CMsgTEShatterSurface::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEShatterSurface)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::origin(this), target);
  }

  // optional .proto.dota.CMsgQAngle angles = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::angles(this), target);
  }

  // optional .proto.dota.CMsgVector force = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::force(this), target);
  }

  // optional .proto.dota.CMsgVector forcepos = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::forcepos(this), target);
  }

  // optional float width = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->width(), target);
  }

  // optional float height = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->height(), target);
  }

  // optional float shardsize = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->shardsize(), target);
  }

  // optional uint32 surfacetype = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->surfacetype(), target);
  }

  // optional fixed32 frontcolor = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(9, this->frontcolor(), target);
  }

  // optional fixed32 backcolor = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(10, this->backcolor(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEShatterSurface)
  return target;
}

size_t CMsgTEShatterSurface::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEShatterSurface)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .proto.dota.CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .proto.dota.CMsgQAngle angles = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *angles_);
    }

    // optional .proto.dota.CMsgVector force = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *force_);
    }

    // optional .proto.dota.CMsgVector forcepos = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *forcepos_);
    }

    // optional float width = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float height = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float shardsize = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional uint32 surfacetype = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->surfacetype());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional fixed32 frontcolor = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional fixed32 backcolor = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEShatterSurface::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEShatterSurface)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEShatterSurface* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEShatterSurface>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEShatterSurface)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEShatterSurface)
    MergeFrom(*source);
  }
}

void CMsgTEShatterSurface::MergeFrom(const CMsgTEShatterSurface& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEShatterSurface)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_origin()->::proto::dota::CMsgVector::MergeFrom(from.origin());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_angles()->::proto::dota::CMsgQAngle::MergeFrom(from.angles());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_force()->::proto::dota::CMsgVector::MergeFrom(from.force());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_forcepos()->::proto::dota::CMsgVector::MergeFrom(from.forcepos());
    }
    if (cached_has_bits & 0x00000010u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000020u) {
      height_ = from.height_;
    }
    if (cached_has_bits & 0x00000040u) {
      shardsize_ = from.shardsize_;
    }
    if (cached_has_bits & 0x00000080u) {
      surfacetype_ = from.surfacetype_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      frontcolor_ = from.frontcolor_;
    }
    if (cached_has_bits & 0x00000200u) {
      backcolor_ = from.backcolor_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEShatterSurface::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEShatterSurface)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEShatterSurface::CopyFrom(const CMsgTEShatterSurface& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEShatterSurface)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEShatterSurface::IsInitialized() const {
  return true;
}

void CMsgTEShatterSurface::Swap(CMsgTEShatterSurface* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEShatterSurface::InternalSwap(CMsgTEShatterSurface* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(origin_, other->origin_);
  swap(angles_, other->angles_);
  swap(force_, other->force_);
  swap(forcepos_, other->forcepos_);
  swap(width_, other->width_);
  swap(height_, other->height_);
  swap(shardsize_, other->shardsize_);
  swap(surfacetype_, other->surfacetype_);
  swap(frontcolor_, other->frontcolor_);
  swap(backcolor_, other->backcolor_);
}

::google::protobuf::Metadata CMsgTEShatterSurface::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTEGlowSprite::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTEGlowSprite_default_instance_._instance.get_mutable()->origin_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
}
class CMsgTEGlowSprite::HasBitSetters {
 public:
  static const ::proto::dota::CMsgVector& origin(const CMsgTEGlowSprite* msg);
  static void set_has_origin(CMsgTEGlowSprite* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_scale(CMsgTEGlowSprite* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_life(CMsgTEGlowSprite* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_brightness(CMsgTEGlowSprite* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
};

const ::proto::dota::CMsgVector&
CMsgTEGlowSprite::HasBitSetters::origin(const CMsgTEGlowSprite* msg) {
  return *msg->origin_;
}
void CMsgTEGlowSprite::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEGlowSprite::kOriginFieldNumber;
const int CMsgTEGlowSprite::kScaleFieldNumber;
const int CMsgTEGlowSprite::kLifeFieldNumber;
const int CMsgTEGlowSprite::kBrightnessFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEGlowSprite::CMsgTEGlowSprite()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEGlowSprite)
}
CMsgTEGlowSprite::CMsgTEGlowSprite(const CMsgTEGlowSprite& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_origin()) {
    origin_ = new ::proto::dota::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  ::memcpy(&scale_, &from.scale_,
    static_cast<size_t>(reinterpret_cast<char*>(&brightness_) -
    reinterpret_cast<char*>(&scale_)) + sizeof(brightness_));
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEGlowSprite)
}

void CMsgTEGlowSprite::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTEGlowSprite_te_2eproto.base);
  ::memset(&origin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&brightness_) -
      reinterpret_cast<char*>(&origin_)) + sizeof(brightness_));
}

CMsgTEGlowSprite::~CMsgTEGlowSprite() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEGlowSprite)
  SharedDtor();
}

void CMsgTEGlowSprite::SharedDtor() {
  if (this != internal_default_instance()) delete origin_;
}

void CMsgTEGlowSprite::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEGlowSprite& CMsgTEGlowSprite::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEGlowSprite_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEGlowSprite::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEGlowSprite)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(origin_ != nullptr);
    origin_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&scale_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&brightness_) -
        reinterpret_cast<char*>(&scale_)) + sizeof(brightness_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEGlowSprite::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEGlowSprite*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_origin();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional float scale = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 21) goto handle_unusual;
        msg->set_scale(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float life = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        msg->set_life(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional uint32 brightness = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_brightness(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEGlowSprite::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEGlowSprite)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float scale = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_scale(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &scale_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float life = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_life(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &life_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 brightness = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_brightness(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &brightness_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEGlowSprite)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEGlowSprite)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEGlowSprite::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEGlowSprite)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::origin(this), output);
  }

  // optional float scale = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->scale(), output);
  }

  // optional float life = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->life(), output);
  }

  // optional uint32 brightness = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->brightness(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEGlowSprite)
}

::google::protobuf::uint8* CMsgTEGlowSprite::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEGlowSprite)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::origin(this), target);
  }

  // optional float scale = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->scale(), target);
  }

  // optional float life = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->life(), target);
  }

  // optional uint32 brightness = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->brightness(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEGlowSprite)
  return target;
}

size_t CMsgTEGlowSprite::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEGlowSprite)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .proto.dota.CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional float scale = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float life = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 brightness = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->brightness());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEGlowSprite::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEGlowSprite)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEGlowSprite* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEGlowSprite>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEGlowSprite)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEGlowSprite)
    MergeFrom(*source);
  }
}

void CMsgTEGlowSprite::MergeFrom(const CMsgTEGlowSprite& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEGlowSprite)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_origin()->::proto::dota::CMsgVector::MergeFrom(from.origin());
    }
    if (cached_has_bits & 0x00000002u) {
      scale_ = from.scale_;
    }
    if (cached_has_bits & 0x00000004u) {
      life_ = from.life_;
    }
    if (cached_has_bits & 0x00000008u) {
      brightness_ = from.brightness_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEGlowSprite::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEGlowSprite)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEGlowSprite::CopyFrom(const CMsgTEGlowSprite& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEGlowSprite)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEGlowSprite::IsInitialized() const {
  return true;
}

void CMsgTEGlowSprite::Swap(CMsgTEGlowSprite* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEGlowSprite::InternalSwap(CMsgTEGlowSprite* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(origin_, other->origin_);
  swap(scale_, other->scale_);
  swap(life_, other->life_);
  swap(brightness_, other->brightness_);
}

::google::protobuf::Metadata CMsgTEGlowSprite::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTEImpact::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTEImpact_default_instance_._instance.get_mutable()->origin_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgTEImpact_default_instance_._instance.get_mutable()->normal_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
}
class CMsgTEImpact::HasBitSetters {
 public:
  static const ::proto::dota::CMsgVector& origin(const CMsgTEImpact* msg);
  static void set_has_origin(CMsgTEImpact* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::proto::dota::CMsgVector& normal(const CMsgTEImpact* msg);
  static void set_has_normal(CMsgTEImpact* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_type(CMsgTEImpact* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

const ::proto::dota::CMsgVector&
CMsgTEImpact::HasBitSetters::origin(const CMsgTEImpact* msg) {
  return *msg->origin_;
}
const ::proto::dota::CMsgVector&
CMsgTEImpact::HasBitSetters::normal(const CMsgTEImpact* msg) {
  return *msg->normal_;
}
void CMsgTEImpact::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEImpact::clear_normal() {
  if (normal_ != nullptr) normal_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEImpact::kOriginFieldNumber;
const int CMsgTEImpact::kNormalFieldNumber;
const int CMsgTEImpact::kTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEImpact::CMsgTEImpact()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEImpact)
}
CMsgTEImpact::CMsgTEImpact(const CMsgTEImpact& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_origin()) {
    origin_ = new ::proto::dota::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from.has_normal()) {
    normal_ = new ::proto::dota::CMsgVector(*from.normal_);
  } else {
    normal_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEImpact)
}

void CMsgTEImpact::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTEImpact_te_2eproto.base);
  ::memset(&origin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&origin_)) + sizeof(type_));
}

CMsgTEImpact::~CMsgTEImpact() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEImpact)
  SharedDtor();
}

void CMsgTEImpact::SharedDtor() {
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete normal_;
}

void CMsgTEImpact::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEImpact& CMsgTEImpact::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEImpact_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEImpact::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEImpact)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(normal_ != nullptr);
      normal_->Clear();
    }
  }
  type_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEImpact::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEImpact*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_origin();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgVector normal = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_normal();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional uint32 type = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_type(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEImpact::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEImpact)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgVector normal = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_normal()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 type = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_type(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEImpact)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEImpact)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEImpact::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEImpact)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::origin(this), output);
  }

  // optional .proto.dota.CMsgVector normal = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::normal(this), output);
  }

  // optional uint32 type = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEImpact)
}

::google::protobuf::uint8* CMsgTEImpact::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEImpact)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::origin(this), target);
  }

  // optional .proto.dota.CMsgVector normal = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::normal(this), target);
  }

  // optional uint32 type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEImpact)
  return target;
}

size_t CMsgTEImpact::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEImpact)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .proto.dota.CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .proto.dota.CMsgVector normal = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *normal_);
    }

    // optional uint32 type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEImpact::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEImpact)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEImpact* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEImpact>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEImpact)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEImpact)
    MergeFrom(*source);
  }
}

void CMsgTEImpact::MergeFrom(const CMsgTEImpact& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEImpact)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_origin()->::proto::dota::CMsgVector::MergeFrom(from.origin());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_normal()->::proto::dota::CMsgVector::MergeFrom(from.normal());
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEImpact::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEImpact)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEImpact::CopyFrom(const CMsgTEImpact& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEImpact)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEImpact::IsInitialized() const {
  return true;
}

void CMsgTEImpact::Swap(CMsgTEImpact* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEImpact::InternalSwap(CMsgTEImpact* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(origin_, other->origin_);
  swap(normal_, other->normal_);
  swap(type_, other->type_);
}

::google::protobuf::Metadata CMsgTEImpact::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTEMuzzleFlash::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTEMuzzleFlash_default_instance_._instance.get_mutable()->origin_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgTEMuzzleFlash_default_instance_._instance.get_mutable()->angles_ = const_cast< ::proto::dota::CMsgQAngle*>(
      ::proto::dota::CMsgQAngle::internal_default_instance());
}
class CMsgTEMuzzleFlash::HasBitSetters {
 public:
  static const ::proto::dota::CMsgVector& origin(const CMsgTEMuzzleFlash* msg);
  static void set_has_origin(CMsgTEMuzzleFlash* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::proto::dota::CMsgQAngle& angles(const CMsgTEMuzzleFlash* msg);
  static void set_has_angles(CMsgTEMuzzleFlash* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_scale(CMsgTEMuzzleFlash* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_type(CMsgTEMuzzleFlash* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
};

const ::proto::dota::CMsgVector&
CMsgTEMuzzleFlash::HasBitSetters::origin(const CMsgTEMuzzleFlash* msg) {
  return *msg->origin_;
}
const ::proto::dota::CMsgQAngle&
CMsgTEMuzzleFlash::HasBitSetters::angles(const CMsgTEMuzzleFlash* msg) {
  return *msg->angles_;
}
void CMsgTEMuzzleFlash::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEMuzzleFlash::clear_angles() {
  if (angles_ != nullptr) angles_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEMuzzleFlash::kOriginFieldNumber;
const int CMsgTEMuzzleFlash::kAnglesFieldNumber;
const int CMsgTEMuzzleFlash::kScaleFieldNumber;
const int CMsgTEMuzzleFlash::kTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEMuzzleFlash::CMsgTEMuzzleFlash()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEMuzzleFlash)
}
CMsgTEMuzzleFlash::CMsgTEMuzzleFlash(const CMsgTEMuzzleFlash& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_origin()) {
    origin_ = new ::proto::dota::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from.has_angles()) {
    angles_ = new ::proto::dota::CMsgQAngle(*from.angles_);
  } else {
    angles_ = nullptr;
  }
  ::memcpy(&scale_, &from.scale_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&scale_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEMuzzleFlash)
}

void CMsgTEMuzzleFlash::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTEMuzzleFlash_te_2eproto.base);
  ::memset(&origin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&origin_)) + sizeof(type_));
}

CMsgTEMuzzleFlash::~CMsgTEMuzzleFlash() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEMuzzleFlash)
  SharedDtor();
}

void CMsgTEMuzzleFlash::SharedDtor() {
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete angles_;
}

void CMsgTEMuzzleFlash::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEMuzzleFlash& CMsgTEMuzzleFlash::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEMuzzleFlash_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEMuzzleFlash::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEMuzzleFlash)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(angles_ != nullptr);
      angles_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&scale_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&type_) -
        reinterpret_cast<char*>(&scale_)) + sizeof(type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEMuzzleFlash::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEMuzzleFlash*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_origin();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgQAngle angles = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgQAngle::_InternalParse;
        object = msg->mutable_angles();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional float scale = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        msg->set_scale(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional uint32 type = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_type(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEMuzzleFlash::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEMuzzleFlash)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgQAngle angles = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_angles()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float scale = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_scale(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &scale_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 type = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_type(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEMuzzleFlash)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEMuzzleFlash)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEMuzzleFlash::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEMuzzleFlash)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::origin(this), output);
  }

  // optional .proto.dota.CMsgQAngle angles = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::angles(this), output);
  }

  // optional float scale = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->scale(), output);
  }

  // optional uint32 type = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEMuzzleFlash)
}

::google::protobuf::uint8* CMsgTEMuzzleFlash::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEMuzzleFlash)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::origin(this), target);
  }

  // optional .proto.dota.CMsgQAngle angles = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::angles(this), target);
  }

  // optional float scale = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->scale(), target);
  }

  // optional uint32 type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEMuzzleFlash)
  return target;
}

size_t CMsgTEMuzzleFlash::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEMuzzleFlash)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .proto.dota.CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .proto.dota.CMsgQAngle angles = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *angles_);
    }

    // optional float scale = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 type = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEMuzzleFlash::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEMuzzleFlash)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEMuzzleFlash* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEMuzzleFlash>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEMuzzleFlash)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEMuzzleFlash)
    MergeFrom(*source);
  }
}

void CMsgTEMuzzleFlash::MergeFrom(const CMsgTEMuzzleFlash& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEMuzzleFlash)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_origin()->::proto::dota::CMsgVector::MergeFrom(from.origin());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_angles()->::proto::dota::CMsgQAngle::MergeFrom(from.angles());
    }
    if (cached_has_bits & 0x00000004u) {
      scale_ = from.scale_;
    }
    if (cached_has_bits & 0x00000008u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEMuzzleFlash::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEMuzzleFlash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEMuzzleFlash::CopyFrom(const CMsgTEMuzzleFlash& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEMuzzleFlash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEMuzzleFlash::IsInitialized() const {
  return true;
}

void CMsgTEMuzzleFlash::Swap(CMsgTEMuzzleFlash* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEMuzzleFlash::InternalSwap(CMsgTEMuzzleFlash* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(origin_, other->origin_);
  swap(angles_, other->angles_);
  swap(scale_, other->scale_);
  swap(type_, other->type_);
}

::google::protobuf::Metadata CMsgTEMuzzleFlash::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTEBloodStream::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTEBloodStream_default_instance_._instance.get_mutable()->origin_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgTEBloodStream_default_instance_._instance.get_mutable()->direction_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
}
class CMsgTEBloodStream::HasBitSetters {
 public:
  static const ::proto::dota::CMsgVector& origin(const CMsgTEBloodStream* msg);
  static void set_has_origin(CMsgTEBloodStream* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::proto::dota::CMsgVector& direction(const CMsgTEBloodStream* msg);
  static void set_has_direction(CMsgTEBloodStream* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_color(CMsgTEBloodStream* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_amount(CMsgTEBloodStream* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
};

const ::proto::dota::CMsgVector&
CMsgTEBloodStream::HasBitSetters::origin(const CMsgTEBloodStream* msg) {
  return *msg->origin_;
}
const ::proto::dota::CMsgVector&
CMsgTEBloodStream::HasBitSetters::direction(const CMsgTEBloodStream* msg) {
  return *msg->direction_;
}
void CMsgTEBloodStream::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBloodStream::clear_direction() {
  if (direction_ != nullptr) direction_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEBloodStream::kOriginFieldNumber;
const int CMsgTEBloodStream::kDirectionFieldNumber;
const int CMsgTEBloodStream::kColorFieldNumber;
const int CMsgTEBloodStream::kAmountFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEBloodStream::CMsgTEBloodStream()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEBloodStream)
}
CMsgTEBloodStream::CMsgTEBloodStream(const CMsgTEBloodStream& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_origin()) {
    origin_ = new ::proto::dota::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from.has_direction()) {
    direction_ = new ::proto::dota::CMsgVector(*from.direction_);
  } else {
    direction_ = nullptr;
  }
  ::memcpy(&color_, &from.color_,
    static_cast<size_t>(reinterpret_cast<char*>(&amount_) -
    reinterpret_cast<char*>(&color_)) + sizeof(amount_));
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEBloodStream)
}

void CMsgTEBloodStream::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTEBloodStream_te_2eproto.base);
  ::memset(&origin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&amount_) -
      reinterpret_cast<char*>(&origin_)) + sizeof(amount_));
}

CMsgTEBloodStream::~CMsgTEBloodStream() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEBloodStream)
  SharedDtor();
}

void CMsgTEBloodStream::SharedDtor() {
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete direction_;
}

void CMsgTEBloodStream::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEBloodStream& CMsgTEBloodStream::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEBloodStream_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEBloodStream::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEBloodStream)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(direction_ != nullptr);
      direction_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&color_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&amount_) -
        reinterpret_cast<char*>(&color_)) + sizeof(amount_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEBloodStream::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEBloodStream*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_origin();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgVector direction = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_direction();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional fixed32 color = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        msg->set_color(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint32>(ptr));
        ptr += sizeof(::google::protobuf::uint32);
        break;
      }
      // optional uint32 amount = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_amount(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEBloodStream::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEBloodStream)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgVector direction = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_direction()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed32 color = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_color(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &color_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 amount = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_amount(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &amount_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEBloodStream)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEBloodStream)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEBloodStream::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEBloodStream)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::origin(this), output);
  }

  // optional .proto.dota.CMsgVector direction = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::direction(this), output);
  }

  // optional fixed32 color = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(3, this->color(), output);
  }

  // optional uint32 amount = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->amount(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEBloodStream)
}

::google::protobuf::uint8* CMsgTEBloodStream::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEBloodStream)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::origin(this), target);
  }

  // optional .proto.dota.CMsgVector direction = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::direction(this), target);
  }

  // optional fixed32 color = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(3, this->color(), target);
  }

  // optional uint32 amount = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->amount(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEBloodStream)
  return target;
}

size_t CMsgTEBloodStream::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEBloodStream)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .proto.dota.CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .proto.dota.CMsgVector direction = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *direction_);
    }

    // optional fixed32 color = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 amount = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->amount());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEBloodStream::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEBloodStream)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEBloodStream* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEBloodStream>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEBloodStream)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEBloodStream)
    MergeFrom(*source);
  }
}

void CMsgTEBloodStream::MergeFrom(const CMsgTEBloodStream& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEBloodStream)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_origin()->::proto::dota::CMsgVector::MergeFrom(from.origin());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_direction()->::proto::dota::CMsgVector::MergeFrom(from.direction());
    }
    if (cached_has_bits & 0x00000004u) {
      color_ = from.color_;
    }
    if (cached_has_bits & 0x00000008u) {
      amount_ = from.amount_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEBloodStream::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEBloodStream)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBloodStream::CopyFrom(const CMsgTEBloodStream& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEBloodStream)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBloodStream::IsInitialized() const {
  return true;
}

void CMsgTEBloodStream::Swap(CMsgTEBloodStream* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEBloodStream::InternalSwap(CMsgTEBloodStream* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(origin_, other->origin_);
  swap(direction_, other->direction_);
  swap(color_, other->color_);
  swap(amount_, other->amount_);
}

::google::protobuf::Metadata CMsgTEBloodStream::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTEExplosion::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTEExplosion_default_instance_._instance.get_mutable()->origin_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgTEExplosion_default_instance_._instance.get_mutable()->normal_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
}
class CMsgTEExplosion::HasBitSetters {
 public:
  static const ::proto::dota::CMsgVector& origin(const CMsgTEExplosion* msg);
  static void set_has_origin(CMsgTEExplosion* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_framerate(CMsgTEExplosion* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_flags(CMsgTEExplosion* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static const ::proto::dota::CMsgVector& normal(const CMsgTEExplosion* msg);
  static void set_has_normal(CMsgTEExplosion* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_materialtype(CMsgTEExplosion* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_radius(CMsgTEExplosion* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_magnitude(CMsgTEExplosion* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_scale(CMsgTEExplosion* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_affect_ragdolls(CMsgTEExplosion* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
};

const ::proto::dota::CMsgVector&
CMsgTEExplosion::HasBitSetters::origin(const CMsgTEExplosion* msg) {
  return *msg->origin_;
}
const ::proto::dota::CMsgVector&
CMsgTEExplosion::HasBitSetters::normal(const CMsgTEExplosion* msg) {
  return *msg->normal_;
}
void CMsgTEExplosion::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEExplosion::clear_normal() {
  if (normal_ != nullptr) normal_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEExplosion::kOriginFieldNumber;
const int CMsgTEExplosion::kFramerateFieldNumber;
const int CMsgTEExplosion::kFlagsFieldNumber;
const int CMsgTEExplosion::kNormalFieldNumber;
const int CMsgTEExplosion::kMaterialtypeFieldNumber;
const int CMsgTEExplosion::kRadiusFieldNumber;
const int CMsgTEExplosion::kMagnitudeFieldNumber;
const int CMsgTEExplosion::kScaleFieldNumber;
const int CMsgTEExplosion::kAffectRagdollsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEExplosion::CMsgTEExplosion()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEExplosion)
}
CMsgTEExplosion::CMsgTEExplosion(const CMsgTEExplosion& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_origin()) {
    origin_ = new ::proto::dota::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from.has_normal()) {
    normal_ = new ::proto::dota::CMsgVector(*from.normal_);
  } else {
    normal_ = nullptr;
  }
  ::memcpy(&framerate_, &from.framerate_,
    static_cast<size_t>(reinterpret_cast<char*>(&affect_ragdolls_) -
    reinterpret_cast<char*>(&framerate_)) + sizeof(affect_ragdolls_));
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEExplosion)
}

void CMsgTEExplosion::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTEExplosion_te_2eproto.base);
  ::memset(&origin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&affect_ragdolls_) -
      reinterpret_cast<char*>(&origin_)) + sizeof(affect_ragdolls_));
}

CMsgTEExplosion::~CMsgTEExplosion() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEExplosion)
  SharedDtor();
}

void CMsgTEExplosion::SharedDtor() {
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete normal_;
}

void CMsgTEExplosion::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEExplosion& CMsgTEExplosion::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEExplosion_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEExplosion::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEExplosion)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(normal_ != nullptr);
      normal_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&framerate_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&scale_) -
        reinterpret_cast<char*>(&framerate_)) + sizeof(scale_));
  }
  affect_ragdolls_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEExplosion::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEExplosion*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_origin();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional uint32 framerate = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_framerate(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 flags = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_flags(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .proto.dota.CMsgVector normal = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_normal();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional uint32 materialtype = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_materialtype(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 radius = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        msg->set_radius(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 magnitude = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        msg->set_magnitude(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional float scale = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 69) goto handle_unusual;
        msg->set_scale(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional bool affect_ragdolls = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 72) goto handle_unusual;
        msg->set_affect_ragdolls(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEExplosion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEExplosion)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 framerate = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_framerate(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &framerate_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 flags = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_flags(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgVector normal = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_normal()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 materialtype = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_materialtype(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &materialtype_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 radius = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_radius(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &radius_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 magnitude = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_magnitude(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &magnitude_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float scale = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (69 & 0xFF)) {
          HasBitSetters::set_has_scale(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &scale_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool affect_ragdolls = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_affect_ragdolls(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &affect_ragdolls_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEExplosion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEExplosion)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEExplosion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEExplosion)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::origin(this), output);
  }

  // optional uint32 framerate = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->framerate(), output);
  }

  // optional uint32 flags = 3;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->flags(), output);
  }

  // optional .proto.dota.CMsgVector normal = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::normal(this), output);
  }

  // optional uint32 materialtype = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->materialtype(), output);
  }

  // optional uint32 radius = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->radius(), output);
  }

  // optional uint32 magnitude = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->magnitude(), output);
  }

  // optional float scale = 8;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->scale(), output);
  }

  // optional bool affect_ragdolls = 9;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->affect_ragdolls(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEExplosion)
}

::google::protobuf::uint8* CMsgTEExplosion::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEExplosion)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::origin(this), target);
  }

  // optional uint32 framerate = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->framerate(), target);
  }

  // optional uint32 flags = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->flags(), target);
  }

  // optional .proto.dota.CMsgVector normal = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::normal(this), target);
  }

  // optional uint32 materialtype = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->materialtype(), target);
  }

  // optional uint32 radius = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->radius(), target);
  }

  // optional uint32 magnitude = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->magnitude(), target);
  }

  // optional float scale = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->scale(), target);
  }

  // optional bool affect_ragdolls = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(9, this->affect_ragdolls(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEExplosion)
  return target;
}

size_t CMsgTEExplosion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEExplosion)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .proto.dota.CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .proto.dota.CMsgVector normal = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *normal_);
    }

    // optional uint32 framerate = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->framerate());
    }

    // optional uint32 flags = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

    // optional uint32 materialtype = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->materialtype());
    }

    // optional uint32 radius = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->radius());
    }

    // optional uint32 magnitude = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->magnitude());
    }

    // optional float scale = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  // optional bool affect_ragdolls = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEExplosion::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEExplosion)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEExplosion* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEExplosion>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEExplosion)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEExplosion)
    MergeFrom(*source);
  }
}

void CMsgTEExplosion::MergeFrom(const CMsgTEExplosion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEExplosion)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_origin()->::proto::dota::CMsgVector::MergeFrom(from.origin());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_normal()->::proto::dota::CMsgVector::MergeFrom(from.normal());
    }
    if (cached_has_bits & 0x00000004u) {
      framerate_ = from.framerate_;
    }
    if (cached_has_bits & 0x00000008u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000010u) {
      materialtype_ = from.materialtype_;
    }
    if (cached_has_bits & 0x00000020u) {
      radius_ = from.radius_;
    }
    if (cached_has_bits & 0x00000040u) {
      magnitude_ = from.magnitude_;
    }
    if (cached_has_bits & 0x00000080u) {
      scale_ = from.scale_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    set_affect_ragdolls(from.affect_ragdolls());
  }
}

void CMsgTEExplosion::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEExplosion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEExplosion::CopyFrom(const CMsgTEExplosion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEExplosion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEExplosion::IsInitialized() const {
  return true;
}

void CMsgTEExplosion::Swap(CMsgTEExplosion* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEExplosion::InternalSwap(CMsgTEExplosion* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(origin_, other->origin_);
  swap(normal_, other->normal_);
  swap(framerate_, other->framerate_);
  swap(flags_, other->flags_);
  swap(materialtype_, other->materialtype_);
  swap(radius_, other->radius_);
  swap(magnitude_, other->magnitude_);
  swap(scale_, other->scale_);
  swap(affect_ragdolls_, other->affect_ragdolls_);
}

::google::protobuf::Metadata CMsgTEExplosion::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTEDust::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTEDust_default_instance_._instance.get_mutable()->origin_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgTEDust_default_instance_._instance.get_mutable()->direction_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
}
class CMsgTEDust::HasBitSetters {
 public:
  static const ::proto::dota::CMsgVector& origin(const CMsgTEDust* msg);
  static void set_has_origin(CMsgTEDust* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_size(CMsgTEDust* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_speed(CMsgTEDust* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static const ::proto::dota::CMsgVector& direction(const CMsgTEDust* msg);
  static void set_has_direction(CMsgTEDust* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

const ::proto::dota::CMsgVector&
CMsgTEDust::HasBitSetters::origin(const CMsgTEDust* msg) {
  return *msg->origin_;
}
const ::proto::dota::CMsgVector&
CMsgTEDust::HasBitSetters::direction(const CMsgTEDust* msg) {
  return *msg->direction_;
}
void CMsgTEDust::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEDust::clear_direction() {
  if (direction_ != nullptr) direction_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEDust::kOriginFieldNumber;
const int CMsgTEDust::kSizeFieldNumber;
const int CMsgTEDust::kSpeedFieldNumber;
const int CMsgTEDust::kDirectionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEDust::CMsgTEDust()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEDust)
}
CMsgTEDust::CMsgTEDust(const CMsgTEDust& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_origin()) {
    origin_ = new ::proto::dota::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from.has_direction()) {
    direction_ = new ::proto::dota::CMsgVector(*from.direction_);
  } else {
    direction_ = nullptr;
  }
  ::memcpy(&size_, &from.size_,
    static_cast<size_t>(reinterpret_cast<char*>(&speed_) -
    reinterpret_cast<char*>(&size_)) + sizeof(speed_));
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEDust)
}

void CMsgTEDust::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTEDust_te_2eproto.base);
  ::memset(&origin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&speed_) -
      reinterpret_cast<char*>(&origin_)) + sizeof(speed_));
}

CMsgTEDust::~CMsgTEDust() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEDust)
  SharedDtor();
}

void CMsgTEDust::SharedDtor() {
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete direction_;
}

void CMsgTEDust::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEDust& CMsgTEDust::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEDust_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEDust::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEDust)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(direction_ != nullptr);
      direction_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&speed_) -
        reinterpret_cast<char*>(&size_)) + sizeof(speed_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEDust::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEDust*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_origin();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional float size = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 21) goto handle_unusual;
        msg->set_size(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional float speed = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        msg->set_speed(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      // optional .proto.dota.CMsgVector direction = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_direction();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEDust::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEDust)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float size = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_size(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float speed = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_speed(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &speed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgVector direction = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_direction()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEDust)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEDust)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEDust::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEDust)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::origin(this), output);
  }

  // optional float size = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->size(), output);
  }

  // optional float speed = 3;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->speed(), output);
  }

  // optional .proto.dota.CMsgVector direction = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::direction(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEDust)
}

::google::protobuf::uint8* CMsgTEDust::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEDust)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::origin(this), target);
  }

  // optional float size = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->size(), target);
  }

  // optional float speed = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->speed(), target);
  }

  // optional .proto.dota.CMsgVector direction = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::direction(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEDust)
  return target;
}

size_t CMsgTEDust::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEDust)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .proto.dota.CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .proto.dota.CMsgVector direction = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *direction_);
    }

    // optional float size = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float speed = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEDust::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEDust)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEDust* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEDust>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEDust)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEDust)
    MergeFrom(*source);
  }
}

void CMsgTEDust::MergeFrom(const CMsgTEDust& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEDust)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_origin()->::proto::dota::CMsgVector::MergeFrom(from.origin());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_direction()->::proto::dota::CMsgVector::MergeFrom(from.direction());
    }
    if (cached_has_bits & 0x00000004u) {
      size_ = from.size_;
    }
    if (cached_has_bits & 0x00000008u) {
      speed_ = from.speed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEDust::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEDust)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEDust::CopyFrom(const CMsgTEDust& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEDust)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEDust::IsInitialized() const {
  return true;
}

void CMsgTEDust::Swap(CMsgTEDust* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEDust::InternalSwap(CMsgTEDust* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(origin_, other->origin_);
  swap(direction_, other->direction_);
  swap(size_, other->size_);
  swap(speed_, other->speed_);
}

::google::protobuf::Metadata CMsgTEDust::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTELargeFunnel::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTELargeFunnel_default_instance_._instance.get_mutable()->origin_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
}
class CMsgTELargeFunnel::HasBitSetters {
 public:
  static const ::proto::dota::CMsgVector& origin(const CMsgTELargeFunnel* msg);
  static void set_has_origin(CMsgTELargeFunnel* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_reversed(CMsgTELargeFunnel* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

const ::proto::dota::CMsgVector&
CMsgTELargeFunnel::HasBitSetters::origin(const CMsgTELargeFunnel* msg) {
  return *msg->origin_;
}
void CMsgTELargeFunnel::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTELargeFunnel::kOriginFieldNumber;
const int CMsgTELargeFunnel::kReversedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTELargeFunnel::CMsgTELargeFunnel()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTELargeFunnel)
}
CMsgTELargeFunnel::CMsgTELargeFunnel(const CMsgTELargeFunnel& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_origin()) {
    origin_ = new ::proto::dota::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  reversed_ = from.reversed_;
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTELargeFunnel)
}

void CMsgTELargeFunnel::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTELargeFunnel_te_2eproto.base);
  ::memset(&origin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&reversed_) -
      reinterpret_cast<char*>(&origin_)) + sizeof(reversed_));
}

CMsgTELargeFunnel::~CMsgTELargeFunnel() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTELargeFunnel)
  SharedDtor();
}

void CMsgTELargeFunnel::SharedDtor() {
  if (this != internal_default_instance()) delete origin_;
}

void CMsgTELargeFunnel::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTELargeFunnel& CMsgTELargeFunnel::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTELargeFunnel_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTELargeFunnel::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTELargeFunnel)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(origin_ != nullptr);
    origin_->Clear();
  }
  reversed_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTELargeFunnel::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTELargeFunnel*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_origin();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional uint32 reversed = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_reversed(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTELargeFunnel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTELargeFunnel)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 reversed = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_reversed(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &reversed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTELargeFunnel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTELargeFunnel)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTELargeFunnel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTELargeFunnel)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::origin(this), output);
  }

  // optional uint32 reversed = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->reversed(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTELargeFunnel)
}

::google::protobuf::uint8* CMsgTELargeFunnel::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTELargeFunnel)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::origin(this), target);
  }

  // optional uint32 reversed = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->reversed(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTELargeFunnel)
  return target;
}

size_t CMsgTELargeFunnel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTELargeFunnel)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .proto.dota.CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional uint32 reversed = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->reversed());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTELargeFunnel::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTELargeFunnel)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTELargeFunnel* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTELargeFunnel>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTELargeFunnel)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTELargeFunnel)
    MergeFrom(*source);
  }
}

void CMsgTELargeFunnel::MergeFrom(const CMsgTELargeFunnel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTELargeFunnel)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_origin()->::proto::dota::CMsgVector::MergeFrom(from.origin());
    }
    if (cached_has_bits & 0x00000002u) {
      reversed_ = from.reversed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTELargeFunnel::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTELargeFunnel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTELargeFunnel::CopyFrom(const CMsgTELargeFunnel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTELargeFunnel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTELargeFunnel::IsInitialized() const {
  return true;
}

void CMsgTELargeFunnel::Swap(CMsgTELargeFunnel* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTELargeFunnel::InternalSwap(CMsgTELargeFunnel* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(origin_, other->origin_);
  swap(reversed_, other->reversed_);
}

::google::protobuf::Metadata CMsgTELargeFunnel::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTESparks::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTESparks_default_instance_._instance.get_mutable()->origin_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgTESparks_default_instance_._instance.get_mutable()->direction_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
}
class CMsgTESparks::HasBitSetters {
 public:
  static const ::proto::dota::CMsgVector& origin(const CMsgTESparks* msg);
  static void set_has_origin(CMsgTESparks* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_magnitude(CMsgTESparks* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_length(CMsgTESparks* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static const ::proto::dota::CMsgVector& direction(const CMsgTESparks* msg);
  static void set_has_direction(CMsgTESparks* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

const ::proto::dota::CMsgVector&
CMsgTESparks::HasBitSetters::origin(const CMsgTESparks* msg) {
  return *msg->origin_;
}
const ::proto::dota::CMsgVector&
CMsgTESparks::HasBitSetters::direction(const CMsgTESparks* msg) {
  return *msg->direction_;
}
void CMsgTESparks::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTESparks::clear_direction() {
  if (direction_ != nullptr) direction_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTESparks::kOriginFieldNumber;
const int CMsgTESparks::kMagnitudeFieldNumber;
const int CMsgTESparks::kLengthFieldNumber;
const int CMsgTESparks::kDirectionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTESparks::CMsgTESparks()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTESparks)
}
CMsgTESparks::CMsgTESparks(const CMsgTESparks& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_origin()) {
    origin_ = new ::proto::dota::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from.has_direction()) {
    direction_ = new ::proto::dota::CMsgVector(*from.direction_);
  } else {
    direction_ = nullptr;
  }
  ::memcpy(&magnitude_, &from.magnitude_,
    static_cast<size_t>(reinterpret_cast<char*>(&length_) -
    reinterpret_cast<char*>(&magnitude_)) + sizeof(length_));
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTESparks)
}

void CMsgTESparks::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTESparks_te_2eproto.base);
  ::memset(&origin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&length_) -
      reinterpret_cast<char*>(&origin_)) + sizeof(length_));
}

CMsgTESparks::~CMsgTESparks() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTESparks)
  SharedDtor();
}

void CMsgTESparks::SharedDtor() {
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete direction_;
}

void CMsgTESparks::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTESparks& CMsgTESparks::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTESparks_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTESparks::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTESparks)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(direction_ != nullptr);
      direction_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&magnitude_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&length_) -
        reinterpret_cast<char*>(&magnitude_)) + sizeof(length_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTESparks::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTESparks*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_origin();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional uint32 magnitude = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_magnitude(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 length = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_length(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .proto.dota.CMsgVector direction = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_direction();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTESparks::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTESparks)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 magnitude = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_magnitude(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &magnitude_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 length = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_length(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgVector direction = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_direction()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTESparks)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTESparks)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTESparks::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTESparks)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::origin(this), output);
  }

  // optional uint32 magnitude = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->magnitude(), output);
  }

  // optional uint32 length = 3;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->length(), output);
  }

  // optional .proto.dota.CMsgVector direction = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::direction(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTESparks)
}

::google::protobuf::uint8* CMsgTESparks::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTESparks)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::origin(this), target);
  }

  // optional uint32 magnitude = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->magnitude(), target);
  }

  // optional uint32 length = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->length(), target);
  }

  // optional .proto.dota.CMsgVector direction = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::direction(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTESparks)
  return target;
}

size_t CMsgTESparks::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTESparks)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .proto.dota.CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .proto.dota.CMsgVector direction = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *direction_);
    }

    // optional uint32 magnitude = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->magnitude());
    }

    // optional uint32 length = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->length());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTESparks::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTESparks)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTESparks* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTESparks>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTESparks)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTESparks)
    MergeFrom(*source);
  }
}

void CMsgTESparks::MergeFrom(const CMsgTESparks& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTESparks)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_origin()->::proto::dota::CMsgVector::MergeFrom(from.origin());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_direction()->::proto::dota::CMsgVector::MergeFrom(from.direction());
    }
    if (cached_has_bits & 0x00000004u) {
      magnitude_ = from.magnitude_;
    }
    if (cached_has_bits & 0x00000008u) {
      length_ = from.length_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTESparks::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTESparks)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTESparks::CopyFrom(const CMsgTESparks& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTESparks)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTESparks::IsInitialized() const {
  return true;
}

void CMsgTESparks::Swap(CMsgTESparks* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTESparks::InternalSwap(CMsgTESparks* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(origin_, other->origin_);
  swap(direction_, other->direction_);
  swap(magnitude_, other->magnitude_);
  swap(length_, other->length_);
}

::google::protobuf::Metadata CMsgTESparks::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTEPhysicsProp::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTEPhysicsProp_default_instance_._instance.get_mutable()->origin_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgTEPhysicsProp_default_instance_._instance.get_mutable()->velocity_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgTEPhysicsProp_default_instance_._instance.get_mutable()->angles_ = const_cast< ::proto::dota::CMsgQAngle*>(
      ::proto::dota::CMsgQAngle::internal_default_instance());
}
class CMsgTEPhysicsProp::HasBitSetters {
 public:
  static const ::proto::dota::CMsgVector& origin(const CMsgTEPhysicsProp* msg);
  static void set_has_origin(CMsgTEPhysicsProp* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::proto::dota::CMsgVector& velocity(const CMsgTEPhysicsProp* msg);
  static void set_has_velocity(CMsgTEPhysicsProp* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::proto::dota::CMsgQAngle& angles(const CMsgTEPhysicsProp* msg);
  static void set_has_angles(CMsgTEPhysicsProp* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_skin(CMsgTEPhysicsProp* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_flags(CMsgTEPhysicsProp* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_effects(CMsgTEPhysicsProp* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_color(CMsgTEPhysicsProp* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_modelindex(CMsgTEPhysicsProp* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_unused_breakmodelsnottomake(CMsgTEPhysicsProp* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static void set_has_scale(CMsgTEPhysicsProp* msg) {
    msg->_has_bits_[0] |= 0x00000200u;
  }
};

const ::proto::dota::CMsgVector&
CMsgTEPhysicsProp::HasBitSetters::origin(const CMsgTEPhysicsProp* msg) {
  return *msg->origin_;
}
const ::proto::dota::CMsgVector&
CMsgTEPhysicsProp::HasBitSetters::velocity(const CMsgTEPhysicsProp* msg) {
  return *msg->velocity_;
}
const ::proto::dota::CMsgQAngle&
CMsgTEPhysicsProp::HasBitSetters::angles(const CMsgTEPhysicsProp* msg) {
  return *msg->angles_;
}
void CMsgTEPhysicsProp::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEPhysicsProp::clear_velocity() {
  if (velocity_ != nullptr) velocity_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEPhysicsProp::clear_angles() {
  if (angles_ != nullptr) angles_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEPhysicsProp::kOriginFieldNumber;
const int CMsgTEPhysicsProp::kVelocityFieldNumber;
const int CMsgTEPhysicsProp::kAnglesFieldNumber;
const int CMsgTEPhysicsProp::kSkinFieldNumber;
const int CMsgTEPhysicsProp::kFlagsFieldNumber;
const int CMsgTEPhysicsProp::kEffectsFieldNumber;
const int CMsgTEPhysicsProp::kColorFieldNumber;
const int CMsgTEPhysicsProp::kModelindexFieldNumber;
const int CMsgTEPhysicsProp::kUnusedBreakmodelsnottomakeFieldNumber;
const int CMsgTEPhysicsProp::kScaleFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEPhysicsProp::CMsgTEPhysicsProp()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEPhysicsProp)
}
CMsgTEPhysicsProp::CMsgTEPhysicsProp(const CMsgTEPhysicsProp& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_origin()) {
    origin_ = new ::proto::dota::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from.has_velocity()) {
    velocity_ = new ::proto::dota::CMsgVector(*from.velocity_);
  } else {
    velocity_ = nullptr;
  }
  if (from.has_angles()) {
    angles_ = new ::proto::dota::CMsgQAngle(*from.angles_);
  } else {
    angles_ = nullptr;
  }
  ::memcpy(&skin_, &from.skin_,
    static_cast<size_t>(reinterpret_cast<char*>(&scale_) -
    reinterpret_cast<char*>(&skin_)) + sizeof(scale_));
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEPhysicsProp)
}

void CMsgTEPhysicsProp::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTEPhysicsProp_te_2eproto.base);
  ::memset(&origin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&scale_) -
      reinterpret_cast<char*>(&origin_)) + sizeof(scale_));
}

CMsgTEPhysicsProp::~CMsgTEPhysicsProp() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEPhysicsProp)
  SharedDtor();
}

void CMsgTEPhysicsProp::SharedDtor() {
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete velocity_;
  if (this != internal_default_instance()) delete angles_;
}

void CMsgTEPhysicsProp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEPhysicsProp& CMsgTEPhysicsProp::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEPhysicsProp_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEPhysicsProp::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEPhysicsProp)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(velocity_ != nullptr);
      velocity_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(angles_ != nullptr);
      angles_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&skin_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&modelindex_) -
        reinterpret_cast<char*>(&skin_)) + sizeof(modelindex_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&unused_breakmodelsnottomake_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&scale_) -
        reinterpret_cast<char*>(&unused_breakmodelsnottomake_)) + sizeof(scale_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEPhysicsProp::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEPhysicsProp*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_origin();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgVector velocity = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_velocity();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgQAngle angles = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgQAngle::_InternalParse;
        object = msg->mutable_angles();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional fixed32 skin = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 37) goto handle_unusual;
        msg->set_skin(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint32>(ptr));
        ptr += sizeof(::google::protobuf::uint32);
        break;
      }
      // optional uint32 flags = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_flags(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 effects = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        msg->set_effects(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional fixed32 color = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 61) goto handle_unusual;
        msg->set_color(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint32>(ptr));
        ptr += sizeof(::google::protobuf::uint32);
        break;
      }
      // optional fixed64 modelindex = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 65) goto handle_unusual;
        msg->set_modelindex(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr));
        ptr += sizeof(::google::protobuf::uint64);
        break;
      }
      // optional uint32 unused_breakmodelsnottomake = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 72) goto handle_unusual;
        msg->set_unused_breakmodelsnottomake(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional float scale = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 85) goto handle_unusual;
        msg->set_scale(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEPhysicsProp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEPhysicsProp)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgVector velocity = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_velocity()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgQAngle angles = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_angles()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed32 skin = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (37 & 0xFF)) {
          HasBitSetters::set_has_skin(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &skin_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 flags = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_flags(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 effects = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_effects(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &effects_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed32 color = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (61 & 0xFF)) {
          HasBitSetters::set_has_color(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &color_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed64 modelindex = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (65 & 0xFF)) {
          HasBitSetters::set_has_modelindex(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &modelindex_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 unused_breakmodelsnottomake = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_unused_breakmodelsnottomake(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unused_breakmodelsnottomake_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float scale = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (85 & 0xFF)) {
          HasBitSetters::set_has_scale(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &scale_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEPhysicsProp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEPhysicsProp)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEPhysicsProp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEPhysicsProp)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::origin(this), output);
  }

  // optional .proto.dota.CMsgVector velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::velocity(this), output);
  }

  // optional .proto.dota.CMsgQAngle angles = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::angles(this), output);
  }

  // optional fixed32 skin = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(4, this->skin(), output);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->flags(), output);
  }

  // optional uint32 effects = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->effects(), output);
  }

  // optional fixed32 color = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(7, this->color(), output);
  }

  // optional fixed64 modelindex = 8;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(8, this->modelindex(), output);
  }

  // optional uint32 unused_breakmodelsnottomake = 9;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->unused_breakmodelsnottomake(), output);
  }

  // optional float scale = 10;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->scale(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEPhysicsProp)
}

::google::protobuf::uint8* CMsgTEPhysicsProp::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEPhysicsProp)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::origin(this), target);
  }

  // optional .proto.dota.CMsgVector velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::velocity(this), target);
  }

  // optional .proto.dota.CMsgQAngle angles = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::angles(this), target);
  }

  // optional fixed32 skin = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(4, this->skin(), target);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->flags(), target);
  }

  // optional uint32 effects = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->effects(), target);
  }

  // optional fixed32 color = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(7, this->color(), target);
  }

  // optional fixed64 modelindex = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(8, this->modelindex(), target);
  }

  // optional uint32 unused_breakmodelsnottomake = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->unused_breakmodelsnottomake(), target);
  }

  // optional float scale = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(10, this->scale(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEPhysicsProp)
  return target;
}

size_t CMsgTEPhysicsProp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEPhysicsProp)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .proto.dota.CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .proto.dota.CMsgVector velocity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *velocity_);
    }

    // optional .proto.dota.CMsgQAngle angles = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *angles_);
    }

    // optional fixed32 skin = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional uint32 flags = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

    // optional uint32 effects = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->effects());
    }

    // optional fixed32 color = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional fixed64 modelindex = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 unused_breakmodelsnottomake = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unused_breakmodelsnottomake());
    }

    // optional float scale = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEPhysicsProp::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEPhysicsProp)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEPhysicsProp* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEPhysicsProp>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEPhysicsProp)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEPhysicsProp)
    MergeFrom(*source);
  }
}

void CMsgTEPhysicsProp::MergeFrom(const CMsgTEPhysicsProp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEPhysicsProp)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_origin()->::proto::dota::CMsgVector::MergeFrom(from.origin());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_velocity()->::proto::dota::CMsgVector::MergeFrom(from.velocity());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_angles()->::proto::dota::CMsgQAngle::MergeFrom(from.angles());
    }
    if (cached_has_bits & 0x00000008u) {
      skin_ = from.skin_;
    }
    if (cached_has_bits & 0x00000010u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000020u) {
      effects_ = from.effects_;
    }
    if (cached_has_bits & 0x00000040u) {
      color_ = from.color_;
    }
    if (cached_has_bits & 0x00000080u) {
      modelindex_ = from.modelindex_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      unused_breakmodelsnottomake_ = from.unused_breakmodelsnottomake_;
    }
    if (cached_has_bits & 0x00000200u) {
      scale_ = from.scale_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEPhysicsProp::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEPhysicsProp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEPhysicsProp::CopyFrom(const CMsgTEPhysicsProp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEPhysicsProp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEPhysicsProp::IsInitialized() const {
  return true;
}

void CMsgTEPhysicsProp::Swap(CMsgTEPhysicsProp* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEPhysicsProp::InternalSwap(CMsgTEPhysicsProp* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(origin_, other->origin_);
  swap(velocity_, other->velocity_);
  swap(angles_, other->angles_);
  swap(skin_, other->skin_);
  swap(flags_, other->flags_);
  swap(effects_, other->effects_);
  swap(color_, other->color_);
  swap(modelindex_, other->modelindex_);
  swap(unused_breakmodelsnottomake_, other->unused_breakmodelsnottomake_);
  swap(scale_, other->scale_);
}

::google::protobuf::Metadata CMsgTEPhysicsProp::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTEPlayerDecal::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTEPlayerDecal_default_instance_._instance.get_mutable()->origin_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
}
class CMsgTEPlayerDecal::HasBitSetters {
 public:
  static const ::proto::dota::CMsgVector& origin(const CMsgTEPlayerDecal* msg);
  static void set_has_origin(CMsgTEPlayerDecal* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_player(CMsgTEPlayerDecal* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_entity(CMsgTEPlayerDecal* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

const ::proto::dota::CMsgVector&
CMsgTEPlayerDecal::HasBitSetters::origin(const CMsgTEPlayerDecal* msg) {
  return *msg->origin_;
}
void CMsgTEPlayerDecal::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEPlayerDecal::kOriginFieldNumber;
const int CMsgTEPlayerDecal::kPlayerFieldNumber;
const int CMsgTEPlayerDecal::kEntityFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEPlayerDecal::CMsgTEPlayerDecal()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEPlayerDecal)
}
CMsgTEPlayerDecal::CMsgTEPlayerDecal(const CMsgTEPlayerDecal& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_origin()) {
    origin_ = new ::proto::dota::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  ::memcpy(&player_, &from.player_,
    static_cast<size_t>(reinterpret_cast<char*>(&entity_) -
    reinterpret_cast<char*>(&player_)) + sizeof(entity_));
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEPlayerDecal)
}

void CMsgTEPlayerDecal::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTEPlayerDecal_te_2eproto.base);
  ::memset(&origin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&entity_) -
      reinterpret_cast<char*>(&origin_)) + sizeof(entity_));
}

CMsgTEPlayerDecal::~CMsgTEPlayerDecal() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEPlayerDecal)
  SharedDtor();
}

void CMsgTEPlayerDecal::SharedDtor() {
  if (this != internal_default_instance()) delete origin_;
}

void CMsgTEPlayerDecal::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEPlayerDecal& CMsgTEPlayerDecal::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEPlayerDecal_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEPlayerDecal::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEPlayerDecal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(origin_ != nullptr);
    origin_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&player_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&entity_) -
        reinterpret_cast<char*>(&player_)) + sizeof(entity_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEPlayerDecal::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEPlayerDecal*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_origin();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional uint32 player = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_player(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 entity = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_entity(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEPlayerDecal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEPlayerDecal)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 player = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_player(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 entity = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_entity(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &entity_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEPlayerDecal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEPlayerDecal)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEPlayerDecal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEPlayerDecal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::origin(this), output);
  }

  // optional uint32 player = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->player(), output);
  }

  // optional uint32 entity = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->entity(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEPlayerDecal)
}

::google::protobuf::uint8* CMsgTEPlayerDecal::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEPlayerDecal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::origin(this), target);
  }

  // optional uint32 player = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->player(), target);
  }

  // optional uint32 entity = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->entity(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEPlayerDecal)
  return target;
}

size_t CMsgTEPlayerDecal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEPlayerDecal)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .proto.dota.CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional uint32 player = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player());
    }

    // optional uint32 entity = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->entity());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEPlayerDecal::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEPlayerDecal)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEPlayerDecal* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEPlayerDecal>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEPlayerDecal)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEPlayerDecal)
    MergeFrom(*source);
  }
}

void CMsgTEPlayerDecal::MergeFrom(const CMsgTEPlayerDecal& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEPlayerDecal)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_origin()->::proto::dota::CMsgVector::MergeFrom(from.origin());
    }
    if (cached_has_bits & 0x00000002u) {
      player_ = from.player_;
    }
    if (cached_has_bits & 0x00000004u) {
      entity_ = from.entity_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEPlayerDecal::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEPlayerDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEPlayerDecal::CopyFrom(const CMsgTEPlayerDecal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEPlayerDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEPlayerDecal::IsInitialized() const {
  return true;
}

void CMsgTEPlayerDecal::Swap(CMsgTEPlayerDecal* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEPlayerDecal::InternalSwap(CMsgTEPlayerDecal* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(origin_, other->origin_);
  swap(player_, other->player_);
  swap(entity_, other->entity_);
}

::google::protobuf::Metadata CMsgTEPlayerDecal::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTEProjectedDecal::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTEProjectedDecal_default_instance_._instance.get_mutable()->origin_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgTEProjectedDecal_default_instance_._instance.get_mutable()->angles_ = const_cast< ::proto::dota::CMsgQAngle*>(
      ::proto::dota::CMsgQAngle::internal_default_instance());
}
class CMsgTEProjectedDecal::HasBitSetters {
 public:
  static const ::proto::dota::CMsgVector& origin(const CMsgTEProjectedDecal* msg);
  static void set_has_origin(CMsgTEProjectedDecal* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::proto::dota::CMsgQAngle& angles(const CMsgTEProjectedDecal* msg);
  static void set_has_angles(CMsgTEProjectedDecal* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_index(CMsgTEProjectedDecal* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_distance(CMsgTEProjectedDecal* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
};

const ::proto::dota::CMsgVector&
CMsgTEProjectedDecal::HasBitSetters::origin(const CMsgTEProjectedDecal* msg) {
  return *msg->origin_;
}
const ::proto::dota::CMsgQAngle&
CMsgTEProjectedDecal::HasBitSetters::angles(const CMsgTEProjectedDecal* msg) {
  return *msg->angles_;
}
void CMsgTEProjectedDecal::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEProjectedDecal::clear_angles() {
  if (angles_ != nullptr) angles_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEProjectedDecal::kOriginFieldNumber;
const int CMsgTEProjectedDecal::kAnglesFieldNumber;
const int CMsgTEProjectedDecal::kIndexFieldNumber;
const int CMsgTEProjectedDecal::kDistanceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEProjectedDecal::CMsgTEProjectedDecal()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEProjectedDecal)
}
CMsgTEProjectedDecal::CMsgTEProjectedDecal(const CMsgTEProjectedDecal& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_origin()) {
    origin_ = new ::proto::dota::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from.has_angles()) {
    angles_ = new ::proto::dota::CMsgQAngle(*from.angles_);
  } else {
    angles_ = nullptr;
  }
  ::memcpy(&index_, &from.index_,
    static_cast<size_t>(reinterpret_cast<char*>(&distance_) -
    reinterpret_cast<char*>(&index_)) + sizeof(distance_));
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEProjectedDecal)
}

void CMsgTEProjectedDecal::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTEProjectedDecal_te_2eproto.base);
  ::memset(&origin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&distance_) -
      reinterpret_cast<char*>(&origin_)) + sizeof(distance_));
}

CMsgTEProjectedDecal::~CMsgTEProjectedDecal() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEProjectedDecal)
  SharedDtor();
}

void CMsgTEProjectedDecal::SharedDtor() {
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete angles_;
}

void CMsgTEProjectedDecal::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEProjectedDecal& CMsgTEProjectedDecal::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEProjectedDecal_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEProjectedDecal::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEProjectedDecal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(angles_ != nullptr);
      angles_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&distance_) -
        reinterpret_cast<char*>(&index_)) + sizeof(distance_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEProjectedDecal::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEProjectedDecal*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_origin();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgQAngle angles = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgQAngle::_InternalParse;
        object = msg->mutable_angles();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional uint32 index = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_index(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional float distance = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 37) goto handle_unusual;
        msg->set_distance(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEProjectedDecal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEProjectedDecal)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgQAngle angles = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_angles()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 index = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_index(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float distance = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (37 & 0xFF)) {
          HasBitSetters::set_has_distance(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEProjectedDecal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEProjectedDecal)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEProjectedDecal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEProjectedDecal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::origin(this), output);
  }

  // optional .proto.dota.CMsgQAngle angles = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::angles(this), output);
  }

  // optional uint32 index = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->index(), output);
  }

  // optional float distance = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->distance(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEProjectedDecal)
}

::google::protobuf::uint8* CMsgTEProjectedDecal::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEProjectedDecal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::origin(this), target);
  }

  // optional .proto.dota.CMsgQAngle angles = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::angles(this), target);
  }

  // optional uint32 index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->index(), target);
  }

  // optional float distance = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->distance(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEProjectedDecal)
  return target;
}

size_t CMsgTEProjectedDecal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEProjectedDecal)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .proto.dota.CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .proto.dota.CMsgQAngle angles = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *angles_);
    }

    // optional uint32 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

    // optional float distance = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEProjectedDecal::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEProjectedDecal)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEProjectedDecal* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEProjectedDecal>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEProjectedDecal)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEProjectedDecal)
    MergeFrom(*source);
  }
}

void CMsgTEProjectedDecal::MergeFrom(const CMsgTEProjectedDecal& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEProjectedDecal)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_origin()->::proto::dota::CMsgVector::MergeFrom(from.origin());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_angles()->::proto::dota::CMsgQAngle::MergeFrom(from.angles());
    }
    if (cached_has_bits & 0x00000004u) {
      index_ = from.index_;
    }
    if (cached_has_bits & 0x00000008u) {
      distance_ = from.distance_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEProjectedDecal::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEProjectedDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEProjectedDecal::CopyFrom(const CMsgTEProjectedDecal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEProjectedDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEProjectedDecal::IsInitialized() const {
  return true;
}

void CMsgTEProjectedDecal::Swap(CMsgTEProjectedDecal* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEProjectedDecal::InternalSwap(CMsgTEProjectedDecal* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(origin_, other->origin_);
  swap(angles_, other->angles_);
  swap(index_, other->index_);
  swap(distance_, other->distance_);
}

::google::protobuf::Metadata CMsgTEProjectedDecal::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTESmoke::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTESmoke_default_instance_._instance.get_mutable()->origin_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
}
class CMsgTESmoke::HasBitSetters {
 public:
  static const ::proto::dota::CMsgVector& origin(const CMsgTESmoke* msg);
  static void set_has_origin(CMsgTESmoke* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_scale(CMsgTESmoke* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

const ::proto::dota::CMsgVector&
CMsgTESmoke::HasBitSetters::origin(const CMsgTESmoke* msg) {
  return *msg->origin_;
}
void CMsgTESmoke::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTESmoke::kOriginFieldNumber;
const int CMsgTESmoke::kScaleFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTESmoke::CMsgTESmoke()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTESmoke)
}
CMsgTESmoke::CMsgTESmoke(const CMsgTESmoke& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_origin()) {
    origin_ = new ::proto::dota::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  scale_ = from.scale_;
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTESmoke)
}

void CMsgTESmoke::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTESmoke_te_2eproto.base);
  ::memset(&origin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&scale_) -
      reinterpret_cast<char*>(&origin_)) + sizeof(scale_));
}

CMsgTESmoke::~CMsgTESmoke() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTESmoke)
  SharedDtor();
}

void CMsgTESmoke::SharedDtor() {
  if (this != internal_default_instance()) delete origin_;
}

void CMsgTESmoke::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTESmoke& CMsgTESmoke::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTESmoke_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTESmoke::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTESmoke)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(origin_ != nullptr);
    origin_->Clear();
  }
  scale_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTESmoke::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTESmoke*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_origin();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional float scale = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 21) goto handle_unusual;
        msg->set_scale(::google::protobuf::io::UnalignedLoad<float>(ptr));
        ptr += sizeof(float);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTESmoke::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTESmoke)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float scale = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_scale(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &scale_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTESmoke)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTESmoke)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTESmoke::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTESmoke)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::origin(this), output);
  }

  // optional float scale = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->scale(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTESmoke)
}

::google::protobuf::uint8* CMsgTESmoke::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTESmoke)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::origin(this), target);
  }

  // optional float scale = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->scale(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTESmoke)
  return target;
}

size_t CMsgTESmoke::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTESmoke)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .proto.dota.CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional float scale = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTESmoke::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTESmoke)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTESmoke* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTESmoke>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTESmoke)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTESmoke)
    MergeFrom(*source);
  }
}

void CMsgTESmoke::MergeFrom(const CMsgTESmoke& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTESmoke)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_origin()->::proto::dota::CMsgVector::MergeFrom(from.origin());
    }
    if (cached_has_bits & 0x00000002u) {
      scale_ = from.scale_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTESmoke::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTESmoke)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTESmoke::CopyFrom(const CMsgTESmoke& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTESmoke)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTESmoke::IsInitialized() const {
  return true;
}

void CMsgTESmoke::Swap(CMsgTESmoke* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTESmoke::InternalSwap(CMsgTESmoke* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(origin_, other->origin_);
  swap(scale_, other->scale_);
}

::google::protobuf::Metadata CMsgTESmoke::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CMsgTEWorldDecal::InitAsDefaultInstance() {
  ::proto::dota::_CMsgTEWorldDecal_default_instance_._instance.get_mutable()->origin_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
  ::proto::dota::_CMsgTEWorldDecal_default_instance_._instance.get_mutable()->normal_ = const_cast< ::proto::dota::CMsgVector*>(
      ::proto::dota::CMsgVector::internal_default_instance());
}
class CMsgTEWorldDecal::HasBitSetters {
 public:
  static const ::proto::dota::CMsgVector& origin(const CMsgTEWorldDecal* msg);
  static void set_has_origin(CMsgTEWorldDecal* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::proto::dota::CMsgVector& normal(const CMsgTEWorldDecal* msg);
  static void set_has_normal(CMsgTEWorldDecal* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_index(CMsgTEWorldDecal* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

const ::proto::dota::CMsgVector&
CMsgTEWorldDecal::HasBitSetters::origin(const CMsgTEWorldDecal* msg) {
  return *msg->origin_;
}
const ::proto::dota::CMsgVector&
CMsgTEWorldDecal::HasBitSetters::normal(const CMsgTEWorldDecal* msg) {
  return *msg->normal_;
}
void CMsgTEWorldDecal::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEWorldDecal::clear_normal() {
  if (normal_ != nullptr) normal_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CMsgTEWorldDecal::kOriginFieldNumber;
const int CMsgTEWorldDecal::kNormalFieldNumber;
const int CMsgTEWorldDecal::kIndexFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CMsgTEWorldDecal::CMsgTEWorldDecal()
  : ::google::protobuf::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.dota.CMsgTEWorldDecal)
}
CMsgTEWorldDecal::CMsgTEWorldDecal(const CMsgTEWorldDecal& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_origin()) {
    origin_ = new ::proto::dota::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from.has_normal()) {
    normal_ = new ::proto::dota::CMsgVector(*from.normal_);
  } else {
    normal_ = nullptr;
  }
  index_ = from.index_;
  // @@protoc_insertion_point(copy_constructor:proto.dota.CMsgTEWorldDecal)
}

void CMsgTEWorldDecal::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CMsgTEWorldDecal_te_2eproto.base);
  ::memset(&origin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&index_) -
      reinterpret_cast<char*>(&origin_)) + sizeof(index_));
}

CMsgTEWorldDecal::~CMsgTEWorldDecal() {
  // @@protoc_insertion_point(destructor:proto.dota.CMsgTEWorldDecal)
  SharedDtor();
}

void CMsgTEWorldDecal::SharedDtor() {
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete normal_;
}

void CMsgTEWorldDecal::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CMsgTEWorldDecal& CMsgTEWorldDecal::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CMsgTEWorldDecal_te_2eproto.base);
  return *internal_default_instance();
}


void CMsgTEWorldDecal::Clear() {
// @@protoc_insertion_point(message_clear_start:proto.dota.CMsgTEWorldDecal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(normal_ != nullptr);
      normal_->Clear();
    }
  }
  index_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CMsgTEWorldDecal::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CMsgTEWorldDecal*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_origin();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .proto.dota.CMsgVector normal = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::proto::dota::CMsgVector::_InternalParse;
        object = msg->mutable_normal();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional uint32 index = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_index(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CMsgTEWorldDecal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.dota.CMsgTEWorldDecal)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.dota.CMsgVector origin = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .proto.dota.CMsgVector normal = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_normal()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 index = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_index(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.dota.CMsgTEWorldDecal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.dota.CMsgTEWorldDecal)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CMsgTEWorldDecal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.dota.CMsgTEWorldDecal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::origin(this), output);
  }

  // optional .proto.dota.CMsgVector normal = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::normal(this), output);
  }

  // optional uint32 index = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->index(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:proto.dota.CMsgTEWorldDecal)
}

::google::protobuf::uint8* CMsgTEWorldDecal::InternalSerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.dota.CMsgTEWorldDecal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .proto.dota.CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::origin(this), target);
  }

  // optional .proto.dota.CMsgVector normal = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::normal(this), target);
  }

  // optional uint32 index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->index(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:proto.dota.CMsgTEWorldDecal)
  return target;
}

size_t CMsgTEWorldDecal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:proto.dota.CMsgTEWorldDecal)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .proto.dota.CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .proto.dota.CMsgVector normal = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *normal_);
    }

    // optional uint32 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEWorldDecal::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:proto.dota.CMsgTEWorldDecal)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEWorldDecal* source =
      ::google::protobuf::DynamicCastToGenerated<CMsgTEWorldDecal>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:proto.dota.CMsgTEWorldDecal)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:proto.dota.CMsgTEWorldDecal)
    MergeFrom(*source);
  }
}

void CMsgTEWorldDecal::MergeFrom(const CMsgTEWorldDecal& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:proto.dota.CMsgTEWorldDecal)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_origin()->::proto::dota::CMsgVector::MergeFrom(from.origin());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_normal()->::proto::dota::CMsgVector::MergeFrom(from.normal());
    }
    if (cached_has_bits & 0x00000004u) {
      index_ = from.index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEWorldDecal::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:proto.dota.CMsgTEWorldDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEWorldDecal::CopyFrom(const CMsgTEWorldDecal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:proto.dota.CMsgTEWorldDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEWorldDecal::IsInitialized() const {
  return true;
}

void CMsgTEWorldDecal::Swap(CMsgTEWorldDecal* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CMsgTEWorldDecal::InternalSwap(CMsgTEWorldDecal* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(origin_, other->origin_);
  swap(normal_, other->normal_);
  swap(index_, other->index_);
}

::google::protobuf::Metadata CMsgTEWorldDecal::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_te_2eproto);
  return ::file_level_metadata_te_2eproto[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace dota
}  // namespace proto
namespace google {
namespace protobuf {
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEArmorRicochet* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEArmorRicochet >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEArmorRicochet >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEBaseBeam* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEBaseBeam >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEBaseBeam >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEBeamEntPoint* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEBeamEntPoint >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEBeamEntPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEBeamEnts* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEBeamEnts >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEBeamEnts >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEBeamPoints* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEBeamPoints >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEBeamPoints >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEBeamRing* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEBeamRing >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEBeamRing >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEBreakModel* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEBreakModel >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEBreakModel >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEBSPDecal* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEBSPDecal >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEBSPDecal >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEBubbles* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEBubbles >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEBubbles >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEBubbleTrail* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEBubbleTrail >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEBubbleTrail >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEDecal* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEDecal >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEDecal >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgEffectData* Arena::CreateMaybeMessage< ::proto::dota::CMsgEffectData >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgEffectData >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEEffectDispatch* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEEffectDispatch >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEEffectDispatch >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEEnergySplash* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEEnergySplash >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEEnergySplash >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEFizz* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEFizz >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEFizz >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEShatterSurface* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEShatterSurface >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEShatterSurface >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEGlowSprite* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEGlowSprite >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEGlowSprite >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEImpact* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEImpact >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEImpact >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEMuzzleFlash* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEMuzzleFlash >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEMuzzleFlash >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEBloodStream* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEBloodStream >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEBloodStream >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEExplosion* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEExplosion >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEExplosion >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEDust* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEDust >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEDust >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTELargeFunnel* Arena::CreateMaybeMessage< ::proto::dota::CMsgTELargeFunnel >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTELargeFunnel >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTESparks* Arena::CreateMaybeMessage< ::proto::dota::CMsgTESparks >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTESparks >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEPhysicsProp* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEPhysicsProp >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEPhysicsProp >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEPlayerDecal* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEPlayerDecal >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEPlayerDecal >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEProjectedDecal* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEProjectedDecal >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEProjectedDecal >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTESmoke* Arena::CreateMaybeMessage< ::proto::dota::CMsgTESmoke >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTESmoke >(arena);
}
template<> PROTOBUF_NOINLINE ::proto::dota::CMsgTEWorldDecal* Arena::CreateMaybeMessage< ::proto::dota::CMsgTEWorldDecal >(Arena* arena) {
  return Arena::CreateInternal< ::proto::dota::CMsgTEWorldDecal >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
