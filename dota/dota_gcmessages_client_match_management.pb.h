// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dota_gcmessages_client_match_management.proto

#ifndef PROTOBUF_INCLUDED_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto
#define PROTOBUF_INCLUDED_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "steammessages.pb.h"
#include "dota_shared_enums.pb.h"
#include "dota_client_enums.pb.h"
#include "base_gcmessages.pb.h"
#include "dota_gcmessages_common_match_management.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[64]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto();
namespace proto {
namespace dota {
class CMsgAbandonCurrentGame;
class CMsgAbandonCurrentGameDefaultTypeInternal;
extern CMsgAbandonCurrentGameDefaultTypeInternal _CMsgAbandonCurrentGame_default_instance_;
class CMsgApplyTeamToPracticeLobby;
class CMsgApplyTeamToPracticeLobbyDefaultTypeInternal;
extern CMsgApplyTeamToPracticeLobbyDefaultTypeInternal _CMsgApplyTeamToPracticeLobby_default_instance_;
class CMsgBotGameCreate;
class CMsgBotGameCreateDefaultTypeInternal;
extern CMsgBotGameCreateDefaultTypeInternal _CMsgBotGameCreate_default_instance_;
class CMsgClearPracticeLobbyTeam;
class CMsgClearPracticeLobbyTeamDefaultTypeInternal;
extern CMsgClearPracticeLobbyTeamDefaultTypeInternal _CMsgClearPracticeLobbyTeam_default_instance_;
class CMsgClientToGCRequestSteamDatagramTicket;
class CMsgClientToGCRequestSteamDatagramTicketDefaultTypeInternal;
extern CMsgClientToGCRequestSteamDatagramTicketDefaultTypeInternal _CMsgClientToGCRequestSteamDatagramTicket_default_instance_;
class CMsgClientToGCRequestSteamDatagramTicketResponse;
class CMsgClientToGCRequestSteamDatagramTicketResponseDefaultTypeInternal;
extern CMsgClientToGCRequestSteamDatagramTicketResponseDefaultTypeInternal _CMsgClientToGCRequestSteamDatagramTicketResponse_default_instance_;
class CMsgCreateSpectatorLobby;
class CMsgCreateSpectatorLobbyDefaultTypeInternal;
extern CMsgCreateSpectatorLobbyDefaultTypeInternal _CMsgCreateSpectatorLobby_default_instance_;
class CMsgCustomGameCreate;
class CMsgCustomGameCreateDefaultTypeInternal;
extern CMsgCustomGameCreateDefaultTypeInternal _CMsgCustomGameCreate_default_instance_;
class CMsgDOTACancelGroupInvites;
class CMsgDOTACancelGroupInvitesDefaultTypeInternal;
extern CMsgDOTACancelGroupInvitesDefaultTypeInternal _CMsgDOTACancelGroupInvites_default_instance_;
class CMsgDOTAGroupMergeInvite;
class CMsgDOTAGroupMergeInviteDefaultTypeInternal;
extern CMsgDOTAGroupMergeInviteDefaultTypeInternal _CMsgDOTAGroupMergeInvite_default_instance_;
class CMsgDOTAGroupMergeReply;
class CMsgDOTAGroupMergeReplyDefaultTypeInternal;
extern CMsgDOTAGroupMergeReplyDefaultTypeInternal _CMsgDOTAGroupMergeReply_default_instance_;
class CMsgDOTAGroupMergeResponse;
class CMsgDOTAGroupMergeResponseDefaultTypeInternal;
extern CMsgDOTAGroupMergeResponseDefaultTypeInternal _CMsgDOTAGroupMergeResponse_default_instance_;
class CMsgDOTAPartyMemberSetCoach;
class CMsgDOTAPartyMemberSetCoachDefaultTypeInternal;
extern CMsgDOTAPartyMemberSetCoachDefaultTypeInternal _CMsgDOTAPartyMemberSetCoach_default_instance_;
class CMsgDOTASetGroupLeader;
class CMsgDOTASetGroupLeaderDefaultTypeInternal;
extern CMsgDOTASetGroupLeaderDefaultTypeInternal _CMsgDOTASetGroupLeader_default_instance_;
class CMsgDOTASetGroupOpenStatus;
class CMsgDOTASetGroupOpenStatusDefaultTypeInternal;
extern CMsgDOTASetGroupOpenStatusDefaultTypeInternal _CMsgDOTASetGroupOpenStatus_default_instance_;
class CMsgEventGameCreate;
class CMsgEventGameCreateDefaultTypeInternal;
extern CMsgEventGameCreateDefaultTypeInternal _CMsgEventGameCreate_default_instance_;
class CMsgFriendPracticeLobbyListRequest;
class CMsgFriendPracticeLobbyListRequestDefaultTypeInternal;
extern CMsgFriendPracticeLobbyListRequestDefaultTypeInternal _CMsgFriendPracticeLobbyListRequest_default_instance_;
class CMsgFriendPracticeLobbyListResponse;
class CMsgFriendPracticeLobbyListResponseDefaultTypeInternal;
extern CMsgFriendPracticeLobbyListResponseDefaultTypeInternal _CMsgFriendPracticeLobbyListResponse_default_instance_;
class CMsgGCToClientRequestLaneSelection;
class CMsgGCToClientRequestLaneSelectionDefaultTypeInternal;
extern CMsgGCToClientRequestLaneSelectionDefaultTypeInternal _CMsgGCToClientRequestLaneSelection_default_instance_;
class CMsgGCToClientRequestLaneSelectionResponse;
class CMsgGCToClientRequestLaneSelectionResponseDefaultTypeInternal;
extern CMsgGCToClientRequestLaneSelectionResponseDefaultTypeInternal _CMsgGCToClientRequestLaneSelectionResponse_default_instance_;
class CMsgGCToClientSteamDatagramTicket;
class CMsgGCToClientSteamDatagramTicketDefaultTypeInternal;
extern CMsgGCToClientSteamDatagramTicketDefaultTypeInternal _CMsgGCToClientSteamDatagramTicket_default_instance_;
class CMsgGuildmatePracticeLobbyListRequest;
class CMsgGuildmatePracticeLobbyListRequestDefaultTypeInternal;
extern CMsgGuildmatePracticeLobbyListRequestDefaultTypeInternal _CMsgGuildmatePracticeLobbyListRequest_default_instance_;
class CMsgGuildmatePracticeLobbyListResponse;
class CMsgGuildmatePracticeLobbyListResponseDefaultTypeInternal;
extern CMsgGuildmatePracticeLobbyListResponseDefaultTypeInternal _CMsgGuildmatePracticeLobbyListResponse_default_instance_;
class CMsgJoinableCustomGameModesRequest;
class CMsgJoinableCustomGameModesRequestDefaultTypeInternal;
extern CMsgJoinableCustomGameModesRequestDefaultTypeInternal _CMsgJoinableCustomGameModesRequest_default_instance_;
class CMsgJoinableCustomGameModesResponse;
class CMsgJoinableCustomGameModesResponseDefaultTypeInternal;
extern CMsgJoinableCustomGameModesResponseDefaultTypeInternal _CMsgJoinableCustomGameModesResponse_default_instance_;
class CMsgJoinableCustomGameModesResponseEntry;
class CMsgJoinableCustomGameModesResponseEntryDefaultTypeInternal;
extern CMsgJoinableCustomGameModesResponseEntryDefaultTypeInternal _CMsgJoinableCustomGameModesResponseEntry_default_instance_;
class CMsgJoinableCustomLobbiesRequest;
class CMsgJoinableCustomLobbiesRequestDefaultTypeInternal;
extern CMsgJoinableCustomLobbiesRequestDefaultTypeInternal _CMsgJoinableCustomLobbiesRequest_default_instance_;
class CMsgJoinableCustomLobbiesResponse;
class CMsgJoinableCustomLobbiesResponseDefaultTypeInternal;
extern CMsgJoinableCustomLobbiesResponseDefaultTypeInternal _CMsgJoinableCustomLobbiesResponse_default_instance_;
class CMsgJoinableCustomLobbiesResponseEntry;
class CMsgJoinableCustomLobbiesResponseEntryDefaultTypeInternal;
extern CMsgJoinableCustomLobbiesResponseEntryDefaultTypeInternal _CMsgJoinableCustomLobbiesResponseEntry_default_instance_;
class CMsgLobbyList;
class CMsgLobbyListDefaultTypeInternal;
extern CMsgLobbyListDefaultTypeInternal _CMsgLobbyList_default_instance_;
class CMsgLobbyListResponse;
class CMsgLobbyListResponseDefaultTypeInternal;
extern CMsgLobbyListResponseDefaultTypeInternal _CMsgLobbyListResponse_default_instance_;
class CMsgPartyBuilderOptions;
class CMsgPartyBuilderOptionsDefaultTypeInternal;
extern CMsgPartyBuilderOptionsDefaultTypeInternal _CMsgPartyBuilderOptions_default_instance_;
class CMsgPracticeLobbyCloseBroadcastChannel;
class CMsgPracticeLobbyCloseBroadcastChannelDefaultTypeInternal;
extern CMsgPracticeLobbyCloseBroadcastChannelDefaultTypeInternal _CMsgPracticeLobbyCloseBroadcastChannel_default_instance_;
class CMsgPracticeLobbyCreate;
class CMsgPracticeLobbyCreateDefaultTypeInternal;
extern CMsgPracticeLobbyCreateDefaultTypeInternal _CMsgPracticeLobbyCreate_default_instance_;
class CMsgPracticeLobbyCreate_SaveGame;
class CMsgPracticeLobbyCreate_SaveGameDefaultTypeInternal;
extern CMsgPracticeLobbyCreate_SaveGameDefaultTypeInternal _CMsgPracticeLobbyCreate_SaveGame_default_instance_;
class CMsgPracticeLobbyJoin;
class CMsgPracticeLobbyJoinDefaultTypeInternal;
extern CMsgPracticeLobbyJoinDefaultTypeInternal _CMsgPracticeLobbyJoin_default_instance_;
class CMsgPracticeLobbyJoinBroadcastChannel;
class CMsgPracticeLobbyJoinBroadcastChannelDefaultTypeInternal;
extern CMsgPracticeLobbyJoinBroadcastChannelDefaultTypeInternal _CMsgPracticeLobbyJoinBroadcastChannel_default_instance_;
class CMsgPracticeLobbyJoinResponse;
class CMsgPracticeLobbyJoinResponseDefaultTypeInternal;
extern CMsgPracticeLobbyJoinResponseDefaultTypeInternal _CMsgPracticeLobbyJoinResponse_default_instance_;
class CMsgPracticeLobbyKick;
class CMsgPracticeLobbyKickDefaultTypeInternal;
extern CMsgPracticeLobbyKickDefaultTypeInternal _CMsgPracticeLobbyKick_default_instance_;
class CMsgPracticeLobbyKickFromTeam;
class CMsgPracticeLobbyKickFromTeamDefaultTypeInternal;
extern CMsgPracticeLobbyKickFromTeamDefaultTypeInternal _CMsgPracticeLobbyKickFromTeam_default_instance_;
class CMsgPracticeLobbyLaunch;
class CMsgPracticeLobbyLaunchDefaultTypeInternal;
extern CMsgPracticeLobbyLaunchDefaultTypeInternal _CMsgPracticeLobbyLaunch_default_instance_;
class CMsgPracticeLobbyLeave;
class CMsgPracticeLobbyLeaveDefaultTypeInternal;
extern CMsgPracticeLobbyLeaveDefaultTypeInternal _CMsgPracticeLobbyLeave_default_instance_;
class CMsgPracticeLobbyList;
class CMsgPracticeLobbyListDefaultTypeInternal;
extern CMsgPracticeLobbyListDefaultTypeInternal _CMsgPracticeLobbyList_default_instance_;
class CMsgPracticeLobbyListResponse;
class CMsgPracticeLobbyListResponseDefaultTypeInternal;
extern CMsgPracticeLobbyListResponseDefaultTypeInternal _CMsgPracticeLobbyListResponse_default_instance_;
class CMsgPracticeLobbyListResponseEntry;
class CMsgPracticeLobbyListResponseEntryDefaultTypeInternal;
extern CMsgPracticeLobbyListResponseEntryDefaultTypeInternal _CMsgPracticeLobbyListResponseEntry_default_instance_;
class CMsgPracticeLobbyListResponseEntry_CLobbyMember;
class CMsgPracticeLobbyListResponseEntry_CLobbyMemberDefaultTypeInternal;
extern CMsgPracticeLobbyListResponseEntry_CLobbyMemberDefaultTypeInternal _CMsgPracticeLobbyListResponseEntry_CLobbyMember_default_instance_;
class CMsgPracticeLobbySetCoach;
class CMsgPracticeLobbySetCoachDefaultTypeInternal;
extern CMsgPracticeLobbySetCoachDefaultTypeInternal _CMsgPracticeLobbySetCoach_default_instance_;
class CMsgPracticeLobbySetDetails;
class CMsgPracticeLobbySetDetailsDefaultTypeInternal;
extern CMsgPracticeLobbySetDetailsDefaultTypeInternal _CMsgPracticeLobbySetDetails_default_instance_;
class CMsgPracticeLobbySetTeamSlot;
class CMsgPracticeLobbySetTeamSlotDefaultTypeInternal;
extern CMsgPracticeLobbySetTeamSlotDefaultTypeInternal _CMsgPracticeLobbySetTeamSlot_default_instance_;
class CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus;
class CMsgPracticeLobbyToggleBroadcastChannelCameramanStatusDefaultTypeInternal;
extern CMsgPracticeLobbyToggleBroadcastChannelCameramanStatusDefaultTypeInternal _CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus_default_instance_;
class CMsgQuickJoinCustomLobby;
class CMsgQuickJoinCustomLobbyDefaultTypeInternal;
extern CMsgQuickJoinCustomLobbyDefaultTypeInternal _CMsgQuickJoinCustomLobby_default_instance_;
class CMsgQuickJoinCustomLobbyResponse;
class CMsgQuickJoinCustomLobbyResponseDefaultTypeInternal;
extern CMsgQuickJoinCustomLobbyResponseDefaultTypeInternal _CMsgQuickJoinCustomLobbyResponse_default_instance_;
class CMsgQuickJoinCustomLobby_LegacyRegionPing;
class CMsgQuickJoinCustomLobby_LegacyRegionPingDefaultTypeInternal;
extern CMsgQuickJoinCustomLobby_LegacyRegionPingDefaultTypeInternal _CMsgQuickJoinCustomLobby_LegacyRegionPing_default_instance_;
class CMsgReadyUp;
class CMsgReadyUpDefaultTypeInternal;
extern CMsgReadyUpDefaultTypeInternal _CMsgReadyUp_default_instance_;
class CMsgReadyUpStatus;
class CMsgReadyUpStatusDefaultTypeInternal;
extern CMsgReadyUpStatusDefaultTypeInternal _CMsgReadyUpStatus_default_instance_;
class CMsgSetSpectatorLobbyDetails;
class CMsgSetSpectatorLobbyDetailsDefaultTypeInternal;
extern CMsgSetSpectatorLobbyDetailsDefaultTypeInternal _CMsgSetSpectatorLobbyDetails_default_instance_;
class CMsgSpectatorLobbyGameDetails;
class CMsgSpectatorLobbyGameDetailsDefaultTypeInternal;
extern CMsgSpectatorLobbyGameDetailsDefaultTypeInternal _CMsgSpectatorLobbyGameDetails_default_instance_;
class CMsgSpectatorLobbyGameDetails_Team;
class CMsgSpectatorLobbyGameDetails_TeamDefaultTypeInternal;
extern CMsgSpectatorLobbyGameDetails_TeamDefaultTypeInternal _CMsgSpectatorLobbyGameDetails_Team_default_instance_;
class CMsgSpectatorLobbyList;
class CMsgSpectatorLobbyListDefaultTypeInternal;
extern CMsgSpectatorLobbyListDefaultTypeInternal _CMsgSpectatorLobbyList_default_instance_;
class CMsgSpectatorLobbyListResponse;
class CMsgSpectatorLobbyListResponseDefaultTypeInternal;
extern CMsgSpectatorLobbyListResponseDefaultTypeInternal _CMsgSpectatorLobbyListResponse_default_instance_;
class CMsgSpectatorLobbyListResponse_SpectatorLobby;
class CMsgSpectatorLobbyListResponse_SpectatorLobbyDefaultTypeInternal;
extern CMsgSpectatorLobbyListResponse_SpectatorLobbyDefaultTypeInternal _CMsgSpectatorLobbyListResponse_SpectatorLobby_default_instance_;
class CMsgStartFindingMatch;
class CMsgStartFindingMatchDefaultTypeInternal;
extern CMsgStartFindingMatchDefaultTypeInternal _CMsgStartFindingMatch_default_instance_;
class CMsgStartFindingMatchResult;
class CMsgStartFindingMatchResultDefaultTypeInternal;
extern CMsgStartFindingMatchResultDefaultTypeInternal _CMsgStartFindingMatchResult_default_instance_;
class CMsgStopFindingMatch;
class CMsgStopFindingMatchDefaultTypeInternal;
extern CMsgStopFindingMatchDefaultTypeInternal _CMsgStopFindingMatch_default_instance_;
}  // namespace dota
}  // namespace proto
namespace google {
namespace protobuf {
template<> ::proto::dota::CMsgAbandonCurrentGame* Arena::CreateMaybeMessage<::proto::dota::CMsgAbandonCurrentGame>(Arena*);
template<> ::proto::dota::CMsgApplyTeamToPracticeLobby* Arena::CreateMaybeMessage<::proto::dota::CMsgApplyTeamToPracticeLobby>(Arena*);
template<> ::proto::dota::CMsgBotGameCreate* Arena::CreateMaybeMessage<::proto::dota::CMsgBotGameCreate>(Arena*);
template<> ::proto::dota::CMsgClearPracticeLobbyTeam* Arena::CreateMaybeMessage<::proto::dota::CMsgClearPracticeLobbyTeam>(Arena*);
template<> ::proto::dota::CMsgClientToGCRequestSteamDatagramTicket* Arena::CreateMaybeMessage<::proto::dota::CMsgClientToGCRequestSteamDatagramTicket>(Arena*);
template<> ::proto::dota::CMsgClientToGCRequestSteamDatagramTicketResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgClientToGCRequestSteamDatagramTicketResponse>(Arena*);
template<> ::proto::dota::CMsgCreateSpectatorLobby* Arena::CreateMaybeMessage<::proto::dota::CMsgCreateSpectatorLobby>(Arena*);
template<> ::proto::dota::CMsgCustomGameCreate* Arena::CreateMaybeMessage<::proto::dota::CMsgCustomGameCreate>(Arena*);
template<> ::proto::dota::CMsgDOTACancelGroupInvites* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTACancelGroupInvites>(Arena*);
template<> ::proto::dota::CMsgDOTAGroupMergeInvite* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAGroupMergeInvite>(Arena*);
template<> ::proto::dota::CMsgDOTAGroupMergeReply* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAGroupMergeReply>(Arena*);
template<> ::proto::dota::CMsgDOTAGroupMergeResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAGroupMergeResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAPartyMemberSetCoach* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAPartyMemberSetCoach>(Arena*);
template<> ::proto::dota::CMsgDOTASetGroupLeader* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTASetGroupLeader>(Arena*);
template<> ::proto::dota::CMsgDOTASetGroupOpenStatus* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTASetGroupOpenStatus>(Arena*);
template<> ::proto::dota::CMsgEventGameCreate* Arena::CreateMaybeMessage<::proto::dota::CMsgEventGameCreate>(Arena*);
template<> ::proto::dota::CMsgFriendPracticeLobbyListRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgFriendPracticeLobbyListRequest>(Arena*);
template<> ::proto::dota::CMsgFriendPracticeLobbyListResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgFriendPracticeLobbyListResponse>(Arena*);
template<> ::proto::dota::CMsgGCToClientRequestLaneSelection* Arena::CreateMaybeMessage<::proto::dota::CMsgGCToClientRequestLaneSelection>(Arena*);
template<> ::proto::dota::CMsgGCToClientRequestLaneSelectionResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgGCToClientRequestLaneSelectionResponse>(Arena*);
template<> ::proto::dota::CMsgGCToClientSteamDatagramTicket* Arena::CreateMaybeMessage<::proto::dota::CMsgGCToClientSteamDatagramTicket>(Arena*);
template<> ::proto::dota::CMsgGuildmatePracticeLobbyListRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgGuildmatePracticeLobbyListRequest>(Arena*);
template<> ::proto::dota::CMsgGuildmatePracticeLobbyListResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgGuildmatePracticeLobbyListResponse>(Arena*);
template<> ::proto::dota::CMsgJoinableCustomGameModesRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgJoinableCustomGameModesRequest>(Arena*);
template<> ::proto::dota::CMsgJoinableCustomGameModesResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgJoinableCustomGameModesResponse>(Arena*);
template<> ::proto::dota::CMsgJoinableCustomGameModesResponseEntry* Arena::CreateMaybeMessage<::proto::dota::CMsgJoinableCustomGameModesResponseEntry>(Arena*);
template<> ::proto::dota::CMsgJoinableCustomLobbiesRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgJoinableCustomLobbiesRequest>(Arena*);
template<> ::proto::dota::CMsgJoinableCustomLobbiesResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgJoinableCustomLobbiesResponse>(Arena*);
template<> ::proto::dota::CMsgJoinableCustomLobbiesResponseEntry* Arena::CreateMaybeMessage<::proto::dota::CMsgJoinableCustomLobbiesResponseEntry>(Arena*);
template<> ::proto::dota::CMsgLobbyList* Arena::CreateMaybeMessage<::proto::dota::CMsgLobbyList>(Arena*);
template<> ::proto::dota::CMsgLobbyListResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgLobbyListResponse>(Arena*);
template<> ::proto::dota::CMsgPartyBuilderOptions* Arena::CreateMaybeMessage<::proto::dota::CMsgPartyBuilderOptions>(Arena*);
template<> ::proto::dota::CMsgPracticeLobbyCloseBroadcastChannel* Arena::CreateMaybeMessage<::proto::dota::CMsgPracticeLobbyCloseBroadcastChannel>(Arena*);
template<> ::proto::dota::CMsgPracticeLobbyCreate* Arena::CreateMaybeMessage<::proto::dota::CMsgPracticeLobbyCreate>(Arena*);
template<> ::proto::dota::CMsgPracticeLobbyCreate_SaveGame* Arena::CreateMaybeMessage<::proto::dota::CMsgPracticeLobbyCreate_SaveGame>(Arena*);
template<> ::proto::dota::CMsgPracticeLobbyJoin* Arena::CreateMaybeMessage<::proto::dota::CMsgPracticeLobbyJoin>(Arena*);
template<> ::proto::dota::CMsgPracticeLobbyJoinBroadcastChannel* Arena::CreateMaybeMessage<::proto::dota::CMsgPracticeLobbyJoinBroadcastChannel>(Arena*);
template<> ::proto::dota::CMsgPracticeLobbyJoinResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgPracticeLobbyJoinResponse>(Arena*);
template<> ::proto::dota::CMsgPracticeLobbyKick* Arena::CreateMaybeMessage<::proto::dota::CMsgPracticeLobbyKick>(Arena*);
template<> ::proto::dota::CMsgPracticeLobbyKickFromTeam* Arena::CreateMaybeMessage<::proto::dota::CMsgPracticeLobbyKickFromTeam>(Arena*);
template<> ::proto::dota::CMsgPracticeLobbyLaunch* Arena::CreateMaybeMessage<::proto::dota::CMsgPracticeLobbyLaunch>(Arena*);
template<> ::proto::dota::CMsgPracticeLobbyLeave* Arena::CreateMaybeMessage<::proto::dota::CMsgPracticeLobbyLeave>(Arena*);
template<> ::proto::dota::CMsgPracticeLobbyList* Arena::CreateMaybeMessage<::proto::dota::CMsgPracticeLobbyList>(Arena*);
template<> ::proto::dota::CMsgPracticeLobbyListResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgPracticeLobbyListResponse>(Arena*);
template<> ::proto::dota::CMsgPracticeLobbyListResponseEntry* Arena::CreateMaybeMessage<::proto::dota::CMsgPracticeLobbyListResponseEntry>(Arena*);
template<> ::proto::dota::CMsgPracticeLobbyListResponseEntry_CLobbyMember* Arena::CreateMaybeMessage<::proto::dota::CMsgPracticeLobbyListResponseEntry_CLobbyMember>(Arena*);
template<> ::proto::dota::CMsgPracticeLobbySetCoach* Arena::CreateMaybeMessage<::proto::dota::CMsgPracticeLobbySetCoach>(Arena*);
template<> ::proto::dota::CMsgPracticeLobbySetDetails* Arena::CreateMaybeMessage<::proto::dota::CMsgPracticeLobbySetDetails>(Arena*);
template<> ::proto::dota::CMsgPracticeLobbySetTeamSlot* Arena::CreateMaybeMessage<::proto::dota::CMsgPracticeLobbySetTeamSlot>(Arena*);
template<> ::proto::dota::CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus* Arena::CreateMaybeMessage<::proto::dota::CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus>(Arena*);
template<> ::proto::dota::CMsgQuickJoinCustomLobby* Arena::CreateMaybeMessage<::proto::dota::CMsgQuickJoinCustomLobby>(Arena*);
template<> ::proto::dota::CMsgQuickJoinCustomLobbyResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgQuickJoinCustomLobbyResponse>(Arena*);
template<> ::proto::dota::CMsgQuickJoinCustomLobby_LegacyRegionPing* Arena::CreateMaybeMessage<::proto::dota::CMsgQuickJoinCustomLobby_LegacyRegionPing>(Arena*);
template<> ::proto::dota::CMsgReadyUp* Arena::CreateMaybeMessage<::proto::dota::CMsgReadyUp>(Arena*);
template<> ::proto::dota::CMsgReadyUpStatus* Arena::CreateMaybeMessage<::proto::dota::CMsgReadyUpStatus>(Arena*);
template<> ::proto::dota::CMsgSetSpectatorLobbyDetails* Arena::CreateMaybeMessage<::proto::dota::CMsgSetSpectatorLobbyDetails>(Arena*);
template<> ::proto::dota::CMsgSpectatorLobbyGameDetails* Arena::CreateMaybeMessage<::proto::dota::CMsgSpectatorLobbyGameDetails>(Arena*);
template<> ::proto::dota::CMsgSpectatorLobbyGameDetails_Team* Arena::CreateMaybeMessage<::proto::dota::CMsgSpectatorLobbyGameDetails_Team>(Arena*);
template<> ::proto::dota::CMsgSpectatorLobbyList* Arena::CreateMaybeMessage<::proto::dota::CMsgSpectatorLobbyList>(Arena*);
template<> ::proto::dota::CMsgSpectatorLobbyListResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgSpectatorLobbyListResponse>(Arena*);
template<> ::proto::dota::CMsgSpectatorLobbyListResponse_SpectatorLobby* Arena::CreateMaybeMessage<::proto::dota::CMsgSpectatorLobbyListResponse_SpectatorLobby>(Arena*);
template<> ::proto::dota::CMsgStartFindingMatch* Arena::CreateMaybeMessage<::proto::dota::CMsgStartFindingMatch>(Arena*);
template<> ::proto::dota::CMsgStartFindingMatchResult* Arena::CreateMaybeMessage<::proto::dota::CMsgStartFindingMatchResult>(Arena*);
template<> ::proto::dota::CMsgStopFindingMatch* Arena::CreateMaybeMessage<::proto::dota::CMsgStopFindingMatch>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace proto {
namespace dota {

enum EStartFindingMatchResult {
  k_EStartFindingMatchResult_Invalid = 0,
  k_EStartFindingMatchResult_OK = 1,
  k_EStartFindingMatchResult_AlreadySearching = 2,
  k_EStartFindingMatchResult_FailGeneric = 100,
  k_EStartFindingMatchResult_FailedIgnore = 101,
  k_EStartFindingMatchResult_MatchmakingDisabled = 102,
  k_EStartFindingMatchResult_RegionOffline = 103,
  k_EStartFindingMatchResult_MatchmakingCooldown = 104,
  k_EStartFindingMatchResult_ClientOutOfDate = 105,
  k_EStartFindingMatchResult_CompetitiveNoLowPriority = 106,
  k_EStartFindingMatchResult_CompetitiveNotUnlocked = 107,
  k_EStartFindingMatchResult_GameModeNotUnlocked = 108,
  k_EStartFindingMatchResult_CompetitiveNotEnoughSkillData = 109,
  k_EStartFindingMatchResult_MissingInitialSkill = 110,
  k_EStartFindingMatchResult_CompetitiveRankSpreadTooLarge = 111,
  k_EStartFindingMatchResult_MemberAlreadyInLobby = 112,
  k_EStartFindingMatchResult_MemberNotVACVerified = 113,
  k_EStartFindingMatchResult_WeekendTourneyBadPartySize = 114,
  k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooSmall = 115,
  k_EStartFindingMatchResult_WeekendTourneyIndividualBuyInTooLarge = 116,
  k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooLarge = 117,
  k_EStartFindingMatchResult_MemberMissingEventOwnership = 118,
  k_EStartFindingMatchResult_WeekendTourneyNotUnlocked = 119,
  k_EStartFindingMatchResult_WeekendTourneyRecentParticipation = 120,
  k_EStartFindingMatchResult_MemberMissingAnchoredPhoneNumber = 121,
  k_EStartFindingMatchResult_NotMemberOfClan = 122
};
bool EStartFindingMatchResult_IsValid(int value);
const EStartFindingMatchResult EStartFindingMatchResult_MIN = k_EStartFindingMatchResult_Invalid;
const EStartFindingMatchResult EStartFindingMatchResult_MAX = k_EStartFindingMatchResult_NotMemberOfClan;
const int EStartFindingMatchResult_ARRAYSIZE = EStartFindingMatchResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* EStartFindingMatchResult_descriptor();
inline const ::std::string& EStartFindingMatchResult_Name(EStartFindingMatchResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    EStartFindingMatchResult_descriptor(), value);
}
inline bool EStartFindingMatchResult_Parse(
    const ::std::string& name, EStartFindingMatchResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EStartFindingMatchResult>(
    EStartFindingMatchResult_descriptor(), name, value);
}
// ===================================================================

class CMsgStartFindingMatch final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgStartFindingMatch) */ {
 public:
  CMsgStartFindingMatch();
  virtual ~CMsgStartFindingMatch();

  CMsgStartFindingMatch(const CMsgStartFindingMatch& from);

  inline CMsgStartFindingMatch& operator=(const CMsgStartFindingMatch& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgStartFindingMatch(CMsgStartFindingMatch&& from) noexcept
    : CMsgStartFindingMatch() {
    *this = ::std::move(from);
  }

  inline CMsgStartFindingMatch& operator=(CMsgStartFindingMatch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgStartFindingMatch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgStartFindingMatch* internal_default_instance() {
    return reinterpret_cast<const CMsgStartFindingMatch*>(
               &_CMsgStartFindingMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CMsgStartFindingMatch* other);
  friend void swap(CMsgStartFindingMatch& a, CMsgStartFindingMatch& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgStartFindingMatch* New() const final {
    return CreateMaybeMessage<CMsgStartFindingMatch>(nullptr);
  }

  CMsgStartFindingMatch* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgStartFindingMatch>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgStartFindingMatch& from);
  void MergeFrom(const CMsgStartFindingMatch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgStartFindingMatch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string game_language_name = 11;
  bool has_game_language_name() const;
  void clear_game_language_name();
  static const int kGameLanguageNameFieldNumber = 11;
  const ::std::string& game_language_name() const;
  void set_game_language_name(const ::std::string& value);
  #if LANG_CXX11
  void set_game_language_name(::std::string&& value);
  #endif
  void set_game_language_name(const char* value);
  void set_game_language_name(const char* value, size_t size);
  ::std::string* mutable_game_language_name();
  ::std::string* release_game_language_name();
  void set_allocated_game_language_name(::std::string* game_language_name);

  // optional .proto.dota.CMsgClientPingData ping_data = 12;
  bool has_ping_data() const;
  void clear_ping_data();
  static const int kPingDataFieldNumber = 12;
  const ::proto::dota::CMsgClientPingData& ping_data() const;
  ::proto::dota::CMsgClientPingData* release_ping_data();
  ::proto::dota::CMsgClientPingData* mutable_ping_data();
  void set_allocated_ping_data(::proto::dota::CMsgClientPingData* ping_data);

  // optional uint32 client_version = 3;
  bool has_client_version() const;
  void clear_client_version();
  static const int kClientVersionFieldNumber = 3;
  ::google::protobuf::uint32 client_version() const;
  void set_client_version(::google::protobuf::uint32 value);

  // optional .proto.dota.MatchType match_type = 6 [default = MATCH_TYPE_CASUAL];
  bool has_match_type() const;
  void clear_match_type();
  static const int kMatchTypeFieldNumber = 6;
  ::proto::dota::MatchType match_type() const;
  void set_match_type(::proto::dota::MatchType value);

  // optional uint32 team_id = 8;
  bool has_team_id() const;
  void clear_team_id();
  static const int kTeamIdFieldNumber = 8;
  ::google::protobuf::uint32 team_id() const;
  void set_team_id(::google::protobuf::uint32 value);

  // optional .proto.dota.MatchLanguages game_language_enum = 10 [default = MATCH_LANGUAGE_INVALID];
  bool has_game_language_enum() const;
  void clear_game_language_enum();
  static const int kGameLanguageEnumFieldNumber = 10;
  ::proto::dota::MatchLanguages game_language_enum() const;
  void set_game_language_enum(::proto::dota::MatchLanguages value);

  // optional uint32 region_select_flags = 13;
  bool has_region_select_flags() const;
  void clear_region_select_flags();
  static const int kRegionSelectFlagsFieldNumber = 13;
  ::google::protobuf::uint32 region_select_flags() const;
  void set_region_select_flags(::google::protobuf::uint32 value);

  // optional uint32 bot_script_index = 15;
  bool has_bot_script_index() const;
  void clear_bot_script_index();
  static const int kBotScriptIndexFieldNumber = 15;
  ::google::protobuf::uint32 bot_script_index() const;
  void set_bot_script_index(::google::protobuf::uint32 value);

  // optional bool solo_queue = 14;
  bool has_solo_queue() const;
  void clear_solo_queue();
  static const int kSoloQueueFieldNumber = 14;
  bool solo_queue() const;
  void set_solo_queue(bool value);

  // optional bool is_challenge_match = 17;
  bool has_is_challenge_match() const;
  void clear_is_challenge_match();
  static const int kIsChallengeMatchFieldNumber = 17;
  bool is_challenge_match() const;
  void set_is_challenge_match(bool value);

  // optional uint32 steam_clan_account_id = 16;
  bool has_steam_clan_account_id() const;
  void clear_steam_clan_account_id();
  static const int kSteamClanAccountIdFieldNumber = 16;
  ::google::protobuf::uint32 steam_clan_account_id() const;
  void set_steam_clan_account_id(::google::protobuf::uint32 value);

  // optional uint32 lane_selection_flags = 18;
  bool has_lane_selection_flags() const;
  void clear_lane_selection_flags();
  static const int kLaneSelectionFlagsFieldNumber = 18;
  ::google::protobuf::uint32 lane_selection_flags() const;
  void set_lane_selection_flags(::google::protobuf::uint32 value);

  // optional uint32 matchgroups = 2 [default = 4294967295];
  bool has_matchgroups() const;
  void clear_matchgroups();
  static const int kMatchgroupsFieldNumber = 2;
  ::google::protobuf::uint32 matchgroups() const;
  void set_matchgroups(::google::protobuf::uint32 value);

  // optional uint32 game_modes = 4 [default = 4294967295];
  bool has_game_modes() const;
  void clear_game_modes();
  static const int kGameModesFieldNumber = 4;
  ::google::protobuf::uint32 game_modes() const;
  void set_game_modes(::google::protobuf::uint32 value);

  // optional .proto.dota.DOTABotDifficulty bot_difficulty = 5 [default = BOT_DIFFICULTY_HARD];
  bool has_bot_difficulty() const;
  void clear_bot_difficulty();
  static const int kBotDifficultyFieldNumber = 5;
  ::proto::dota::DOTABotDifficulty bot_difficulty() const;
  void set_bot_difficulty(::proto::dota::DOTABotDifficulty value);

  // optional uint32 matchlanguages = 7 [default = 4294967295];
  bool has_matchlanguages() const;
  void clear_matchlanguages();
  static const int kMatchlanguagesFieldNumber = 7;
  ::google::protobuf::uint32 matchlanguages() const;
  void set_matchlanguages(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgStartFindingMatch)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr game_language_name_;
  ::proto::dota::CMsgClientPingData* ping_data_;
  ::google::protobuf::uint32 client_version_;
  int match_type_;
  ::google::protobuf::uint32 team_id_;
  int game_language_enum_;
  ::google::protobuf::uint32 region_select_flags_;
  ::google::protobuf::uint32 bot_script_index_;
  bool solo_queue_;
  bool is_challenge_match_;
  ::google::protobuf::uint32 steam_clan_account_id_;
  ::google::protobuf::uint32 lane_selection_flags_;
  ::google::protobuf::uint32 matchgroups_;
  ::google::protobuf::uint32 game_modes_;
  int bot_difficulty_;
  ::google::protobuf::uint32 matchlanguages_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgStartFindingMatchResult final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgStartFindingMatchResult) */ {
 public:
  CMsgStartFindingMatchResult();
  virtual ~CMsgStartFindingMatchResult();

  CMsgStartFindingMatchResult(const CMsgStartFindingMatchResult& from);

  inline CMsgStartFindingMatchResult& operator=(const CMsgStartFindingMatchResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgStartFindingMatchResult(CMsgStartFindingMatchResult&& from) noexcept
    : CMsgStartFindingMatchResult() {
    *this = ::std::move(from);
  }

  inline CMsgStartFindingMatchResult& operator=(CMsgStartFindingMatchResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgStartFindingMatchResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgStartFindingMatchResult* internal_default_instance() {
    return reinterpret_cast<const CMsgStartFindingMatchResult*>(
               &_CMsgStartFindingMatchResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(CMsgStartFindingMatchResult* other);
  friend void swap(CMsgStartFindingMatchResult& a, CMsgStartFindingMatchResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgStartFindingMatchResult* New() const final {
    return CreateMaybeMessage<CMsgStartFindingMatchResult>(nullptr);
  }

  CMsgStartFindingMatchResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgStartFindingMatchResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgStartFindingMatchResult& from);
  void MergeFrom(const CMsgStartFindingMatchResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgStartFindingMatchResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated fixed64 responsible_party_members = 5;
  int responsible_party_members_size() const;
  void clear_responsible_party_members();
  static const int kResponsiblePartyMembersFieldNumber = 5;
  ::google::protobuf::uint64 responsible_party_members(int index) const;
  void set_responsible_party_members(int index, ::google::protobuf::uint64 value);
  void add_responsible_party_members(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      responsible_party_members() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_responsible_party_members();

  // optional string error_token = 3;
  bool has_error_token() const;
  void clear_error_token();
  static const int kErrorTokenFieldNumber = 3;
  const ::std::string& error_token() const;
  void set_error_token(const ::std::string& value);
  #if LANG_CXX11
  void set_error_token(::std::string&& value);
  #endif
  void set_error_token(const char* value);
  void set_error_token(const char* value, size_t size);
  ::std::string* mutable_error_token();
  ::std::string* release_error_token();
  void set_allocated_error_token(::std::string* error_token);

  // optional string debug_message = 4;
  bool has_debug_message() const;
  void clear_debug_message();
  static const int kDebugMessageFieldNumber = 4;
  const ::std::string& debug_message() const;
  void set_debug_message(const ::std::string& value);
  #if LANG_CXX11
  void set_debug_message(::std::string&& value);
  #endif
  void set_debug_message(const char* value);
  void set_debug_message(const char* value, size_t size);
  ::std::string* mutable_debug_message();
  ::std::string* release_debug_message();
  void set_allocated_debug_message(::std::string* debug_message);

  // optional .proto.dota.EStartFindingMatchResult result = 2 [default = k_EStartFindingMatchResult_Invalid];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 2;
  ::proto::dota::EStartFindingMatchResult result() const;
  void set_result(::proto::dota::EStartFindingMatchResult value);

  // optional uint32 legacy_generic_eresult = 1 [default = 2];
  bool has_legacy_generic_eresult() const;
  void clear_legacy_generic_eresult();
  static const int kLegacyGenericEresultFieldNumber = 1;
  ::google::protobuf::uint32 legacy_generic_eresult() const;
  void set_legacy_generic_eresult(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgStartFindingMatchResult)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > responsible_party_members_;
  ::google::protobuf::internal::ArenaStringPtr error_token_;
  ::google::protobuf::internal::ArenaStringPtr debug_message_;
  int result_;
  ::google::protobuf::uint32 legacy_generic_eresult_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgStopFindingMatch final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgStopFindingMatch) */ {
 public:
  CMsgStopFindingMatch();
  virtual ~CMsgStopFindingMatch();

  CMsgStopFindingMatch(const CMsgStopFindingMatch& from);

  inline CMsgStopFindingMatch& operator=(const CMsgStopFindingMatch& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgStopFindingMatch(CMsgStopFindingMatch&& from) noexcept
    : CMsgStopFindingMatch() {
    *this = ::std::move(from);
  }

  inline CMsgStopFindingMatch& operator=(CMsgStopFindingMatch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgStopFindingMatch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgStopFindingMatch* internal_default_instance() {
    return reinterpret_cast<const CMsgStopFindingMatch*>(
               &_CMsgStopFindingMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(CMsgStopFindingMatch* other);
  friend void swap(CMsgStopFindingMatch& a, CMsgStopFindingMatch& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgStopFindingMatch* New() const final {
    return CreateMaybeMessage<CMsgStopFindingMatch>(nullptr);
  }

  CMsgStopFindingMatch* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgStopFindingMatch>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgStopFindingMatch& from);
  void MergeFrom(const CMsgStopFindingMatch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgStopFindingMatch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgStopFindingMatch)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgPartyBuilderOptions final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgPartyBuilderOptions) */ {
 public:
  CMsgPartyBuilderOptions();
  virtual ~CMsgPartyBuilderOptions();

  CMsgPartyBuilderOptions(const CMsgPartyBuilderOptions& from);

  inline CMsgPartyBuilderOptions& operator=(const CMsgPartyBuilderOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgPartyBuilderOptions(CMsgPartyBuilderOptions&& from) noexcept
    : CMsgPartyBuilderOptions() {
    *this = ::std::move(from);
  }

  inline CMsgPartyBuilderOptions& operator=(CMsgPartyBuilderOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgPartyBuilderOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgPartyBuilderOptions* internal_default_instance() {
    return reinterpret_cast<const CMsgPartyBuilderOptions*>(
               &_CMsgPartyBuilderOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(CMsgPartyBuilderOptions* other);
  friend void swap(CMsgPartyBuilderOptions& a, CMsgPartyBuilderOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgPartyBuilderOptions* New() const final {
    return CreateMaybeMessage<CMsgPartyBuilderOptions>(nullptr);
  }

  CMsgPartyBuilderOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgPartyBuilderOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgPartyBuilderOptions& from);
  void MergeFrom(const CMsgPartyBuilderOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgPartyBuilderOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 additional_slots = 1;
  bool has_additional_slots() const;
  void clear_additional_slots();
  static const int kAdditionalSlotsFieldNumber = 1;
  ::google::protobuf::uint32 additional_slots() const;
  void set_additional_slots(::google::protobuf::uint32 value);

  // optional .proto.dota.MatchType match_type = 2 [default = MATCH_TYPE_CASUAL];
  bool has_match_type() const;
  void clear_match_type();
  static const int kMatchTypeFieldNumber = 2;
  ::proto::dota::MatchType match_type() const;
  void set_match_type(::proto::dota::MatchType value);

  // optional uint32 matchgroups = 3;
  bool has_matchgroups() const;
  void clear_matchgroups();
  static const int kMatchgroupsFieldNumber = 3;
  ::google::protobuf::uint32 matchgroups() const;
  void set_matchgroups(::google::protobuf::uint32 value);

  // optional uint32 client_version = 4;
  bool has_client_version() const;
  void clear_client_version();
  static const int kClientVersionFieldNumber = 4;
  ::google::protobuf::uint32 client_version() const;
  void set_client_version(::google::protobuf::uint32 value);

  // optional .proto.dota.MatchLanguages language = 5 [default = MATCH_LANGUAGE_INVALID];
  bool has_language() const;
  void clear_language();
  static const int kLanguageFieldNumber = 5;
  ::proto::dota::MatchLanguages language() const;
  void set_language(::proto::dota::MatchLanguages value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgPartyBuilderOptions)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 additional_slots_;
  int match_type_;
  ::google::protobuf::uint32 matchgroups_;
  ::google::protobuf::uint32 client_version_;
  int language_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgReadyUp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgReadyUp) */ {
 public:
  CMsgReadyUp();
  virtual ~CMsgReadyUp();

  CMsgReadyUp(const CMsgReadyUp& from);

  inline CMsgReadyUp& operator=(const CMsgReadyUp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgReadyUp(CMsgReadyUp&& from) noexcept
    : CMsgReadyUp() {
    *this = ::std::move(from);
  }

  inline CMsgReadyUp& operator=(CMsgReadyUp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgReadyUp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgReadyUp* internal_default_instance() {
    return reinterpret_cast<const CMsgReadyUp*>(
               &_CMsgReadyUp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(CMsgReadyUp* other);
  friend void swap(CMsgReadyUp& a, CMsgReadyUp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgReadyUp* New() const final {
    return CreateMaybeMessage<CMsgReadyUp>(nullptr);
  }

  CMsgReadyUp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgReadyUp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgReadyUp& from);
  void MergeFrom(const CMsgReadyUp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgReadyUp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CDOTAClientHardwareSpecs hardware_specs = 3;
  bool has_hardware_specs() const;
  void clear_hardware_specs();
  static const int kHardwareSpecsFieldNumber = 3;
  const ::proto::dota::CDOTAClientHardwareSpecs& hardware_specs() const;
  ::proto::dota::CDOTAClientHardwareSpecs* release_hardware_specs();
  ::proto::dota::CDOTAClientHardwareSpecs* mutable_hardware_specs();
  void set_allocated_hardware_specs(::proto::dota::CDOTAClientHardwareSpecs* hardware_specs);

  // optional fixed64 ready_up_key = 2;
  bool has_ready_up_key() const;
  void clear_ready_up_key();
  static const int kReadyUpKeyFieldNumber = 2;
  ::google::protobuf::uint64 ready_up_key() const;
  void set_ready_up_key(::google::protobuf::uint64 value);

  // optional .proto.dota.DOTALobbyReadyState state = 1 [default = DOTALobbyReadyState_UNDECLARED];
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  ::proto::dota::DOTALobbyReadyState state() const;
  void set_state(::proto::dota::DOTALobbyReadyState value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgReadyUp)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::proto::dota::CDOTAClientHardwareSpecs* hardware_specs_;
  ::google::protobuf::uint64 ready_up_key_;
  int state_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgReadyUpStatus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgReadyUpStatus) */ {
 public:
  CMsgReadyUpStatus();
  virtual ~CMsgReadyUpStatus();

  CMsgReadyUpStatus(const CMsgReadyUpStatus& from);

  inline CMsgReadyUpStatus& operator=(const CMsgReadyUpStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgReadyUpStatus(CMsgReadyUpStatus&& from) noexcept
    : CMsgReadyUpStatus() {
    *this = ::std::move(from);
  }

  inline CMsgReadyUpStatus& operator=(CMsgReadyUpStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgReadyUpStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgReadyUpStatus* internal_default_instance() {
    return reinterpret_cast<const CMsgReadyUpStatus*>(
               &_CMsgReadyUpStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(CMsgReadyUpStatus* other);
  friend void swap(CMsgReadyUpStatus& a, CMsgReadyUpStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgReadyUpStatus* New() const final {
    return CreateMaybeMessage<CMsgReadyUpStatus>(nullptr);
  }

  CMsgReadyUpStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgReadyUpStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgReadyUpStatus& from);
  void MergeFrom(const CMsgReadyUpStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgReadyUpStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 accepted_ids = 2;
  int accepted_ids_size() const;
  void clear_accepted_ids();
  static const int kAcceptedIdsFieldNumber = 2;
  ::google::protobuf::uint32 accepted_ids(int index) const;
  void set_accepted_ids(int index, ::google::protobuf::uint32 value);
  void add_accepted_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      accepted_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_accepted_ids();

  // repeated uint32 declined_ids = 3;
  int declined_ids_size() const;
  void clear_declined_ids();
  static const int kDeclinedIdsFieldNumber = 3;
  ::google::protobuf::uint32 declined_ids(int index) const;
  void set_declined_ids(int index, ::google::protobuf::uint32 value);
  void add_declined_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      declined_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_declined_ids();

  // optional fixed64 lobby_id = 1;
  bool has_lobby_id() const;
  void clear_lobby_id();
  static const int kLobbyIdFieldNumber = 1;
  ::google::protobuf::uint64 lobby_id() const;
  void set_lobby_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgReadyUpStatus)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > accepted_ids_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > declined_ids_;
  ::google::protobuf::uint64 lobby_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgAbandonCurrentGame final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgAbandonCurrentGame) */ {
 public:
  CMsgAbandonCurrentGame();
  virtual ~CMsgAbandonCurrentGame();

  CMsgAbandonCurrentGame(const CMsgAbandonCurrentGame& from);

  inline CMsgAbandonCurrentGame& operator=(const CMsgAbandonCurrentGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgAbandonCurrentGame(CMsgAbandonCurrentGame&& from) noexcept
    : CMsgAbandonCurrentGame() {
    *this = ::std::move(from);
  }

  inline CMsgAbandonCurrentGame& operator=(CMsgAbandonCurrentGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgAbandonCurrentGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgAbandonCurrentGame* internal_default_instance() {
    return reinterpret_cast<const CMsgAbandonCurrentGame*>(
               &_CMsgAbandonCurrentGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(CMsgAbandonCurrentGame* other);
  friend void swap(CMsgAbandonCurrentGame& a, CMsgAbandonCurrentGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgAbandonCurrentGame* New() const final {
    return CreateMaybeMessage<CMsgAbandonCurrentGame>(nullptr);
  }

  CMsgAbandonCurrentGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgAbandonCurrentGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgAbandonCurrentGame& from);
  void MergeFrom(const CMsgAbandonCurrentGame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgAbandonCurrentGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgAbandonCurrentGame)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgPracticeLobbySetDetails final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgPracticeLobbySetDetails) */ {
 public:
  CMsgPracticeLobbySetDetails();
  virtual ~CMsgPracticeLobbySetDetails();

  CMsgPracticeLobbySetDetails(const CMsgPracticeLobbySetDetails& from);

  inline CMsgPracticeLobbySetDetails& operator=(const CMsgPracticeLobbySetDetails& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgPracticeLobbySetDetails(CMsgPracticeLobbySetDetails&& from) noexcept
    : CMsgPracticeLobbySetDetails() {
    *this = ::std::move(from);
  }

  inline CMsgPracticeLobbySetDetails& operator=(CMsgPracticeLobbySetDetails&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgPracticeLobbySetDetails& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgPracticeLobbySetDetails* internal_default_instance() {
    return reinterpret_cast<const CMsgPracticeLobbySetDetails*>(
               &_CMsgPracticeLobbySetDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(CMsgPracticeLobbySetDetails* other);
  friend void swap(CMsgPracticeLobbySetDetails& a, CMsgPracticeLobbySetDetails& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgPracticeLobbySetDetails* New() const final {
    return CreateMaybeMessage<CMsgPracticeLobbySetDetails>(nullptr);
  }

  CMsgPracticeLobbySetDetails* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgPracticeLobbySetDetails>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgPracticeLobbySetDetails& from);
  void MergeFrom(const CMsgPracticeLobbySetDetails& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgPracticeLobbySetDetails* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CLobbyTeamDetails team_details = 3;
  int team_details_size() const;
  void clear_team_details();
  static const int kTeamDetailsFieldNumber = 3;
  ::proto::dota::CLobbyTeamDetails* mutable_team_details(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CLobbyTeamDetails >*
      mutable_team_details();
  const ::proto::dota::CLobbyTeamDetails& team_details(int index) const;
  ::proto::dota::CLobbyTeamDetails* add_team_details();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CLobbyTeamDetails >&
      team_details() const;

  // optional string game_name = 2;
  bool has_game_name() const;
  void clear_game_name();
  static const int kGameNameFieldNumber = 2;
  const ::std::string& game_name() const;
  void set_game_name(const ::std::string& value);
  #if LANG_CXX11
  void set_game_name(::std::string&& value);
  #endif
  void set_game_name(const char* value);
  void set_game_name(const char* value, size_t size);
  ::std::string* mutable_game_name();
  ::std::string* release_game_name();
  void set_allocated_game_name(::std::string* game_name);

  // optional string pass_key = 15;
  bool has_pass_key() const;
  void clear_pass_key();
  static const int kPassKeyFieldNumber = 15;
  const ::std::string& pass_key() const;
  void set_pass_key(const ::std::string& value);
  #if LANG_CXX11
  void set_pass_key(::std::string&& value);
  #endif
  void set_pass_key(const char* value);
  void set_pass_key(const char* value, size_t size);
  ::std::string* mutable_pass_key();
  ::std::string* release_pass_key();
  void set_allocated_pass_key(::std::string* pass_key);

  // optional string custom_game_mode = 26;
  bool has_custom_game_mode() const;
  void clear_custom_game_mode();
  static const int kCustomGameModeFieldNumber = 26;
  const ::std::string& custom_game_mode() const;
  void set_custom_game_mode(const ::std::string& value);
  #if LANG_CXX11
  void set_custom_game_mode(::std::string&& value);
  #endif
  void set_custom_game_mode(const char* value);
  void set_custom_game_mode(const char* value, size_t size);
  ::std::string* mutable_custom_game_mode();
  ::std::string* release_custom_game_mode();
  void set_allocated_custom_game_mode(::std::string* custom_game_mode);

  // optional string custom_map_name = 27;
  bool has_custom_map_name() const;
  void clear_custom_map_name();
  static const int kCustomMapNameFieldNumber = 27;
  const ::std::string& custom_map_name() const;
  void set_custom_map_name(const ::std::string& value);
  #if LANG_CXX11
  void set_custom_map_name(::std::string&& value);
  #endif
  void set_custom_map_name(const char* value);
  void set_custom_map_name(const char* value, size_t size);
  ::std::string* mutable_custom_map_name();
  ::std::string* release_custom_map_name();
  void set_allocated_custom_map_name(::std::string* custom_map_name);

  // optional string lan_host_ping_location = 48;
  bool has_lan_host_ping_location() const;
  void clear_lan_host_ping_location();
  static const int kLanHostPingLocationFieldNumber = 48;
  const ::std::string& lan_host_ping_location() const;
  void set_lan_host_ping_location(const ::std::string& value);
  #if LANG_CXX11
  void set_lan_host_ping_location(::std::string&& value);
  #endif
  void set_lan_host_ping_location(const char* value);
  void set_lan_host_ping_location(const char* value, size_t size);
  ::std::string* mutable_lan_host_ping_location();
  ::std::string* release_lan_host_ping_location();
  void set_allocated_lan_host_ping_location(::std::string* lan_host_ping_location);

  // optional uint64 lobby_id = 1;
  bool has_lobby_id() const;
  void clear_lobby_id();
  static const int kLobbyIdFieldNumber = 1;
  ::google::protobuf::uint64 lobby_id() const;
  void set_lobby_id(::google::protobuf::uint64 value);

  // optional uint32 server_region = 4;
  bool has_server_region() const;
  void clear_server_region();
  static const int kServerRegionFieldNumber = 4;
  ::google::protobuf::uint32 server_region() const;
  void set_server_region(::google::protobuf::uint32 value);

  // optional uint32 game_mode = 5;
  bool has_game_mode() const;
  void clear_game_mode();
  static const int kGameModeFieldNumber = 5;
  ::google::protobuf::uint32 game_mode() const;
  void set_game_mode(::google::protobuf::uint32 value);

  // optional .proto.dota.DOTA_CM_PICK cm_pick = 6 [default = DOTA_CM_RANDOM];
  bool has_cm_pick() const;
  void clear_cm_pick();
  static const int kCmPickFieldNumber = 6;
  ::proto::dota::DOTA_CM_PICK cm_pick() const;
  void set_cm_pick(::proto::dota::DOTA_CM_PICK value);

  // optional .proto.dota.DOTABotDifficulty bot_difficulty_radiant = 9 [default = BOT_DIFFICULTY_PASSIVE];
  bool has_bot_difficulty_radiant() const;
  void clear_bot_difficulty_radiant();
  static const int kBotDifficultyRadiantFieldNumber = 9;
  ::proto::dota::DOTABotDifficulty bot_difficulty_radiant() const;
  void set_bot_difficulty_radiant(::proto::dota::DOTABotDifficulty value);

  // optional bool allow_cheats = 10;
  bool has_allow_cheats() const;
  void clear_allow_cheats();
  static const int kAllowCheatsFieldNumber = 10;
  bool allow_cheats() const;
  void set_allow_cheats(bool value);

  // optional bool fill_with_bots = 11;
  bool has_fill_with_bots() const;
  void clear_fill_with_bots();
  static const int kFillWithBotsFieldNumber = 11;
  bool fill_with_bots() const;
  void set_fill_with_bots(bool value);

  // optional bool intro_mode = 12;
  bool has_intro_mode() const;
  void clear_intro_mode();
  static const int kIntroModeFieldNumber = 12;
  bool intro_mode() const;
  void set_intro_mode(bool value);

  // optional bool allow_spectating = 13;
  bool has_allow_spectating() const;
  void clear_allow_spectating();
  static const int kAllowSpectatingFieldNumber = 13;
  bool allow_spectating() const;
  void set_allow_spectating(bool value);

  // optional .proto.dota.DOTAGameVersion game_version = 14 [default = GAME_VERSION_CURRENT];
  bool has_game_version() const;
  void clear_game_version();
  static const int kGameVersionFieldNumber = 14;
  ::proto::dota::DOTAGameVersion game_version() const;
  void set_game_version(::proto::dota::DOTAGameVersion value);

  // optional uint32 leagueid = 16;
  bool has_leagueid() const;
  void clear_leagueid();
  static const int kLeagueidFieldNumber = 16;
  ::google::protobuf::uint32 leagueid() const;
  void set_leagueid(::google::protobuf::uint32 value);

  // optional uint32 penalty_level_radiant = 17;
  bool has_penalty_level_radiant() const;
  void clear_penalty_level_radiant();
  static const int kPenaltyLevelRadiantFieldNumber = 17;
  ::google::protobuf::uint32 penalty_level_radiant() const;
  void set_penalty_level_radiant(::google::protobuf::uint32 value);

  // optional uint32 penalty_level_dire = 18;
  bool has_penalty_level_dire() const;
  void clear_penalty_level_dire();
  static const int kPenaltyLevelDireFieldNumber = 18;
  ::google::protobuf::uint32 penalty_level_dire() const;
  void set_penalty_level_dire(::google::protobuf::uint32 value);

  // optional uint32 load_game_id = 19;
  bool has_load_game_id() const;
  void clear_load_game_id();
  static const int kLoadGameIdFieldNumber = 19;
  ::google::protobuf::uint32 load_game_id() const;
  void set_load_game_id(::google::protobuf::uint32 value);

  // optional uint32 series_type = 20;
  bool has_series_type() const;
  void clear_series_type();
  static const int kSeriesTypeFieldNumber = 20;
  ::google::protobuf::uint32 series_type() const;
  void set_series_type(::google::protobuf::uint32 value);

  // optional uint32 radiant_series_wins = 21;
  bool has_radiant_series_wins() const;
  void clear_radiant_series_wins();
  static const int kRadiantSeriesWinsFieldNumber = 21;
  ::google::protobuf::uint32 radiant_series_wins() const;
  void set_radiant_series_wins(::google::protobuf::uint32 value);

  // optional uint32 dire_series_wins = 22;
  bool has_dire_series_wins() const;
  void clear_dire_series_wins();
  static const int kDireSeriesWinsFieldNumber = 22;
  ::google::protobuf::uint32 dire_series_wins() const;
  void set_dire_series_wins(::google::protobuf::uint32 value);

  // optional uint32 custom_difficulty = 28;
  bool has_custom_difficulty() const;
  void clear_custom_difficulty();
  static const int kCustomDifficultyFieldNumber = 28;
  ::google::protobuf::uint32 custom_difficulty() const;
  void set_custom_difficulty(::google::protobuf::uint32 value);

  // optional uint64 custom_game_id = 29;
  bool has_custom_game_id() const;
  void clear_custom_game_id();
  static const int kCustomGameIdFieldNumber = 29;
  ::google::protobuf::uint64 custom_game_id() const;
  void set_custom_game_id(::google::protobuf::uint64 value);

  // optional uint32 custom_min_players = 30;
  bool has_custom_min_players() const;
  void clear_custom_min_players();
  static const int kCustomMinPlayersFieldNumber = 30;
  ::google::protobuf::uint32 custom_min_players() const;
  void set_custom_min_players(::google::protobuf::uint32 value);

  // optional uint32 custom_max_players = 31;
  bool has_custom_max_players() const;
  void clear_custom_max_players();
  static const int kCustomMaxPlayersFieldNumber = 31;
  ::google::protobuf::uint32 custom_max_players() const;
  void set_custom_max_players(::google::protobuf::uint32 value);

  // optional bool allchat = 23 [default = false];
  bool has_allchat() const;
  void clear_allchat();
  static const int kAllchatFieldNumber = 23;
  bool allchat() const;
  void set_allchat(bool value);

  // optional bool lan = 25;
  bool has_lan() const;
  void clear_lan();
  static const int kLanFieldNumber = 25;
  bool lan() const;
  void set_lan(bool value);

  // optional bool custom_game_penalties = 47;
  bool has_custom_game_penalties() const;
  void clear_custom_game_penalties();
  static const int kCustomGamePenaltiesFieldNumber = 47;
  bool custom_game_penalties() const;
  void set_custom_game_penalties(bool value);

  // optional .proto.dota.DOTALobbyVisibility visibility = 33 [default = DOTALobbyVisibility_Public];
  bool has_visibility() const;
  void clear_visibility();
  static const int kVisibilityFieldNumber = 33;
  ::proto::dota::DOTALobbyVisibility visibility() const;
  void set_visibility(::proto::dota::DOTALobbyVisibility value);

  // optional fixed64 custom_game_crc = 34;
  bool has_custom_game_crc() const;
  void clear_custom_game_crc();
  static const int kCustomGameCrcFieldNumber = 34;
  ::google::protobuf::uint64 custom_game_crc() const;
  void set_custom_game_crc(::google::protobuf::uint64 value);

  // optional uint64 previous_match_override = 38;
  bool has_previous_match_override() const;
  void clear_previous_match_override();
  static const int kPreviousMatchOverrideFieldNumber = 38;
  ::google::protobuf::uint64 previous_match_override() const;
  void set_previous_match_override(::google::protobuf::uint64 value);

  // optional fixed32 custom_game_timestamp = 37;
  bool has_custom_game_timestamp() const;
  void clear_custom_game_timestamp();
  static const int kCustomGameTimestampFieldNumber = 37;
  ::google::protobuf::uint32 custom_game_timestamp() const;
  void set_custom_game_timestamp(::google::protobuf::uint32 value);

  // optional .proto.dota.LobbyDotaPauseSetting pause_setting = 42 [default = LobbyDotaPauseSetting_Unlimited];
  bool has_pause_setting() const;
  void clear_pause_setting();
  static const int kPauseSettingFieldNumber = 42;
  ::proto::dota::LobbyDotaPauseSetting pause_setting() const;
  void set_pause_setting(::proto::dota::LobbyDotaPauseSetting value);

  // optional uint32 league_node_id = 49;
  bool has_league_node_id() const;
  void clear_league_node_id();
  static const int kLeagueNodeIdFieldNumber = 49;
  ::google::protobuf::uint32 league_node_id() const;
  void set_league_node_id(::google::protobuf::uint32 value);

  // optional uint64 bot_radiant = 44;
  bool has_bot_radiant() const;
  void clear_bot_radiant();
  static const int kBotRadiantFieldNumber = 44;
  ::google::protobuf::uint64 bot_radiant() const;
  void set_bot_radiant(::google::protobuf::uint64 value);

  // optional .proto.dota.DOTABotDifficulty bot_difficulty_dire = 43 [default = BOT_DIFFICULTY_PASSIVE];
  bool has_bot_difficulty_dire() const;
  void clear_bot_difficulty_dire();
  static const int kBotDifficultyDireFieldNumber = 43;
  ::proto::dota::DOTABotDifficulty bot_difficulty_dire() const;
  void set_bot_difficulty_dire(::proto::dota::DOTABotDifficulty value);

  // optional .proto.dota.DOTASelectionPriorityRules selection_priority_rules = 46 [default = k_DOTASelectionPriorityRules_Manual];
  bool has_selection_priority_rules() const;
  void clear_selection_priority_rules();
  static const int kSelectionPriorityRulesFieldNumber = 46;
  ::proto::dota::DOTASelectionPriorityRules selection_priority_rules() const;
  void set_selection_priority_rules(::proto::dota::DOTASelectionPriorityRules value);

  // optional uint64 bot_dire = 45;
  bool has_bot_dire() const;
  void clear_bot_dire();
  static const int kBotDireFieldNumber = 45;
  ::google::protobuf::uint64 bot_dire() const;
  void set_bot_dire(::google::protobuf::uint64 value);

  // optional .proto.dota.LobbyDotaTVDelay dota_tv_delay = 24 [default = LobbyDotaTV_120];
  bool has_dota_tv_delay() const;
  void clear_dota_tv_delay();
  static const int kDotaTvDelayFieldNumber = 24;
  ::proto::dota::LobbyDotaTVDelay dota_tv_delay() const;
  void set_dota_tv_delay(::proto::dota::LobbyDotaTVDelay value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgPracticeLobbySetDetails)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<2> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CLobbyTeamDetails > team_details_;
  ::google::protobuf::internal::ArenaStringPtr game_name_;
  ::google::protobuf::internal::ArenaStringPtr pass_key_;
  ::google::protobuf::internal::ArenaStringPtr custom_game_mode_;
  ::google::protobuf::internal::ArenaStringPtr custom_map_name_;
  ::google::protobuf::internal::ArenaStringPtr lan_host_ping_location_;
  ::google::protobuf::uint64 lobby_id_;
  ::google::protobuf::uint32 server_region_;
  ::google::protobuf::uint32 game_mode_;
  int cm_pick_;
  int bot_difficulty_radiant_;
  bool allow_cheats_;
  bool fill_with_bots_;
  bool intro_mode_;
  bool allow_spectating_;
  int game_version_;
  ::google::protobuf::uint32 leagueid_;
  ::google::protobuf::uint32 penalty_level_radiant_;
  ::google::protobuf::uint32 penalty_level_dire_;
  ::google::protobuf::uint32 load_game_id_;
  ::google::protobuf::uint32 series_type_;
  ::google::protobuf::uint32 radiant_series_wins_;
  ::google::protobuf::uint32 dire_series_wins_;
  ::google::protobuf::uint32 custom_difficulty_;
  ::google::protobuf::uint64 custom_game_id_;
  ::google::protobuf::uint32 custom_min_players_;
  ::google::protobuf::uint32 custom_max_players_;
  bool allchat_;
  bool lan_;
  bool custom_game_penalties_;
  int visibility_;
  ::google::protobuf::uint64 custom_game_crc_;
  ::google::protobuf::uint64 previous_match_override_;
  ::google::protobuf::uint32 custom_game_timestamp_;
  int pause_setting_;
  ::google::protobuf::uint32 league_node_id_;
  ::google::protobuf::uint64 bot_radiant_;
  int bot_difficulty_dire_;
  int selection_priority_rules_;
  ::google::protobuf::uint64 bot_dire_;
  int dota_tv_delay_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgPracticeLobbyCreate_SaveGame final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgPracticeLobbyCreate.SaveGame) */ {
 public:
  CMsgPracticeLobbyCreate_SaveGame();
  virtual ~CMsgPracticeLobbyCreate_SaveGame();

  CMsgPracticeLobbyCreate_SaveGame(const CMsgPracticeLobbyCreate_SaveGame& from);

  inline CMsgPracticeLobbyCreate_SaveGame& operator=(const CMsgPracticeLobbyCreate_SaveGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgPracticeLobbyCreate_SaveGame(CMsgPracticeLobbyCreate_SaveGame&& from) noexcept
    : CMsgPracticeLobbyCreate_SaveGame() {
    *this = ::std::move(from);
  }

  inline CMsgPracticeLobbyCreate_SaveGame& operator=(CMsgPracticeLobbyCreate_SaveGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgPracticeLobbyCreate_SaveGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgPracticeLobbyCreate_SaveGame* internal_default_instance() {
    return reinterpret_cast<const CMsgPracticeLobbyCreate_SaveGame*>(
               &_CMsgPracticeLobbyCreate_SaveGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(CMsgPracticeLobbyCreate_SaveGame* other);
  friend void swap(CMsgPracticeLobbyCreate_SaveGame& a, CMsgPracticeLobbyCreate_SaveGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgPracticeLobbyCreate_SaveGame* New() const final {
    return CreateMaybeMessage<CMsgPracticeLobbyCreate_SaveGame>(nullptr);
  }

  CMsgPracticeLobbyCreate_SaveGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgPracticeLobbyCreate_SaveGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgPracticeLobbyCreate_SaveGame& from);
  void MergeFrom(const CMsgPracticeLobbyCreate_SaveGame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgPracticeLobbyCreate_SaveGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 1;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional fixed64 steam_id = 3;
  bool has_steam_id() const;
  void clear_steam_id();
  static const int kSteamIdFieldNumber = 3;
  ::google::protobuf::uint64 steam_id() const;
  void set_steam_id(::google::protobuf::uint64 value);

  // optional fixed64 signature = 4;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 4;
  ::google::protobuf::uint64 signature() const;
  void set_signature(::google::protobuf::uint64 value);

  // optional int32 version = 2;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgPracticeLobbyCreate.SaveGame)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint64 steam_id_;
  ::google::protobuf::uint64 signature_;
  ::google::protobuf::int32 version_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgPracticeLobbyCreate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgPracticeLobbyCreate) */ {
 public:
  CMsgPracticeLobbyCreate();
  virtual ~CMsgPracticeLobbyCreate();

  CMsgPracticeLobbyCreate(const CMsgPracticeLobbyCreate& from);

  inline CMsgPracticeLobbyCreate& operator=(const CMsgPracticeLobbyCreate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgPracticeLobbyCreate(CMsgPracticeLobbyCreate&& from) noexcept
    : CMsgPracticeLobbyCreate() {
    *this = ::std::move(from);
  }

  inline CMsgPracticeLobbyCreate& operator=(CMsgPracticeLobbyCreate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgPracticeLobbyCreate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgPracticeLobbyCreate* internal_default_instance() {
    return reinterpret_cast<const CMsgPracticeLobbyCreate*>(
               &_CMsgPracticeLobbyCreate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(CMsgPracticeLobbyCreate* other);
  friend void swap(CMsgPracticeLobbyCreate& a, CMsgPracticeLobbyCreate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgPracticeLobbyCreate* New() const final {
    return CreateMaybeMessage<CMsgPracticeLobbyCreate>(nullptr);
  }

  CMsgPracticeLobbyCreate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgPracticeLobbyCreate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgPracticeLobbyCreate& from);
  void MergeFrom(const CMsgPracticeLobbyCreate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgPracticeLobbyCreate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgPracticeLobbyCreate_SaveGame SaveGame;

  // accessors -------------------------------------------------------

  // optional string search_key = 1;
  bool has_search_key() const;
  void clear_search_key();
  static const int kSearchKeyFieldNumber = 1;
  const ::std::string& search_key() const;
  void set_search_key(const ::std::string& value);
  #if LANG_CXX11
  void set_search_key(::std::string&& value);
  #endif
  void set_search_key(const char* value);
  void set_search_key(const char* value, size_t size);
  ::std::string* mutable_search_key();
  ::std::string* release_search_key();
  void set_allocated_search_key(::std::string* search_key);

  // optional string pass_key = 5;
  bool has_pass_key() const;
  void clear_pass_key();
  static const int kPassKeyFieldNumber = 5;
  const ::std::string& pass_key() const;
  void set_pass_key(const ::std::string& value);
  #if LANG_CXX11
  void set_pass_key(::std::string&& value);
  #endif
  void set_pass_key(const char* value);
  void set_pass_key(const char* value, size_t size);
  ::std::string* mutable_pass_key();
  ::std::string* release_pass_key();
  void set_allocated_pass_key(::std::string* pass_key);

  // optional .proto.dota.CMsgPracticeLobbySetDetails lobby_details = 7;
  bool has_lobby_details() const;
  void clear_lobby_details();
  static const int kLobbyDetailsFieldNumber = 7;
  const ::proto::dota::CMsgPracticeLobbySetDetails& lobby_details() const;
  ::proto::dota::CMsgPracticeLobbySetDetails* release_lobby_details();
  ::proto::dota::CMsgPracticeLobbySetDetails* mutable_lobby_details();
  void set_allocated_lobby_details(::proto::dota::CMsgPracticeLobbySetDetails* lobby_details);

  // optional .proto.dota.CMsgPracticeLobbyCreate.SaveGame save_game = 8;
  bool has_save_game() const;
  void clear_save_game();
  static const int kSaveGameFieldNumber = 8;
  const ::proto::dota::CMsgPracticeLobbyCreate_SaveGame& save_game() const;
  ::proto::dota::CMsgPracticeLobbyCreate_SaveGame* release_save_game();
  ::proto::dota::CMsgPracticeLobbyCreate_SaveGame* mutable_save_game();
  void set_allocated_save_game(::proto::dota::CMsgPracticeLobbyCreate_SaveGame* save_game);

  // optional uint32 client_version = 6;
  bool has_client_version() const;
  void clear_client_version();
  static const int kClientVersionFieldNumber = 6;
  ::google::protobuf::uint32 client_version() const;
  void set_client_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgPracticeLobbyCreate)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr search_key_;
  ::google::protobuf::internal::ArenaStringPtr pass_key_;
  ::proto::dota::CMsgPracticeLobbySetDetails* lobby_details_;
  ::proto::dota::CMsgPracticeLobbyCreate_SaveGame* save_game_;
  ::google::protobuf::uint32 client_version_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgPracticeLobbySetTeamSlot final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgPracticeLobbySetTeamSlot) */ {
 public:
  CMsgPracticeLobbySetTeamSlot();
  virtual ~CMsgPracticeLobbySetTeamSlot();

  CMsgPracticeLobbySetTeamSlot(const CMsgPracticeLobbySetTeamSlot& from);

  inline CMsgPracticeLobbySetTeamSlot& operator=(const CMsgPracticeLobbySetTeamSlot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgPracticeLobbySetTeamSlot(CMsgPracticeLobbySetTeamSlot&& from) noexcept
    : CMsgPracticeLobbySetTeamSlot() {
    *this = ::std::move(from);
  }

  inline CMsgPracticeLobbySetTeamSlot& operator=(CMsgPracticeLobbySetTeamSlot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgPracticeLobbySetTeamSlot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgPracticeLobbySetTeamSlot* internal_default_instance() {
    return reinterpret_cast<const CMsgPracticeLobbySetTeamSlot*>(
               &_CMsgPracticeLobbySetTeamSlot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(CMsgPracticeLobbySetTeamSlot* other);
  friend void swap(CMsgPracticeLobbySetTeamSlot& a, CMsgPracticeLobbySetTeamSlot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgPracticeLobbySetTeamSlot* New() const final {
    return CreateMaybeMessage<CMsgPracticeLobbySetTeamSlot>(nullptr);
  }

  CMsgPracticeLobbySetTeamSlot* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgPracticeLobbySetTeamSlot>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgPracticeLobbySetTeamSlot& from);
  void MergeFrom(const CMsgPracticeLobbySetTeamSlot& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgPracticeLobbySetTeamSlot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.DOTA_GC_TEAM team = 1 [default = DOTA_GC_TEAM_GOOD_GUYS];
  bool has_team() const;
  void clear_team();
  static const int kTeamFieldNumber = 1;
  ::proto::dota::DOTA_GC_TEAM team() const;
  void set_team(::proto::dota::DOTA_GC_TEAM value);

  // optional uint32 slot = 2;
  bool has_slot() const;
  void clear_slot();
  static const int kSlotFieldNumber = 2;
  ::google::protobuf::uint32 slot() const;
  void set_slot(::google::protobuf::uint32 value);

  // optional .proto.dota.DOTABotDifficulty bot_difficulty = 3 [default = BOT_DIFFICULTY_PASSIVE];
  bool has_bot_difficulty() const;
  void clear_bot_difficulty();
  static const int kBotDifficultyFieldNumber = 3;
  ::proto::dota::DOTABotDifficulty bot_difficulty() const;
  void set_bot_difficulty(::proto::dota::DOTABotDifficulty value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgPracticeLobbySetTeamSlot)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int team_;
  ::google::protobuf::uint32 slot_;
  int bot_difficulty_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgPracticeLobbySetCoach final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgPracticeLobbySetCoach) */ {
 public:
  CMsgPracticeLobbySetCoach();
  virtual ~CMsgPracticeLobbySetCoach();

  CMsgPracticeLobbySetCoach(const CMsgPracticeLobbySetCoach& from);

  inline CMsgPracticeLobbySetCoach& operator=(const CMsgPracticeLobbySetCoach& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgPracticeLobbySetCoach(CMsgPracticeLobbySetCoach&& from) noexcept
    : CMsgPracticeLobbySetCoach() {
    *this = ::std::move(from);
  }

  inline CMsgPracticeLobbySetCoach& operator=(CMsgPracticeLobbySetCoach&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgPracticeLobbySetCoach& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgPracticeLobbySetCoach* internal_default_instance() {
    return reinterpret_cast<const CMsgPracticeLobbySetCoach*>(
               &_CMsgPracticeLobbySetCoach_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(CMsgPracticeLobbySetCoach* other);
  friend void swap(CMsgPracticeLobbySetCoach& a, CMsgPracticeLobbySetCoach& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgPracticeLobbySetCoach* New() const final {
    return CreateMaybeMessage<CMsgPracticeLobbySetCoach>(nullptr);
  }

  CMsgPracticeLobbySetCoach* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgPracticeLobbySetCoach>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgPracticeLobbySetCoach& from);
  void MergeFrom(const CMsgPracticeLobbySetCoach& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgPracticeLobbySetCoach* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.DOTA_GC_TEAM team = 1 [default = DOTA_GC_TEAM_GOOD_GUYS];
  bool has_team() const;
  void clear_team();
  static const int kTeamFieldNumber = 1;
  ::proto::dota::DOTA_GC_TEAM team() const;
  void set_team(::proto::dota::DOTA_GC_TEAM value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgPracticeLobbySetCoach)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int team_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgPracticeLobbyJoinBroadcastChannel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel) */ {
 public:
  CMsgPracticeLobbyJoinBroadcastChannel();
  virtual ~CMsgPracticeLobbyJoinBroadcastChannel();

  CMsgPracticeLobbyJoinBroadcastChannel(const CMsgPracticeLobbyJoinBroadcastChannel& from);

  inline CMsgPracticeLobbyJoinBroadcastChannel& operator=(const CMsgPracticeLobbyJoinBroadcastChannel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgPracticeLobbyJoinBroadcastChannel(CMsgPracticeLobbyJoinBroadcastChannel&& from) noexcept
    : CMsgPracticeLobbyJoinBroadcastChannel() {
    *this = ::std::move(from);
  }

  inline CMsgPracticeLobbyJoinBroadcastChannel& operator=(CMsgPracticeLobbyJoinBroadcastChannel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgPracticeLobbyJoinBroadcastChannel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgPracticeLobbyJoinBroadcastChannel* internal_default_instance() {
    return reinterpret_cast<const CMsgPracticeLobbyJoinBroadcastChannel*>(
               &_CMsgPracticeLobbyJoinBroadcastChannel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(CMsgPracticeLobbyJoinBroadcastChannel* other);
  friend void swap(CMsgPracticeLobbyJoinBroadcastChannel& a, CMsgPracticeLobbyJoinBroadcastChannel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgPracticeLobbyJoinBroadcastChannel* New() const final {
    return CreateMaybeMessage<CMsgPracticeLobbyJoinBroadcastChannel>(nullptr);
  }

  CMsgPracticeLobbyJoinBroadcastChannel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgPracticeLobbyJoinBroadcastChannel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgPracticeLobbyJoinBroadcastChannel& from);
  void MergeFrom(const CMsgPracticeLobbyJoinBroadcastChannel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgPracticeLobbyJoinBroadcastChannel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string preferred_description = 2;
  bool has_preferred_description() const;
  void clear_preferred_description();
  static const int kPreferredDescriptionFieldNumber = 2;
  const ::std::string& preferred_description() const;
  void set_preferred_description(const ::std::string& value);
  #if LANG_CXX11
  void set_preferred_description(::std::string&& value);
  #endif
  void set_preferred_description(const char* value);
  void set_preferred_description(const char* value, size_t size);
  ::std::string* mutable_preferred_description();
  ::std::string* release_preferred_description();
  void set_allocated_preferred_description(::std::string* preferred_description);

  // optional string preferred_country_code = 3;
  bool has_preferred_country_code() const;
  void clear_preferred_country_code();
  static const int kPreferredCountryCodeFieldNumber = 3;
  const ::std::string& preferred_country_code() const;
  void set_preferred_country_code(const ::std::string& value);
  #if LANG_CXX11
  void set_preferred_country_code(::std::string&& value);
  #endif
  void set_preferred_country_code(const char* value);
  void set_preferred_country_code(const char* value, size_t size);
  ::std::string* mutable_preferred_country_code();
  ::std::string* release_preferred_country_code();
  void set_allocated_preferred_country_code(::std::string* preferred_country_code);

  // optional string preferred_language_code = 4;
  bool has_preferred_language_code() const;
  void clear_preferred_language_code();
  static const int kPreferredLanguageCodeFieldNumber = 4;
  const ::std::string& preferred_language_code() const;
  void set_preferred_language_code(const ::std::string& value);
  #if LANG_CXX11
  void set_preferred_language_code(::std::string&& value);
  #endif
  void set_preferred_language_code(const char* value);
  void set_preferred_language_code(const char* value, size_t size);
  ::std::string* mutable_preferred_language_code();
  ::std::string* release_preferred_language_code();
  void set_allocated_preferred_language_code(::std::string* preferred_language_code);

  // optional uint32 channel = 1;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 1;
  ::google::protobuf::uint32 channel() const;
  void set_channel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr preferred_description_;
  ::google::protobuf::internal::ArenaStringPtr preferred_country_code_;
  ::google::protobuf::internal::ArenaStringPtr preferred_language_code_;
  ::google::protobuf::uint32 channel_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgPracticeLobbyCloseBroadcastChannel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgPracticeLobbyCloseBroadcastChannel) */ {
 public:
  CMsgPracticeLobbyCloseBroadcastChannel();
  virtual ~CMsgPracticeLobbyCloseBroadcastChannel();

  CMsgPracticeLobbyCloseBroadcastChannel(const CMsgPracticeLobbyCloseBroadcastChannel& from);

  inline CMsgPracticeLobbyCloseBroadcastChannel& operator=(const CMsgPracticeLobbyCloseBroadcastChannel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgPracticeLobbyCloseBroadcastChannel(CMsgPracticeLobbyCloseBroadcastChannel&& from) noexcept
    : CMsgPracticeLobbyCloseBroadcastChannel() {
    *this = ::std::move(from);
  }

  inline CMsgPracticeLobbyCloseBroadcastChannel& operator=(CMsgPracticeLobbyCloseBroadcastChannel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgPracticeLobbyCloseBroadcastChannel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgPracticeLobbyCloseBroadcastChannel* internal_default_instance() {
    return reinterpret_cast<const CMsgPracticeLobbyCloseBroadcastChannel*>(
               &_CMsgPracticeLobbyCloseBroadcastChannel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(CMsgPracticeLobbyCloseBroadcastChannel* other);
  friend void swap(CMsgPracticeLobbyCloseBroadcastChannel& a, CMsgPracticeLobbyCloseBroadcastChannel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgPracticeLobbyCloseBroadcastChannel* New() const final {
    return CreateMaybeMessage<CMsgPracticeLobbyCloseBroadcastChannel>(nullptr);
  }

  CMsgPracticeLobbyCloseBroadcastChannel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgPracticeLobbyCloseBroadcastChannel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgPracticeLobbyCloseBroadcastChannel& from);
  void MergeFrom(const CMsgPracticeLobbyCloseBroadcastChannel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgPracticeLobbyCloseBroadcastChannel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 channel = 1;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 1;
  ::google::protobuf::uint32 channel() const;
  void set_channel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgPracticeLobbyCloseBroadcastChannel)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 channel_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus) */ {
 public:
  CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus();
  virtual ~CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus();

  CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus(const CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus& from);

  inline CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus& operator=(const CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus(CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus&& from) noexcept
    : CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus() {
    *this = ::std::move(from);
  }

  inline CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus& operator=(CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus* internal_default_instance() {
    return reinterpret_cast<const CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus*>(
               &_CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus* other);
  friend void swap(CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus& a, CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus* New() const final {
    return CreateMaybeMessage<CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus>(nullptr);
  }

  CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus& from);
  void MergeFrom(const CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgPracticeLobbyKick final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgPracticeLobbyKick) */ {
 public:
  CMsgPracticeLobbyKick();
  virtual ~CMsgPracticeLobbyKick();

  CMsgPracticeLobbyKick(const CMsgPracticeLobbyKick& from);

  inline CMsgPracticeLobbyKick& operator=(const CMsgPracticeLobbyKick& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgPracticeLobbyKick(CMsgPracticeLobbyKick&& from) noexcept
    : CMsgPracticeLobbyKick() {
    *this = ::std::move(from);
  }

  inline CMsgPracticeLobbyKick& operator=(CMsgPracticeLobbyKick&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgPracticeLobbyKick& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgPracticeLobbyKick* internal_default_instance() {
    return reinterpret_cast<const CMsgPracticeLobbyKick*>(
               &_CMsgPracticeLobbyKick_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(CMsgPracticeLobbyKick* other);
  friend void swap(CMsgPracticeLobbyKick& a, CMsgPracticeLobbyKick& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgPracticeLobbyKick* New() const final {
    return CreateMaybeMessage<CMsgPracticeLobbyKick>(nullptr);
  }

  CMsgPracticeLobbyKick* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgPracticeLobbyKick>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgPracticeLobbyKick& from);
  void MergeFrom(const CMsgPracticeLobbyKick& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgPracticeLobbyKick* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 account_id = 3;
  bool has_account_id() const;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 3;
  ::google::protobuf::uint32 account_id() const;
  void set_account_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgPracticeLobbyKick)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 account_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgPracticeLobbyKickFromTeam final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgPracticeLobbyKickFromTeam) */ {
 public:
  CMsgPracticeLobbyKickFromTeam();
  virtual ~CMsgPracticeLobbyKickFromTeam();

  CMsgPracticeLobbyKickFromTeam(const CMsgPracticeLobbyKickFromTeam& from);

  inline CMsgPracticeLobbyKickFromTeam& operator=(const CMsgPracticeLobbyKickFromTeam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgPracticeLobbyKickFromTeam(CMsgPracticeLobbyKickFromTeam&& from) noexcept
    : CMsgPracticeLobbyKickFromTeam() {
    *this = ::std::move(from);
  }

  inline CMsgPracticeLobbyKickFromTeam& operator=(CMsgPracticeLobbyKickFromTeam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgPracticeLobbyKickFromTeam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgPracticeLobbyKickFromTeam* internal_default_instance() {
    return reinterpret_cast<const CMsgPracticeLobbyKickFromTeam*>(
               &_CMsgPracticeLobbyKickFromTeam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(CMsgPracticeLobbyKickFromTeam* other);
  friend void swap(CMsgPracticeLobbyKickFromTeam& a, CMsgPracticeLobbyKickFromTeam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgPracticeLobbyKickFromTeam* New() const final {
    return CreateMaybeMessage<CMsgPracticeLobbyKickFromTeam>(nullptr);
  }

  CMsgPracticeLobbyKickFromTeam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgPracticeLobbyKickFromTeam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgPracticeLobbyKickFromTeam& from);
  void MergeFrom(const CMsgPracticeLobbyKickFromTeam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgPracticeLobbyKickFromTeam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 account_id = 1;
  bool has_account_id() const;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  ::google::protobuf::uint32 account_id() const;
  void set_account_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgPracticeLobbyKickFromTeam)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 account_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgPracticeLobbyLeave final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgPracticeLobbyLeave) */ {
 public:
  CMsgPracticeLobbyLeave();
  virtual ~CMsgPracticeLobbyLeave();

  CMsgPracticeLobbyLeave(const CMsgPracticeLobbyLeave& from);

  inline CMsgPracticeLobbyLeave& operator=(const CMsgPracticeLobbyLeave& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgPracticeLobbyLeave(CMsgPracticeLobbyLeave&& from) noexcept
    : CMsgPracticeLobbyLeave() {
    *this = ::std::move(from);
  }

  inline CMsgPracticeLobbyLeave& operator=(CMsgPracticeLobbyLeave&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgPracticeLobbyLeave& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgPracticeLobbyLeave* internal_default_instance() {
    return reinterpret_cast<const CMsgPracticeLobbyLeave*>(
               &_CMsgPracticeLobbyLeave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(CMsgPracticeLobbyLeave* other);
  friend void swap(CMsgPracticeLobbyLeave& a, CMsgPracticeLobbyLeave& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgPracticeLobbyLeave* New() const final {
    return CreateMaybeMessage<CMsgPracticeLobbyLeave>(nullptr);
  }

  CMsgPracticeLobbyLeave* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgPracticeLobbyLeave>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgPracticeLobbyLeave& from);
  void MergeFrom(const CMsgPracticeLobbyLeave& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgPracticeLobbyLeave* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgPracticeLobbyLeave)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgPracticeLobbyLaunch final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgPracticeLobbyLaunch) */ {
 public:
  CMsgPracticeLobbyLaunch();
  virtual ~CMsgPracticeLobbyLaunch();

  CMsgPracticeLobbyLaunch(const CMsgPracticeLobbyLaunch& from);

  inline CMsgPracticeLobbyLaunch& operator=(const CMsgPracticeLobbyLaunch& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgPracticeLobbyLaunch(CMsgPracticeLobbyLaunch&& from) noexcept
    : CMsgPracticeLobbyLaunch() {
    *this = ::std::move(from);
  }

  inline CMsgPracticeLobbyLaunch& operator=(CMsgPracticeLobbyLaunch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgPracticeLobbyLaunch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgPracticeLobbyLaunch* internal_default_instance() {
    return reinterpret_cast<const CMsgPracticeLobbyLaunch*>(
               &_CMsgPracticeLobbyLaunch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(CMsgPracticeLobbyLaunch* other);
  friend void swap(CMsgPracticeLobbyLaunch& a, CMsgPracticeLobbyLaunch& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgPracticeLobbyLaunch* New() const final {
    return CreateMaybeMessage<CMsgPracticeLobbyLaunch>(nullptr);
  }

  CMsgPracticeLobbyLaunch* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgPracticeLobbyLaunch>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgPracticeLobbyLaunch& from);
  void MergeFrom(const CMsgPracticeLobbyLaunch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgPracticeLobbyLaunch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 client_version = 5;
  bool has_client_version() const;
  void clear_client_version();
  static const int kClientVersionFieldNumber = 5;
  ::google::protobuf::uint32 client_version() const;
  void set_client_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgPracticeLobbyLaunch)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 client_version_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgApplyTeamToPracticeLobby final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgApplyTeamToPracticeLobby) */ {
 public:
  CMsgApplyTeamToPracticeLobby();
  virtual ~CMsgApplyTeamToPracticeLobby();

  CMsgApplyTeamToPracticeLobby(const CMsgApplyTeamToPracticeLobby& from);

  inline CMsgApplyTeamToPracticeLobby& operator=(const CMsgApplyTeamToPracticeLobby& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgApplyTeamToPracticeLobby(CMsgApplyTeamToPracticeLobby&& from) noexcept
    : CMsgApplyTeamToPracticeLobby() {
    *this = ::std::move(from);
  }

  inline CMsgApplyTeamToPracticeLobby& operator=(CMsgApplyTeamToPracticeLobby&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgApplyTeamToPracticeLobby& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgApplyTeamToPracticeLobby* internal_default_instance() {
    return reinterpret_cast<const CMsgApplyTeamToPracticeLobby*>(
               &_CMsgApplyTeamToPracticeLobby_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(CMsgApplyTeamToPracticeLobby* other);
  friend void swap(CMsgApplyTeamToPracticeLobby& a, CMsgApplyTeamToPracticeLobby& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgApplyTeamToPracticeLobby* New() const final {
    return CreateMaybeMessage<CMsgApplyTeamToPracticeLobby>(nullptr);
  }

  CMsgApplyTeamToPracticeLobby* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgApplyTeamToPracticeLobby>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgApplyTeamToPracticeLobby& from);
  void MergeFrom(const CMsgApplyTeamToPracticeLobby& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgApplyTeamToPracticeLobby* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 team_id = 1;
  bool has_team_id() const;
  void clear_team_id();
  static const int kTeamIdFieldNumber = 1;
  ::google::protobuf::uint32 team_id() const;
  void set_team_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgApplyTeamToPracticeLobby)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 team_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgClearPracticeLobbyTeam final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgClearPracticeLobbyTeam) */ {
 public:
  CMsgClearPracticeLobbyTeam();
  virtual ~CMsgClearPracticeLobbyTeam();

  CMsgClearPracticeLobbyTeam(const CMsgClearPracticeLobbyTeam& from);

  inline CMsgClearPracticeLobbyTeam& operator=(const CMsgClearPracticeLobbyTeam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgClearPracticeLobbyTeam(CMsgClearPracticeLobbyTeam&& from) noexcept
    : CMsgClearPracticeLobbyTeam() {
    *this = ::std::move(from);
  }

  inline CMsgClearPracticeLobbyTeam& operator=(CMsgClearPracticeLobbyTeam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgClearPracticeLobbyTeam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgClearPracticeLobbyTeam* internal_default_instance() {
    return reinterpret_cast<const CMsgClearPracticeLobbyTeam*>(
               &_CMsgClearPracticeLobbyTeam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(CMsgClearPracticeLobbyTeam* other);
  friend void swap(CMsgClearPracticeLobbyTeam& a, CMsgClearPracticeLobbyTeam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgClearPracticeLobbyTeam* New() const final {
    return CreateMaybeMessage<CMsgClearPracticeLobbyTeam>(nullptr);
  }

  CMsgClearPracticeLobbyTeam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgClearPracticeLobbyTeam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgClearPracticeLobbyTeam& from);
  void MergeFrom(const CMsgClearPracticeLobbyTeam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClearPracticeLobbyTeam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgClearPracticeLobbyTeam)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgPracticeLobbyList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgPracticeLobbyList) */ {
 public:
  CMsgPracticeLobbyList();
  virtual ~CMsgPracticeLobbyList();

  CMsgPracticeLobbyList(const CMsgPracticeLobbyList& from);

  inline CMsgPracticeLobbyList& operator=(const CMsgPracticeLobbyList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgPracticeLobbyList(CMsgPracticeLobbyList&& from) noexcept
    : CMsgPracticeLobbyList() {
    *this = ::std::move(from);
  }

  inline CMsgPracticeLobbyList& operator=(CMsgPracticeLobbyList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgPracticeLobbyList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgPracticeLobbyList* internal_default_instance() {
    return reinterpret_cast<const CMsgPracticeLobbyList*>(
               &_CMsgPracticeLobbyList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(CMsgPracticeLobbyList* other);
  friend void swap(CMsgPracticeLobbyList& a, CMsgPracticeLobbyList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgPracticeLobbyList* New() const final {
    return CreateMaybeMessage<CMsgPracticeLobbyList>(nullptr);
  }

  CMsgPracticeLobbyList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgPracticeLobbyList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgPracticeLobbyList& from);
  void MergeFrom(const CMsgPracticeLobbyList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgPracticeLobbyList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string pass_key = 2;
  bool has_pass_key() const;
  void clear_pass_key();
  static const int kPassKeyFieldNumber = 2;
  const ::std::string& pass_key() const;
  void set_pass_key(const ::std::string& value);
  #if LANG_CXX11
  void set_pass_key(::std::string&& value);
  #endif
  void set_pass_key(const char* value);
  void set_pass_key(const char* value, size_t size);
  ::std::string* mutable_pass_key();
  ::std::string* release_pass_key();
  void set_allocated_pass_key(::std::string* pass_key);

  // optional uint32 region = 3;
  bool has_region() const;
  void clear_region();
  static const int kRegionFieldNumber = 3;
  ::google::protobuf::uint32 region() const;
  void set_region(::google::protobuf::uint32 value);

  // optional .proto.dota.DOTA_GameMode game_mode = 4 [default = DOTA_GAMEMODE_NONE];
  bool has_game_mode() const;
  void clear_game_mode();
  static const int kGameModeFieldNumber = 4;
  ::proto::dota::DOTA_GameMode game_mode() const;
  void set_game_mode(::proto::dota::DOTA_GameMode value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgPracticeLobbyList)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr pass_key_;
  ::google::protobuf::uint32 region_;
  int game_mode_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgPracticeLobbyListResponseEntry_CLobbyMember final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgPracticeLobbyListResponseEntry.CLobbyMember) */ {
 public:
  CMsgPracticeLobbyListResponseEntry_CLobbyMember();
  virtual ~CMsgPracticeLobbyListResponseEntry_CLobbyMember();

  CMsgPracticeLobbyListResponseEntry_CLobbyMember(const CMsgPracticeLobbyListResponseEntry_CLobbyMember& from);

  inline CMsgPracticeLobbyListResponseEntry_CLobbyMember& operator=(const CMsgPracticeLobbyListResponseEntry_CLobbyMember& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgPracticeLobbyListResponseEntry_CLobbyMember(CMsgPracticeLobbyListResponseEntry_CLobbyMember&& from) noexcept
    : CMsgPracticeLobbyListResponseEntry_CLobbyMember() {
    *this = ::std::move(from);
  }

  inline CMsgPracticeLobbyListResponseEntry_CLobbyMember& operator=(CMsgPracticeLobbyListResponseEntry_CLobbyMember&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgPracticeLobbyListResponseEntry_CLobbyMember& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgPracticeLobbyListResponseEntry_CLobbyMember* internal_default_instance() {
    return reinterpret_cast<const CMsgPracticeLobbyListResponseEntry_CLobbyMember*>(
               &_CMsgPracticeLobbyListResponseEntry_CLobbyMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(CMsgPracticeLobbyListResponseEntry_CLobbyMember* other);
  friend void swap(CMsgPracticeLobbyListResponseEntry_CLobbyMember& a, CMsgPracticeLobbyListResponseEntry_CLobbyMember& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgPracticeLobbyListResponseEntry_CLobbyMember* New() const final {
    return CreateMaybeMessage<CMsgPracticeLobbyListResponseEntry_CLobbyMember>(nullptr);
  }

  CMsgPracticeLobbyListResponseEntry_CLobbyMember* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgPracticeLobbyListResponseEntry_CLobbyMember>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgPracticeLobbyListResponseEntry_CLobbyMember& from);
  void MergeFrom(const CMsgPracticeLobbyListResponseEntry_CLobbyMember& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgPracticeLobbyListResponseEntry_CLobbyMember* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string player_name = 2;
  bool has_player_name() const;
  void clear_player_name();
  static const int kPlayerNameFieldNumber = 2;
  const ::std::string& player_name() const;
  void set_player_name(const ::std::string& value);
  #if LANG_CXX11
  void set_player_name(::std::string&& value);
  #endif
  void set_player_name(const char* value);
  void set_player_name(const char* value, size_t size);
  ::std::string* mutable_player_name();
  ::std::string* release_player_name();
  void set_allocated_player_name(::std::string* player_name);

  // optional uint32 account_id = 1;
  bool has_account_id() const;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  ::google::protobuf::uint32 account_id() const;
  void set_account_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgPracticeLobbyListResponseEntry.CLobbyMember)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr player_name_;
  ::google::protobuf::uint32 account_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgPracticeLobbyListResponseEntry final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgPracticeLobbyListResponseEntry) */ {
 public:
  CMsgPracticeLobbyListResponseEntry();
  virtual ~CMsgPracticeLobbyListResponseEntry();

  CMsgPracticeLobbyListResponseEntry(const CMsgPracticeLobbyListResponseEntry& from);

  inline CMsgPracticeLobbyListResponseEntry& operator=(const CMsgPracticeLobbyListResponseEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgPracticeLobbyListResponseEntry(CMsgPracticeLobbyListResponseEntry&& from) noexcept
    : CMsgPracticeLobbyListResponseEntry() {
    *this = ::std::move(from);
  }

  inline CMsgPracticeLobbyListResponseEntry& operator=(CMsgPracticeLobbyListResponseEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgPracticeLobbyListResponseEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgPracticeLobbyListResponseEntry* internal_default_instance() {
    return reinterpret_cast<const CMsgPracticeLobbyListResponseEntry*>(
               &_CMsgPracticeLobbyListResponseEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(CMsgPracticeLobbyListResponseEntry* other);
  friend void swap(CMsgPracticeLobbyListResponseEntry& a, CMsgPracticeLobbyListResponseEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgPracticeLobbyListResponseEntry* New() const final {
    return CreateMaybeMessage<CMsgPracticeLobbyListResponseEntry>(nullptr);
  }

  CMsgPracticeLobbyListResponseEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgPracticeLobbyListResponseEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgPracticeLobbyListResponseEntry& from);
  void MergeFrom(const CMsgPracticeLobbyListResponseEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgPracticeLobbyListResponseEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgPracticeLobbyListResponseEntry_CLobbyMember CLobbyMember;

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgPracticeLobbyListResponseEntry.CLobbyMember members = 5;
  int members_size() const;
  void clear_members();
  static const int kMembersFieldNumber = 5;
  ::proto::dota::CMsgPracticeLobbyListResponseEntry_CLobbyMember* mutable_members(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry_CLobbyMember >*
      mutable_members();
  const ::proto::dota::CMsgPracticeLobbyListResponseEntry_CLobbyMember& members(int index) const;
  ::proto::dota::CMsgPracticeLobbyListResponseEntry_CLobbyMember* add_members();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry_CLobbyMember >&
      members() const;

  // optional string name = 10;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 10;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string custom_game_mode = 11;
  bool has_custom_game_mode() const;
  void clear_custom_game_mode();
  static const int kCustomGameModeFieldNumber = 11;
  const ::std::string& custom_game_mode() const;
  void set_custom_game_mode(const ::std::string& value);
  #if LANG_CXX11
  void set_custom_game_mode(::std::string&& value);
  #endif
  void set_custom_game_mode(const char* value);
  void set_custom_game_mode(const char* value, size_t size);
  ::std::string* mutable_custom_game_mode();
  ::std::string* release_custom_game_mode();
  void set_allocated_custom_game_mode(::std::string* custom_game_mode);

  // optional string custom_map_name = 15;
  bool has_custom_map_name() const;
  void clear_custom_map_name();
  static const int kCustomMapNameFieldNumber = 15;
  const ::std::string& custom_map_name() const;
  void set_custom_map_name(const ::std::string& value);
  #if LANG_CXX11
  void set_custom_map_name(::std::string&& value);
  #endif
  void set_custom_map_name(const char* value);
  void set_custom_map_name(const char* value, size_t size);
  ::std::string* mutable_custom_map_name();
  ::std::string* release_custom_map_name();
  void set_allocated_custom_map_name(::std::string* custom_map_name);

  // optional string lan_host_ping_location = 20;
  bool has_lan_host_ping_location() const;
  void clear_lan_host_ping_location();
  static const int kLanHostPingLocationFieldNumber = 20;
  const ::std::string& lan_host_ping_location() const;
  void set_lan_host_ping_location(const ::std::string& value);
  #if LANG_CXX11
  void set_lan_host_ping_location(::std::string&& value);
  #endif
  void set_lan_host_ping_location(const char* value);
  void set_lan_host_ping_location(const char* value, size_t size);
  ::std::string* mutable_lan_host_ping_location();
  ::std::string* release_lan_host_ping_location();
  void set_allocated_lan_host_ping_location(::std::string* lan_host_ping_location);

  // optional uint64 id = 1 [(.proto.dota.key_field) = true];
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // optional uint32 leader_account_id = 7;
  bool has_leader_account_id() const;
  void clear_leader_account_id();
  static const int kLeaderAccountIdFieldNumber = 7;
  ::google::protobuf::uint32 leader_account_id() const;
  void set_leader_account_id(::google::protobuf::uint32 value);

  // optional uint32 guild_id = 8;
  bool has_guild_id() const;
  void clear_guild_id();
  static const int kGuildIdFieldNumber = 8;
  ::google::protobuf::uint32 guild_id() const;
  void set_guild_id(::google::protobuf::uint32 value);

  // optional uint64 guild_logo = 9;
  bool has_guild_logo() const;
  void clear_guild_logo();
  static const int kGuildLogoFieldNumber = 9;
  ::google::protobuf::uint64 guild_logo() const;
  void set_guild_logo(::google::protobuf::uint64 value);

  // optional bool requires_pass_key = 6;
  bool has_requires_pass_key() const;
  void clear_requires_pass_key();
  static const int kRequiresPassKeyFieldNumber = 6;
  bool requires_pass_key() const;
  void set_requires_pass_key(bool value);

  // optional bool friend_present = 13;
  bool has_friend_present() const;
  void clear_friend_present();
  static const int kFriendPresentFieldNumber = 13;
  bool friend_present() const;
  void set_friend_present(bool value);

  // optional .proto.dota.DOTA_GameMode game_mode = 12 [default = DOTA_GAMEMODE_NONE];
  bool has_game_mode() const;
  void clear_game_mode();
  static const int kGameModeFieldNumber = 12;
  ::proto::dota::DOTA_GameMode game_mode() const;
  void set_game_mode(::proto::dota::DOTA_GameMode value);

  // optional uint32 players = 14;
  bool has_players() const;
  void clear_players();
  static const int kPlayersFieldNumber = 14;
  ::google::protobuf::uint32 players() const;
  void set_players(::google::protobuf::uint32 value);

  // optional uint32 max_player_count = 16;
  bool has_max_player_count() const;
  void clear_max_player_count();
  static const int kMaxPlayerCountFieldNumber = 16;
  ::google::protobuf::uint32 max_player_count() const;
  void set_max_player_count(::google::protobuf::uint32 value);

  // optional uint32 server_region = 17;
  bool has_server_region() const;
  void clear_server_region();
  static const int kServerRegionFieldNumber = 17;
  ::google::protobuf::uint32 server_region() const;
  void set_server_region(::google::protobuf::uint32 value);

  // optional uint32 league_id = 19;
  bool has_league_id() const;
  void clear_league_id();
  static const int kLeagueIdFieldNumber = 19;
  ::google::protobuf::uint32 league_id() const;
  void set_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgPracticeLobbyListResponseEntry)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry_CLobbyMember > members_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr custom_game_mode_;
  ::google::protobuf::internal::ArenaStringPtr custom_map_name_;
  ::google::protobuf::internal::ArenaStringPtr lan_host_ping_location_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint32 leader_account_id_;
  ::google::protobuf::uint32 guild_id_;
  ::google::protobuf::uint64 guild_logo_;
  bool requires_pass_key_;
  bool friend_present_;
  int game_mode_;
  ::google::protobuf::uint32 players_;
  ::google::protobuf::uint32 max_player_count_;
  ::google::protobuf::uint32 server_region_;
  ::google::protobuf::uint32 league_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgPracticeLobbyListResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgPracticeLobbyListResponse) */ {
 public:
  CMsgPracticeLobbyListResponse();
  virtual ~CMsgPracticeLobbyListResponse();

  CMsgPracticeLobbyListResponse(const CMsgPracticeLobbyListResponse& from);

  inline CMsgPracticeLobbyListResponse& operator=(const CMsgPracticeLobbyListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgPracticeLobbyListResponse(CMsgPracticeLobbyListResponse&& from) noexcept
    : CMsgPracticeLobbyListResponse() {
    *this = ::std::move(from);
  }

  inline CMsgPracticeLobbyListResponse& operator=(CMsgPracticeLobbyListResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgPracticeLobbyListResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgPracticeLobbyListResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgPracticeLobbyListResponse*>(
               &_CMsgPracticeLobbyListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(CMsgPracticeLobbyListResponse* other);
  friend void swap(CMsgPracticeLobbyListResponse& a, CMsgPracticeLobbyListResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgPracticeLobbyListResponse* New() const final {
    return CreateMaybeMessage<CMsgPracticeLobbyListResponse>(nullptr);
  }

  CMsgPracticeLobbyListResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgPracticeLobbyListResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgPracticeLobbyListResponse& from);
  void MergeFrom(const CMsgPracticeLobbyListResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgPracticeLobbyListResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgPracticeLobbyListResponseEntry lobbies = 2;
  int lobbies_size() const;
  void clear_lobbies();
  static const int kLobbiesFieldNumber = 2;
  ::proto::dota::CMsgPracticeLobbyListResponseEntry* mutable_lobbies(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry >*
      mutable_lobbies();
  const ::proto::dota::CMsgPracticeLobbyListResponseEntry& lobbies(int index) const;
  ::proto::dota::CMsgPracticeLobbyListResponseEntry* add_lobbies();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry >&
      lobbies() const;

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgPracticeLobbyListResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry > lobbies_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgLobbyList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgLobbyList) */ {
 public:
  CMsgLobbyList();
  virtual ~CMsgLobbyList();

  CMsgLobbyList(const CMsgLobbyList& from);

  inline CMsgLobbyList& operator=(const CMsgLobbyList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgLobbyList(CMsgLobbyList&& from) noexcept
    : CMsgLobbyList() {
    *this = ::std::move(from);
  }

  inline CMsgLobbyList& operator=(CMsgLobbyList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgLobbyList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgLobbyList* internal_default_instance() {
    return reinterpret_cast<const CMsgLobbyList*>(
               &_CMsgLobbyList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(CMsgLobbyList* other);
  friend void swap(CMsgLobbyList& a, CMsgLobbyList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgLobbyList* New() const final {
    return CreateMaybeMessage<CMsgLobbyList>(nullptr);
  }

  CMsgLobbyList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgLobbyList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgLobbyList& from);
  void MergeFrom(const CMsgLobbyList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgLobbyList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 server_region = 1 [default = 0];
  bool has_server_region() const;
  void clear_server_region();
  static const int kServerRegionFieldNumber = 1;
  ::google::protobuf::uint32 server_region() const;
  void set_server_region(::google::protobuf::uint32 value);

  // optional .proto.dota.DOTA_GameMode game_mode = 2 [default = DOTA_GAMEMODE_NONE];
  bool has_game_mode() const;
  void clear_game_mode();
  static const int kGameModeFieldNumber = 2;
  ::proto::dota::DOTA_GameMode game_mode() const;
  void set_game_mode(::proto::dota::DOTA_GameMode value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgLobbyList)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 server_region_;
  int game_mode_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgLobbyListResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgLobbyListResponse) */ {
 public:
  CMsgLobbyListResponse();
  virtual ~CMsgLobbyListResponse();

  CMsgLobbyListResponse(const CMsgLobbyListResponse& from);

  inline CMsgLobbyListResponse& operator=(const CMsgLobbyListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgLobbyListResponse(CMsgLobbyListResponse&& from) noexcept
    : CMsgLobbyListResponse() {
    *this = ::std::move(from);
  }

  inline CMsgLobbyListResponse& operator=(CMsgLobbyListResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgLobbyListResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgLobbyListResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgLobbyListResponse*>(
               &_CMsgLobbyListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(CMsgLobbyListResponse* other);
  friend void swap(CMsgLobbyListResponse& a, CMsgLobbyListResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgLobbyListResponse* New() const final {
    return CreateMaybeMessage<CMsgLobbyListResponse>(nullptr);
  }

  CMsgLobbyListResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgLobbyListResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgLobbyListResponse& from);
  void MergeFrom(const CMsgLobbyListResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgLobbyListResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgPracticeLobbyListResponseEntry lobbies = 1;
  int lobbies_size() const;
  void clear_lobbies();
  static const int kLobbiesFieldNumber = 1;
  ::proto::dota::CMsgPracticeLobbyListResponseEntry* mutable_lobbies(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry >*
      mutable_lobbies();
  const ::proto::dota::CMsgPracticeLobbyListResponseEntry& lobbies(int index) const;
  ::proto::dota::CMsgPracticeLobbyListResponseEntry* add_lobbies();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry >&
      lobbies() const;

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgLobbyListResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry > lobbies_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgPracticeLobbyJoin final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgPracticeLobbyJoin) */ {
 public:
  CMsgPracticeLobbyJoin();
  virtual ~CMsgPracticeLobbyJoin();

  CMsgPracticeLobbyJoin(const CMsgPracticeLobbyJoin& from);

  inline CMsgPracticeLobbyJoin& operator=(const CMsgPracticeLobbyJoin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgPracticeLobbyJoin(CMsgPracticeLobbyJoin&& from) noexcept
    : CMsgPracticeLobbyJoin() {
    *this = ::std::move(from);
  }

  inline CMsgPracticeLobbyJoin& operator=(CMsgPracticeLobbyJoin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgPracticeLobbyJoin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgPracticeLobbyJoin* internal_default_instance() {
    return reinterpret_cast<const CMsgPracticeLobbyJoin*>(
               &_CMsgPracticeLobbyJoin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(CMsgPracticeLobbyJoin* other);
  friend void swap(CMsgPracticeLobbyJoin& a, CMsgPracticeLobbyJoin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgPracticeLobbyJoin* New() const final {
    return CreateMaybeMessage<CMsgPracticeLobbyJoin>(nullptr);
  }

  CMsgPracticeLobbyJoin* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgPracticeLobbyJoin>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgPracticeLobbyJoin& from);
  void MergeFrom(const CMsgPracticeLobbyJoin& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgPracticeLobbyJoin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string pass_key = 3;
  bool has_pass_key() const;
  void clear_pass_key();
  static const int kPassKeyFieldNumber = 3;
  const ::std::string& pass_key() const;
  void set_pass_key(const ::std::string& value);
  #if LANG_CXX11
  void set_pass_key(::std::string&& value);
  #endif
  void set_pass_key(const char* value);
  void set_pass_key(const char* value, size_t size);
  ::std::string* mutable_pass_key();
  ::std::string* release_pass_key();
  void set_allocated_pass_key(::std::string* pass_key);

  // optional uint64 lobby_id = 1;
  bool has_lobby_id() const;
  void clear_lobby_id();
  static const int kLobbyIdFieldNumber = 1;
  ::google::protobuf::uint64 lobby_id() const;
  void set_lobby_id(::google::protobuf::uint64 value);

  // optional uint32 client_version = 2;
  bool has_client_version() const;
  void clear_client_version();
  static const int kClientVersionFieldNumber = 2;
  ::google::protobuf::uint32 client_version() const;
  void set_client_version(::google::protobuf::uint32 value);

  // optional fixed32 custom_game_timestamp = 5;
  bool has_custom_game_timestamp() const;
  void clear_custom_game_timestamp();
  static const int kCustomGameTimestampFieldNumber = 5;
  ::google::protobuf::uint32 custom_game_timestamp() const;
  void set_custom_game_timestamp(::google::protobuf::uint32 value);

  // optional fixed64 custom_game_crc = 4;
  bool has_custom_game_crc() const;
  void clear_custom_game_crc();
  static const int kCustomGameCrcFieldNumber = 4;
  ::google::protobuf::uint64 custom_game_crc() const;
  void set_custom_game_crc(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgPracticeLobbyJoin)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr pass_key_;
  ::google::protobuf::uint64 lobby_id_;
  ::google::protobuf::uint32 client_version_;
  ::google::protobuf::uint32 custom_game_timestamp_;
  ::google::protobuf::uint64 custom_game_crc_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgPracticeLobbyJoinResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgPracticeLobbyJoinResponse) */ {
 public:
  CMsgPracticeLobbyJoinResponse();
  virtual ~CMsgPracticeLobbyJoinResponse();

  CMsgPracticeLobbyJoinResponse(const CMsgPracticeLobbyJoinResponse& from);

  inline CMsgPracticeLobbyJoinResponse& operator=(const CMsgPracticeLobbyJoinResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgPracticeLobbyJoinResponse(CMsgPracticeLobbyJoinResponse&& from) noexcept
    : CMsgPracticeLobbyJoinResponse() {
    *this = ::std::move(from);
  }

  inline CMsgPracticeLobbyJoinResponse& operator=(CMsgPracticeLobbyJoinResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgPracticeLobbyJoinResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgPracticeLobbyJoinResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgPracticeLobbyJoinResponse*>(
               &_CMsgPracticeLobbyJoinResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(CMsgPracticeLobbyJoinResponse* other);
  friend void swap(CMsgPracticeLobbyJoinResponse& a, CMsgPracticeLobbyJoinResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgPracticeLobbyJoinResponse* New() const final {
    return CreateMaybeMessage<CMsgPracticeLobbyJoinResponse>(nullptr);
  }

  CMsgPracticeLobbyJoinResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgPracticeLobbyJoinResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgPracticeLobbyJoinResponse& from);
  void MergeFrom(const CMsgPracticeLobbyJoinResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgPracticeLobbyJoinResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.DOTAJoinLobbyResult result = 1 [default = DOTA_JOIN_RESULT_SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::DOTAJoinLobbyResult result() const;
  void set_result(::proto::dota::DOTAJoinLobbyResult value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgPracticeLobbyJoinResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int result_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgFriendPracticeLobbyListRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgFriendPracticeLobbyListRequest) */ {
 public:
  CMsgFriendPracticeLobbyListRequest();
  virtual ~CMsgFriendPracticeLobbyListRequest();

  CMsgFriendPracticeLobbyListRequest(const CMsgFriendPracticeLobbyListRequest& from);

  inline CMsgFriendPracticeLobbyListRequest& operator=(const CMsgFriendPracticeLobbyListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgFriendPracticeLobbyListRequest(CMsgFriendPracticeLobbyListRequest&& from) noexcept
    : CMsgFriendPracticeLobbyListRequest() {
    *this = ::std::move(from);
  }

  inline CMsgFriendPracticeLobbyListRequest& operator=(CMsgFriendPracticeLobbyListRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgFriendPracticeLobbyListRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgFriendPracticeLobbyListRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgFriendPracticeLobbyListRequest*>(
               &_CMsgFriendPracticeLobbyListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(CMsgFriendPracticeLobbyListRequest* other);
  friend void swap(CMsgFriendPracticeLobbyListRequest& a, CMsgFriendPracticeLobbyListRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgFriendPracticeLobbyListRequest* New() const final {
    return CreateMaybeMessage<CMsgFriendPracticeLobbyListRequest>(nullptr);
  }

  CMsgFriendPracticeLobbyListRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgFriendPracticeLobbyListRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgFriendPracticeLobbyListRequest& from);
  void MergeFrom(const CMsgFriendPracticeLobbyListRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgFriendPracticeLobbyListRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 friends = 1;
  int friends_size() const;
  void clear_friends();
  static const int kFriendsFieldNumber = 1;
  ::google::protobuf::uint32 friends(int index) const;
  void set_friends(int index, ::google::protobuf::uint32 value);
  void add_friends(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      friends() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_friends();

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgFriendPracticeLobbyListRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > friends_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgFriendPracticeLobbyListResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgFriendPracticeLobbyListResponse) */ {
 public:
  CMsgFriendPracticeLobbyListResponse();
  virtual ~CMsgFriendPracticeLobbyListResponse();

  CMsgFriendPracticeLobbyListResponse(const CMsgFriendPracticeLobbyListResponse& from);

  inline CMsgFriendPracticeLobbyListResponse& operator=(const CMsgFriendPracticeLobbyListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgFriendPracticeLobbyListResponse(CMsgFriendPracticeLobbyListResponse&& from) noexcept
    : CMsgFriendPracticeLobbyListResponse() {
    *this = ::std::move(from);
  }

  inline CMsgFriendPracticeLobbyListResponse& operator=(CMsgFriendPracticeLobbyListResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgFriendPracticeLobbyListResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgFriendPracticeLobbyListResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgFriendPracticeLobbyListResponse*>(
               &_CMsgFriendPracticeLobbyListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(CMsgFriendPracticeLobbyListResponse* other);
  friend void swap(CMsgFriendPracticeLobbyListResponse& a, CMsgFriendPracticeLobbyListResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgFriendPracticeLobbyListResponse* New() const final {
    return CreateMaybeMessage<CMsgFriendPracticeLobbyListResponse>(nullptr);
  }

  CMsgFriendPracticeLobbyListResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgFriendPracticeLobbyListResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgFriendPracticeLobbyListResponse& from);
  void MergeFrom(const CMsgFriendPracticeLobbyListResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgFriendPracticeLobbyListResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgPracticeLobbyListResponseEntry lobbies = 1;
  int lobbies_size() const;
  void clear_lobbies();
  static const int kLobbiesFieldNumber = 1;
  ::proto::dota::CMsgPracticeLobbyListResponseEntry* mutable_lobbies(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry >*
      mutable_lobbies();
  const ::proto::dota::CMsgPracticeLobbyListResponseEntry& lobbies(int index) const;
  ::proto::dota::CMsgPracticeLobbyListResponseEntry* add_lobbies();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry >&
      lobbies() const;

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgFriendPracticeLobbyListResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry > lobbies_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgGuildmatePracticeLobbyListRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgGuildmatePracticeLobbyListRequest) */ {
 public:
  CMsgGuildmatePracticeLobbyListRequest();
  virtual ~CMsgGuildmatePracticeLobbyListRequest();

  CMsgGuildmatePracticeLobbyListRequest(const CMsgGuildmatePracticeLobbyListRequest& from);

  inline CMsgGuildmatePracticeLobbyListRequest& operator=(const CMsgGuildmatePracticeLobbyListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgGuildmatePracticeLobbyListRequest(CMsgGuildmatePracticeLobbyListRequest&& from) noexcept
    : CMsgGuildmatePracticeLobbyListRequest() {
    *this = ::std::move(from);
  }

  inline CMsgGuildmatePracticeLobbyListRequest& operator=(CMsgGuildmatePracticeLobbyListRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgGuildmatePracticeLobbyListRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgGuildmatePracticeLobbyListRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgGuildmatePracticeLobbyListRequest*>(
               &_CMsgGuildmatePracticeLobbyListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(CMsgGuildmatePracticeLobbyListRequest* other);
  friend void swap(CMsgGuildmatePracticeLobbyListRequest& a, CMsgGuildmatePracticeLobbyListRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgGuildmatePracticeLobbyListRequest* New() const final {
    return CreateMaybeMessage<CMsgGuildmatePracticeLobbyListRequest>(nullptr);
  }

  CMsgGuildmatePracticeLobbyListRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgGuildmatePracticeLobbyListRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgGuildmatePracticeLobbyListRequest& from);
  void MergeFrom(const CMsgGuildmatePracticeLobbyListRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgGuildmatePracticeLobbyListRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 guilds = 1;
  int guilds_size() const;
  void clear_guilds();
  static const int kGuildsFieldNumber = 1;
  ::google::protobuf::uint32 guilds(int index) const;
  void set_guilds(int index, ::google::protobuf::uint32 value);
  void add_guilds(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      guilds() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_guilds();

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgGuildmatePracticeLobbyListRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > guilds_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgGuildmatePracticeLobbyListResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgGuildmatePracticeLobbyListResponse) */ {
 public:
  CMsgGuildmatePracticeLobbyListResponse();
  virtual ~CMsgGuildmatePracticeLobbyListResponse();

  CMsgGuildmatePracticeLobbyListResponse(const CMsgGuildmatePracticeLobbyListResponse& from);

  inline CMsgGuildmatePracticeLobbyListResponse& operator=(const CMsgGuildmatePracticeLobbyListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgGuildmatePracticeLobbyListResponse(CMsgGuildmatePracticeLobbyListResponse&& from) noexcept
    : CMsgGuildmatePracticeLobbyListResponse() {
    *this = ::std::move(from);
  }

  inline CMsgGuildmatePracticeLobbyListResponse& operator=(CMsgGuildmatePracticeLobbyListResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgGuildmatePracticeLobbyListResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgGuildmatePracticeLobbyListResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgGuildmatePracticeLobbyListResponse*>(
               &_CMsgGuildmatePracticeLobbyListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(CMsgGuildmatePracticeLobbyListResponse* other);
  friend void swap(CMsgGuildmatePracticeLobbyListResponse& a, CMsgGuildmatePracticeLobbyListResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgGuildmatePracticeLobbyListResponse* New() const final {
    return CreateMaybeMessage<CMsgGuildmatePracticeLobbyListResponse>(nullptr);
  }

  CMsgGuildmatePracticeLobbyListResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgGuildmatePracticeLobbyListResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgGuildmatePracticeLobbyListResponse& from);
  void MergeFrom(const CMsgGuildmatePracticeLobbyListResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgGuildmatePracticeLobbyListResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgPracticeLobbyListResponseEntry lobbies = 1;
  int lobbies_size() const;
  void clear_lobbies();
  static const int kLobbiesFieldNumber = 1;
  ::proto::dota::CMsgPracticeLobbyListResponseEntry* mutable_lobbies(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry >*
      mutable_lobbies();
  const ::proto::dota::CMsgPracticeLobbyListResponseEntry& lobbies(int index) const;
  ::proto::dota::CMsgPracticeLobbyListResponseEntry* add_lobbies();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry >&
      lobbies() const;

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgGuildmatePracticeLobbyListResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry > lobbies_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgJoinableCustomGameModesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgJoinableCustomGameModesRequest) */ {
 public:
  CMsgJoinableCustomGameModesRequest();
  virtual ~CMsgJoinableCustomGameModesRequest();

  CMsgJoinableCustomGameModesRequest(const CMsgJoinableCustomGameModesRequest& from);

  inline CMsgJoinableCustomGameModesRequest& operator=(const CMsgJoinableCustomGameModesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgJoinableCustomGameModesRequest(CMsgJoinableCustomGameModesRequest&& from) noexcept
    : CMsgJoinableCustomGameModesRequest() {
    *this = ::std::move(from);
  }

  inline CMsgJoinableCustomGameModesRequest& operator=(CMsgJoinableCustomGameModesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgJoinableCustomGameModesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgJoinableCustomGameModesRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgJoinableCustomGameModesRequest*>(
               &_CMsgJoinableCustomGameModesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(CMsgJoinableCustomGameModesRequest* other);
  friend void swap(CMsgJoinableCustomGameModesRequest& a, CMsgJoinableCustomGameModesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgJoinableCustomGameModesRequest* New() const final {
    return CreateMaybeMessage<CMsgJoinableCustomGameModesRequest>(nullptr);
  }

  CMsgJoinableCustomGameModesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgJoinableCustomGameModesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgJoinableCustomGameModesRequest& from);
  void MergeFrom(const CMsgJoinableCustomGameModesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgJoinableCustomGameModesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 server_region = 1;
  bool has_server_region() const;
  void clear_server_region();
  static const int kServerRegionFieldNumber = 1;
  ::google::protobuf::uint32 server_region() const;
  void set_server_region(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgJoinableCustomGameModesRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 server_region_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgJoinableCustomGameModesResponseEntry final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgJoinableCustomGameModesResponseEntry) */ {
 public:
  CMsgJoinableCustomGameModesResponseEntry();
  virtual ~CMsgJoinableCustomGameModesResponseEntry();

  CMsgJoinableCustomGameModesResponseEntry(const CMsgJoinableCustomGameModesResponseEntry& from);

  inline CMsgJoinableCustomGameModesResponseEntry& operator=(const CMsgJoinableCustomGameModesResponseEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgJoinableCustomGameModesResponseEntry(CMsgJoinableCustomGameModesResponseEntry&& from) noexcept
    : CMsgJoinableCustomGameModesResponseEntry() {
    *this = ::std::move(from);
  }

  inline CMsgJoinableCustomGameModesResponseEntry& operator=(CMsgJoinableCustomGameModesResponseEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgJoinableCustomGameModesResponseEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgJoinableCustomGameModesResponseEntry* internal_default_instance() {
    return reinterpret_cast<const CMsgJoinableCustomGameModesResponseEntry*>(
               &_CMsgJoinableCustomGameModesResponseEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(CMsgJoinableCustomGameModesResponseEntry* other);
  friend void swap(CMsgJoinableCustomGameModesResponseEntry& a, CMsgJoinableCustomGameModesResponseEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgJoinableCustomGameModesResponseEntry* New() const final {
    return CreateMaybeMessage<CMsgJoinableCustomGameModesResponseEntry>(nullptr);
  }

  CMsgJoinableCustomGameModesResponseEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgJoinableCustomGameModesResponseEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgJoinableCustomGameModesResponseEntry& from);
  void MergeFrom(const CMsgJoinableCustomGameModesResponseEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgJoinableCustomGameModesResponseEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 custom_game_id = 1;
  bool has_custom_game_id() const;
  void clear_custom_game_id();
  static const int kCustomGameIdFieldNumber = 1;
  ::google::protobuf::uint64 custom_game_id() const;
  void set_custom_game_id(::google::protobuf::uint64 value);

  // optional uint32 lobby_count = 2;
  bool has_lobby_count() const;
  void clear_lobby_count();
  static const int kLobbyCountFieldNumber = 2;
  ::google::protobuf::uint32 lobby_count() const;
  void set_lobby_count(::google::protobuf::uint32 value);

  // optional uint32 player_count = 3;
  bool has_player_count() const;
  void clear_player_count();
  static const int kPlayerCountFieldNumber = 3;
  ::google::protobuf::uint32 player_count() const;
  void set_player_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgJoinableCustomGameModesResponseEntry)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 custom_game_id_;
  ::google::protobuf::uint32 lobby_count_;
  ::google::protobuf::uint32 player_count_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgJoinableCustomGameModesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgJoinableCustomGameModesResponse) */ {
 public:
  CMsgJoinableCustomGameModesResponse();
  virtual ~CMsgJoinableCustomGameModesResponse();

  CMsgJoinableCustomGameModesResponse(const CMsgJoinableCustomGameModesResponse& from);

  inline CMsgJoinableCustomGameModesResponse& operator=(const CMsgJoinableCustomGameModesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgJoinableCustomGameModesResponse(CMsgJoinableCustomGameModesResponse&& from) noexcept
    : CMsgJoinableCustomGameModesResponse() {
    *this = ::std::move(from);
  }

  inline CMsgJoinableCustomGameModesResponse& operator=(CMsgJoinableCustomGameModesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgJoinableCustomGameModesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgJoinableCustomGameModesResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgJoinableCustomGameModesResponse*>(
               &_CMsgJoinableCustomGameModesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(CMsgJoinableCustomGameModesResponse* other);
  friend void swap(CMsgJoinableCustomGameModesResponse& a, CMsgJoinableCustomGameModesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgJoinableCustomGameModesResponse* New() const final {
    return CreateMaybeMessage<CMsgJoinableCustomGameModesResponse>(nullptr);
  }

  CMsgJoinableCustomGameModesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgJoinableCustomGameModesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgJoinableCustomGameModesResponse& from);
  void MergeFrom(const CMsgJoinableCustomGameModesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgJoinableCustomGameModesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgJoinableCustomGameModesResponseEntry game_modes = 1;
  int game_modes_size() const;
  void clear_game_modes();
  static const int kGameModesFieldNumber = 1;
  ::proto::dota::CMsgJoinableCustomGameModesResponseEntry* mutable_game_modes(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgJoinableCustomGameModesResponseEntry >*
      mutable_game_modes();
  const ::proto::dota::CMsgJoinableCustomGameModesResponseEntry& game_modes(int index) const;
  ::proto::dota::CMsgJoinableCustomGameModesResponseEntry* add_game_modes();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgJoinableCustomGameModesResponseEntry >&
      game_modes() const;

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgJoinableCustomGameModesResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgJoinableCustomGameModesResponseEntry > game_modes_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgJoinableCustomLobbiesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgJoinableCustomLobbiesRequest) */ {
 public:
  CMsgJoinableCustomLobbiesRequest();
  virtual ~CMsgJoinableCustomLobbiesRequest();

  CMsgJoinableCustomLobbiesRequest(const CMsgJoinableCustomLobbiesRequest& from);

  inline CMsgJoinableCustomLobbiesRequest& operator=(const CMsgJoinableCustomLobbiesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgJoinableCustomLobbiesRequest(CMsgJoinableCustomLobbiesRequest&& from) noexcept
    : CMsgJoinableCustomLobbiesRequest() {
    *this = ::std::move(from);
  }

  inline CMsgJoinableCustomLobbiesRequest& operator=(CMsgJoinableCustomLobbiesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgJoinableCustomLobbiesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgJoinableCustomLobbiesRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgJoinableCustomLobbiesRequest*>(
               &_CMsgJoinableCustomLobbiesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(CMsgJoinableCustomLobbiesRequest* other);
  friend void swap(CMsgJoinableCustomLobbiesRequest& a, CMsgJoinableCustomLobbiesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgJoinableCustomLobbiesRequest* New() const final {
    return CreateMaybeMessage<CMsgJoinableCustomLobbiesRequest>(nullptr);
  }

  CMsgJoinableCustomLobbiesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgJoinableCustomLobbiesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgJoinableCustomLobbiesRequest& from);
  void MergeFrom(const CMsgJoinableCustomLobbiesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgJoinableCustomLobbiesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 custom_game_id = 2;
  bool has_custom_game_id() const;
  void clear_custom_game_id();
  static const int kCustomGameIdFieldNumber = 2;
  ::google::protobuf::uint64 custom_game_id() const;
  void set_custom_game_id(::google::protobuf::uint64 value);

  // optional uint32 server_region = 1;
  bool has_server_region() const;
  void clear_server_region();
  static const int kServerRegionFieldNumber = 1;
  ::google::protobuf::uint32 server_region() const;
  void set_server_region(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgJoinableCustomLobbiesRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 custom_game_id_;
  ::google::protobuf::uint32 server_region_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgJoinableCustomLobbiesResponseEntry final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgJoinableCustomLobbiesResponseEntry) */ {
 public:
  CMsgJoinableCustomLobbiesResponseEntry();
  virtual ~CMsgJoinableCustomLobbiesResponseEntry();

  CMsgJoinableCustomLobbiesResponseEntry(const CMsgJoinableCustomLobbiesResponseEntry& from);

  inline CMsgJoinableCustomLobbiesResponseEntry& operator=(const CMsgJoinableCustomLobbiesResponseEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgJoinableCustomLobbiesResponseEntry(CMsgJoinableCustomLobbiesResponseEntry&& from) noexcept
    : CMsgJoinableCustomLobbiesResponseEntry() {
    *this = ::std::move(from);
  }

  inline CMsgJoinableCustomLobbiesResponseEntry& operator=(CMsgJoinableCustomLobbiesResponseEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgJoinableCustomLobbiesResponseEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgJoinableCustomLobbiesResponseEntry* internal_default_instance() {
    return reinterpret_cast<const CMsgJoinableCustomLobbiesResponseEntry*>(
               &_CMsgJoinableCustomLobbiesResponseEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(CMsgJoinableCustomLobbiesResponseEntry* other);
  friend void swap(CMsgJoinableCustomLobbiesResponseEntry& a, CMsgJoinableCustomLobbiesResponseEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgJoinableCustomLobbiesResponseEntry* New() const final {
    return CreateMaybeMessage<CMsgJoinableCustomLobbiesResponseEntry>(nullptr);
  }

  CMsgJoinableCustomLobbiesResponseEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgJoinableCustomLobbiesResponseEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgJoinableCustomLobbiesResponseEntry& from);
  void MergeFrom(const CMsgJoinableCustomLobbiesResponseEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgJoinableCustomLobbiesResponseEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string lobby_name = 3;
  bool has_lobby_name() const;
  void clear_lobby_name();
  static const int kLobbyNameFieldNumber = 3;
  const ::std::string& lobby_name() const;
  void set_lobby_name(const ::std::string& value);
  #if LANG_CXX11
  void set_lobby_name(::std::string&& value);
  #endif
  void set_lobby_name(const char* value);
  void set_lobby_name(const char* value, size_t size);
  ::std::string* mutable_lobby_name();
  ::std::string* release_lobby_name();
  void set_allocated_lobby_name(::std::string* lobby_name);

  // optional string leader_name = 6;
  bool has_leader_name() const;
  void clear_leader_name();
  static const int kLeaderNameFieldNumber = 6;
  const ::std::string& leader_name() const;
  void set_leader_name(const ::std::string& value);
  #if LANG_CXX11
  void set_leader_name(::std::string&& value);
  #endif
  void set_leader_name(const char* value);
  void set_leader_name(const char* value, size_t size);
  ::std::string* mutable_leader_name();
  ::std::string* release_leader_name();
  void set_allocated_leader_name(::std::string* leader_name);

  // optional string custom_map_name = 7;
  bool has_custom_map_name() const;
  void clear_custom_map_name();
  static const int kCustomMapNameFieldNumber = 7;
  const ::std::string& custom_map_name() const;
  void set_custom_map_name(const ::std::string& value);
  #if LANG_CXX11
  void set_custom_map_name(::std::string&& value);
  #endif
  void set_custom_map_name(const char* value);
  void set_custom_map_name(const char* value, size_t size);
  ::std::string* mutable_custom_map_name();
  ::std::string* release_custom_map_name();
  void set_allocated_custom_map_name(::std::string* custom_map_name);

  // optional string lan_host_ping_location = 12;
  bool has_lan_host_ping_location() const;
  void clear_lan_host_ping_location();
  static const int kLanHostPingLocationFieldNumber = 12;
  const ::std::string& lan_host_ping_location() const;
  void set_lan_host_ping_location(const ::std::string& value);
  #if LANG_CXX11
  void set_lan_host_ping_location(::std::string&& value);
  #endif
  void set_lan_host_ping_location(const char* value);
  void set_lan_host_ping_location(const char* value, size_t size);
  ::std::string* mutable_lan_host_ping_location();
  ::std::string* release_lan_host_ping_location();
  void set_allocated_lan_host_ping_location(::std::string* lan_host_ping_location);

  // optional fixed64 lobby_id = 1;
  bool has_lobby_id() const;
  void clear_lobby_id();
  static const int kLobbyIdFieldNumber = 1;
  ::google::protobuf::uint64 lobby_id() const;
  void set_lobby_id(::google::protobuf::uint64 value);

  // optional uint64 custom_game_id = 2;
  bool has_custom_game_id() const;
  void clear_custom_game_id();
  static const int kCustomGameIdFieldNumber = 2;
  ::google::protobuf::uint64 custom_game_id() const;
  void set_custom_game_id(::google::protobuf::uint64 value);

  // optional uint32 member_count = 4;
  bool has_member_count() const;
  void clear_member_count();
  static const int kMemberCountFieldNumber = 4;
  ::google::protobuf::uint32 member_count() const;
  void set_member_count(::google::protobuf::uint32 value);

  // optional uint32 leader_account_id = 5;
  bool has_leader_account_id() const;
  void clear_leader_account_id();
  static const int kLeaderAccountIdFieldNumber = 5;
  ::google::protobuf::uint32 leader_account_id() const;
  void set_leader_account_id(::google::protobuf::uint32 value);

  // optional uint32 max_player_count = 8;
  bool has_max_player_count() const;
  void clear_max_player_count();
  static const int kMaxPlayerCountFieldNumber = 8;
  ::google::protobuf::uint32 max_player_count() const;
  void set_max_player_count(::google::protobuf::uint32 value);

  // optional uint32 server_region = 9;
  bool has_server_region() const;
  void clear_server_region();
  static const int kServerRegionFieldNumber = 9;
  ::google::protobuf::uint32 server_region() const;
  void set_server_region(::google::protobuf::uint32 value);

  // optional bool has_pass_key = 11;
  bool has_has_pass_key() const;
  void clear_has_pass_key();
  static const int kHasPassKeyFieldNumber = 11;
  bool has_pass_key() const;
  void set_has_pass_key(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgJoinableCustomLobbiesResponseEntry)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr lobby_name_;
  ::google::protobuf::internal::ArenaStringPtr leader_name_;
  ::google::protobuf::internal::ArenaStringPtr custom_map_name_;
  ::google::protobuf::internal::ArenaStringPtr lan_host_ping_location_;
  ::google::protobuf::uint64 lobby_id_;
  ::google::protobuf::uint64 custom_game_id_;
  ::google::protobuf::uint32 member_count_;
  ::google::protobuf::uint32 leader_account_id_;
  ::google::protobuf::uint32 max_player_count_;
  ::google::protobuf::uint32 server_region_;
  bool has_pass_key_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgJoinableCustomLobbiesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgJoinableCustomLobbiesResponse) */ {
 public:
  CMsgJoinableCustomLobbiesResponse();
  virtual ~CMsgJoinableCustomLobbiesResponse();

  CMsgJoinableCustomLobbiesResponse(const CMsgJoinableCustomLobbiesResponse& from);

  inline CMsgJoinableCustomLobbiesResponse& operator=(const CMsgJoinableCustomLobbiesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgJoinableCustomLobbiesResponse(CMsgJoinableCustomLobbiesResponse&& from) noexcept
    : CMsgJoinableCustomLobbiesResponse() {
    *this = ::std::move(from);
  }

  inline CMsgJoinableCustomLobbiesResponse& operator=(CMsgJoinableCustomLobbiesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgJoinableCustomLobbiesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgJoinableCustomLobbiesResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgJoinableCustomLobbiesResponse*>(
               &_CMsgJoinableCustomLobbiesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(CMsgJoinableCustomLobbiesResponse* other);
  friend void swap(CMsgJoinableCustomLobbiesResponse& a, CMsgJoinableCustomLobbiesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgJoinableCustomLobbiesResponse* New() const final {
    return CreateMaybeMessage<CMsgJoinableCustomLobbiesResponse>(nullptr);
  }

  CMsgJoinableCustomLobbiesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgJoinableCustomLobbiesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgJoinableCustomLobbiesResponse& from);
  void MergeFrom(const CMsgJoinableCustomLobbiesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgJoinableCustomLobbiesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgJoinableCustomLobbiesResponseEntry lobbies = 1;
  int lobbies_size() const;
  void clear_lobbies();
  static const int kLobbiesFieldNumber = 1;
  ::proto::dota::CMsgJoinableCustomLobbiesResponseEntry* mutable_lobbies(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgJoinableCustomLobbiesResponseEntry >*
      mutable_lobbies();
  const ::proto::dota::CMsgJoinableCustomLobbiesResponseEntry& lobbies(int index) const;
  ::proto::dota::CMsgJoinableCustomLobbiesResponseEntry* add_lobbies();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgJoinableCustomLobbiesResponseEntry >&
      lobbies() const;

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgJoinableCustomLobbiesResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgJoinableCustomLobbiesResponseEntry > lobbies_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgQuickJoinCustomLobby_LegacyRegionPing final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgQuickJoinCustomLobby.LegacyRegionPing) */ {
 public:
  CMsgQuickJoinCustomLobby_LegacyRegionPing();
  virtual ~CMsgQuickJoinCustomLobby_LegacyRegionPing();

  CMsgQuickJoinCustomLobby_LegacyRegionPing(const CMsgQuickJoinCustomLobby_LegacyRegionPing& from);

  inline CMsgQuickJoinCustomLobby_LegacyRegionPing& operator=(const CMsgQuickJoinCustomLobby_LegacyRegionPing& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgQuickJoinCustomLobby_LegacyRegionPing(CMsgQuickJoinCustomLobby_LegacyRegionPing&& from) noexcept
    : CMsgQuickJoinCustomLobby_LegacyRegionPing() {
    *this = ::std::move(from);
  }

  inline CMsgQuickJoinCustomLobby_LegacyRegionPing& operator=(CMsgQuickJoinCustomLobby_LegacyRegionPing&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgQuickJoinCustomLobby_LegacyRegionPing& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgQuickJoinCustomLobby_LegacyRegionPing* internal_default_instance() {
    return reinterpret_cast<const CMsgQuickJoinCustomLobby_LegacyRegionPing*>(
               &_CMsgQuickJoinCustomLobby_LegacyRegionPing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(CMsgQuickJoinCustomLobby_LegacyRegionPing* other);
  friend void swap(CMsgQuickJoinCustomLobby_LegacyRegionPing& a, CMsgQuickJoinCustomLobby_LegacyRegionPing& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgQuickJoinCustomLobby_LegacyRegionPing* New() const final {
    return CreateMaybeMessage<CMsgQuickJoinCustomLobby_LegacyRegionPing>(nullptr);
  }

  CMsgQuickJoinCustomLobby_LegacyRegionPing* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgQuickJoinCustomLobby_LegacyRegionPing>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgQuickJoinCustomLobby_LegacyRegionPing& from);
  void MergeFrom(const CMsgQuickJoinCustomLobby_LegacyRegionPing& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgQuickJoinCustomLobby_LegacyRegionPing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 server_region = 1;
  bool has_server_region() const;
  void clear_server_region();
  static const int kServerRegionFieldNumber = 1;
  ::google::protobuf::uint32 server_region() const;
  void set_server_region(::google::protobuf::uint32 value);

  // optional uint32 ping = 2;
  bool has_ping() const;
  void clear_ping();
  static const int kPingFieldNumber = 2;
  ::google::protobuf::uint32 ping() const;
  void set_ping(::google::protobuf::uint32 value);

  // optional fixed32 region_code = 3;
  bool has_region_code() const;
  void clear_region_code();
  static const int kRegionCodeFieldNumber = 3;
  ::google::protobuf::uint32 region_code() const;
  void set_region_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgQuickJoinCustomLobby.LegacyRegionPing)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 server_region_;
  ::google::protobuf::uint32 ping_;
  ::google::protobuf::uint32 region_code_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgQuickJoinCustomLobby final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgQuickJoinCustomLobby) */ {
 public:
  CMsgQuickJoinCustomLobby();
  virtual ~CMsgQuickJoinCustomLobby();

  CMsgQuickJoinCustomLobby(const CMsgQuickJoinCustomLobby& from);

  inline CMsgQuickJoinCustomLobby& operator=(const CMsgQuickJoinCustomLobby& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgQuickJoinCustomLobby(CMsgQuickJoinCustomLobby&& from) noexcept
    : CMsgQuickJoinCustomLobby() {
    *this = ::std::move(from);
  }

  inline CMsgQuickJoinCustomLobby& operator=(CMsgQuickJoinCustomLobby&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgQuickJoinCustomLobby& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgQuickJoinCustomLobby* internal_default_instance() {
    return reinterpret_cast<const CMsgQuickJoinCustomLobby*>(
               &_CMsgQuickJoinCustomLobby_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(CMsgQuickJoinCustomLobby* other);
  friend void swap(CMsgQuickJoinCustomLobby& a, CMsgQuickJoinCustomLobby& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgQuickJoinCustomLobby* New() const final {
    return CreateMaybeMessage<CMsgQuickJoinCustomLobby>(nullptr);
  }

  CMsgQuickJoinCustomLobby* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgQuickJoinCustomLobby>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgQuickJoinCustomLobby& from);
  void MergeFrom(const CMsgQuickJoinCustomLobby& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgQuickJoinCustomLobby* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgQuickJoinCustomLobby_LegacyRegionPing LegacyRegionPing;

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgQuickJoinCustomLobby.LegacyRegionPing legacy_region_pings = 6;
  int legacy_region_pings_size() const;
  void clear_legacy_region_pings();
  static const int kLegacyRegionPingsFieldNumber = 6;
  ::proto::dota::CMsgQuickJoinCustomLobby_LegacyRegionPing* mutable_legacy_region_pings(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgQuickJoinCustomLobby_LegacyRegionPing >*
      mutable_legacy_region_pings();
  const ::proto::dota::CMsgQuickJoinCustomLobby_LegacyRegionPing& legacy_region_pings(int index) const;
  ::proto::dota::CMsgQuickJoinCustomLobby_LegacyRegionPing* add_legacy_region_pings();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgQuickJoinCustomLobby_LegacyRegionPing >&
      legacy_region_pings() const;

  // optional .proto.dota.CMsgPracticeLobbySetDetails create_lobby_details = 4;
  bool has_create_lobby_details() const;
  void clear_create_lobby_details();
  static const int kCreateLobbyDetailsFieldNumber = 4;
  const ::proto::dota::CMsgPracticeLobbySetDetails& create_lobby_details() const;
  ::proto::dota::CMsgPracticeLobbySetDetails* release_create_lobby_details();
  ::proto::dota::CMsgPracticeLobbySetDetails* mutable_create_lobby_details();
  void set_allocated_create_lobby_details(::proto::dota::CMsgPracticeLobbySetDetails* create_lobby_details);

  // optional .proto.dota.CMsgClientPingData ping_data = 7;
  bool has_ping_data() const;
  void clear_ping_data();
  static const int kPingDataFieldNumber = 7;
  const ::proto::dota::CMsgClientPingData& ping_data() const;
  ::proto::dota::CMsgClientPingData* release_ping_data();
  ::proto::dota::CMsgClientPingData* mutable_ping_data();
  void set_allocated_ping_data(::proto::dota::CMsgClientPingData* ping_data);

  // optional uint64 custom_game_id = 2;
  bool has_custom_game_id() const;
  void clear_custom_game_id();
  static const int kCustomGameIdFieldNumber = 2;
  ::google::protobuf::uint64 custom_game_id() const;
  void set_custom_game_id(::google::protobuf::uint64 value);

  // optional uint32 legacy_server_region = 1;
  bool has_legacy_server_region() const;
  void clear_legacy_server_region();
  static const int kLegacyServerRegionFieldNumber = 1;
  ::google::protobuf::uint32 legacy_server_region() const;
  void set_legacy_server_region(::google::protobuf::uint32 value);

  // optional uint32 client_version = 3;
  bool has_client_version() const;
  void clear_client_version();
  static const int kClientVersionFieldNumber = 3;
  ::google::protobuf::uint32 client_version() const;
  void set_client_version(::google::protobuf::uint32 value);

  // optional bool allow_any_map = 5;
  bool has_allow_any_map() const;
  void clear_allow_any_map();
  static const int kAllowAnyMapFieldNumber = 5;
  bool allow_any_map() const;
  void set_allow_any_map(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgQuickJoinCustomLobby)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgQuickJoinCustomLobby_LegacyRegionPing > legacy_region_pings_;
  ::proto::dota::CMsgPracticeLobbySetDetails* create_lobby_details_;
  ::proto::dota::CMsgClientPingData* ping_data_;
  ::google::protobuf::uint64 custom_game_id_;
  ::google::protobuf::uint32 legacy_server_region_;
  ::google::protobuf::uint32 client_version_;
  bool allow_any_map_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgQuickJoinCustomLobbyResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgQuickJoinCustomLobbyResponse) */ {
 public:
  CMsgQuickJoinCustomLobbyResponse();
  virtual ~CMsgQuickJoinCustomLobbyResponse();

  CMsgQuickJoinCustomLobbyResponse(const CMsgQuickJoinCustomLobbyResponse& from);

  inline CMsgQuickJoinCustomLobbyResponse& operator=(const CMsgQuickJoinCustomLobbyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgQuickJoinCustomLobbyResponse(CMsgQuickJoinCustomLobbyResponse&& from) noexcept
    : CMsgQuickJoinCustomLobbyResponse() {
    *this = ::std::move(from);
  }

  inline CMsgQuickJoinCustomLobbyResponse& operator=(CMsgQuickJoinCustomLobbyResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgQuickJoinCustomLobbyResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgQuickJoinCustomLobbyResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgQuickJoinCustomLobbyResponse*>(
               &_CMsgQuickJoinCustomLobbyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(CMsgQuickJoinCustomLobbyResponse* other);
  friend void swap(CMsgQuickJoinCustomLobbyResponse& a, CMsgQuickJoinCustomLobbyResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgQuickJoinCustomLobbyResponse* New() const final {
    return CreateMaybeMessage<CMsgQuickJoinCustomLobbyResponse>(nullptr);
  }

  CMsgQuickJoinCustomLobbyResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgQuickJoinCustomLobbyResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgQuickJoinCustomLobbyResponse& from);
  void MergeFrom(const CMsgQuickJoinCustomLobbyResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgQuickJoinCustomLobbyResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.DOTAJoinLobbyResult result = 1 [default = DOTA_JOIN_RESULT_SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::DOTAJoinLobbyResult result() const;
  void set_result(::proto::dota::DOTAJoinLobbyResult value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgQuickJoinCustomLobbyResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int result_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgBotGameCreate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgBotGameCreate) */ {
 public:
  CMsgBotGameCreate();
  virtual ~CMsgBotGameCreate();

  CMsgBotGameCreate(const CMsgBotGameCreate& from);

  inline CMsgBotGameCreate& operator=(const CMsgBotGameCreate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgBotGameCreate(CMsgBotGameCreate&& from) noexcept
    : CMsgBotGameCreate() {
    *this = ::std::move(from);
  }

  inline CMsgBotGameCreate& operator=(CMsgBotGameCreate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgBotGameCreate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgBotGameCreate* internal_default_instance() {
    return reinterpret_cast<const CMsgBotGameCreate*>(
               &_CMsgBotGameCreate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(CMsgBotGameCreate* other);
  friend void swap(CMsgBotGameCreate& a, CMsgBotGameCreate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgBotGameCreate* New() const final {
    return CreateMaybeMessage<CMsgBotGameCreate>(nullptr);
  }

  CMsgBotGameCreate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgBotGameCreate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgBotGameCreate& from);
  void MergeFrom(const CMsgBotGameCreate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgBotGameCreate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string search_key = 1;
  bool has_search_key() const;
  void clear_search_key();
  static const int kSearchKeyFieldNumber = 1;
  const ::std::string& search_key() const;
  void set_search_key(const ::std::string& value);
  #if LANG_CXX11
  void set_search_key(::std::string&& value);
  #endif
  void set_search_key(const char* value);
  void set_search_key(const char* value, size_t size);
  ::std::string* mutable_search_key();
  ::std::string* release_search_key();
  void set_allocated_search_key(::std::string* search_key);

  // optional uint32 client_version = 2;
  bool has_client_version() const;
  void clear_client_version();
  static const int kClientVersionFieldNumber = 2;
  ::google::protobuf::uint32 client_version() const;
  void set_client_version(::google::protobuf::uint32 value);

  // optional .proto.dota.DOTABotDifficulty difficulty_radiant = 3 [default = BOT_DIFFICULTY_PASSIVE];
  bool has_difficulty_radiant() const;
  void clear_difficulty_radiant();
  static const int kDifficultyRadiantFieldNumber = 3;
  ::proto::dota::DOTABotDifficulty difficulty_radiant() const;
  void set_difficulty_radiant(::proto::dota::DOTABotDifficulty value);

  // optional .proto.dota.DOTA_GC_TEAM team = 4 [default = DOTA_GC_TEAM_GOOD_GUYS];
  bool has_team() const;
  void clear_team();
  static const int kTeamFieldNumber = 4;
  ::proto::dota::DOTA_GC_TEAM team() const;
  void set_team(::proto::dota::DOTA_GC_TEAM value);

  // optional uint32 game_mode = 5;
  bool has_game_mode() const;
  void clear_game_mode();
  static const int kGameModeFieldNumber = 5;
  ::google::protobuf::uint32 game_mode() const;
  void set_game_mode(::google::protobuf::uint32 value);

  // optional .proto.dota.DOTABotDifficulty difficulty_dire = 6 [default = BOT_DIFFICULTY_PASSIVE];
  bool has_difficulty_dire() const;
  void clear_difficulty_dire();
  static const int kDifficultyDireFieldNumber = 6;
  ::proto::dota::DOTABotDifficulty difficulty_dire() const;
  void set_difficulty_dire(::proto::dota::DOTABotDifficulty value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgBotGameCreate)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr search_key_;
  ::google::protobuf::uint32 client_version_;
  int difficulty_radiant_;
  int team_;
  ::google::protobuf::uint32 game_mode_;
  int difficulty_dire_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgCustomGameCreate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgCustomGameCreate) */ {
 public:
  CMsgCustomGameCreate();
  virtual ~CMsgCustomGameCreate();

  CMsgCustomGameCreate(const CMsgCustomGameCreate& from);

  inline CMsgCustomGameCreate& operator=(const CMsgCustomGameCreate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgCustomGameCreate(CMsgCustomGameCreate&& from) noexcept
    : CMsgCustomGameCreate() {
    *this = ::std::move(from);
  }

  inline CMsgCustomGameCreate& operator=(CMsgCustomGameCreate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgCustomGameCreate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgCustomGameCreate* internal_default_instance() {
    return reinterpret_cast<const CMsgCustomGameCreate*>(
               &_CMsgCustomGameCreate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(CMsgCustomGameCreate* other);
  friend void swap(CMsgCustomGameCreate& a, CMsgCustomGameCreate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgCustomGameCreate* New() const final {
    return CreateMaybeMessage<CMsgCustomGameCreate>(nullptr);
  }

  CMsgCustomGameCreate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgCustomGameCreate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgCustomGameCreate& from);
  void MergeFrom(const CMsgCustomGameCreate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgCustomGameCreate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string search_key = 1;
  bool has_search_key() const;
  void clear_search_key();
  static const int kSearchKeyFieldNumber = 1;
  const ::std::string& search_key() const;
  void set_search_key(const ::std::string& value);
  #if LANG_CXX11
  void set_search_key(::std::string&& value);
  #endif
  void set_search_key(const char* value);
  void set_search_key(const char* value, size_t size);
  ::std::string* mutable_search_key();
  ::std::string* release_search_key();
  void set_allocated_search_key(::std::string* search_key);

  // optional string game_mode = 4;
  bool has_game_mode() const;
  void clear_game_mode();
  static const int kGameModeFieldNumber = 4;
  const ::std::string& game_mode() const;
  void set_game_mode(const ::std::string& value);
  #if LANG_CXX11
  void set_game_mode(::std::string&& value);
  #endif
  void set_game_mode(const char* value);
  void set_game_mode(const char* value, size_t size);
  ::std::string* mutable_game_mode();
  ::std::string* release_game_mode();
  void set_allocated_game_mode(::std::string* game_mode);

  // optional string map = 5;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 5;
  const ::std::string& map() const;
  void set_map(const ::std::string& value);
  #if LANG_CXX11
  void set_map(::std::string&& value);
  #endif
  void set_map(const char* value);
  void set_map(const char* value, size_t size);
  ::std::string* mutable_map();
  ::std::string* release_map();
  void set_allocated_map(::std::string* map);

  // optional uint32 client_version = 2;
  bool has_client_version() const;
  void clear_client_version();
  static const int kClientVersionFieldNumber = 2;
  ::google::protobuf::uint32 client_version() const;
  void set_client_version(::google::protobuf::uint32 value);

  // optional uint32 difficulty = 3;
  bool has_difficulty() const;
  void clear_difficulty();
  static const int kDifficultyFieldNumber = 3;
  ::google::protobuf::uint32 difficulty() const;
  void set_difficulty(::google::protobuf::uint32 value);

  // optional uint64 custom_game_id = 7;
  bool has_custom_game_id() const;
  void clear_custom_game_id();
  static const int kCustomGameIdFieldNumber = 7;
  ::google::protobuf::uint64 custom_game_id() const;
  void set_custom_game_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgCustomGameCreate)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr search_key_;
  ::google::protobuf::internal::ArenaStringPtr game_mode_;
  ::google::protobuf::internal::ArenaStringPtr map_;
  ::google::protobuf::uint32 client_version_;
  ::google::protobuf::uint32 difficulty_;
  ::google::protobuf::uint64 custom_game_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgEventGameCreate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgEventGameCreate) */ {
 public:
  CMsgEventGameCreate();
  virtual ~CMsgEventGameCreate();

  CMsgEventGameCreate(const CMsgEventGameCreate& from);

  inline CMsgEventGameCreate& operator=(const CMsgEventGameCreate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgEventGameCreate(CMsgEventGameCreate&& from) noexcept
    : CMsgEventGameCreate() {
    *this = ::std::move(from);
  }

  inline CMsgEventGameCreate& operator=(CMsgEventGameCreate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgEventGameCreate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgEventGameCreate* internal_default_instance() {
    return reinterpret_cast<const CMsgEventGameCreate*>(
               &_CMsgEventGameCreate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(CMsgEventGameCreate* other);
  friend void swap(CMsgEventGameCreate& a, CMsgEventGameCreate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgEventGameCreate* New() const final {
    return CreateMaybeMessage<CMsgEventGameCreate>(nullptr);
  }

  CMsgEventGameCreate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgEventGameCreate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgEventGameCreate& from);
  void MergeFrom(const CMsgEventGameCreate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgEventGameCreate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string search_key = 1;
  bool has_search_key() const;
  void clear_search_key();
  static const int kSearchKeyFieldNumber = 1;
  const ::std::string& search_key() const;
  void set_search_key(const ::std::string& value);
  #if LANG_CXX11
  void set_search_key(::std::string&& value);
  #endif
  void set_search_key(const char* value);
  void set_search_key(const char* value, size_t size);
  ::std::string* mutable_search_key();
  ::std::string* release_search_key();
  void set_allocated_search_key(::std::string* search_key);

  // optional string game_mode = 4;
  bool has_game_mode() const;
  void clear_game_mode();
  static const int kGameModeFieldNumber = 4;
  const ::std::string& game_mode() const;
  void set_game_mode(const ::std::string& value);
  #if LANG_CXX11
  void set_game_mode(::std::string&& value);
  #endif
  void set_game_mode(const char* value);
  void set_game_mode(const char* value, size_t size);
  ::std::string* mutable_game_mode();
  ::std::string* release_game_mode();
  void set_allocated_game_mode(::std::string* game_mode);

  // optional string map = 5;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 5;
  const ::std::string& map() const;
  void set_map(const ::std::string& value);
  #if LANG_CXX11
  void set_map(::std::string&& value);
  #endif
  void set_map(const char* value);
  void set_map(const char* value, size_t size);
  ::std::string* mutable_map();
  ::std::string* release_map();
  void set_allocated_map(::std::string* map);

  // optional uint32 client_version = 2;
  bool has_client_version() const;
  void clear_client_version();
  static const int kClientVersionFieldNumber = 2;
  ::google::protobuf::uint32 client_version() const;
  void set_client_version(::google::protobuf::uint32 value);

  // optional uint32 difficulty = 3;
  bool has_difficulty() const;
  void clear_difficulty();
  static const int kDifficultyFieldNumber = 3;
  ::google::protobuf::uint32 difficulty() const;
  void set_difficulty(::google::protobuf::uint32 value);

  // optional uint64 custom_game_id = 7;
  bool has_custom_game_id() const;
  void clear_custom_game_id();
  static const int kCustomGameIdFieldNumber = 7;
  ::google::protobuf::uint64 custom_game_id() const;
  void set_custom_game_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgEventGameCreate)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr search_key_;
  ::google::protobuf::internal::ArenaStringPtr game_mode_;
  ::google::protobuf::internal::ArenaStringPtr map_;
  ::google::protobuf::uint32 client_version_;
  ::google::protobuf::uint32 difficulty_;
  ::google::protobuf::uint64 custom_game_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAPartyMemberSetCoach final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAPartyMemberSetCoach) */ {
 public:
  CMsgDOTAPartyMemberSetCoach();
  virtual ~CMsgDOTAPartyMemberSetCoach();

  CMsgDOTAPartyMemberSetCoach(const CMsgDOTAPartyMemberSetCoach& from);

  inline CMsgDOTAPartyMemberSetCoach& operator=(const CMsgDOTAPartyMemberSetCoach& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAPartyMemberSetCoach(CMsgDOTAPartyMemberSetCoach&& from) noexcept
    : CMsgDOTAPartyMemberSetCoach() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAPartyMemberSetCoach& operator=(CMsgDOTAPartyMemberSetCoach&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAPartyMemberSetCoach& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAPartyMemberSetCoach* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAPartyMemberSetCoach*>(
               &_CMsgDOTAPartyMemberSetCoach_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(CMsgDOTAPartyMemberSetCoach* other);
  friend void swap(CMsgDOTAPartyMemberSetCoach& a, CMsgDOTAPartyMemberSetCoach& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAPartyMemberSetCoach* New() const final {
    return CreateMaybeMessage<CMsgDOTAPartyMemberSetCoach>(nullptr);
  }

  CMsgDOTAPartyMemberSetCoach* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAPartyMemberSetCoach>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAPartyMemberSetCoach& from);
  void MergeFrom(const CMsgDOTAPartyMemberSetCoach& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAPartyMemberSetCoach* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool wants_coach = 1;
  bool has_wants_coach() const;
  void clear_wants_coach();
  static const int kWantsCoachFieldNumber = 1;
  bool wants_coach() const;
  void set_wants_coach(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAPartyMemberSetCoach)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool wants_coach_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTASetGroupLeader final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTASetGroupLeader) */ {
 public:
  CMsgDOTASetGroupLeader();
  virtual ~CMsgDOTASetGroupLeader();

  CMsgDOTASetGroupLeader(const CMsgDOTASetGroupLeader& from);

  inline CMsgDOTASetGroupLeader& operator=(const CMsgDOTASetGroupLeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTASetGroupLeader(CMsgDOTASetGroupLeader&& from) noexcept
    : CMsgDOTASetGroupLeader() {
    *this = ::std::move(from);
  }

  inline CMsgDOTASetGroupLeader& operator=(CMsgDOTASetGroupLeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTASetGroupLeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTASetGroupLeader* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTASetGroupLeader*>(
               &_CMsgDOTASetGroupLeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(CMsgDOTASetGroupLeader* other);
  friend void swap(CMsgDOTASetGroupLeader& a, CMsgDOTASetGroupLeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTASetGroupLeader* New() const final {
    return CreateMaybeMessage<CMsgDOTASetGroupLeader>(nullptr);
  }

  CMsgDOTASetGroupLeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTASetGroupLeader>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTASetGroupLeader& from);
  void MergeFrom(const CMsgDOTASetGroupLeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTASetGroupLeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 new_leader_steamid = 1;
  bool has_new_leader_steamid() const;
  void clear_new_leader_steamid();
  static const int kNewLeaderSteamidFieldNumber = 1;
  ::google::protobuf::uint64 new_leader_steamid() const;
  void set_new_leader_steamid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTASetGroupLeader)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 new_leader_steamid_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTACancelGroupInvites final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTACancelGroupInvites) */ {
 public:
  CMsgDOTACancelGroupInvites();
  virtual ~CMsgDOTACancelGroupInvites();

  CMsgDOTACancelGroupInvites(const CMsgDOTACancelGroupInvites& from);

  inline CMsgDOTACancelGroupInvites& operator=(const CMsgDOTACancelGroupInvites& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTACancelGroupInvites(CMsgDOTACancelGroupInvites&& from) noexcept
    : CMsgDOTACancelGroupInvites() {
    *this = ::std::move(from);
  }

  inline CMsgDOTACancelGroupInvites& operator=(CMsgDOTACancelGroupInvites&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTACancelGroupInvites& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTACancelGroupInvites* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTACancelGroupInvites*>(
               &_CMsgDOTACancelGroupInvites_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  void Swap(CMsgDOTACancelGroupInvites* other);
  friend void swap(CMsgDOTACancelGroupInvites& a, CMsgDOTACancelGroupInvites& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTACancelGroupInvites* New() const final {
    return CreateMaybeMessage<CMsgDOTACancelGroupInvites>(nullptr);
  }

  CMsgDOTACancelGroupInvites* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTACancelGroupInvites>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTACancelGroupInvites& from);
  void MergeFrom(const CMsgDOTACancelGroupInvites& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTACancelGroupInvites* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated fixed64 invited_steamids = 1;
  int invited_steamids_size() const;
  void clear_invited_steamids();
  static const int kInvitedSteamidsFieldNumber = 1;
  ::google::protobuf::uint64 invited_steamids(int index) const;
  void set_invited_steamids(int index, ::google::protobuf::uint64 value);
  void add_invited_steamids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      invited_steamids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_invited_steamids();

  // repeated fixed64 invited_groupids = 2;
  int invited_groupids_size() const;
  void clear_invited_groupids();
  static const int kInvitedGroupidsFieldNumber = 2;
  ::google::protobuf::uint64 invited_groupids(int index) const;
  void set_invited_groupids(int index, ::google::protobuf::uint64 value);
  void add_invited_groupids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      invited_groupids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_invited_groupids();

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTACancelGroupInvites)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > invited_steamids_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > invited_groupids_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTASetGroupOpenStatus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTASetGroupOpenStatus) */ {
 public:
  CMsgDOTASetGroupOpenStatus();
  virtual ~CMsgDOTASetGroupOpenStatus();

  CMsgDOTASetGroupOpenStatus(const CMsgDOTASetGroupOpenStatus& from);

  inline CMsgDOTASetGroupOpenStatus& operator=(const CMsgDOTASetGroupOpenStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTASetGroupOpenStatus(CMsgDOTASetGroupOpenStatus&& from) noexcept
    : CMsgDOTASetGroupOpenStatus() {
    *this = ::std::move(from);
  }

  inline CMsgDOTASetGroupOpenStatus& operator=(CMsgDOTASetGroupOpenStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTASetGroupOpenStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTASetGroupOpenStatus* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTASetGroupOpenStatus*>(
               &_CMsgDOTASetGroupOpenStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  void Swap(CMsgDOTASetGroupOpenStatus* other);
  friend void swap(CMsgDOTASetGroupOpenStatus& a, CMsgDOTASetGroupOpenStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTASetGroupOpenStatus* New() const final {
    return CreateMaybeMessage<CMsgDOTASetGroupOpenStatus>(nullptr);
  }

  CMsgDOTASetGroupOpenStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTASetGroupOpenStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTASetGroupOpenStatus& from);
  void MergeFrom(const CMsgDOTASetGroupOpenStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTASetGroupOpenStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool open = 1;
  bool has_open() const;
  void clear_open();
  static const int kOpenFieldNumber = 1;
  bool open() const;
  void set_open(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTASetGroupOpenStatus)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool open_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAGroupMergeInvite final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAGroupMergeInvite) */ {
 public:
  CMsgDOTAGroupMergeInvite();
  virtual ~CMsgDOTAGroupMergeInvite();

  CMsgDOTAGroupMergeInvite(const CMsgDOTAGroupMergeInvite& from);

  inline CMsgDOTAGroupMergeInvite& operator=(const CMsgDOTAGroupMergeInvite& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAGroupMergeInvite(CMsgDOTAGroupMergeInvite&& from) noexcept
    : CMsgDOTAGroupMergeInvite() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAGroupMergeInvite& operator=(CMsgDOTAGroupMergeInvite&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAGroupMergeInvite& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAGroupMergeInvite* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAGroupMergeInvite*>(
               &_CMsgDOTAGroupMergeInvite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  void Swap(CMsgDOTAGroupMergeInvite* other);
  friend void swap(CMsgDOTAGroupMergeInvite& a, CMsgDOTAGroupMergeInvite& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAGroupMergeInvite* New() const final {
    return CreateMaybeMessage<CMsgDOTAGroupMergeInvite>(nullptr);
  }

  CMsgDOTAGroupMergeInvite* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAGroupMergeInvite>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAGroupMergeInvite& from);
  void MergeFrom(const CMsgDOTAGroupMergeInvite& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAGroupMergeInvite* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 other_group_id = 1;
  bool has_other_group_id() const;
  void clear_other_group_id();
  static const int kOtherGroupIdFieldNumber = 1;
  ::google::protobuf::uint64 other_group_id() const;
  void set_other_group_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAGroupMergeInvite)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 other_group_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAGroupMergeResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAGroupMergeResponse) */ {
 public:
  CMsgDOTAGroupMergeResponse();
  virtual ~CMsgDOTAGroupMergeResponse();

  CMsgDOTAGroupMergeResponse(const CMsgDOTAGroupMergeResponse& from);

  inline CMsgDOTAGroupMergeResponse& operator=(const CMsgDOTAGroupMergeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAGroupMergeResponse(CMsgDOTAGroupMergeResponse&& from) noexcept
    : CMsgDOTAGroupMergeResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAGroupMergeResponse& operator=(CMsgDOTAGroupMergeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAGroupMergeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAGroupMergeResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAGroupMergeResponse*>(
               &_CMsgDOTAGroupMergeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  void Swap(CMsgDOTAGroupMergeResponse* other);
  friend void swap(CMsgDOTAGroupMergeResponse& a, CMsgDOTAGroupMergeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAGroupMergeResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAGroupMergeResponse>(nullptr);
  }

  CMsgDOTAGroupMergeResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAGroupMergeResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAGroupMergeResponse& from);
  void MergeFrom(const CMsgDOTAGroupMergeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAGroupMergeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 initiator_group_id = 1;
  bool has_initiator_group_id() const;
  void clear_initiator_group_id();
  static const int kInitiatorGroupIdFieldNumber = 1;
  ::google::protobuf::uint64 initiator_group_id() const;
  void set_initiator_group_id(::google::protobuf::uint64 value);

  // optional bool accept = 2;
  bool has_accept() const;
  void clear_accept();
  static const int kAcceptFieldNumber = 2;
  bool accept() const;
  void set_accept(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAGroupMergeResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 initiator_group_id_;
  bool accept_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAGroupMergeReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAGroupMergeReply) */ {
 public:
  CMsgDOTAGroupMergeReply();
  virtual ~CMsgDOTAGroupMergeReply();

  CMsgDOTAGroupMergeReply(const CMsgDOTAGroupMergeReply& from);

  inline CMsgDOTAGroupMergeReply& operator=(const CMsgDOTAGroupMergeReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAGroupMergeReply(CMsgDOTAGroupMergeReply&& from) noexcept
    : CMsgDOTAGroupMergeReply() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAGroupMergeReply& operator=(CMsgDOTAGroupMergeReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAGroupMergeReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAGroupMergeReply* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAGroupMergeReply*>(
               &_CMsgDOTAGroupMergeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  void Swap(CMsgDOTAGroupMergeReply* other);
  friend void swap(CMsgDOTAGroupMergeReply& a, CMsgDOTAGroupMergeReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAGroupMergeReply* New() const final {
    return CreateMaybeMessage<CMsgDOTAGroupMergeReply>(nullptr);
  }

  CMsgDOTAGroupMergeReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAGroupMergeReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAGroupMergeReply& from);
  void MergeFrom(const CMsgDOTAGroupMergeReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAGroupMergeReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.EDOTAGroupMergeResult result = 1 [default = k_EDOTAGroupMergeResult_OK];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::EDOTAGroupMergeResult result() const;
  void set_result(::proto::dota::EDOTAGroupMergeResult value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAGroupMergeReply)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int result_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgSpectatorLobbyGameDetails_Team final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgSpectatorLobbyGameDetails.Team) */ {
 public:
  CMsgSpectatorLobbyGameDetails_Team();
  virtual ~CMsgSpectatorLobbyGameDetails_Team();

  CMsgSpectatorLobbyGameDetails_Team(const CMsgSpectatorLobbyGameDetails_Team& from);

  inline CMsgSpectatorLobbyGameDetails_Team& operator=(const CMsgSpectatorLobbyGameDetails_Team& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgSpectatorLobbyGameDetails_Team(CMsgSpectatorLobbyGameDetails_Team&& from) noexcept
    : CMsgSpectatorLobbyGameDetails_Team() {
    *this = ::std::move(from);
  }

  inline CMsgSpectatorLobbyGameDetails_Team& operator=(CMsgSpectatorLobbyGameDetails_Team&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgSpectatorLobbyGameDetails_Team& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgSpectatorLobbyGameDetails_Team* internal_default_instance() {
    return reinterpret_cast<const CMsgSpectatorLobbyGameDetails_Team*>(
               &_CMsgSpectatorLobbyGameDetails_Team_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  void Swap(CMsgSpectatorLobbyGameDetails_Team* other);
  friend void swap(CMsgSpectatorLobbyGameDetails_Team& a, CMsgSpectatorLobbyGameDetails_Team& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgSpectatorLobbyGameDetails_Team* New() const final {
    return CreateMaybeMessage<CMsgSpectatorLobbyGameDetails_Team>(nullptr);
  }

  CMsgSpectatorLobbyGameDetails_Team* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgSpectatorLobbyGameDetails_Team>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgSpectatorLobbyGameDetails_Team& from);
  void MergeFrom(const CMsgSpectatorLobbyGameDetails_Team& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgSpectatorLobbyGameDetails_Team* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string team_name = 2;
  bool has_team_name() const;
  void clear_team_name();
  static const int kTeamNameFieldNumber = 2;
  const ::std::string& team_name() const;
  void set_team_name(const ::std::string& value);
  #if LANG_CXX11
  void set_team_name(::std::string&& value);
  #endif
  void set_team_name(const char* value);
  void set_team_name(const char* value, size_t size);
  ::std::string* mutable_team_name();
  ::std::string* release_team_name();
  void set_allocated_team_name(::std::string* team_name);

  // optional fixed64 team_logo = 3;
  bool has_team_logo() const;
  void clear_team_logo();
  static const int kTeamLogoFieldNumber = 3;
  ::google::protobuf::uint64 team_logo() const;
  void set_team_logo(::google::protobuf::uint64 value);

  // optional uint32 team_id = 1;
  bool has_team_id() const;
  void clear_team_id();
  static const int kTeamIdFieldNumber = 1;
  ::google::protobuf::uint32 team_id() const;
  void set_team_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgSpectatorLobbyGameDetails.Team)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr team_name_;
  ::google::protobuf::uint64 team_logo_;
  ::google::protobuf::uint32 team_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgSpectatorLobbyGameDetails final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgSpectatorLobbyGameDetails) */ {
 public:
  CMsgSpectatorLobbyGameDetails();
  virtual ~CMsgSpectatorLobbyGameDetails();

  CMsgSpectatorLobbyGameDetails(const CMsgSpectatorLobbyGameDetails& from);

  inline CMsgSpectatorLobbyGameDetails& operator=(const CMsgSpectatorLobbyGameDetails& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgSpectatorLobbyGameDetails(CMsgSpectatorLobbyGameDetails&& from) noexcept
    : CMsgSpectatorLobbyGameDetails() {
    *this = ::std::move(from);
  }

  inline CMsgSpectatorLobbyGameDetails& operator=(CMsgSpectatorLobbyGameDetails&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgSpectatorLobbyGameDetails& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgSpectatorLobbyGameDetails* internal_default_instance() {
    return reinterpret_cast<const CMsgSpectatorLobbyGameDetails*>(
               &_CMsgSpectatorLobbyGameDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  void Swap(CMsgSpectatorLobbyGameDetails* other);
  friend void swap(CMsgSpectatorLobbyGameDetails& a, CMsgSpectatorLobbyGameDetails& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgSpectatorLobbyGameDetails* New() const final {
    return CreateMaybeMessage<CMsgSpectatorLobbyGameDetails>(nullptr);
  }

  CMsgSpectatorLobbyGameDetails* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgSpectatorLobbyGameDetails>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgSpectatorLobbyGameDetails& from);
  void MergeFrom(const CMsgSpectatorLobbyGameDetails& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgSpectatorLobbyGameDetails* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgSpectatorLobbyGameDetails_Team Team;

  // accessors -------------------------------------------------------

  // optional string stream_url = 4;
  bool has_stream_url() const;
  void clear_stream_url();
  static const int kStreamUrlFieldNumber = 4;
  const ::std::string& stream_url() const;
  void set_stream_url(const ::std::string& value);
  #if LANG_CXX11
  void set_stream_url(::std::string&& value);
  #endif
  void set_stream_url(const char* value);
  void set_stream_url(const char* value, size_t size);
  ::std::string* mutable_stream_url();
  ::std::string* release_stream_url();
  void set_allocated_stream_url(::std::string* stream_url);

  // optional string stream_name = 5;
  bool has_stream_name() const;
  void clear_stream_name();
  static const int kStreamNameFieldNumber = 5;
  const ::std::string& stream_name() const;
  void set_stream_name(const ::std::string& value);
  #if LANG_CXX11
  void set_stream_name(::std::string&& value);
  #endif
  void set_stream_name(const char* value);
  void set_stream_name(const char* value, size_t size);
  ::std::string* mutable_stream_name();
  ::std::string* release_stream_name();
  void set_allocated_stream_name(::std::string* stream_name);

  // optional .proto.dota.CMsgSpectatorLobbyGameDetails.Team radiant_team = 9;
  bool has_radiant_team() const;
  void clear_radiant_team();
  static const int kRadiantTeamFieldNumber = 9;
  const ::proto::dota::CMsgSpectatorLobbyGameDetails_Team& radiant_team() const;
  ::proto::dota::CMsgSpectatorLobbyGameDetails_Team* release_radiant_team();
  ::proto::dota::CMsgSpectatorLobbyGameDetails_Team* mutable_radiant_team();
  void set_allocated_radiant_team(::proto::dota::CMsgSpectatorLobbyGameDetails_Team* radiant_team);

  // optional .proto.dota.CMsgSpectatorLobbyGameDetails.Team dire_team = 10;
  bool has_dire_team() const;
  void clear_dire_team();
  static const int kDireTeamFieldNumber = 10;
  const ::proto::dota::CMsgSpectatorLobbyGameDetails_Team& dire_team() const;
  ::proto::dota::CMsgSpectatorLobbyGameDetails_Team* release_dire_team();
  ::proto::dota::CMsgSpectatorLobbyGameDetails_Team* mutable_dire_team();
  void set_allocated_dire_team(::proto::dota::CMsgSpectatorLobbyGameDetails_Team* dire_team);

  // optional uint64 match_id = 2;
  bool has_match_id() const;
  void clear_match_id();
  static const int kMatchIdFieldNumber = 2;
  ::google::protobuf::uint64 match_id() const;
  void set_match_id(::google::protobuf::uint64 value);

  // optional fixed64 server_steam_id = 3;
  bool has_server_steam_id() const;
  void clear_server_steam_id();
  static const int kServerSteamIdFieldNumber = 3;
  ::google::protobuf::uint64 server_steam_id() const;
  void set_server_steam_id(::google::protobuf::uint64 value);

  // optional uint32 language = 1;
  bool has_language() const;
  void clear_language();
  static const int kLanguageFieldNumber = 1;
  ::google::protobuf::uint32 language() const;
  void set_language(::google::protobuf::uint32 value);

  // optional uint32 league_id = 6;
  bool has_league_id() const;
  void clear_league_id();
  static const int kLeagueIdFieldNumber = 6;
  ::google::protobuf::uint32 league_id() const;
  void set_league_id(::google::protobuf::uint32 value);

  // optional uint32 series_type = 7;
  bool has_series_type() const;
  void clear_series_type();
  static const int kSeriesTypeFieldNumber = 7;
  ::google::protobuf::uint32 series_type() const;
  void set_series_type(::google::protobuf::uint32 value);

  // optional uint32 series_game = 8;
  bool has_series_game() const;
  void clear_series_game();
  static const int kSeriesGameFieldNumber = 8;
  ::google::protobuf::uint32 series_game() const;
  void set_series_game(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgSpectatorLobbyGameDetails)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr stream_url_;
  ::google::protobuf::internal::ArenaStringPtr stream_name_;
  ::proto::dota::CMsgSpectatorLobbyGameDetails_Team* radiant_team_;
  ::proto::dota::CMsgSpectatorLobbyGameDetails_Team* dire_team_;
  ::google::protobuf::uint64 match_id_;
  ::google::protobuf::uint64 server_steam_id_;
  ::google::protobuf::uint32 language_;
  ::google::protobuf::uint32 league_id_;
  ::google::protobuf::uint32 series_type_;
  ::google::protobuf::uint32 series_game_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgSetSpectatorLobbyDetails final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgSetSpectatorLobbyDetails) */ {
 public:
  CMsgSetSpectatorLobbyDetails();
  virtual ~CMsgSetSpectatorLobbyDetails();

  CMsgSetSpectatorLobbyDetails(const CMsgSetSpectatorLobbyDetails& from);

  inline CMsgSetSpectatorLobbyDetails& operator=(const CMsgSetSpectatorLobbyDetails& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgSetSpectatorLobbyDetails(CMsgSetSpectatorLobbyDetails&& from) noexcept
    : CMsgSetSpectatorLobbyDetails() {
    *this = ::std::move(from);
  }

  inline CMsgSetSpectatorLobbyDetails& operator=(CMsgSetSpectatorLobbyDetails&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgSetSpectatorLobbyDetails& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgSetSpectatorLobbyDetails* internal_default_instance() {
    return reinterpret_cast<const CMsgSetSpectatorLobbyDetails*>(
               &_CMsgSetSpectatorLobbyDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  void Swap(CMsgSetSpectatorLobbyDetails* other);
  friend void swap(CMsgSetSpectatorLobbyDetails& a, CMsgSetSpectatorLobbyDetails& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgSetSpectatorLobbyDetails* New() const final {
    return CreateMaybeMessage<CMsgSetSpectatorLobbyDetails>(nullptr);
  }

  CMsgSetSpectatorLobbyDetails* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgSetSpectatorLobbyDetails>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgSetSpectatorLobbyDetails& from);
  void MergeFrom(const CMsgSetSpectatorLobbyDetails& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgSetSpectatorLobbyDetails* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string lobby_name = 2;
  bool has_lobby_name() const;
  void clear_lobby_name();
  static const int kLobbyNameFieldNumber = 2;
  const ::std::string& lobby_name() const;
  void set_lobby_name(const ::std::string& value);
  #if LANG_CXX11
  void set_lobby_name(::std::string&& value);
  #endif
  void set_lobby_name(const char* value);
  void set_lobby_name(const char* value, size_t size);
  ::std::string* mutable_lobby_name();
  ::std::string* release_lobby_name();
  void set_allocated_lobby_name(::std::string* lobby_name);

  // optional string pass_key = 3;
  bool has_pass_key() const;
  void clear_pass_key();
  static const int kPassKeyFieldNumber = 3;
  const ::std::string& pass_key() const;
  void set_pass_key(const ::std::string& value);
  #if LANG_CXX11
  void set_pass_key(::std::string&& value);
  #endif
  void set_pass_key(const char* value);
  void set_pass_key(const char* value, size_t size);
  ::std::string* mutable_pass_key();
  ::std::string* release_pass_key();
  void set_allocated_pass_key(::std::string* pass_key);

  // optional .proto.dota.CMsgSpectatorLobbyGameDetails game_details = 4;
  bool has_game_details() const;
  void clear_game_details();
  static const int kGameDetailsFieldNumber = 4;
  const ::proto::dota::CMsgSpectatorLobbyGameDetails& game_details() const;
  ::proto::dota::CMsgSpectatorLobbyGameDetails* release_game_details();
  ::proto::dota::CMsgSpectatorLobbyGameDetails* mutable_game_details();
  void set_allocated_game_details(::proto::dota::CMsgSpectatorLobbyGameDetails* game_details);

  // optional uint64 lobby_id = 1;
  bool has_lobby_id() const;
  void clear_lobby_id();
  static const int kLobbyIdFieldNumber = 1;
  ::google::protobuf::uint64 lobby_id() const;
  void set_lobby_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgSetSpectatorLobbyDetails)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr lobby_name_;
  ::google::protobuf::internal::ArenaStringPtr pass_key_;
  ::proto::dota::CMsgSpectatorLobbyGameDetails* game_details_;
  ::google::protobuf::uint64 lobby_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgCreateSpectatorLobby final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgCreateSpectatorLobby) */ {
 public:
  CMsgCreateSpectatorLobby();
  virtual ~CMsgCreateSpectatorLobby();

  CMsgCreateSpectatorLobby(const CMsgCreateSpectatorLobby& from);

  inline CMsgCreateSpectatorLobby& operator=(const CMsgCreateSpectatorLobby& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgCreateSpectatorLobby(CMsgCreateSpectatorLobby&& from) noexcept
    : CMsgCreateSpectatorLobby() {
    *this = ::std::move(from);
  }

  inline CMsgCreateSpectatorLobby& operator=(CMsgCreateSpectatorLobby&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgCreateSpectatorLobby& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgCreateSpectatorLobby* internal_default_instance() {
    return reinterpret_cast<const CMsgCreateSpectatorLobby*>(
               &_CMsgCreateSpectatorLobby_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  void Swap(CMsgCreateSpectatorLobby* other);
  friend void swap(CMsgCreateSpectatorLobby& a, CMsgCreateSpectatorLobby& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgCreateSpectatorLobby* New() const final {
    return CreateMaybeMessage<CMsgCreateSpectatorLobby>(nullptr);
  }

  CMsgCreateSpectatorLobby* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgCreateSpectatorLobby>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgCreateSpectatorLobby& from);
  void MergeFrom(const CMsgCreateSpectatorLobby& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgCreateSpectatorLobby* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgSetSpectatorLobbyDetails details = 2;
  bool has_details() const;
  void clear_details();
  static const int kDetailsFieldNumber = 2;
  const ::proto::dota::CMsgSetSpectatorLobbyDetails& details() const;
  ::proto::dota::CMsgSetSpectatorLobbyDetails* release_details();
  ::proto::dota::CMsgSetSpectatorLobbyDetails* mutable_details();
  void set_allocated_details(::proto::dota::CMsgSetSpectatorLobbyDetails* details);

  // optional uint32 client_version = 1;
  bool has_client_version() const;
  void clear_client_version();
  static const int kClientVersionFieldNumber = 1;
  ::google::protobuf::uint32 client_version() const;
  void set_client_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgCreateSpectatorLobby)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::proto::dota::CMsgSetSpectatorLobbyDetails* details_;
  ::google::protobuf::uint32 client_version_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgSpectatorLobbyList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgSpectatorLobbyList) */ {
 public:
  CMsgSpectatorLobbyList();
  virtual ~CMsgSpectatorLobbyList();

  CMsgSpectatorLobbyList(const CMsgSpectatorLobbyList& from);

  inline CMsgSpectatorLobbyList& operator=(const CMsgSpectatorLobbyList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgSpectatorLobbyList(CMsgSpectatorLobbyList&& from) noexcept
    : CMsgSpectatorLobbyList() {
    *this = ::std::move(from);
  }

  inline CMsgSpectatorLobbyList& operator=(CMsgSpectatorLobbyList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgSpectatorLobbyList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgSpectatorLobbyList* internal_default_instance() {
    return reinterpret_cast<const CMsgSpectatorLobbyList*>(
               &_CMsgSpectatorLobbyList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  void Swap(CMsgSpectatorLobbyList* other);
  friend void swap(CMsgSpectatorLobbyList& a, CMsgSpectatorLobbyList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgSpectatorLobbyList* New() const final {
    return CreateMaybeMessage<CMsgSpectatorLobbyList>(nullptr);
  }

  CMsgSpectatorLobbyList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgSpectatorLobbyList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgSpectatorLobbyList& from);
  void MergeFrom(const CMsgSpectatorLobbyList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgSpectatorLobbyList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgSpectatorLobbyList)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgSpectatorLobbyListResponse_SpectatorLobby final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgSpectatorLobbyListResponse.SpectatorLobby) */ {
 public:
  CMsgSpectatorLobbyListResponse_SpectatorLobby();
  virtual ~CMsgSpectatorLobbyListResponse_SpectatorLobby();

  CMsgSpectatorLobbyListResponse_SpectatorLobby(const CMsgSpectatorLobbyListResponse_SpectatorLobby& from);

  inline CMsgSpectatorLobbyListResponse_SpectatorLobby& operator=(const CMsgSpectatorLobbyListResponse_SpectatorLobby& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgSpectatorLobbyListResponse_SpectatorLobby(CMsgSpectatorLobbyListResponse_SpectatorLobby&& from) noexcept
    : CMsgSpectatorLobbyListResponse_SpectatorLobby() {
    *this = ::std::move(from);
  }

  inline CMsgSpectatorLobbyListResponse_SpectatorLobby& operator=(CMsgSpectatorLobbyListResponse_SpectatorLobby&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgSpectatorLobbyListResponse_SpectatorLobby& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgSpectatorLobbyListResponse_SpectatorLobby* internal_default_instance() {
    return reinterpret_cast<const CMsgSpectatorLobbyListResponse_SpectatorLobby*>(
               &_CMsgSpectatorLobbyListResponse_SpectatorLobby_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  void Swap(CMsgSpectatorLobbyListResponse_SpectatorLobby* other);
  friend void swap(CMsgSpectatorLobbyListResponse_SpectatorLobby& a, CMsgSpectatorLobbyListResponse_SpectatorLobby& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgSpectatorLobbyListResponse_SpectatorLobby* New() const final {
    return CreateMaybeMessage<CMsgSpectatorLobbyListResponse_SpectatorLobby>(nullptr);
  }

  CMsgSpectatorLobbyListResponse_SpectatorLobby* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgSpectatorLobbyListResponse_SpectatorLobby>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgSpectatorLobbyListResponse_SpectatorLobby& from);
  void MergeFrom(const CMsgSpectatorLobbyListResponse_SpectatorLobby& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgSpectatorLobbyListResponse_SpectatorLobby* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string game_name = 2;
  bool has_game_name() const;
  void clear_game_name();
  static const int kGameNameFieldNumber = 2;
  const ::std::string& game_name() const;
  void set_game_name(const ::std::string& value);
  #if LANG_CXX11
  void set_game_name(::std::string&& value);
  #endif
  void set_game_name(const char* value);
  void set_game_name(const char* value, size_t size);
  ::std::string* mutable_game_name();
  ::std::string* release_game_name();
  void set_allocated_game_name(::std::string* game_name);

  // optional .proto.dota.CMsgSpectatorLobbyGameDetails game_details = 7;
  bool has_game_details() const;
  void clear_game_details();
  static const int kGameDetailsFieldNumber = 7;
  const ::proto::dota::CMsgSpectatorLobbyGameDetails& game_details() const;
  ::proto::dota::CMsgSpectatorLobbyGameDetails* release_game_details();
  ::proto::dota::CMsgSpectatorLobbyGameDetails* mutable_game_details();
  void set_allocated_game_details(::proto::dota::CMsgSpectatorLobbyGameDetails* game_details);

  // optional uint64 lobby_id = 1;
  bool has_lobby_id() const;
  void clear_lobby_id();
  static const int kLobbyIdFieldNumber = 1;
  ::google::protobuf::uint64 lobby_id() const;
  void set_lobby_id(::google::protobuf::uint64 value);

  // optional bool requires_pass_key = 3;
  bool has_requires_pass_key() const;
  void clear_requires_pass_key();
  static const int kRequiresPassKeyFieldNumber = 3;
  bool requires_pass_key() const;
  void set_requires_pass_key(bool value);

  // optional uint32 leader_account_id = 4;
  bool has_leader_account_id() const;
  void clear_leader_account_id();
  static const int kLeaderAccountIdFieldNumber = 4;
  ::google::protobuf::uint32 leader_account_id() const;
  void set_leader_account_id(::google::protobuf::uint32 value);

  // optional uint32 member_count = 5;
  bool has_member_count() const;
  void clear_member_count();
  static const int kMemberCountFieldNumber = 5;
  ::google::protobuf::uint32 member_count() const;
  void set_member_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgSpectatorLobbyListResponse.SpectatorLobby)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr game_name_;
  ::proto::dota::CMsgSpectatorLobbyGameDetails* game_details_;
  ::google::protobuf::uint64 lobby_id_;
  bool requires_pass_key_;
  ::google::protobuf::uint32 leader_account_id_;
  ::google::protobuf::uint32 member_count_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgSpectatorLobbyListResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgSpectatorLobbyListResponse) */ {
 public:
  CMsgSpectatorLobbyListResponse();
  virtual ~CMsgSpectatorLobbyListResponse();

  CMsgSpectatorLobbyListResponse(const CMsgSpectatorLobbyListResponse& from);

  inline CMsgSpectatorLobbyListResponse& operator=(const CMsgSpectatorLobbyListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgSpectatorLobbyListResponse(CMsgSpectatorLobbyListResponse&& from) noexcept
    : CMsgSpectatorLobbyListResponse() {
    *this = ::std::move(from);
  }

  inline CMsgSpectatorLobbyListResponse& operator=(CMsgSpectatorLobbyListResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgSpectatorLobbyListResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgSpectatorLobbyListResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgSpectatorLobbyListResponse*>(
               &_CMsgSpectatorLobbyListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  void Swap(CMsgSpectatorLobbyListResponse* other);
  friend void swap(CMsgSpectatorLobbyListResponse& a, CMsgSpectatorLobbyListResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgSpectatorLobbyListResponse* New() const final {
    return CreateMaybeMessage<CMsgSpectatorLobbyListResponse>(nullptr);
  }

  CMsgSpectatorLobbyListResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgSpectatorLobbyListResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgSpectatorLobbyListResponse& from);
  void MergeFrom(const CMsgSpectatorLobbyListResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgSpectatorLobbyListResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgSpectatorLobbyListResponse_SpectatorLobby SpectatorLobby;

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgSpectatorLobbyListResponse.SpectatorLobby lobbies = 1;
  int lobbies_size() const;
  void clear_lobbies();
  static const int kLobbiesFieldNumber = 1;
  ::proto::dota::CMsgSpectatorLobbyListResponse_SpectatorLobby* mutable_lobbies(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgSpectatorLobbyListResponse_SpectatorLobby >*
      mutable_lobbies();
  const ::proto::dota::CMsgSpectatorLobbyListResponse_SpectatorLobby& lobbies(int index) const;
  ::proto::dota::CMsgSpectatorLobbyListResponse_SpectatorLobby* add_lobbies();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgSpectatorLobbyListResponse_SpectatorLobby >&
      lobbies() const;

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgSpectatorLobbyListResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgSpectatorLobbyListResponse_SpectatorLobby > lobbies_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCRequestSteamDatagramTicket final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgClientToGCRequestSteamDatagramTicket) */ {
 public:
  CMsgClientToGCRequestSteamDatagramTicket();
  virtual ~CMsgClientToGCRequestSteamDatagramTicket();

  CMsgClientToGCRequestSteamDatagramTicket(const CMsgClientToGCRequestSteamDatagramTicket& from);

  inline CMsgClientToGCRequestSteamDatagramTicket& operator=(const CMsgClientToGCRequestSteamDatagramTicket& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgClientToGCRequestSteamDatagramTicket(CMsgClientToGCRequestSteamDatagramTicket&& from) noexcept
    : CMsgClientToGCRequestSteamDatagramTicket() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCRequestSteamDatagramTicket& operator=(CMsgClientToGCRequestSteamDatagramTicket&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgClientToGCRequestSteamDatagramTicket& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgClientToGCRequestSteamDatagramTicket* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCRequestSteamDatagramTicket*>(
               &_CMsgClientToGCRequestSteamDatagramTicket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  void Swap(CMsgClientToGCRequestSteamDatagramTicket* other);
  friend void swap(CMsgClientToGCRequestSteamDatagramTicket& a, CMsgClientToGCRequestSteamDatagramTicket& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgClientToGCRequestSteamDatagramTicket* New() const final {
    return CreateMaybeMessage<CMsgClientToGCRequestSteamDatagramTicket>(nullptr);
  }

  CMsgClientToGCRequestSteamDatagramTicket* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgClientToGCRequestSteamDatagramTicket>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgClientToGCRequestSteamDatagramTicket& from);
  void MergeFrom(const CMsgClientToGCRequestSteamDatagramTicket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCRequestSteamDatagramTicket* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 server_steam_id = 1;
  bool has_server_steam_id() const;
  void clear_server_steam_id();
  static const int kServerSteamIdFieldNumber = 1;
  ::google::protobuf::uint64 server_steam_id() const;
  void set_server_steam_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgClientToGCRequestSteamDatagramTicket)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 server_steam_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCRequestSteamDatagramTicketResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgClientToGCRequestSteamDatagramTicketResponse) */ {
 public:
  CMsgClientToGCRequestSteamDatagramTicketResponse();
  virtual ~CMsgClientToGCRequestSteamDatagramTicketResponse();

  CMsgClientToGCRequestSteamDatagramTicketResponse(const CMsgClientToGCRequestSteamDatagramTicketResponse& from);

  inline CMsgClientToGCRequestSteamDatagramTicketResponse& operator=(const CMsgClientToGCRequestSteamDatagramTicketResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgClientToGCRequestSteamDatagramTicketResponse(CMsgClientToGCRequestSteamDatagramTicketResponse&& from) noexcept
    : CMsgClientToGCRequestSteamDatagramTicketResponse() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCRequestSteamDatagramTicketResponse& operator=(CMsgClientToGCRequestSteamDatagramTicketResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgClientToGCRequestSteamDatagramTicketResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgClientToGCRequestSteamDatagramTicketResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCRequestSteamDatagramTicketResponse*>(
               &_CMsgClientToGCRequestSteamDatagramTicketResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  void Swap(CMsgClientToGCRequestSteamDatagramTicketResponse* other);
  friend void swap(CMsgClientToGCRequestSteamDatagramTicketResponse& a, CMsgClientToGCRequestSteamDatagramTicketResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgClientToGCRequestSteamDatagramTicketResponse* New() const final {
    return CreateMaybeMessage<CMsgClientToGCRequestSteamDatagramTicketResponse>(nullptr);
  }

  CMsgClientToGCRequestSteamDatagramTicketResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgClientToGCRequestSteamDatagramTicketResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgClientToGCRequestSteamDatagramTicketResponse& from);
  void MergeFrom(const CMsgClientToGCRequestSteamDatagramTicketResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCRequestSteamDatagramTicketResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes serialized_ticket = 1;
  bool has_serialized_ticket() const;
  void clear_serialized_ticket();
  static const int kSerializedTicketFieldNumber = 1;
  const ::std::string& serialized_ticket() const;
  void set_serialized_ticket(const ::std::string& value);
  #if LANG_CXX11
  void set_serialized_ticket(::std::string&& value);
  #endif
  void set_serialized_ticket(const char* value);
  void set_serialized_ticket(const void* value, size_t size);
  ::std::string* mutable_serialized_ticket();
  ::std::string* release_serialized_ticket();
  void set_allocated_serialized_ticket(::std::string* serialized_ticket);

  // optional string message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgClientToGCRequestSteamDatagramTicketResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr serialized_ticket_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgGCToClientSteamDatagramTicket final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgGCToClientSteamDatagramTicket) */ {
 public:
  CMsgGCToClientSteamDatagramTicket();
  virtual ~CMsgGCToClientSteamDatagramTicket();

  CMsgGCToClientSteamDatagramTicket(const CMsgGCToClientSteamDatagramTicket& from);

  inline CMsgGCToClientSteamDatagramTicket& operator=(const CMsgGCToClientSteamDatagramTicket& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgGCToClientSteamDatagramTicket(CMsgGCToClientSteamDatagramTicket&& from) noexcept
    : CMsgGCToClientSteamDatagramTicket() {
    *this = ::std::move(from);
  }

  inline CMsgGCToClientSteamDatagramTicket& operator=(CMsgGCToClientSteamDatagramTicket&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgGCToClientSteamDatagramTicket& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgGCToClientSteamDatagramTicket* internal_default_instance() {
    return reinterpret_cast<const CMsgGCToClientSteamDatagramTicket*>(
               &_CMsgGCToClientSteamDatagramTicket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  void Swap(CMsgGCToClientSteamDatagramTicket* other);
  friend void swap(CMsgGCToClientSteamDatagramTicket& a, CMsgGCToClientSteamDatagramTicket& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgGCToClientSteamDatagramTicket* New() const final {
    return CreateMaybeMessage<CMsgGCToClientSteamDatagramTicket>(nullptr);
  }

  CMsgGCToClientSteamDatagramTicket* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgGCToClientSteamDatagramTicket>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgGCToClientSteamDatagramTicket& from);
  void MergeFrom(const CMsgGCToClientSteamDatagramTicket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgGCToClientSteamDatagramTicket* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes legacy_extra_fields = 8;
  int legacy_extra_fields_size() const;
  void clear_legacy_extra_fields();
  static const int kLegacyExtraFieldsFieldNumber = 8;
  const ::std::string& legacy_extra_fields(int index) const;
  ::std::string* mutable_legacy_extra_fields(int index);
  void set_legacy_extra_fields(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_legacy_extra_fields(int index, ::std::string&& value);
  #endif
  void set_legacy_extra_fields(int index, const char* value);
  void set_legacy_extra_fields(int index, const void* value, size_t size);
  ::std::string* add_legacy_extra_fields();
  void add_legacy_extra_fields(const ::std::string& value);
  #if LANG_CXX11
  void add_legacy_extra_fields(::std::string&& value);
  #endif
  void add_legacy_extra_fields(const char* value);
  void add_legacy_extra_fields(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& legacy_extra_fields() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_legacy_extra_fields();

  // optional bytes legacy_signature = 6;
  bool has_legacy_signature() const;
  void clear_legacy_signature();
  static const int kLegacySignatureFieldNumber = 6;
  const ::std::string& legacy_signature() const;
  void set_legacy_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_legacy_signature(::std::string&& value);
  #endif
  void set_legacy_signature(const char* value);
  void set_legacy_signature(const void* value, size_t size);
  ::std::string* mutable_legacy_signature();
  ::std::string* release_legacy_signature();
  void set_allocated_legacy_signature(::std::string* legacy_signature);

  // optional bytes serialized_ticket = 16;
  bool has_serialized_ticket() const;
  void clear_serialized_ticket();
  static const int kSerializedTicketFieldNumber = 16;
  const ::std::string& serialized_ticket() const;
  void set_serialized_ticket(const ::std::string& value);
  #if LANG_CXX11
  void set_serialized_ticket(::std::string&& value);
  #endif
  void set_serialized_ticket(const char* value);
  void set_serialized_ticket(const void* value, size_t size);
  ::std::string* mutable_serialized_ticket();
  ::std::string* release_serialized_ticket();
  void set_allocated_serialized_ticket(::std::string* serialized_ticket);

  // optional fixed64 legacy_authorized_steam_id = 2;
  bool has_legacy_authorized_steam_id() const;
  void clear_legacy_authorized_steam_id();
  static const int kLegacyAuthorizedSteamIdFieldNumber = 2;
  ::google::protobuf::uint64 legacy_authorized_steam_id() const;
  void set_legacy_authorized_steam_id(::google::protobuf::uint64 value);

  // optional fixed32 legacy_time_expiry = 1;
  bool has_legacy_time_expiry() const;
  void clear_legacy_time_expiry();
  static const int kLegacyTimeExpiryFieldNumber = 1;
  ::google::protobuf::uint32 legacy_time_expiry() const;
  void set_legacy_time_expiry(::google::protobuf::uint32 value);

  // optional fixed32 legacy_authorized_public_ip = 3;
  bool has_legacy_authorized_public_ip() const;
  void clear_legacy_authorized_public_ip();
  static const int kLegacyAuthorizedPublicIpFieldNumber = 3;
  ::google::protobuf::uint32 legacy_authorized_public_ip() const;
  void set_legacy_authorized_public_ip(::google::protobuf::uint32 value);

  // optional fixed64 legacy_gameserver_steam_id = 4;
  bool has_legacy_gameserver_steam_id() const;
  void clear_legacy_gameserver_steam_id();
  static const int kLegacyGameserverSteamIdFieldNumber = 4;
  ::google::protobuf::uint64 legacy_gameserver_steam_id() const;
  void set_legacy_gameserver_steam_id(::google::protobuf::uint64 value);

  // optional fixed64 legacy_gameserver_net_id = 5;
  bool has_legacy_gameserver_net_id() const;
  void clear_legacy_gameserver_net_id();
  static const int kLegacyGameserverNetIdFieldNumber = 5;
  ::google::protobuf::uint64 legacy_gameserver_net_id() const;
  void set_legacy_gameserver_net_id(::google::protobuf::uint64 value);

  // optional uint32 legacy_app_id = 7;
  bool has_legacy_app_id() const;
  void clear_legacy_app_id();
  static const int kLegacyAppIdFieldNumber = 7;
  ::google::protobuf::uint32 legacy_app_id() const;
  void set_legacy_app_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgGCToClientSteamDatagramTicket)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField<::std::string> legacy_extra_fields_;
  ::google::protobuf::internal::ArenaStringPtr legacy_signature_;
  ::google::protobuf::internal::ArenaStringPtr serialized_ticket_;
  ::google::protobuf::uint64 legacy_authorized_steam_id_;
  ::google::protobuf::uint32 legacy_time_expiry_;
  ::google::protobuf::uint32 legacy_authorized_public_ip_;
  ::google::protobuf::uint64 legacy_gameserver_steam_id_;
  ::google::protobuf::uint64 legacy_gameserver_net_id_;
  ::google::protobuf::uint32 legacy_app_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgGCToClientRequestLaneSelection final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgGCToClientRequestLaneSelection) */ {
 public:
  CMsgGCToClientRequestLaneSelection();
  virtual ~CMsgGCToClientRequestLaneSelection();

  CMsgGCToClientRequestLaneSelection(const CMsgGCToClientRequestLaneSelection& from);

  inline CMsgGCToClientRequestLaneSelection& operator=(const CMsgGCToClientRequestLaneSelection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgGCToClientRequestLaneSelection(CMsgGCToClientRequestLaneSelection&& from) noexcept
    : CMsgGCToClientRequestLaneSelection() {
    *this = ::std::move(from);
  }

  inline CMsgGCToClientRequestLaneSelection& operator=(CMsgGCToClientRequestLaneSelection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgGCToClientRequestLaneSelection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgGCToClientRequestLaneSelection* internal_default_instance() {
    return reinterpret_cast<const CMsgGCToClientRequestLaneSelection*>(
               &_CMsgGCToClientRequestLaneSelection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  void Swap(CMsgGCToClientRequestLaneSelection* other);
  friend void swap(CMsgGCToClientRequestLaneSelection& a, CMsgGCToClientRequestLaneSelection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgGCToClientRequestLaneSelection* New() const final {
    return CreateMaybeMessage<CMsgGCToClientRequestLaneSelection>(nullptr);
  }

  CMsgGCToClientRequestLaneSelection* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgGCToClientRequestLaneSelection>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgGCToClientRequestLaneSelection& from);
  void MergeFrom(const CMsgGCToClientRequestLaneSelection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgGCToClientRequestLaneSelection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgGCToClientRequestLaneSelection)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// -------------------------------------------------------------------

class CMsgGCToClientRequestLaneSelectionResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgGCToClientRequestLaneSelectionResponse) */ {
 public:
  CMsgGCToClientRequestLaneSelectionResponse();
  virtual ~CMsgGCToClientRequestLaneSelectionResponse();

  CMsgGCToClientRequestLaneSelectionResponse(const CMsgGCToClientRequestLaneSelectionResponse& from);

  inline CMsgGCToClientRequestLaneSelectionResponse& operator=(const CMsgGCToClientRequestLaneSelectionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgGCToClientRequestLaneSelectionResponse(CMsgGCToClientRequestLaneSelectionResponse&& from) noexcept
    : CMsgGCToClientRequestLaneSelectionResponse() {
    *this = ::std::move(from);
  }

  inline CMsgGCToClientRequestLaneSelectionResponse& operator=(CMsgGCToClientRequestLaneSelectionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgGCToClientRequestLaneSelectionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgGCToClientRequestLaneSelectionResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgGCToClientRequestLaneSelectionResponse*>(
               &_CMsgGCToClientRequestLaneSelectionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  void Swap(CMsgGCToClientRequestLaneSelectionResponse* other);
  friend void swap(CMsgGCToClientRequestLaneSelectionResponse& a, CMsgGCToClientRequestLaneSelectionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgGCToClientRequestLaneSelectionResponse* New() const final {
    return CreateMaybeMessage<CMsgGCToClientRequestLaneSelectionResponse>(nullptr);
  }

  CMsgGCToClientRequestLaneSelectionResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgGCToClientRequestLaneSelectionResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgGCToClientRequestLaneSelectionResponse& from);
  void MergeFrom(const CMsgGCToClientRequestLaneSelectionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgGCToClientRequestLaneSelectionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 lane_selection_flags = 1;
  bool has_lane_selection_flags() const;
  void clear_lane_selection_flags();
  static const int kLaneSelectionFlagsFieldNumber = 1;
  ::google::protobuf::uint32 lane_selection_flags() const;
  void set_lane_selection_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgGCToClientRequestLaneSelectionResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 lane_selection_flags_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CMsgStartFindingMatch

// optional string key = 1;
inline bool CMsgStartFindingMatch::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgStartFindingMatch::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgStartFindingMatch::key() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgStartFindingMatch.key)
  return key_.GetNoArena();
}
inline void CMsgStartFindingMatch::set_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgStartFindingMatch.key)
}
#if LANG_CXX11
inline void CMsgStartFindingMatch::set_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgStartFindingMatch.key)
}
#endif
inline void CMsgStartFindingMatch::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgStartFindingMatch.key)
}
inline void CMsgStartFindingMatch::set_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgStartFindingMatch.key)
}
inline ::std::string* CMsgStartFindingMatch::mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgStartFindingMatch.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgStartFindingMatch::release_key() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgStartFindingMatch.key)
  if (!has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgStartFindingMatch::set_allocated_key(::std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgStartFindingMatch.key)
}

// optional uint32 matchgroups = 2 [default = 4294967295];
inline bool CMsgStartFindingMatch::has_matchgroups() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgStartFindingMatch::clear_matchgroups() {
  matchgroups_ = 4294967295u;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::google::protobuf::uint32 CMsgStartFindingMatch::matchgroups() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgStartFindingMatch.matchgroups)
  return matchgroups_;
}
inline void CMsgStartFindingMatch::set_matchgroups(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00002000u;
  matchgroups_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgStartFindingMatch.matchgroups)
}

// optional uint32 client_version = 3;
inline bool CMsgStartFindingMatch::has_client_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgStartFindingMatch::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgStartFindingMatch::client_version() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgStartFindingMatch.client_version)
  return client_version_;
}
inline void CMsgStartFindingMatch::set_client_version(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  client_version_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgStartFindingMatch.client_version)
}

// optional uint32 game_modes = 4 [default = 4294967295];
inline bool CMsgStartFindingMatch::has_game_modes() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CMsgStartFindingMatch::clear_game_modes() {
  game_modes_ = 4294967295u;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::google::protobuf::uint32 CMsgStartFindingMatch::game_modes() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgStartFindingMatch.game_modes)
  return game_modes_;
}
inline void CMsgStartFindingMatch::set_game_modes(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00004000u;
  game_modes_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgStartFindingMatch.game_modes)
}

// optional .proto.dota.DOTABotDifficulty bot_difficulty = 5 [default = BOT_DIFFICULTY_HARD];
inline bool CMsgStartFindingMatch::has_bot_difficulty() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CMsgStartFindingMatch::clear_bot_difficulty() {
  bot_difficulty_ = 3;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::proto::dota::DOTABotDifficulty CMsgStartFindingMatch::bot_difficulty() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgStartFindingMatch.bot_difficulty)
  return static_cast< ::proto::dota::DOTABotDifficulty >(bot_difficulty_);
}
inline void CMsgStartFindingMatch::set_bot_difficulty(::proto::dota::DOTABotDifficulty value) {
  assert(::proto::dota::DOTABotDifficulty_IsValid(value));
  _has_bits_[0] |= 0x00008000u;
  bot_difficulty_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgStartFindingMatch.bot_difficulty)
}

// optional .proto.dota.MatchType match_type = 6 [default = MATCH_TYPE_CASUAL];
inline bool CMsgStartFindingMatch::has_match_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgStartFindingMatch::clear_match_type() {
  match_type_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::proto::dota::MatchType CMsgStartFindingMatch::match_type() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgStartFindingMatch.match_type)
  return static_cast< ::proto::dota::MatchType >(match_type_);
}
inline void CMsgStartFindingMatch::set_match_type(::proto::dota::MatchType value) {
  assert(::proto::dota::MatchType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  match_type_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgStartFindingMatch.match_type)
}

// optional uint32 matchlanguages = 7 [default = 4294967295];
inline bool CMsgStartFindingMatch::has_matchlanguages() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CMsgStartFindingMatch::clear_matchlanguages() {
  matchlanguages_ = 4294967295u;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::google::protobuf::uint32 CMsgStartFindingMatch::matchlanguages() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgStartFindingMatch.matchlanguages)
  return matchlanguages_;
}
inline void CMsgStartFindingMatch::set_matchlanguages(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00010000u;
  matchlanguages_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgStartFindingMatch.matchlanguages)
}

// optional uint32 team_id = 8;
inline bool CMsgStartFindingMatch::has_team_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgStartFindingMatch::clear_team_id() {
  team_id_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 CMsgStartFindingMatch::team_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgStartFindingMatch.team_id)
  return team_id_;
}
inline void CMsgStartFindingMatch::set_team_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  team_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgStartFindingMatch.team_id)
}

// optional .proto.dota.MatchLanguages game_language_enum = 10 [default = MATCH_LANGUAGE_INVALID];
inline bool CMsgStartFindingMatch::has_game_language_enum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgStartFindingMatch::clear_game_language_enum() {
  game_language_enum_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::proto::dota::MatchLanguages CMsgStartFindingMatch::game_language_enum() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgStartFindingMatch.game_language_enum)
  return static_cast< ::proto::dota::MatchLanguages >(game_language_enum_);
}
inline void CMsgStartFindingMatch::set_game_language_enum(::proto::dota::MatchLanguages value) {
  assert(::proto::dota::MatchLanguages_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  game_language_enum_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgStartFindingMatch.game_language_enum)
}

// optional string game_language_name = 11;
inline bool CMsgStartFindingMatch::has_game_language_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgStartFindingMatch::clear_game_language_name() {
  game_language_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgStartFindingMatch::game_language_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgStartFindingMatch.game_language_name)
  return game_language_name_.GetNoArena();
}
inline void CMsgStartFindingMatch::set_game_language_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  game_language_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgStartFindingMatch.game_language_name)
}
#if LANG_CXX11
inline void CMsgStartFindingMatch::set_game_language_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  game_language_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgStartFindingMatch.game_language_name)
}
#endif
inline void CMsgStartFindingMatch::set_game_language_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  game_language_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgStartFindingMatch.game_language_name)
}
inline void CMsgStartFindingMatch::set_game_language_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  game_language_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgStartFindingMatch.game_language_name)
}
inline ::std::string* CMsgStartFindingMatch::mutable_game_language_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgStartFindingMatch.game_language_name)
  return game_language_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgStartFindingMatch::release_game_language_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgStartFindingMatch.game_language_name)
  if (!has_game_language_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return game_language_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgStartFindingMatch::set_allocated_game_language_name(::std::string* game_language_name) {
  if (game_language_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  game_language_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), game_language_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgStartFindingMatch.game_language_name)
}

// optional .proto.dota.CMsgClientPingData ping_data = 12;
inline bool CMsgStartFindingMatch::has_ping_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline const ::proto::dota::CMsgClientPingData& CMsgStartFindingMatch::ping_data() const {
  const ::proto::dota::CMsgClientPingData* p = ping_data_;
  // @@protoc_insertion_point(field_get:proto.dota.CMsgStartFindingMatch.ping_data)
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::dota::CMsgClientPingData*>(
      &::proto::dota::_CMsgClientPingData_default_instance_);
}
inline ::proto::dota::CMsgClientPingData* CMsgStartFindingMatch::release_ping_data() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgStartFindingMatch.ping_data)
  _has_bits_[0] &= ~0x00000004u;
  ::proto::dota::CMsgClientPingData* temp = ping_data_;
  ping_data_ = nullptr;
  return temp;
}
inline ::proto::dota::CMsgClientPingData* CMsgStartFindingMatch::mutable_ping_data() {
  _has_bits_[0] |= 0x00000004u;
  if (ping_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::dota::CMsgClientPingData>(GetArenaNoVirtual());
    ping_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgStartFindingMatch.ping_data)
  return ping_data_;
}
inline void CMsgStartFindingMatch::set_allocated_ping_data(::proto::dota::CMsgClientPingData* ping_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ping_data_);
  }
  if (ping_data) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ping_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ping_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  ping_data_ = ping_data;
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgStartFindingMatch.ping_data)
}

// optional uint32 region_select_flags = 13;
inline bool CMsgStartFindingMatch::has_region_select_flags() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgStartFindingMatch::clear_region_select_flags() {
  region_select_flags_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 CMsgStartFindingMatch::region_select_flags() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgStartFindingMatch.region_select_flags)
  return region_select_flags_;
}
inline void CMsgStartFindingMatch::set_region_select_flags(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  region_select_flags_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgStartFindingMatch.region_select_flags)
}

// optional bool solo_queue = 14;
inline bool CMsgStartFindingMatch::has_solo_queue() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgStartFindingMatch::clear_solo_queue() {
  solo_queue_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool CMsgStartFindingMatch::solo_queue() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgStartFindingMatch.solo_queue)
  return solo_queue_;
}
inline void CMsgStartFindingMatch::set_solo_queue(bool value) {
  _has_bits_[0] |= 0x00000200u;
  solo_queue_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgStartFindingMatch.solo_queue)
}

// optional uint32 bot_script_index = 15;
inline bool CMsgStartFindingMatch::has_bot_script_index() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgStartFindingMatch::clear_bot_script_index() {
  bot_script_index_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint32 CMsgStartFindingMatch::bot_script_index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgStartFindingMatch.bot_script_index)
  return bot_script_index_;
}
inline void CMsgStartFindingMatch::set_bot_script_index(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  bot_script_index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgStartFindingMatch.bot_script_index)
}

// optional uint32 steam_clan_account_id = 16;
inline bool CMsgStartFindingMatch::has_steam_clan_account_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgStartFindingMatch::clear_steam_clan_account_id() {
  steam_clan_account_id_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::google::protobuf::uint32 CMsgStartFindingMatch::steam_clan_account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgStartFindingMatch.steam_clan_account_id)
  return steam_clan_account_id_;
}
inline void CMsgStartFindingMatch::set_steam_clan_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000800u;
  steam_clan_account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgStartFindingMatch.steam_clan_account_id)
}

// optional bool is_challenge_match = 17;
inline bool CMsgStartFindingMatch::has_is_challenge_match() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgStartFindingMatch::clear_is_challenge_match() {
  is_challenge_match_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool CMsgStartFindingMatch::is_challenge_match() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgStartFindingMatch.is_challenge_match)
  return is_challenge_match_;
}
inline void CMsgStartFindingMatch::set_is_challenge_match(bool value) {
  _has_bits_[0] |= 0x00000400u;
  is_challenge_match_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgStartFindingMatch.is_challenge_match)
}

// optional uint32 lane_selection_flags = 18;
inline bool CMsgStartFindingMatch::has_lane_selection_flags() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgStartFindingMatch::clear_lane_selection_flags() {
  lane_selection_flags_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::google::protobuf::uint32 CMsgStartFindingMatch::lane_selection_flags() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgStartFindingMatch.lane_selection_flags)
  return lane_selection_flags_;
}
inline void CMsgStartFindingMatch::set_lane_selection_flags(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00001000u;
  lane_selection_flags_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgStartFindingMatch.lane_selection_flags)
}

// -------------------------------------------------------------------

// CMsgStartFindingMatchResult

// optional uint32 legacy_generic_eresult = 1 [default = 2];
inline bool CMsgStartFindingMatchResult::has_legacy_generic_eresult() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgStartFindingMatchResult::clear_legacy_generic_eresult() {
  legacy_generic_eresult_ = 2u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgStartFindingMatchResult::legacy_generic_eresult() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgStartFindingMatchResult.legacy_generic_eresult)
  return legacy_generic_eresult_;
}
inline void CMsgStartFindingMatchResult::set_legacy_generic_eresult(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  legacy_generic_eresult_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgStartFindingMatchResult.legacy_generic_eresult)
}

// optional .proto.dota.EStartFindingMatchResult result = 2 [default = k_EStartFindingMatchResult_Invalid];
inline bool CMsgStartFindingMatchResult::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgStartFindingMatchResult::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::proto::dota::EStartFindingMatchResult CMsgStartFindingMatchResult::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgStartFindingMatchResult.result)
  return static_cast< ::proto::dota::EStartFindingMatchResult >(result_);
}
inline void CMsgStartFindingMatchResult::set_result(::proto::dota::EStartFindingMatchResult value) {
  assert(::proto::dota::EStartFindingMatchResult_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgStartFindingMatchResult.result)
}

// optional string error_token = 3;
inline bool CMsgStartFindingMatchResult::has_error_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgStartFindingMatchResult::clear_error_token() {
  error_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgStartFindingMatchResult::error_token() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgStartFindingMatchResult.error_token)
  return error_token_.GetNoArena();
}
inline void CMsgStartFindingMatchResult::set_error_token(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  error_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgStartFindingMatchResult.error_token)
}
#if LANG_CXX11
inline void CMsgStartFindingMatchResult::set_error_token(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  error_token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgStartFindingMatchResult.error_token)
}
#endif
inline void CMsgStartFindingMatchResult::set_error_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  error_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgStartFindingMatchResult.error_token)
}
inline void CMsgStartFindingMatchResult::set_error_token(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  error_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgStartFindingMatchResult.error_token)
}
inline ::std::string* CMsgStartFindingMatchResult::mutable_error_token() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgStartFindingMatchResult.error_token)
  return error_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgStartFindingMatchResult::release_error_token() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgStartFindingMatchResult.error_token)
  if (!has_error_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return error_token_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgStartFindingMatchResult::set_allocated_error_token(::std::string* error_token) {
  if (error_token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_token);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgStartFindingMatchResult.error_token)
}

// optional string debug_message = 4;
inline bool CMsgStartFindingMatchResult::has_debug_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgStartFindingMatchResult::clear_debug_message() {
  debug_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgStartFindingMatchResult::debug_message() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgStartFindingMatchResult.debug_message)
  return debug_message_.GetNoArena();
}
inline void CMsgStartFindingMatchResult::set_debug_message(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  debug_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgStartFindingMatchResult.debug_message)
}
#if LANG_CXX11
inline void CMsgStartFindingMatchResult::set_debug_message(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  debug_message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgStartFindingMatchResult.debug_message)
}
#endif
inline void CMsgStartFindingMatchResult::set_debug_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  debug_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgStartFindingMatchResult.debug_message)
}
inline void CMsgStartFindingMatchResult::set_debug_message(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  debug_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgStartFindingMatchResult.debug_message)
}
inline ::std::string* CMsgStartFindingMatchResult::mutable_debug_message() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgStartFindingMatchResult.debug_message)
  return debug_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgStartFindingMatchResult::release_debug_message() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgStartFindingMatchResult.debug_message)
  if (!has_debug_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return debug_message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgStartFindingMatchResult::set_allocated_debug_message(::std::string* debug_message) {
  if (debug_message != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  debug_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), debug_message);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgStartFindingMatchResult.debug_message)
}

// repeated fixed64 responsible_party_members = 5;
inline int CMsgStartFindingMatchResult::responsible_party_members_size() const {
  return responsible_party_members_.size();
}
inline void CMsgStartFindingMatchResult::clear_responsible_party_members() {
  responsible_party_members_.Clear();
}
inline ::google::protobuf::uint64 CMsgStartFindingMatchResult::responsible_party_members(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgStartFindingMatchResult.responsible_party_members)
  return responsible_party_members_.Get(index);
}
inline void CMsgStartFindingMatchResult::set_responsible_party_members(int index, ::google::protobuf::uint64 value) {
  responsible_party_members_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgStartFindingMatchResult.responsible_party_members)
}
inline void CMsgStartFindingMatchResult::add_responsible_party_members(::google::protobuf::uint64 value) {
  responsible_party_members_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgStartFindingMatchResult.responsible_party_members)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CMsgStartFindingMatchResult::responsible_party_members() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgStartFindingMatchResult.responsible_party_members)
  return responsible_party_members_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CMsgStartFindingMatchResult::mutable_responsible_party_members() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgStartFindingMatchResult.responsible_party_members)
  return &responsible_party_members_;
}

// -------------------------------------------------------------------

// CMsgStopFindingMatch

// -------------------------------------------------------------------

// CMsgPartyBuilderOptions

// optional uint32 additional_slots = 1;
inline bool CMsgPartyBuilderOptions::has_additional_slots() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPartyBuilderOptions::clear_additional_slots() {
  additional_slots_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgPartyBuilderOptions::additional_slots() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPartyBuilderOptions.additional_slots)
  return additional_slots_;
}
inline void CMsgPartyBuilderOptions::set_additional_slots(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  additional_slots_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPartyBuilderOptions.additional_slots)
}

// optional .proto.dota.MatchType match_type = 2 [default = MATCH_TYPE_CASUAL];
inline bool CMsgPartyBuilderOptions::has_match_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgPartyBuilderOptions::clear_match_type() {
  match_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::proto::dota::MatchType CMsgPartyBuilderOptions::match_type() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPartyBuilderOptions.match_type)
  return static_cast< ::proto::dota::MatchType >(match_type_);
}
inline void CMsgPartyBuilderOptions::set_match_type(::proto::dota::MatchType value) {
  assert(::proto::dota::MatchType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  match_type_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPartyBuilderOptions.match_type)
}

// optional uint32 matchgroups = 3;
inline bool CMsgPartyBuilderOptions::has_matchgroups() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgPartyBuilderOptions::clear_matchgroups() {
  matchgroups_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgPartyBuilderOptions::matchgroups() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPartyBuilderOptions.matchgroups)
  return matchgroups_;
}
inline void CMsgPartyBuilderOptions::set_matchgroups(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  matchgroups_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPartyBuilderOptions.matchgroups)
}

// optional uint32 client_version = 4;
inline bool CMsgPartyBuilderOptions::has_client_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgPartyBuilderOptions::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgPartyBuilderOptions::client_version() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPartyBuilderOptions.client_version)
  return client_version_;
}
inline void CMsgPartyBuilderOptions::set_client_version(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  client_version_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPartyBuilderOptions.client_version)
}

// optional .proto.dota.MatchLanguages language = 5 [default = MATCH_LANGUAGE_INVALID];
inline bool CMsgPartyBuilderOptions::has_language() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgPartyBuilderOptions::clear_language() {
  language_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::proto::dota::MatchLanguages CMsgPartyBuilderOptions::language() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPartyBuilderOptions.language)
  return static_cast< ::proto::dota::MatchLanguages >(language_);
}
inline void CMsgPartyBuilderOptions::set_language(::proto::dota::MatchLanguages value) {
  assert(::proto::dota::MatchLanguages_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  language_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPartyBuilderOptions.language)
}

// -------------------------------------------------------------------

// CMsgReadyUp

// optional .proto.dota.DOTALobbyReadyState state = 1 [default = DOTALobbyReadyState_UNDECLARED];
inline bool CMsgReadyUp::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgReadyUp::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::proto::dota::DOTALobbyReadyState CMsgReadyUp::state() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgReadyUp.state)
  return static_cast< ::proto::dota::DOTALobbyReadyState >(state_);
}
inline void CMsgReadyUp::set_state(::proto::dota::DOTALobbyReadyState value) {
  assert(::proto::dota::DOTALobbyReadyState_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  state_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgReadyUp.state)
}

// optional fixed64 ready_up_key = 2;
inline bool CMsgReadyUp::has_ready_up_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgReadyUp::clear_ready_up_key() {
  ready_up_key_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 CMsgReadyUp::ready_up_key() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgReadyUp.ready_up_key)
  return ready_up_key_;
}
inline void CMsgReadyUp::set_ready_up_key(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  ready_up_key_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgReadyUp.ready_up_key)
}

// optional .proto.dota.CDOTAClientHardwareSpecs hardware_specs = 3;
inline bool CMsgReadyUp::has_hardware_specs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::proto::dota::CDOTAClientHardwareSpecs& CMsgReadyUp::hardware_specs() const {
  const ::proto::dota::CDOTAClientHardwareSpecs* p = hardware_specs_;
  // @@protoc_insertion_point(field_get:proto.dota.CMsgReadyUp.hardware_specs)
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::dota::CDOTAClientHardwareSpecs*>(
      &::proto::dota::_CDOTAClientHardwareSpecs_default_instance_);
}
inline ::proto::dota::CDOTAClientHardwareSpecs* CMsgReadyUp::release_hardware_specs() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgReadyUp.hardware_specs)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::dota::CDOTAClientHardwareSpecs* temp = hardware_specs_;
  hardware_specs_ = nullptr;
  return temp;
}
inline ::proto::dota::CDOTAClientHardwareSpecs* CMsgReadyUp::mutable_hardware_specs() {
  _has_bits_[0] |= 0x00000001u;
  if (hardware_specs_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::dota::CDOTAClientHardwareSpecs>(GetArenaNoVirtual());
    hardware_specs_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgReadyUp.hardware_specs)
  return hardware_specs_;
}
inline void CMsgReadyUp::set_allocated_hardware_specs(::proto::dota::CDOTAClientHardwareSpecs* hardware_specs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(hardware_specs_);
  }
  if (hardware_specs) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      hardware_specs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hardware_specs, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hardware_specs_ = hardware_specs;
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgReadyUp.hardware_specs)
}

// -------------------------------------------------------------------

// CMsgReadyUpStatus

// optional fixed64 lobby_id = 1;
inline bool CMsgReadyUpStatus::has_lobby_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgReadyUpStatus::clear_lobby_id() {
  lobby_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 CMsgReadyUpStatus::lobby_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgReadyUpStatus.lobby_id)
  return lobby_id_;
}
inline void CMsgReadyUpStatus::set_lobby_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  lobby_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgReadyUpStatus.lobby_id)
}

// repeated uint32 accepted_ids = 2;
inline int CMsgReadyUpStatus::accepted_ids_size() const {
  return accepted_ids_.size();
}
inline void CMsgReadyUpStatus::clear_accepted_ids() {
  accepted_ids_.Clear();
}
inline ::google::protobuf::uint32 CMsgReadyUpStatus::accepted_ids(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgReadyUpStatus.accepted_ids)
  return accepted_ids_.Get(index);
}
inline void CMsgReadyUpStatus::set_accepted_ids(int index, ::google::protobuf::uint32 value) {
  accepted_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgReadyUpStatus.accepted_ids)
}
inline void CMsgReadyUpStatus::add_accepted_ids(::google::protobuf::uint32 value) {
  accepted_ids_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgReadyUpStatus.accepted_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgReadyUpStatus::accepted_ids() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgReadyUpStatus.accepted_ids)
  return accepted_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgReadyUpStatus::mutable_accepted_ids() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgReadyUpStatus.accepted_ids)
  return &accepted_ids_;
}

// repeated uint32 declined_ids = 3;
inline int CMsgReadyUpStatus::declined_ids_size() const {
  return declined_ids_.size();
}
inline void CMsgReadyUpStatus::clear_declined_ids() {
  declined_ids_.Clear();
}
inline ::google::protobuf::uint32 CMsgReadyUpStatus::declined_ids(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgReadyUpStatus.declined_ids)
  return declined_ids_.Get(index);
}
inline void CMsgReadyUpStatus::set_declined_ids(int index, ::google::protobuf::uint32 value) {
  declined_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgReadyUpStatus.declined_ids)
}
inline void CMsgReadyUpStatus::add_declined_ids(::google::protobuf::uint32 value) {
  declined_ids_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgReadyUpStatus.declined_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgReadyUpStatus::declined_ids() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgReadyUpStatus.declined_ids)
  return declined_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgReadyUpStatus::mutable_declined_ids() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgReadyUpStatus.declined_ids)
  return &declined_ids_;
}

// -------------------------------------------------------------------

// CMsgAbandonCurrentGame

// -------------------------------------------------------------------

// CMsgPracticeLobbySetDetails

// optional uint64 lobby_id = 1;
inline bool CMsgPracticeLobbySetDetails::has_lobby_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_lobby_id() {
  lobby_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint64 CMsgPracticeLobbySetDetails::lobby_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.lobby_id)
  return lobby_id_;
}
inline void CMsgPracticeLobbySetDetails::set_lobby_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  lobby_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.lobby_id)
}

// optional string game_name = 2;
inline bool CMsgPracticeLobbySetDetails::has_game_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_game_name() {
  game_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgPracticeLobbySetDetails::game_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.game_name)
  return game_name_.GetNoArena();
}
inline void CMsgPracticeLobbySetDetails::set_game_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  game_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.game_name)
}
#if LANG_CXX11
inline void CMsgPracticeLobbySetDetails::set_game_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  game_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgPracticeLobbySetDetails.game_name)
}
#endif
inline void CMsgPracticeLobbySetDetails::set_game_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  game_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgPracticeLobbySetDetails.game_name)
}
inline void CMsgPracticeLobbySetDetails::set_game_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  game_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgPracticeLobbySetDetails.game_name)
}
inline ::std::string* CMsgPracticeLobbySetDetails::mutable_game_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgPracticeLobbySetDetails.game_name)
  return game_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgPracticeLobbySetDetails::release_game_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgPracticeLobbySetDetails.game_name)
  if (!has_game_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return game_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgPracticeLobbySetDetails::set_allocated_game_name(::std::string* game_name) {
  if (game_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  game_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), game_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgPracticeLobbySetDetails.game_name)
}

// repeated .proto.dota.CLobbyTeamDetails team_details = 3;
inline int CMsgPracticeLobbySetDetails::team_details_size() const {
  return team_details_.size();
}
inline ::proto::dota::CLobbyTeamDetails* CMsgPracticeLobbySetDetails::mutable_team_details(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgPracticeLobbySetDetails.team_details)
  return team_details_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CLobbyTeamDetails >*
CMsgPracticeLobbySetDetails::mutable_team_details() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgPracticeLobbySetDetails.team_details)
  return &team_details_;
}
inline const ::proto::dota::CLobbyTeamDetails& CMsgPracticeLobbySetDetails::team_details(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.team_details)
  return team_details_.Get(index);
}
inline ::proto::dota::CLobbyTeamDetails* CMsgPracticeLobbySetDetails::add_team_details() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgPracticeLobbySetDetails.team_details)
  return team_details_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CLobbyTeamDetails >&
CMsgPracticeLobbySetDetails::team_details() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgPracticeLobbySetDetails.team_details)
  return team_details_;
}

// optional uint32 server_region = 4;
inline bool CMsgPracticeLobbySetDetails::has_server_region() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_server_region() {
  server_region_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbySetDetails::server_region() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.server_region)
  return server_region_;
}
inline void CMsgPracticeLobbySetDetails::set_server_region(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  server_region_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.server_region)
}

// optional uint32 game_mode = 5;
inline bool CMsgPracticeLobbySetDetails::has_game_mode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_game_mode() {
  game_mode_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbySetDetails::game_mode() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.game_mode)
  return game_mode_;
}
inline void CMsgPracticeLobbySetDetails::set_game_mode(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  game_mode_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.game_mode)
}

// optional .proto.dota.DOTA_CM_PICK cm_pick = 6 [default = DOTA_CM_RANDOM];
inline bool CMsgPracticeLobbySetDetails::has_cm_pick() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_cm_pick() {
  cm_pick_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::proto::dota::DOTA_CM_PICK CMsgPracticeLobbySetDetails::cm_pick() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.cm_pick)
  return static_cast< ::proto::dota::DOTA_CM_PICK >(cm_pick_);
}
inline void CMsgPracticeLobbySetDetails::set_cm_pick(::proto::dota::DOTA_CM_PICK value) {
  assert(::proto::dota::DOTA_CM_PICK_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  cm_pick_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.cm_pick)
}

// optional .proto.dota.DOTABotDifficulty bot_difficulty_radiant = 9 [default = BOT_DIFFICULTY_PASSIVE];
inline bool CMsgPracticeLobbySetDetails::has_bot_difficulty_radiant() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_bot_difficulty_radiant() {
  bot_difficulty_radiant_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::proto::dota::DOTABotDifficulty CMsgPracticeLobbySetDetails::bot_difficulty_radiant() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.bot_difficulty_radiant)
  return static_cast< ::proto::dota::DOTABotDifficulty >(bot_difficulty_radiant_);
}
inline void CMsgPracticeLobbySetDetails::set_bot_difficulty_radiant(::proto::dota::DOTABotDifficulty value) {
  assert(::proto::dota::DOTABotDifficulty_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  bot_difficulty_radiant_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.bot_difficulty_radiant)
}

// optional bool allow_cheats = 10;
inline bool CMsgPracticeLobbySetDetails::has_allow_cheats() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_allow_cheats() {
  allow_cheats_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool CMsgPracticeLobbySetDetails::allow_cheats() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.allow_cheats)
  return allow_cheats_;
}
inline void CMsgPracticeLobbySetDetails::set_allow_cheats(bool value) {
  _has_bits_[0] |= 0x00000400u;
  allow_cheats_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.allow_cheats)
}

// optional bool fill_with_bots = 11;
inline bool CMsgPracticeLobbySetDetails::has_fill_with_bots() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_fill_with_bots() {
  fill_with_bots_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool CMsgPracticeLobbySetDetails::fill_with_bots() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.fill_with_bots)
  return fill_with_bots_;
}
inline void CMsgPracticeLobbySetDetails::set_fill_with_bots(bool value) {
  _has_bits_[0] |= 0x00000800u;
  fill_with_bots_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.fill_with_bots)
}

// optional bool intro_mode = 12;
inline bool CMsgPracticeLobbySetDetails::has_intro_mode() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_intro_mode() {
  intro_mode_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool CMsgPracticeLobbySetDetails::intro_mode() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.intro_mode)
  return intro_mode_;
}
inline void CMsgPracticeLobbySetDetails::set_intro_mode(bool value) {
  _has_bits_[0] |= 0x00001000u;
  intro_mode_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.intro_mode)
}

// optional bool allow_spectating = 13;
inline bool CMsgPracticeLobbySetDetails::has_allow_spectating() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_allow_spectating() {
  allow_spectating_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool CMsgPracticeLobbySetDetails::allow_spectating() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.allow_spectating)
  return allow_spectating_;
}
inline void CMsgPracticeLobbySetDetails::set_allow_spectating(bool value) {
  _has_bits_[0] |= 0x00002000u;
  allow_spectating_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.allow_spectating)
}

// optional .proto.dota.DOTAGameVersion game_version = 14 [default = GAME_VERSION_CURRENT];
inline bool CMsgPracticeLobbySetDetails::has_game_version() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_game_version() {
  game_version_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::proto::dota::DOTAGameVersion CMsgPracticeLobbySetDetails::game_version() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.game_version)
  return static_cast< ::proto::dota::DOTAGameVersion >(game_version_);
}
inline void CMsgPracticeLobbySetDetails::set_game_version(::proto::dota::DOTAGameVersion value) {
  assert(::proto::dota::DOTAGameVersion_IsValid(value));
  _has_bits_[0] |= 0x00004000u;
  game_version_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.game_version)
}

// optional string pass_key = 15;
inline bool CMsgPracticeLobbySetDetails::has_pass_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_pass_key() {
  pass_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgPracticeLobbySetDetails::pass_key() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.pass_key)
  return pass_key_.GetNoArena();
}
inline void CMsgPracticeLobbySetDetails::set_pass_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  pass_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.pass_key)
}
#if LANG_CXX11
inline void CMsgPracticeLobbySetDetails::set_pass_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  pass_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgPracticeLobbySetDetails.pass_key)
}
#endif
inline void CMsgPracticeLobbySetDetails::set_pass_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  pass_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgPracticeLobbySetDetails.pass_key)
}
inline void CMsgPracticeLobbySetDetails::set_pass_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  pass_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgPracticeLobbySetDetails.pass_key)
}
inline ::std::string* CMsgPracticeLobbySetDetails::mutable_pass_key() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgPracticeLobbySetDetails.pass_key)
  return pass_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgPracticeLobbySetDetails::release_pass_key() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgPracticeLobbySetDetails.pass_key)
  if (!has_pass_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return pass_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgPracticeLobbySetDetails::set_allocated_pass_key(::std::string* pass_key) {
  if (pass_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  pass_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pass_key);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgPracticeLobbySetDetails.pass_key)
}

// optional uint32 leagueid = 16;
inline bool CMsgPracticeLobbySetDetails::has_leagueid() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_leagueid() {
  leagueid_ = 0u;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbySetDetails::leagueid() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.leagueid)
  return leagueid_;
}
inline void CMsgPracticeLobbySetDetails::set_leagueid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00008000u;
  leagueid_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.leagueid)
}

// optional uint32 penalty_level_radiant = 17;
inline bool CMsgPracticeLobbySetDetails::has_penalty_level_radiant() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_penalty_level_radiant() {
  penalty_level_radiant_ = 0u;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbySetDetails::penalty_level_radiant() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.penalty_level_radiant)
  return penalty_level_radiant_;
}
inline void CMsgPracticeLobbySetDetails::set_penalty_level_radiant(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00010000u;
  penalty_level_radiant_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.penalty_level_radiant)
}

// optional uint32 penalty_level_dire = 18;
inline bool CMsgPracticeLobbySetDetails::has_penalty_level_dire() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_penalty_level_dire() {
  penalty_level_dire_ = 0u;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbySetDetails::penalty_level_dire() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.penalty_level_dire)
  return penalty_level_dire_;
}
inline void CMsgPracticeLobbySetDetails::set_penalty_level_dire(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00020000u;
  penalty_level_dire_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.penalty_level_dire)
}

// optional uint32 load_game_id = 19;
inline bool CMsgPracticeLobbySetDetails::has_load_game_id() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_load_game_id() {
  load_game_id_ = 0u;
  _has_bits_[0] &= ~0x00040000u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbySetDetails::load_game_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.load_game_id)
  return load_game_id_;
}
inline void CMsgPracticeLobbySetDetails::set_load_game_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00040000u;
  load_game_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.load_game_id)
}

// optional uint32 series_type = 20;
inline bool CMsgPracticeLobbySetDetails::has_series_type() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_series_type() {
  series_type_ = 0u;
  _has_bits_[0] &= ~0x00080000u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbySetDetails::series_type() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.series_type)
  return series_type_;
}
inline void CMsgPracticeLobbySetDetails::set_series_type(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00080000u;
  series_type_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.series_type)
}

// optional uint32 radiant_series_wins = 21;
inline bool CMsgPracticeLobbySetDetails::has_radiant_series_wins() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_radiant_series_wins() {
  radiant_series_wins_ = 0u;
  _has_bits_[0] &= ~0x00100000u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbySetDetails::radiant_series_wins() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.radiant_series_wins)
  return radiant_series_wins_;
}
inline void CMsgPracticeLobbySetDetails::set_radiant_series_wins(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00100000u;
  radiant_series_wins_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.radiant_series_wins)
}

// optional uint32 dire_series_wins = 22;
inline bool CMsgPracticeLobbySetDetails::has_dire_series_wins() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_dire_series_wins() {
  dire_series_wins_ = 0u;
  _has_bits_[0] &= ~0x00200000u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbySetDetails::dire_series_wins() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.dire_series_wins)
  return dire_series_wins_;
}
inline void CMsgPracticeLobbySetDetails::set_dire_series_wins(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00200000u;
  dire_series_wins_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.dire_series_wins)
}

// optional bool allchat = 23 [default = false];
inline bool CMsgPracticeLobbySetDetails::has_allchat() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_allchat() {
  allchat_ = false;
  _has_bits_[0] &= ~0x04000000u;
}
inline bool CMsgPracticeLobbySetDetails::allchat() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.allchat)
  return allchat_;
}
inline void CMsgPracticeLobbySetDetails::set_allchat(bool value) {
  _has_bits_[0] |= 0x04000000u;
  allchat_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.allchat)
}

// optional .proto.dota.LobbyDotaTVDelay dota_tv_delay = 24 [default = LobbyDotaTV_120];
inline bool CMsgPracticeLobbySetDetails::has_dota_tv_delay() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_dota_tv_delay() {
  dota_tv_delay_ = 1;
  _has_bits_[1] &= ~0x00000080u;
}
inline ::proto::dota::LobbyDotaTVDelay CMsgPracticeLobbySetDetails::dota_tv_delay() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.dota_tv_delay)
  return static_cast< ::proto::dota::LobbyDotaTVDelay >(dota_tv_delay_);
}
inline void CMsgPracticeLobbySetDetails::set_dota_tv_delay(::proto::dota::LobbyDotaTVDelay value) {
  assert(::proto::dota::LobbyDotaTVDelay_IsValid(value));
  _has_bits_[1] |= 0x00000080u;
  dota_tv_delay_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.dota_tv_delay)
}

// optional bool lan = 25;
inline bool CMsgPracticeLobbySetDetails::has_lan() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_lan() {
  lan_ = false;
  _has_bits_[0] &= ~0x08000000u;
}
inline bool CMsgPracticeLobbySetDetails::lan() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.lan)
  return lan_;
}
inline void CMsgPracticeLobbySetDetails::set_lan(bool value) {
  _has_bits_[0] |= 0x08000000u;
  lan_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.lan)
}

// optional string custom_game_mode = 26;
inline bool CMsgPracticeLobbySetDetails::has_custom_game_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_custom_game_mode() {
  custom_game_mode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& CMsgPracticeLobbySetDetails::custom_game_mode() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.custom_game_mode)
  return custom_game_mode_.GetNoArena();
}
inline void CMsgPracticeLobbySetDetails::set_custom_game_mode(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  custom_game_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.custom_game_mode)
}
#if LANG_CXX11
inline void CMsgPracticeLobbySetDetails::set_custom_game_mode(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  custom_game_mode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgPracticeLobbySetDetails.custom_game_mode)
}
#endif
inline void CMsgPracticeLobbySetDetails::set_custom_game_mode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  custom_game_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgPracticeLobbySetDetails.custom_game_mode)
}
inline void CMsgPracticeLobbySetDetails::set_custom_game_mode(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  custom_game_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgPracticeLobbySetDetails.custom_game_mode)
}
inline ::std::string* CMsgPracticeLobbySetDetails::mutable_custom_game_mode() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgPracticeLobbySetDetails.custom_game_mode)
  return custom_game_mode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgPracticeLobbySetDetails::release_custom_game_mode() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgPracticeLobbySetDetails.custom_game_mode)
  if (!has_custom_game_mode()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return custom_game_mode_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgPracticeLobbySetDetails::set_allocated_custom_game_mode(::std::string* custom_game_mode) {
  if (custom_game_mode != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  custom_game_mode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), custom_game_mode);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgPracticeLobbySetDetails.custom_game_mode)
}

// optional string custom_map_name = 27;
inline bool CMsgPracticeLobbySetDetails::has_custom_map_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_custom_map_name() {
  custom_map_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& CMsgPracticeLobbySetDetails::custom_map_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.custom_map_name)
  return custom_map_name_.GetNoArena();
}
inline void CMsgPracticeLobbySetDetails::set_custom_map_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  custom_map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.custom_map_name)
}
#if LANG_CXX11
inline void CMsgPracticeLobbySetDetails::set_custom_map_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  custom_map_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgPracticeLobbySetDetails.custom_map_name)
}
#endif
inline void CMsgPracticeLobbySetDetails::set_custom_map_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  custom_map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgPracticeLobbySetDetails.custom_map_name)
}
inline void CMsgPracticeLobbySetDetails::set_custom_map_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  custom_map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgPracticeLobbySetDetails.custom_map_name)
}
inline ::std::string* CMsgPracticeLobbySetDetails::mutable_custom_map_name() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgPracticeLobbySetDetails.custom_map_name)
  return custom_map_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgPracticeLobbySetDetails::release_custom_map_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgPracticeLobbySetDetails.custom_map_name)
  if (!has_custom_map_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return custom_map_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgPracticeLobbySetDetails::set_allocated_custom_map_name(::std::string* custom_map_name) {
  if (custom_map_name != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  custom_map_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), custom_map_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgPracticeLobbySetDetails.custom_map_name)
}

// optional uint32 custom_difficulty = 28;
inline bool CMsgPracticeLobbySetDetails::has_custom_difficulty() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_custom_difficulty() {
  custom_difficulty_ = 0u;
  _has_bits_[0] &= ~0x00400000u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbySetDetails::custom_difficulty() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.custom_difficulty)
  return custom_difficulty_;
}
inline void CMsgPracticeLobbySetDetails::set_custom_difficulty(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00400000u;
  custom_difficulty_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.custom_difficulty)
}

// optional uint64 custom_game_id = 29;
inline bool CMsgPracticeLobbySetDetails::has_custom_game_id() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_custom_game_id() {
  custom_game_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00800000u;
}
inline ::google::protobuf::uint64 CMsgPracticeLobbySetDetails::custom_game_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.custom_game_id)
  return custom_game_id_;
}
inline void CMsgPracticeLobbySetDetails::set_custom_game_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00800000u;
  custom_game_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.custom_game_id)
}

// optional uint32 custom_min_players = 30;
inline bool CMsgPracticeLobbySetDetails::has_custom_min_players() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_custom_min_players() {
  custom_min_players_ = 0u;
  _has_bits_[0] &= ~0x01000000u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbySetDetails::custom_min_players() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.custom_min_players)
  return custom_min_players_;
}
inline void CMsgPracticeLobbySetDetails::set_custom_min_players(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x01000000u;
  custom_min_players_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.custom_min_players)
}

// optional uint32 custom_max_players = 31;
inline bool CMsgPracticeLobbySetDetails::has_custom_max_players() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_custom_max_players() {
  custom_max_players_ = 0u;
  _has_bits_[0] &= ~0x02000000u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbySetDetails::custom_max_players() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.custom_max_players)
  return custom_max_players_;
}
inline void CMsgPracticeLobbySetDetails::set_custom_max_players(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x02000000u;
  custom_max_players_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.custom_max_players)
}

// optional .proto.dota.DOTALobbyVisibility visibility = 33 [default = DOTALobbyVisibility_Public];
inline bool CMsgPracticeLobbySetDetails::has_visibility() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_visibility() {
  visibility_ = 0;
  _has_bits_[0] &= ~0x20000000u;
}
inline ::proto::dota::DOTALobbyVisibility CMsgPracticeLobbySetDetails::visibility() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.visibility)
  return static_cast< ::proto::dota::DOTALobbyVisibility >(visibility_);
}
inline void CMsgPracticeLobbySetDetails::set_visibility(::proto::dota::DOTALobbyVisibility value) {
  assert(::proto::dota::DOTALobbyVisibility_IsValid(value));
  _has_bits_[0] |= 0x20000000u;
  visibility_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.visibility)
}

// optional fixed64 custom_game_crc = 34;
inline bool CMsgPracticeLobbySetDetails::has_custom_game_crc() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_custom_game_crc() {
  custom_game_crc_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x40000000u;
}
inline ::google::protobuf::uint64 CMsgPracticeLobbySetDetails::custom_game_crc() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.custom_game_crc)
  return custom_game_crc_;
}
inline void CMsgPracticeLobbySetDetails::set_custom_game_crc(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x40000000u;
  custom_game_crc_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.custom_game_crc)
}

// optional fixed32 custom_game_timestamp = 37;
inline bool CMsgPracticeLobbySetDetails::has_custom_game_timestamp() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_custom_game_timestamp() {
  custom_game_timestamp_ = 0u;
  _has_bits_[1] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbySetDetails::custom_game_timestamp() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.custom_game_timestamp)
  return custom_game_timestamp_;
}
inline void CMsgPracticeLobbySetDetails::set_custom_game_timestamp(::google::protobuf::uint32 value) {
  _has_bits_[1] |= 0x00000001u;
  custom_game_timestamp_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.custom_game_timestamp)
}

// optional uint64 previous_match_override = 38;
inline bool CMsgPracticeLobbySetDetails::has_previous_match_override() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_previous_match_override() {
  previous_match_override_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x80000000u;
}
inline ::google::protobuf::uint64 CMsgPracticeLobbySetDetails::previous_match_override() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.previous_match_override)
  return previous_match_override_;
}
inline void CMsgPracticeLobbySetDetails::set_previous_match_override(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x80000000u;
  previous_match_override_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.previous_match_override)
}

// optional .proto.dota.LobbyDotaPauseSetting pause_setting = 42 [default = LobbyDotaPauseSetting_Unlimited];
inline bool CMsgPracticeLobbySetDetails::has_pause_setting() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_pause_setting() {
  pause_setting_ = 0;
  _has_bits_[1] &= ~0x00000002u;
}
inline ::proto::dota::LobbyDotaPauseSetting CMsgPracticeLobbySetDetails::pause_setting() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.pause_setting)
  return static_cast< ::proto::dota::LobbyDotaPauseSetting >(pause_setting_);
}
inline void CMsgPracticeLobbySetDetails::set_pause_setting(::proto::dota::LobbyDotaPauseSetting value) {
  assert(::proto::dota::LobbyDotaPauseSetting_IsValid(value));
  _has_bits_[1] |= 0x00000002u;
  pause_setting_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.pause_setting)
}

// optional .proto.dota.DOTABotDifficulty bot_difficulty_dire = 43 [default = BOT_DIFFICULTY_PASSIVE];
inline bool CMsgPracticeLobbySetDetails::has_bot_difficulty_dire() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_bot_difficulty_dire() {
  bot_difficulty_dire_ = 0;
  _has_bits_[1] &= ~0x00000010u;
}
inline ::proto::dota::DOTABotDifficulty CMsgPracticeLobbySetDetails::bot_difficulty_dire() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.bot_difficulty_dire)
  return static_cast< ::proto::dota::DOTABotDifficulty >(bot_difficulty_dire_);
}
inline void CMsgPracticeLobbySetDetails::set_bot_difficulty_dire(::proto::dota::DOTABotDifficulty value) {
  assert(::proto::dota::DOTABotDifficulty_IsValid(value));
  _has_bits_[1] |= 0x00000010u;
  bot_difficulty_dire_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.bot_difficulty_dire)
}

// optional uint64 bot_radiant = 44;
inline bool CMsgPracticeLobbySetDetails::has_bot_radiant() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_bot_radiant() {
  bot_radiant_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[1] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 CMsgPracticeLobbySetDetails::bot_radiant() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.bot_radiant)
  return bot_radiant_;
}
inline void CMsgPracticeLobbySetDetails::set_bot_radiant(::google::protobuf::uint64 value) {
  _has_bits_[1] |= 0x00000008u;
  bot_radiant_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.bot_radiant)
}

// optional uint64 bot_dire = 45;
inline bool CMsgPracticeLobbySetDetails::has_bot_dire() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_bot_dire() {
  bot_dire_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[1] &= ~0x00000040u;
}
inline ::google::protobuf::uint64 CMsgPracticeLobbySetDetails::bot_dire() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.bot_dire)
  return bot_dire_;
}
inline void CMsgPracticeLobbySetDetails::set_bot_dire(::google::protobuf::uint64 value) {
  _has_bits_[1] |= 0x00000040u;
  bot_dire_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.bot_dire)
}

// optional .proto.dota.DOTASelectionPriorityRules selection_priority_rules = 46 [default = k_DOTASelectionPriorityRules_Manual];
inline bool CMsgPracticeLobbySetDetails::has_selection_priority_rules() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_selection_priority_rules() {
  selection_priority_rules_ = 0;
  _has_bits_[1] &= ~0x00000020u;
}
inline ::proto::dota::DOTASelectionPriorityRules CMsgPracticeLobbySetDetails::selection_priority_rules() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.selection_priority_rules)
  return static_cast< ::proto::dota::DOTASelectionPriorityRules >(selection_priority_rules_);
}
inline void CMsgPracticeLobbySetDetails::set_selection_priority_rules(::proto::dota::DOTASelectionPriorityRules value) {
  assert(::proto::dota::DOTASelectionPriorityRules_IsValid(value));
  _has_bits_[1] |= 0x00000020u;
  selection_priority_rules_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.selection_priority_rules)
}

// optional bool custom_game_penalties = 47;
inline bool CMsgPracticeLobbySetDetails::has_custom_game_penalties() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_custom_game_penalties() {
  custom_game_penalties_ = false;
  _has_bits_[0] &= ~0x10000000u;
}
inline bool CMsgPracticeLobbySetDetails::custom_game_penalties() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.custom_game_penalties)
  return custom_game_penalties_;
}
inline void CMsgPracticeLobbySetDetails::set_custom_game_penalties(bool value) {
  _has_bits_[0] |= 0x10000000u;
  custom_game_penalties_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.custom_game_penalties)
}

// optional string lan_host_ping_location = 48;
inline bool CMsgPracticeLobbySetDetails::has_lan_host_ping_location() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_lan_host_ping_location() {
  lan_host_ping_location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& CMsgPracticeLobbySetDetails::lan_host_ping_location() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.lan_host_ping_location)
  return lan_host_ping_location_.GetNoArena();
}
inline void CMsgPracticeLobbySetDetails::set_lan_host_ping_location(const ::std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  lan_host_ping_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.lan_host_ping_location)
}
#if LANG_CXX11
inline void CMsgPracticeLobbySetDetails::set_lan_host_ping_location(::std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  lan_host_ping_location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgPracticeLobbySetDetails.lan_host_ping_location)
}
#endif
inline void CMsgPracticeLobbySetDetails::set_lan_host_ping_location(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  lan_host_ping_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgPracticeLobbySetDetails.lan_host_ping_location)
}
inline void CMsgPracticeLobbySetDetails::set_lan_host_ping_location(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  lan_host_ping_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgPracticeLobbySetDetails.lan_host_ping_location)
}
inline ::std::string* CMsgPracticeLobbySetDetails::mutable_lan_host_ping_location() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgPracticeLobbySetDetails.lan_host_ping_location)
  return lan_host_ping_location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgPracticeLobbySetDetails::release_lan_host_ping_location() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgPracticeLobbySetDetails.lan_host_ping_location)
  if (!has_lan_host_ping_location()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return lan_host_ping_location_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgPracticeLobbySetDetails::set_allocated_lan_host_ping_location(::std::string* lan_host_ping_location) {
  if (lan_host_ping_location != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  lan_host_ping_location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lan_host_ping_location);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgPracticeLobbySetDetails.lan_host_ping_location)
}

// optional uint32 league_node_id = 49;
inline bool CMsgPracticeLobbySetDetails::has_league_node_id() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void CMsgPracticeLobbySetDetails::clear_league_node_id() {
  league_node_id_ = 0u;
  _has_bits_[1] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbySetDetails::league_node_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetDetails.league_node_id)
  return league_node_id_;
}
inline void CMsgPracticeLobbySetDetails::set_league_node_id(::google::protobuf::uint32 value) {
  _has_bits_[1] |= 0x00000004u;
  league_node_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetDetails.league_node_id)
}

// -------------------------------------------------------------------

// CMsgPracticeLobbyCreate_SaveGame

// optional bytes data = 1;
inline bool CMsgPracticeLobbyCreate_SaveGame::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPracticeLobbyCreate_SaveGame::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgPracticeLobbyCreate_SaveGame::data() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyCreate.SaveGame.data)
  return data_.GetNoArena();
}
inline void CMsgPracticeLobbyCreate_SaveGame::set_data(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyCreate.SaveGame.data)
}
#if LANG_CXX11
inline void CMsgPracticeLobbyCreate_SaveGame::set_data(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgPracticeLobbyCreate.SaveGame.data)
}
#endif
inline void CMsgPracticeLobbyCreate_SaveGame::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgPracticeLobbyCreate.SaveGame.data)
}
inline void CMsgPracticeLobbyCreate_SaveGame::set_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgPracticeLobbyCreate.SaveGame.data)
}
inline ::std::string* CMsgPracticeLobbyCreate_SaveGame::mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgPracticeLobbyCreate.SaveGame.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgPracticeLobbyCreate_SaveGame::release_data() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgPracticeLobbyCreate.SaveGame.data)
  if (!has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgPracticeLobbyCreate_SaveGame::set_allocated_data(::std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgPracticeLobbyCreate.SaveGame.data)
}

// optional int32 version = 2;
inline bool CMsgPracticeLobbyCreate_SaveGame::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgPracticeLobbyCreate_SaveGame::clear_version() {
  version_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::int32 CMsgPracticeLobbyCreate_SaveGame::version() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyCreate.SaveGame.version)
  return version_;
}
inline void CMsgPracticeLobbyCreate_SaveGame::set_version(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  version_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyCreate.SaveGame.version)
}

// optional fixed64 steam_id = 3;
inline bool CMsgPracticeLobbyCreate_SaveGame::has_steam_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgPracticeLobbyCreate_SaveGame::clear_steam_id() {
  steam_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 CMsgPracticeLobbyCreate_SaveGame::steam_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyCreate.SaveGame.steam_id)
  return steam_id_;
}
inline void CMsgPracticeLobbyCreate_SaveGame::set_steam_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  steam_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyCreate.SaveGame.steam_id)
}

// optional fixed64 signature = 4;
inline bool CMsgPracticeLobbyCreate_SaveGame::has_signature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgPracticeLobbyCreate_SaveGame::clear_signature() {
  signature_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 CMsgPracticeLobbyCreate_SaveGame::signature() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyCreate.SaveGame.signature)
  return signature_;
}
inline void CMsgPracticeLobbyCreate_SaveGame::set_signature(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  signature_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyCreate.SaveGame.signature)
}

// -------------------------------------------------------------------

// CMsgPracticeLobbyCreate

// optional string search_key = 1;
inline bool CMsgPracticeLobbyCreate::has_search_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPracticeLobbyCreate::clear_search_key() {
  search_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgPracticeLobbyCreate::search_key() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyCreate.search_key)
  return search_key_.GetNoArena();
}
inline void CMsgPracticeLobbyCreate::set_search_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  search_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyCreate.search_key)
}
#if LANG_CXX11
inline void CMsgPracticeLobbyCreate::set_search_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  search_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgPracticeLobbyCreate.search_key)
}
#endif
inline void CMsgPracticeLobbyCreate::set_search_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  search_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgPracticeLobbyCreate.search_key)
}
inline void CMsgPracticeLobbyCreate::set_search_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  search_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgPracticeLobbyCreate.search_key)
}
inline ::std::string* CMsgPracticeLobbyCreate::mutable_search_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgPracticeLobbyCreate.search_key)
  return search_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgPracticeLobbyCreate::release_search_key() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgPracticeLobbyCreate.search_key)
  if (!has_search_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return search_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgPracticeLobbyCreate::set_allocated_search_key(::std::string* search_key) {
  if (search_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  search_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), search_key);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgPracticeLobbyCreate.search_key)
}

// optional string pass_key = 5;
inline bool CMsgPracticeLobbyCreate::has_pass_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgPracticeLobbyCreate::clear_pass_key() {
  pass_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgPracticeLobbyCreate::pass_key() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyCreate.pass_key)
  return pass_key_.GetNoArena();
}
inline void CMsgPracticeLobbyCreate::set_pass_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  pass_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyCreate.pass_key)
}
#if LANG_CXX11
inline void CMsgPracticeLobbyCreate::set_pass_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  pass_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgPracticeLobbyCreate.pass_key)
}
#endif
inline void CMsgPracticeLobbyCreate::set_pass_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  pass_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgPracticeLobbyCreate.pass_key)
}
inline void CMsgPracticeLobbyCreate::set_pass_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  pass_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgPracticeLobbyCreate.pass_key)
}
inline ::std::string* CMsgPracticeLobbyCreate::mutable_pass_key() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgPracticeLobbyCreate.pass_key)
  return pass_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgPracticeLobbyCreate::release_pass_key() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgPracticeLobbyCreate.pass_key)
  if (!has_pass_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return pass_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgPracticeLobbyCreate::set_allocated_pass_key(::std::string* pass_key) {
  if (pass_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  pass_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pass_key);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgPracticeLobbyCreate.pass_key)
}

// optional uint32 client_version = 6;
inline bool CMsgPracticeLobbyCreate::has_client_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgPracticeLobbyCreate::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbyCreate::client_version() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyCreate.client_version)
  return client_version_;
}
inline void CMsgPracticeLobbyCreate::set_client_version(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  client_version_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyCreate.client_version)
}

// optional .proto.dota.CMsgPracticeLobbySetDetails lobby_details = 7;
inline bool CMsgPracticeLobbyCreate::has_lobby_details() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgPracticeLobbyCreate::clear_lobby_details() {
  if (lobby_details_ != nullptr) lobby_details_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::proto::dota::CMsgPracticeLobbySetDetails& CMsgPracticeLobbyCreate::lobby_details() const {
  const ::proto::dota::CMsgPracticeLobbySetDetails* p = lobby_details_;
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyCreate.lobby_details)
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::dota::CMsgPracticeLobbySetDetails*>(
      &::proto::dota::_CMsgPracticeLobbySetDetails_default_instance_);
}
inline ::proto::dota::CMsgPracticeLobbySetDetails* CMsgPracticeLobbyCreate::release_lobby_details() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgPracticeLobbyCreate.lobby_details)
  _has_bits_[0] &= ~0x00000004u;
  ::proto::dota::CMsgPracticeLobbySetDetails* temp = lobby_details_;
  lobby_details_ = nullptr;
  return temp;
}
inline ::proto::dota::CMsgPracticeLobbySetDetails* CMsgPracticeLobbyCreate::mutable_lobby_details() {
  _has_bits_[0] |= 0x00000004u;
  if (lobby_details_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::dota::CMsgPracticeLobbySetDetails>(GetArenaNoVirtual());
    lobby_details_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgPracticeLobbyCreate.lobby_details)
  return lobby_details_;
}
inline void CMsgPracticeLobbyCreate::set_allocated_lobby_details(::proto::dota::CMsgPracticeLobbySetDetails* lobby_details) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete lobby_details_;
  }
  if (lobby_details) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      lobby_details = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lobby_details, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  lobby_details_ = lobby_details;
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgPracticeLobbyCreate.lobby_details)
}

// optional .proto.dota.CMsgPracticeLobbyCreate.SaveGame save_game = 8;
inline bool CMsgPracticeLobbyCreate::has_save_game() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgPracticeLobbyCreate::clear_save_game() {
  if (save_game_ != nullptr) save_game_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::proto::dota::CMsgPracticeLobbyCreate_SaveGame& CMsgPracticeLobbyCreate::save_game() const {
  const ::proto::dota::CMsgPracticeLobbyCreate_SaveGame* p = save_game_;
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyCreate.save_game)
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::dota::CMsgPracticeLobbyCreate_SaveGame*>(
      &::proto::dota::_CMsgPracticeLobbyCreate_SaveGame_default_instance_);
}
inline ::proto::dota::CMsgPracticeLobbyCreate_SaveGame* CMsgPracticeLobbyCreate::release_save_game() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgPracticeLobbyCreate.save_game)
  _has_bits_[0] &= ~0x00000008u;
  ::proto::dota::CMsgPracticeLobbyCreate_SaveGame* temp = save_game_;
  save_game_ = nullptr;
  return temp;
}
inline ::proto::dota::CMsgPracticeLobbyCreate_SaveGame* CMsgPracticeLobbyCreate::mutable_save_game() {
  _has_bits_[0] |= 0x00000008u;
  if (save_game_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::dota::CMsgPracticeLobbyCreate_SaveGame>(GetArenaNoVirtual());
    save_game_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgPracticeLobbyCreate.save_game)
  return save_game_;
}
inline void CMsgPracticeLobbyCreate::set_allocated_save_game(::proto::dota::CMsgPracticeLobbyCreate_SaveGame* save_game) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete save_game_;
  }
  if (save_game) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      save_game = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, save_game, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  save_game_ = save_game;
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgPracticeLobbyCreate.save_game)
}

// -------------------------------------------------------------------

// CMsgPracticeLobbySetTeamSlot

// optional .proto.dota.DOTA_GC_TEAM team = 1 [default = DOTA_GC_TEAM_GOOD_GUYS];
inline bool CMsgPracticeLobbySetTeamSlot::has_team() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPracticeLobbySetTeamSlot::clear_team() {
  team_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::DOTA_GC_TEAM CMsgPracticeLobbySetTeamSlot::team() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetTeamSlot.team)
  return static_cast< ::proto::dota::DOTA_GC_TEAM >(team_);
}
inline void CMsgPracticeLobbySetTeamSlot::set_team(::proto::dota::DOTA_GC_TEAM value) {
  assert(::proto::dota::DOTA_GC_TEAM_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  team_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetTeamSlot.team)
}

// optional uint32 slot = 2;
inline bool CMsgPracticeLobbySetTeamSlot::has_slot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgPracticeLobbySetTeamSlot::clear_slot() {
  slot_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbySetTeamSlot::slot() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetTeamSlot.slot)
  return slot_;
}
inline void CMsgPracticeLobbySetTeamSlot::set_slot(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  slot_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetTeamSlot.slot)
}

// optional .proto.dota.DOTABotDifficulty bot_difficulty = 3 [default = BOT_DIFFICULTY_PASSIVE];
inline bool CMsgPracticeLobbySetTeamSlot::has_bot_difficulty() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgPracticeLobbySetTeamSlot::clear_bot_difficulty() {
  bot_difficulty_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::proto::dota::DOTABotDifficulty CMsgPracticeLobbySetTeamSlot::bot_difficulty() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetTeamSlot.bot_difficulty)
  return static_cast< ::proto::dota::DOTABotDifficulty >(bot_difficulty_);
}
inline void CMsgPracticeLobbySetTeamSlot::set_bot_difficulty(::proto::dota::DOTABotDifficulty value) {
  assert(::proto::dota::DOTABotDifficulty_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  bot_difficulty_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetTeamSlot.bot_difficulty)
}

// -------------------------------------------------------------------

// CMsgPracticeLobbySetCoach

// optional .proto.dota.DOTA_GC_TEAM team = 1 [default = DOTA_GC_TEAM_GOOD_GUYS];
inline bool CMsgPracticeLobbySetCoach::has_team() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPracticeLobbySetCoach::clear_team() {
  team_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::DOTA_GC_TEAM CMsgPracticeLobbySetCoach::team() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbySetCoach.team)
  return static_cast< ::proto::dota::DOTA_GC_TEAM >(team_);
}
inline void CMsgPracticeLobbySetCoach::set_team(::proto::dota::DOTA_GC_TEAM value) {
  assert(::proto::dota::DOTA_GC_TEAM_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  team_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbySetCoach.team)
}

// -------------------------------------------------------------------

// CMsgPracticeLobbyJoinBroadcastChannel

// optional uint32 channel = 1;
inline bool CMsgPracticeLobbyJoinBroadcastChannel::has_channel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgPracticeLobbyJoinBroadcastChannel::clear_channel() {
  channel_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbyJoinBroadcastChannel::channel() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.channel)
  return channel_;
}
inline void CMsgPracticeLobbyJoinBroadcastChannel::set_channel(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  channel_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.channel)
}

// optional string preferred_description = 2;
inline bool CMsgPracticeLobbyJoinBroadcastChannel::has_preferred_description() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPracticeLobbyJoinBroadcastChannel::clear_preferred_description() {
  preferred_description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgPracticeLobbyJoinBroadcastChannel::preferred_description() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_description)
  return preferred_description_.GetNoArena();
}
inline void CMsgPracticeLobbyJoinBroadcastChannel::set_preferred_description(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  preferred_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_description)
}
#if LANG_CXX11
inline void CMsgPracticeLobbyJoinBroadcastChannel::set_preferred_description(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  preferred_description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_description)
}
#endif
inline void CMsgPracticeLobbyJoinBroadcastChannel::set_preferred_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  preferred_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_description)
}
inline void CMsgPracticeLobbyJoinBroadcastChannel::set_preferred_description(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  preferred_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_description)
}
inline ::std::string* CMsgPracticeLobbyJoinBroadcastChannel::mutable_preferred_description() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_description)
  return preferred_description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgPracticeLobbyJoinBroadcastChannel::release_preferred_description() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_description)
  if (!has_preferred_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return preferred_description_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgPracticeLobbyJoinBroadcastChannel::set_allocated_preferred_description(::std::string* preferred_description) {
  if (preferred_description != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  preferred_description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), preferred_description);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_description)
}

// optional string preferred_country_code = 3;
inline bool CMsgPracticeLobbyJoinBroadcastChannel::has_preferred_country_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgPracticeLobbyJoinBroadcastChannel::clear_preferred_country_code() {
  preferred_country_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgPracticeLobbyJoinBroadcastChannel::preferred_country_code() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_country_code)
  return preferred_country_code_.GetNoArena();
}
inline void CMsgPracticeLobbyJoinBroadcastChannel::set_preferred_country_code(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  preferred_country_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_country_code)
}
#if LANG_CXX11
inline void CMsgPracticeLobbyJoinBroadcastChannel::set_preferred_country_code(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  preferred_country_code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_country_code)
}
#endif
inline void CMsgPracticeLobbyJoinBroadcastChannel::set_preferred_country_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  preferred_country_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_country_code)
}
inline void CMsgPracticeLobbyJoinBroadcastChannel::set_preferred_country_code(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  preferred_country_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_country_code)
}
inline ::std::string* CMsgPracticeLobbyJoinBroadcastChannel::mutable_preferred_country_code() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_country_code)
  return preferred_country_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgPracticeLobbyJoinBroadcastChannel::release_preferred_country_code() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_country_code)
  if (!has_preferred_country_code()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return preferred_country_code_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgPracticeLobbyJoinBroadcastChannel::set_allocated_preferred_country_code(::std::string* preferred_country_code) {
  if (preferred_country_code != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  preferred_country_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), preferred_country_code);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_country_code)
}

// optional string preferred_language_code = 4;
inline bool CMsgPracticeLobbyJoinBroadcastChannel::has_preferred_language_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgPracticeLobbyJoinBroadcastChannel::clear_preferred_language_code() {
  preferred_language_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& CMsgPracticeLobbyJoinBroadcastChannel::preferred_language_code() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_language_code)
  return preferred_language_code_.GetNoArena();
}
inline void CMsgPracticeLobbyJoinBroadcastChannel::set_preferred_language_code(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  preferred_language_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_language_code)
}
#if LANG_CXX11
inline void CMsgPracticeLobbyJoinBroadcastChannel::set_preferred_language_code(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  preferred_language_code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_language_code)
}
#endif
inline void CMsgPracticeLobbyJoinBroadcastChannel::set_preferred_language_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  preferred_language_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_language_code)
}
inline void CMsgPracticeLobbyJoinBroadcastChannel::set_preferred_language_code(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  preferred_language_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_language_code)
}
inline ::std::string* CMsgPracticeLobbyJoinBroadcastChannel::mutable_preferred_language_code() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_language_code)
  return preferred_language_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgPracticeLobbyJoinBroadcastChannel::release_preferred_language_code() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_language_code)
  if (!has_preferred_language_code()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return preferred_language_code_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgPracticeLobbyJoinBroadcastChannel::set_allocated_preferred_language_code(::std::string* preferred_language_code) {
  if (preferred_language_code != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  preferred_language_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), preferred_language_code);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgPracticeLobbyJoinBroadcastChannel.preferred_language_code)
}

// -------------------------------------------------------------------

// CMsgPracticeLobbyCloseBroadcastChannel

// optional uint32 channel = 1;
inline bool CMsgPracticeLobbyCloseBroadcastChannel::has_channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPracticeLobbyCloseBroadcastChannel::clear_channel() {
  channel_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbyCloseBroadcastChannel::channel() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyCloseBroadcastChannel.channel)
  return channel_;
}
inline void CMsgPracticeLobbyCloseBroadcastChannel::set_channel(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  channel_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyCloseBroadcastChannel.channel)
}

// -------------------------------------------------------------------

// CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus

// -------------------------------------------------------------------

// CMsgPracticeLobbyKick

// optional uint32 account_id = 3;
inline bool CMsgPracticeLobbyKick::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPracticeLobbyKick::clear_account_id() {
  account_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbyKick::account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyKick.account_id)
  return account_id_;
}
inline void CMsgPracticeLobbyKick::set_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyKick.account_id)
}

// -------------------------------------------------------------------

// CMsgPracticeLobbyKickFromTeam

// optional uint32 account_id = 1;
inline bool CMsgPracticeLobbyKickFromTeam::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPracticeLobbyKickFromTeam::clear_account_id() {
  account_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbyKickFromTeam::account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyKickFromTeam.account_id)
  return account_id_;
}
inline void CMsgPracticeLobbyKickFromTeam::set_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyKickFromTeam.account_id)
}

// -------------------------------------------------------------------

// CMsgPracticeLobbyLeave

// -------------------------------------------------------------------

// CMsgPracticeLobbyLaunch

// optional uint32 client_version = 5;
inline bool CMsgPracticeLobbyLaunch::has_client_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPracticeLobbyLaunch::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbyLaunch::client_version() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyLaunch.client_version)
  return client_version_;
}
inline void CMsgPracticeLobbyLaunch::set_client_version(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  client_version_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyLaunch.client_version)
}

// -------------------------------------------------------------------

// CMsgApplyTeamToPracticeLobby

// optional uint32 team_id = 1;
inline bool CMsgApplyTeamToPracticeLobby::has_team_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgApplyTeamToPracticeLobby::clear_team_id() {
  team_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgApplyTeamToPracticeLobby::team_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgApplyTeamToPracticeLobby.team_id)
  return team_id_;
}
inline void CMsgApplyTeamToPracticeLobby::set_team_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  team_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgApplyTeamToPracticeLobby.team_id)
}

// -------------------------------------------------------------------

// CMsgClearPracticeLobbyTeam

// -------------------------------------------------------------------

// CMsgPracticeLobbyList

// optional string pass_key = 2;
inline bool CMsgPracticeLobbyList::has_pass_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPracticeLobbyList::clear_pass_key() {
  pass_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgPracticeLobbyList::pass_key() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyList.pass_key)
  return pass_key_.GetNoArena();
}
inline void CMsgPracticeLobbyList::set_pass_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  pass_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyList.pass_key)
}
#if LANG_CXX11
inline void CMsgPracticeLobbyList::set_pass_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  pass_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgPracticeLobbyList.pass_key)
}
#endif
inline void CMsgPracticeLobbyList::set_pass_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  pass_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgPracticeLobbyList.pass_key)
}
inline void CMsgPracticeLobbyList::set_pass_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  pass_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgPracticeLobbyList.pass_key)
}
inline ::std::string* CMsgPracticeLobbyList::mutable_pass_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgPracticeLobbyList.pass_key)
  return pass_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgPracticeLobbyList::release_pass_key() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgPracticeLobbyList.pass_key)
  if (!has_pass_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return pass_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgPracticeLobbyList::set_allocated_pass_key(::std::string* pass_key) {
  if (pass_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pass_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pass_key);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgPracticeLobbyList.pass_key)
}

// optional uint32 region = 3;
inline bool CMsgPracticeLobbyList::has_region() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgPracticeLobbyList::clear_region() {
  region_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbyList::region() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyList.region)
  return region_;
}
inline void CMsgPracticeLobbyList::set_region(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  region_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyList.region)
}

// optional .proto.dota.DOTA_GameMode game_mode = 4 [default = DOTA_GAMEMODE_NONE];
inline bool CMsgPracticeLobbyList::has_game_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgPracticeLobbyList::clear_game_mode() {
  game_mode_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::proto::dota::DOTA_GameMode CMsgPracticeLobbyList::game_mode() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyList.game_mode)
  return static_cast< ::proto::dota::DOTA_GameMode >(game_mode_);
}
inline void CMsgPracticeLobbyList::set_game_mode(::proto::dota::DOTA_GameMode value) {
  assert(::proto::dota::DOTA_GameMode_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  game_mode_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyList.game_mode)
}

// -------------------------------------------------------------------

// CMsgPracticeLobbyListResponseEntry_CLobbyMember

// optional uint32 account_id = 1;
inline bool CMsgPracticeLobbyListResponseEntry_CLobbyMember::has_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgPracticeLobbyListResponseEntry_CLobbyMember::clear_account_id() {
  account_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbyListResponseEntry_CLobbyMember::account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyListResponseEntry.CLobbyMember.account_id)
  return account_id_;
}
inline void CMsgPracticeLobbyListResponseEntry_CLobbyMember::set_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyListResponseEntry.CLobbyMember.account_id)
}

// optional string player_name = 2;
inline bool CMsgPracticeLobbyListResponseEntry_CLobbyMember::has_player_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPracticeLobbyListResponseEntry_CLobbyMember::clear_player_name() {
  player_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgPracticeLobbyListResponseEntry_CLobbyMember::player_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyListResponseEntry.CLobbyMember.player_name)
  return player_name_.GetNoArena();
}
inline void CMsgPracticeLobbyListResponseEntry_CLobbyMember::set_player_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  player_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyListResponseEntry.CLobbyMember.player_name)
}
#if LANG_CXX11
inline void CMsgPracticeLobbyListResponseEntry_CLobbyMember::set_player_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  player_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgPracticeLobbyListResponseEntry.CLobbyMember.player_name)
}
#endif
inline void CMsgPracticeLobbyListResponseEntry_CLobbyMember::set_player_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  player_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgPracticeLobbyListResponseEntry.CLobbyMember.player_name)
}
inline void CMsgPracticeLobbyListResponseEntry_CLobbyMember::set_player_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  player_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgPracticeLobbyListResponseEntry.CLobbyMember.player_name)
}
inline ::std::string* CMsgPracticeLobbyListResponseEntry_CLobbyMember::mutable_player_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgPracticeLobbyListResponseEntry.CLobbyMember.player_name)
  return player_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgPracticeLobbyListResponseEntry_CLobbyMember::release_player_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgPracticeLobbyListResponseEntry.CLobbyMember.player_name)
  if (!has_player_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return player_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgPracticeLobbyListResponseEntry_CLobbyMember::set_allocated_player_name(::std::string* player_name) {
  if (player_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  player_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), player_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgPracticeLobbyListResponseEntry.CLobbyMember.player_name)
}

// -------------------------------------------------------------------

// CMsgPracticeLobbyListResponseEntry

// optional uint64 id = 1 [(.proto.dota.key_field) = true];
inline bool CMsgPracticeLobbyListResponseEntry::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgPracticeLobbyListResponseEntry::clear_id() {
  id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint64 CMsgPracticeLobbyListResponseEntry::id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyListResponseEntry.id)
  return id_;
}
inline void CMsgPracticeLobbyListResponseEntry::set_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyListResponseEntry.id)
}

// repeated .proto.dota.CMsgPracticeLobbyListResponseEntry.CLobbyMember members = 5;
inline int CMsgPracticeLobbyListResponseEntry::members_size() const {
  return members_.size();
}
inline void CMsgPracticeLobbyListResponseEntry::clear_members() {
  members_.Clear();
}
inline ::proto::dota::CMsgPracticeLobbyListResponseEntry_CLobbyMember* CMsgPracticeLobbyListResponseEntry::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgPracticeLobbyListResponseEntry.members)
  return members_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry_CLobbyMember >*
CMsgPracticeLobbyListResponseEntry::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgPracticeLobbyListResponseEntry.members)
  return &members_;
}
inline const ::proto::dota::CMsgPracticeLobbyListResponseEntry_CLobbyMember& CMsgPracticeLobbyListResponseEntry::members(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyListResponseEntry.members)
  return members_.Get(index);
}
inline ::proto::dota::CMsgPracticeLobbyListResponseEntry_CLobbyMember* CMsgPracticeLobbyListResponseEntry::add_members() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgPracticeLobbyListResponseEntry.members)
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry_CLobbyMember >&
CMsgPracticeLobbyListResponseEntry::members() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgPracticeLobbyListResponseEntry.members)
  return members_;
}

// optional bool requires_pass_key = 6;
inline bool CMsgPracticeLobbyListResponseEntry::has_requires_pass_key() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgPracticeLobbyListResponseEntry::clear_requires_pass_key() {
  requires_pass_key_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool CMsgPracticeLobbyListResponseEntry::requires_pass_key() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyListResponseEntry.requires_pass_key)
  return requires_pass_key_;
}
inline void CMsgPracticeLobbyListResponseEntry::set_requires_pass_key(bool value) {
  _has_bits_[0] |= 0x00000100u;
  requires_pass_key_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyListResponseEntry.requires_pass_key)
}

// optional uint32 leader_account_id = 7;
inline bool CMsgPracticeLobbyListResponseEntry::has_leader_account_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgPracticeLobbyListResponseEntry::clear_leader_account_id() {
  leader_account_id_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbyListResponseEntry::leader_account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyListResponseEntry.leader_account_id)
  return leader_account_id_;
}
inline void CMsgPracticeLobbyListResponseEntry::set_leader_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  leader_account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyListResponseEntry.leader_account_id)
}

// optional uint32 guild_id = 8;
inline bool CMsgPracticeLobbyListResponseEntry::has_guild_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgPracticeLobbyListResponseEntry::clear_guild_id() {
  guild_id_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbyListResponseEntry::guild_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyListResponseEntry.guild_id)
  return guild_id_;
}
inline void CMsgPracticeLobbyListResponseEntry::set_guild_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  guild_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyListResponseEntry.guild_id)
}

// optional uint64 guild_logo = 9;
inline bool CMsgPracticeLobbyListResponseEntry::has_guild_logo() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgPracticeLobbyListResponseEntry::clear_guild_logo() {
  guild_logo_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint64 CMsgPracticeLobbyListResponseEntry::guild_logo() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyListResponseEntry.guild_logo)
  return guild_logo_;
}
inline void CMsgPracticeLobbyListResponseEntry::set_guild_logo(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000080u;
  guild_logo_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyListResponseEntry.guild_logo)
}

// optional string name = 10;
inline bool CMsgPracticeLobbyListResponseEntry::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPracticeLobbyListResponseEntry::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgPracticeLobbyListResponseEntry::name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyListResponseEntry.name)
  return name_.GetNoArena();
}
inline void CMsgPracticeLobbyListResponseEntry::set_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyListResponseEntry.name)
}
#if LANG_CXX11
inline void CMsgPracticeLobbyListResponseEntry::set_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgPracticeLobbyListResponseEntry.name)
}
#endif
inline void CMsgPracticeLobbyListResponseEntry::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgPracticeLobbyListResponseEntry.name)
}
inline void CMsgPracticeLobbyListResponseEntry::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgPracticeLobbyListResponseEntry.name)
}
inline ::std::string* CMsgPracticeLobbyListResponseEntry::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgPracticeLobbyListResponseEntry.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgPracticeLobbyListResponseEntry::release_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgPracticeLobbyListResponseEntry.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgPracticeLobbyListResponseEntry::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgPracticeLobbyListResponseEntry.name)
}

// optional string custom_game_mode = 11;
inline bool CMsgPracticeLobbyListResponseEntry::has_custom_game_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgPracticeLobbyListResponseEntry::clear_custom_game_mode() {
  custom_game_mode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgPracticeLobbyListResponseEntry::custom_game_mode() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyListResponseEntry.custom_game_mode)
  return custom_game_mode_.GetNoArena();
}
inline void CMsgPracticeLobbyListResponseEntry::set_custom_game_mode(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  custom_game_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyListResponseEntry.custom_game_mode)
}
#if LANG_CXX11
inline void CMsgPracticeLobbyListResponseEntry::set_custom_game_mode(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  custom_game_mode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgPracticeLobbyListResponseEntry.custom_game_mode)
}
#endif
inline void CMsgPracticeLobbyListResponseEntry::set_custom_game_mode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  custom_game_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgPracticeLobbyListResponseEntry.custom_game_mode)
}
inline void CMsgPracticeLobbyListResponseEntry::set_custom_game_mode(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  custom_game_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgPracticeLobbyListResponseEntry.custom_game_mode)
}
inline ::std::string* CMsgPracticeLobbyListResponseEntry::mutable_custom_game_mode() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgPracticeLobbyListResponseEntry.custom_game_mode)
  return custom_game_mode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgPracticeLobbyListResponseEntry::release_custom_game_mode() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgPracticeLobbyListResponseEntry.custom_game_mode)
  if (!has_custom_game_mode()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return custom_game_mode_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgPracticeLobbyListResponseEntry::set_allocated_custom_game_mode(::std::string* custom_game_mode) {
  if (custom_game_mode != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  custom_game_mode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), custom_game_mode);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgPracticeLobbyListResponseEntry.custom_game_mode)
}

// optional .proto.dota.DOTA_GameMode game_mode = 12 [default = DOTA_GAMEMODE_NONE];
inline bool CMsgPracticeLobbyListResponseEntry::has_game_mode() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgPracticeLobbyListResponseEntry::clear_game_mode() {
  game_mode_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::proto::dota::DOTA_GameMode CMsgPracticeLobbyListResponseEntry::game_mode() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyListResponseEntry.game_mode)
  return static_cast< ::proto::dota::DOTA_GameMode >(game_mode_);
}
inline void CMsgPracticeLobbyListResponseEntry::set_game_mode(::proto::dota::DOTA_GameMode value) {
  assert(::proto::dota::DOTA_GameMode_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  game_mode_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyListResponseEntry.game_mode)
}

// optional bool friend_present = 13;
inline bool CMsgPracticeLobbyListResponseEntry::has_friend_present() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgPracticeLobbyListResponseEntry::clear_friend_present() {
  friend_present_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool CMsgPracticeLobbyListResponseEntry::friend_present() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyListResponseEntry.friend_present)
  return friend_present_;
}
inline void CMsgPracticeLobbyListResponseEntry::set_friend_present(bool value) {
  _has_bits_[0] |= 0x00000200u;
  friend_present_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyListResponseEntry.friend_present)
}

// optional uint32 players = 14;
inline bool CMsgPracticeLobbyListResponseEntry::has_players() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgPracticeLobbyListResponseEntry::clear_players() {
  players_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbyListResponseEntry::players() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyListResponseEntry.players)
  return players_;
}
inline void CMsgPracticeLobbyListResponseEntry::set_players(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000800u;
  players_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyListResponseEntry.players)
}

// optional string custom_map_name = 15;
inline bool CMsgPracticeLobbyListResponseEntry::has_custom_map_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgPracticeLobbyListResponseEntry::clear_custom_map_name() {
  custom_map_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& CMsgPracticeLobbyListResponseEntry::custom_map_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyListResponseEntry.custom_map_name)
  return custom_map_name_.GetNoArena();
}
inline void CMsgPracticeLobbyListResponseEntry::set_custom_map_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  custom_map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyListResponseEntry.custom_map_name)
}
#if LANG_CXX11
inline void CMsgPracticeLobbyListResponseEntry::set_custom_map_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  custom_map_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgPracticeLobbyListResponseEntry.custom_map_name)
}
#endif
inline void CMsgPracticeLobbyListResponseEntry::set_custom_map_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  custom_map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgPracticeLobbyListResponseEntry.custom_map_name)
}
inline void CMsgPracticeLobbyListResponseEntry::set_custom_map_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  custom_map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgPracticeLobbyListResponseEntry.custom_map_name)
}
inline ::std::string* CMsgPracticeLobbyListResponseEntry::mutable_custom_map_name() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgPracticeLobbyListResponseEntry.custom_map_name)
  return custom_map_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgPracticeLobbyListResponseEntry::release_custom_map_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgPracticeLobbyListResponseEntry.custom_map_name)
  if (!has_custom_map_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return custom_map_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgPracticeLobbyListResponseEntry::set_allocated_custom_map_name(::std::string* custom_map_name) {
  if (custom_map_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  custom_map_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), custom_map_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgPracticeLobbyListResponseEntry.custom_map_name)
}

// optional uint32 max_player_count = 16;
inline bool CMsgPracticeLobbyListResponseEntry::has_max_player_count() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgPracticeLobbyListResponseEntry::clear_max_player_count() {
  max_player_count_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbyListResponseEntry::max_player_count() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyListResponseEntry.max_player_count)
  return max_player_count_;
}
inline void CMsgPracticeLobbyListResponseEntry::set_max_player_count(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00001000u;
  max_player_count_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyListResponseEntry.max_player_count)
}

// optional uint32 server_region = 17;
inline bool CMsgPracticeLobbyListResponseEntry::has_server_region() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgPracticeLobbyListResponseEntry::clear_server_region() {
  server_region_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbyListResponseEntry::server_region() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyListResponseEntry.server_region)
  return server_region_;
}
inline void CMsgPracticeLobbyListResponseEntry::set_server_region(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00002000u;
  server_region_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyListResponseEntry.server_region)
}

// optional uint32 league_id = 19;
inline bool CMsgPracticeLobbyListResponseEntry::has_league_id() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CMsgPracticeLobbyListResponseEntry::clear_league_id() {
  league_id_ = 0u;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbyListResponseEntry::league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyListResponseEntry.league_id)
  return league_id_;
}
inline void CMsgPracticeLobbyListResponseEntry::set_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00004000u;
  league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyListResponseEntry.league_id)
}

// optional string lan_host_ping_location = 20;
inline bool CMsgPracticeLobbyListResponseEntry::has_lan_host_ping_location() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgPracticeLobbyListResponseEntry::clear_lan_host_ping_location() {
  lan_host_ping_location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& CMsgPracticeLobbyListResponseEntry::lan_host_ping_location() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyListResponseEntry.lan_host_ping_location)
  return lan_host_ping_location_.GetNoArena();
}
inline void CMsgPracticeLobbyListResponseEntry::set_lan_host_ping_location(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  lan_host_ping_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyListResponseEntry.lan_host_ping_location)
}
#if LANG_CXX11
inline void CMsgPracticeLobbyListResponseEntry::set_lan_host_ping_location(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  lan_host_ping_location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgPracticeLobbyListResponseEntry.lan_host_ping_location)
}
#endif
inline void CMsgPracticeLobbyListResponseEntry::set_lan_host_ping_location(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  lan_host_ping_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgPracticeLobbyListResponseEntry.lan_host_ping_location)
}
inline void CMsgPracticeLobbyListResponseEntry::set_lan_host_ping_location(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  lan_host_ping_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgPracticeLobbyListResponseEntry.lan_host_ping_location)
}
inline ::std::string* CMsgPracticeLobbyListResponseEntry::mutable_lan_host_ping_location() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgPracticeLobbyListResponseEntry.lan_host_ping_location)
  return lan_host_ping_location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgPracticeLobbyListResponseEntry::release_lan_host_ping_location() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgPracticeLobbyListResponseEntry.lan_host_ping_location)
  if (!has_lan_host_ping_location()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return lan_host_ping_location_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgPracticeLobbyListResponseEntry::set_allocated_lan_host_ping_location(::std::string* lan_host_ping_location) {
  if (lan_host_ping_location != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  lan_host_ping_location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lan_host_ping_location);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgPracticeLobbyListResponseEntry.lan_host_ping_location)
}

// -------------------------------------------------------------------

// CMsgPracticeLobbyListResponse

// repeated .proto.dota.CMsgPracticeLobbyListResponseEntry lobbies = 2;
inline int CMsgPracticeLobbyListResponse::lobbies_size() const {
  return lobbies_.size();
}
inline void CMsgPracticeLobbyListResponse::clear_lobbies() {
  lobbies_.Clear();
}
inline ::proto::dota::CMsgPracticeLobbyListResponseEntry* CMsgPracticeLobbyListResponse::mutable_lobbies(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgPracticeLobbyListResponse.lobbies)
  return lobbies_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry >*
CMsgPracticeLobbyListResponse::mutable_lobbies() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgPracticeLobbyListResponse.lobbies)
  return &lobbies_;
}
inline const ::proto::dota::CMsgPracticeLobbyListResponseEntry& CMsgPracticeLobbyListResponse::lobbies(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyListResponse.lobbies)
  return lobbies_.Get(index);
}
inline ::proto::dota::CMsgPracticeLobbyListResponseEntry* CMsgPracticeLobbyListResponse::add_lobbies() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgPracticeLobbyListResponse.lobbies)
  return lobbies_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry >&
CMsgPracticeLobbyListResponse::lobbies() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgPracticeLobbyListResponse.lobbies)
  return lobbies_;
}

// -------------------------------------------------------------------

// CMsgLobbyList

// optional uint32 server_region = 1 [default = 0];
inline bool CMsgLobbyList::has_server_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgLobbyList::clear_server_region() {
  server_region_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgLobbyList::server_region() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgLobbyList.server_region)
  return server_region_;
}
inline void CMsgLobbyList::set_server_region(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  server_region_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgLobbyList.server_region)
}

// optional .proto.dota.DOTA_GameMode game_mode = 2 [default = DOTA_GAMEMODE_NONE];
inline bool CMsgLobbyList::has_game_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgLobbyList::clear_game_mode() {
  game_mode_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::proto::dota::DOTA_GameMode CMsgLobbyList::game_mode() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgLobbyList.game_mode)
  return static_cast< ::proto::dota::DOTA_GameMode >(game_mode_);
}
inline void CMsgLobbyList::set_game_mode(::proto::dota::DOTA_GameMode value) {
  assert(::proto::dota::DOTA_GameMode_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  game_mode_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgLobbyList.game_mode)
}

// -------------------------------------------------------------------

// CMsgLobbyListResponse

// repeated .proto.dota.CMsgPracticeLobbyListResponseEntry lobbies = 1;
inline int CMsgLobbyListResponse::lobbies_size() const {
  return lobbies_.size();
}
inline void CMsgLobbyListResponse::clear_lobbies() {
  lobbies_.Clear();
}
inline ::proto::dota::CMsgPracticeLobbyListResponseEntry* CMsgLobbyListResponse::mutable_lobbies(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgLobbyListResponse.lobbies)
  return lobbies_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry >*
CMsgLobbyListResponse::mutable_lobbies() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgLobbyListResponse.lobbies)
  return &lobbies_;
}
inline const ::proto::dota::CMsgPracticeLobbyListResponseEntry& CMsgLobbyListResponse::lobbies(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgLobbyListResponse.lobbies)
  return lobbies_.Get(index);
}
inline ::proto::dota::CMsgPracticeLobbyListResponseEntry* CMsgLobbyListResponse::add_lobbies() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgLobbyListResponse.lobbies)
  return lobbies_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry >&
CMsgLobbyListResponse::lobbies() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgLobbyListResponse.lobbies)
  return lobbies_;
}

// -------------------------------------------------------------------

// CMsgPracticeLobbyJoin

// optional uint64 lobby_id = 1;
inline bool CMsgPracticeLobbyJoin::has_lobby_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgPracticeLobbyJoin::clear_lobby_id() {
  lobby_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 CMsgPracticeLobbyJoin::lobby_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyJoin.lobby_id)
  return lobby_id_;
}
inline void CMsgPracticeLobbyJoin::set_lobby_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  lobby_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyJoin.lobby_id)
}

// optional uint32 client_version = 2;
inline bool CMsgPracticeLobbyJoin::has_client_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgPracticeLobbyJoin::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbyJoin::client_version() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyJoin.client_version)
  return client_version_;
}
inline void CMsgPracticeLobbyJoin::set_client_version(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  client_version_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyJoin.client_version)
}

// optional string pass_key = 3;
inline bool CMsgPracticeLobbyJoin::has_pass_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPracticeLobbyJoin::clear_pass_key() {
  pass_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgPracticeLobbyJoin::pass_key() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyJoin.pass_key)
  return pass_key_.GetNoArena();
}
inline void CMsgPracticeLobbyJoin::set_pass_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  pass_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyJoin.pass_key)
}
#if LANG_CXX11
inline void CMsgPracticeLobbyJoin::set_pass_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  pass_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgPracticeLobbyJoin.pass_key)
}
#endif
inline void CMsgPracticeLobbyJoin::set_pass_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  pass_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgPracticeLobbyJoin.pass_key)
}
inline void CMsgPracticeLobbyJoin::set_pass_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  pass_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgPracticeLobbyJoin.pass_key)
}
inline ::std::string* CMsgPracticeLobbyJoin::mutable_pass_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgPracticeLobbyJoin.pass_key)
  return pass_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgPracticeLobbyJoin::release_pass_key() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgPracticeLobbyJoin.pass_key)
  if (!has_pass_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return pass_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgPracticeLobbyJoin::set_allocated_pass_key(::std::string* pass_key) {
  if (pass_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pass_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pass_key);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgPracticeLobbyJoin.pass_key)
}

// optional fixed64 custom_game_crc = 4;
inline bool CMsgPracticeLobbyJoin::has_custom_game_crc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgPracticeLobbyJoin::clear_custom_game_crc() {
  custom_game_crc_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint64 CMsgPracticeLobbyJoin::custom_game_crc() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyJoin.custom_game_crc)
  return custom_game_crc_;
}
inline void CMsgPracticeLobbyJoin::set_custom_game_crc(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  custom_game_crc_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyJoin.custom_game_crc)
}

// optional fixed32 custom_game_timestamp = 5;
inline bool CMsgPracticeLobbyJoin::has_custom_game_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgPracticeLobbyJoin::clear_custom_game_timestamp() {
  custom_game_timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgPracticeLobbyJoin::custom_game_timestamp() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyJoin.custom_game_timestamp)
  return custom_game_timestamp_;
}
inline void CMsgPracticeLobbyJoin::set_custom_game_timestamp(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  custom_game_timestamp_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyJoin.custom_game_timestamp)
}

// -------------------------------------------------------------------

// CMsgPracticeLobbyJoinResponse

// optional .proto.dota.DOTAJoinLobbyResult result = 1 [default = DOTA_JOIN_RESULT_SUCCESS];
inline bool CMsgPracticeLobbyJoinResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgPracticeLobbyJoinResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::DOTAJoinLobbyResult CMsgPracticeLobbyJoinResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgPracticeLobbyJoinResponse.result)
  return static_cast< ::proto::dota::DOTAJoinLobbyResult >(result_);
}
inline void CMsgPracticeLobbyJoinResponse::set_result(::proto::dota::DOTAJoinLobbyResult value) {
  assert(::proto::dota::DOTAJoinLobbyResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgPracticeLobbyJoinResponse.result)
}

// -------------------------------------------------------------------

// CMsgFriendPracticeLobbyListRequest

// repeated uint32 friends = 1;
inline int CMsgFriendPracticeLobbyListRequest::friends_size() const {
  return friends_.size();
}
inline void CMsgFriendPracticeLobbyListRequest::clear_friends() {
  friends_.Clear();
}
inline ::google::protobuf::uint32 CMsgFriendPracticeLobbyListRequest::friends(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgFriendPracticeLobbyListRequest.friends)
  return friends_.Get(index);
}
inline void CMsgFriendPracticeLobbyListRequest::set_friends(int index, ::google::protobuf::uint32 value) {
  friends_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgFriendPracticeLobbyListRequest.friends)
}
inline void CMsgFriendPracticeLobbyListRequest::add_friends(::google::protobuf::uint32 value) {
  friends_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgFriendPracticeLobbyListRequest.friends)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgFriendPracticeLobbyListRequest::friends() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgFriendPracticeLobbyListRequest.friends)
  return friends_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgFriendPracticeLobbyListRequest::mutable_friends() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgFriendPracticeLobbyListRequest.friends)
  return &friends_;
}

// -------------------------------------------------------------------

// CMsgFriendPracticeLobbyListResponse

// repeated .proto.dota.CMsgPracticeLobbyListResponseEntry lobbies = 1;
inline int CMsgFriendPracticeLobbyListResponse::lobbies_size() const {
  return lobbies_.size();
}
inline void CMsgFriendPracticeLobbyListResponse::clear_lobbies() {
  lobbies_.Clear();
}
inline ::proto::dota::CMsgPracticeLobbyListResponseEntry* CMsgFriendPracticeLobbyListResponse::mutable_lobbies(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgFriendPracticeLobbyListResponse.lobbies)
  return lobbies_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry >*
CMsgFriendPracticeLobbyListResponse::mutable_lobbies() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgFriendPracticeLobbyListResponse.lobbies)
  return &lobbies_;
}
inline const ::proto::dota::CMsgPracticeLobbyListResponseEntry& CMsgFriendPracticeLobbyListResponse::lobbies(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgFriendPracticeLobbyListResponse.lobbies)
  return lobbies_.Get(index);
}
inline ::proto::dota::CMsgPracticeLobbyListResponseEntry* CMsgFriendPracticeLobbyListResponse::add_lobbies() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgFriendPracticeLobbyListResponse.lobbies)
  return lobbies_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry >&
CMsgFriendPracticeLobbyListResponse::lobbies() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgFriendPracticeLobbyListResponse.lobbies)
  return lobbies_;
}

// -------------------------------------------------------------------

// CMsgGuildmatePracticeLobbyListRequest

// repeated uint32 guilds = 1;
inline int CMsgGuildmatePracticeLobbyListRequest::guilds_size() const {
  return guilds_.size();
}
inline void CMsgGuildmatePracticeLobbyListRequest::clear_guilds() {
  guilds_.Clear();
}
inline ::google::protobuf::uint32 CMsgGuildmatePracticeLobbyListRequest::guilds(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgGuildmatePracticeLobbyListRequest.guilds)
  return guilds_.Get(index);
}
inline void CMsgGuildmatePracticeLobbyListRequest::set_guilds(int index, ::google::protobuf::uint32 value) {
  guilds_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgGuildmatePracticeLobbyListRequest.guilds)
}
inline void CMsgGuildmatePracticeLobbyListRequest::add_guilds(::google::protobuf::uint32 value) {
  guilds_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgGuildmatePracticeLobbyListRequest.guilds)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgGuildmatePracticeLobbyListRequest::guilds() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgGuildmatePracticeLobbyListRequest.guilds)
  return guilds_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgGuildmatePracticeLobbyListRequest::mutable_guilds() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgGuildmatePracticeLobbyListRequest.guilds)
  return &guilds_;
}

// -------------------------------------------------------------------

// CMsgGuildmatePracticeLobbyListResponse

// repeated .proto.dota.CMsgPracticeLobbyListResponseEntry lobbies = 1;
inline int CMsgGuildmatePracticeLobbyListResponse::lobbies_size() const {
  return lobbies_.size();
}
inline void CMsgGuildmatePracticeLobbyListResponse::clear_lobbies() {
  lobbies_.Clear();
}
inline ::proto::dota::CMsgPracticeLobbyListResponseEntry* CMsgGuildmatePracticeLobbyListResponse::mutable_lobbies(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgGuildmatePracticeLobbyListResponse.lobbies)
  return lobbies_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry >*
CMsgGuildmatePracticeLobbyListResponse::mutable_lobbies() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgGuildmatePracticeLobbyListResponse.lobbies)
  return &lobbies_;
}
inline const ::proto::dota::CMsgPracticeLobbyListResponseEntry& CMsgGuildmatePracticeLobbyListResponse::lobbies(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgGuildmatePracticeLobbyListResponse.lobbies)
  return lobbies_.Get(index);
}
inline ::proto::dota::CMsgPracticeLobbyListResponseEntry* CMsgGuildmatePracticeLobbyListResponse::add_lobbies() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgGuildmatePracticeLobbyListResponse.lobbies)
  return lobbies_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgPracticeLobbyListResponseEntry >&
CMsgGuildmatePracticeLobbyListResponse::lobbies() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgGuildmatePracticeLobbyListResponse.lobbies)
  return lobbies_;
}

// -------------------------------------------------------------------

// CMsgJoinableCustomGameModesRequest

// optional uint32 server_region = 1;
inline bool CMsgJoinableCustomGameModesRequest::has_server_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgJoinableCustomGameModesRequest::clear_server_region() {
  server_region_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgJoinableCustomGameModesRequest::server_region() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgJoinableCustomGameModesRequest.server_region)
  return server_region_;
}
inline void CMsgJoinableCustomGameModesRequest::set_server_region(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  server_region_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgJoinableCustomGameModesRequest.server_region)
}

// -------------------------------------------------------------------

// CMsgJoinableCustomGameModesResponseEntry

// optional uint64 custom_game_id = 1;
inline bool CMsgJoinableCustomGameModesResponseEntry::has_custom_game_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgJoinableCustomGameModesResponseEntry::clear_custom_game_id() {
  custom_game_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 CMsgJoinableCustomGameModesResponseEntry::custom_game_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgJoinableCustomGameModesResponseEntry.custom_game_id)
  return custom_game_id_;
}
inline void CMsgJoinableCustomGameModesResponseEntry::set_custom_game_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  custom_game_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgJoinableCustomGameModesResponseEntry.custom_game_id)
}

// optional uint32 lobby_count = 2;
inline bool CMsgJoinableCustomGameModesResponseEntry::has_lobby_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgJoinableCustomGameModesResponseEntry::clear_lobby_count() {
  lobby_count_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgJoinableCustomGameModesResponseEntry::lobby_count() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgJoinableCustomGameModesResponseEntry.lobby_count)
  return lobby_count_;
}
inline void CMsgJoinableCustomGameModesResponseEntry::set_lobby_count(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  lobby_count_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgJoinableCustomGameModesResponseEntry.lobby_count)
}

// optional uint32 player_count = 3;
inline bool CMsgJoinableCustomGameModesResponseEntry::has_player_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgJoinableCustomGameModesResponseEntry::clear_player_count() {
  player_count_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgJoinableCustomGameModesResponseEntry::player_count() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgJoinableCustomGameModesResponseEntry.player_count)
  return player_count_;
}
inline void CMsgJoinableCustomGameModesResponseEntry::set_player_count(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  player_count_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgJoinableCustomGameModesResponseEntry.player_count)
}

// -------------------------------------------------------------------

// CMsgJoinableCustomGameModesResponse

// repeated .proto.dota.CMsgJoinableCustomGameModesResponseEntry game_modes = 1;
inline int CMsgJoinableCustomGameModesResponse::game_modes_size() const {
  return game_modes_.size();
}
inline void CMsgJoinableCustomGameModesResponse::clear_game_modes() {
  game_modes_.Clear();
}
inline ::proto::dota::CMsgJoinableCustomGameModesResponseEntry* CMsgJoinableCustomGameModesResponse::mutable_game_modes(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgJoinableCustomGameModesResponse.game_modes)
  return game_modes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgJoinableCustomGameModesResponseEntry >*
CMsgJoinableCustomGameModesResponse::mutable_game_modes() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgJoinableCustomGameModesResponse.game_modes)
  return &game_modes_;
}
inline const ::proto::dota::CMsgJoinableCustomGameModesResponseEntry& CMsgJoinableCustomGameModesResponse::game_modes(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgJoinableCustomGameModesResponse.game_modes)
  return game_modes_.Get(index);
}
inline ::proto::dota::CMsgJoinableCustomGameModesResponseEntry* CMsgJoinableCustomGameModesResponse::add_game_modes() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgJoinableCustomGameModesResponse.game_modes)
  return game_modes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgJoinableCustomGameModesResponseEntry >&
CMsgJoinableCustomGameModesResponse::game_modes() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgJoinableCustomGameModesResponse.game_modes)
  return game_modes_;
}

// -------------------------------------------------------------------

// CMsgJoinableCustomLobbiesRequest

// optional uint32 server_region = 1;
inline bool CMsgJoinableCustomLobbiesRequest::has_server_region() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgJoinableCustomLobbiesRequest::clear_server_region() {
  server_region_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgJoinableCustomLobbiesRequest::server_region() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgJoinableCustomLobbiesRequest.server_region)
  return server_region_;
}
inline void CMsgJoinableCustomLobbiesRequest::set_server_region(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  server_region_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgJoinableCustomLobbiesRequest.server_region)
}

// optional uint64 custom_game_id = 2;
inline bool CMsgJoinableCustomLobbiesRequest::has_custom_game_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgJoinableCustomLobbiesRequest::clear_custom_game_id() {
  custom_game_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 CMsgJoinableCustomLobbiesRequest::custom_game_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgJoinableCustomLobbiesRequest.custom_game_id)
  return custom_game_id_;
}
inline void CMsgJoinableCustomLobbiesRequest::set_custom_game_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  custom_game_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgJoinableCustomLobbiesRequest.custom_game_id)
}

// -------------------------------------------------------------------

// CMsgJoinableCustomLobbiesResponseEntry

// optional fixed64 lobby_id = 1;
inline bool CMsgJoinableCustomLobbiesResponseEntry::has_lobby_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgJoinableCustomLobbiesResponseEntry::clear_lobby_id() {
  lobby_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint64 CMsgJoinableCustomLobbiesResponseEntry::lobby_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.lobby_id)
  return lobby_id_;
}
inline void CMsgJoinableCustomLobbiesResponseEntry::set_lobby_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  lobby_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.lobby_id)
}

// optional uint64 custom_game_id = 2;
inline bool CMsgJoinableCustomLobbiesResponseEntry::has_custom_game_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgJoinableCustomLobbiesResponseEntry::clear_custom_game_id() {
  custom_game_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint64 CMsgJoinableCustomLobbiesResponseEntry::custom_game_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.custom_game_id)
  return custom_game_id_;
}
inline void CMsgJoinableCustomLobbiesResponseEntry::set_custom_game_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  custom_game_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.custom_game_id)
}

// optional string lobby_name = 3;
inline bool CMsgJoinableCustomLobbiesResponseEntry::has_lobby_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgJoinableCustomLobbiesResponseEntry::clear_lobby_name() {
  lobby_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgJoinableCustomLobbiesResponseEntry::lobby_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.lobby_name)
  return lobby_name_.GetNoArena();
}
inline void CMsgJoinableCustomLobbiesResponseEntry::set_lobby_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  lobby_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.lobby_name)
}
#if LANG_CXX11
inline void CMsgJoinableCustomLobbiesResponseEntry::set_lobby_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  lobby_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.lobby_name)
}
#endif
inline void CMsgJoinableCustomLobbiesResponseEntry::set_lobby_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  lobby_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.lobby_name)
}
inline void CMsgJoinableCustomLobbiesResponseEntry::set_lobby_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  lobby_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.lobby_name)
}
inline ::std::string* CMsgJoinableCustomLobbiesResponseEntry::mutable_lobby_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.lobby_name)
  return lobby_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgJoinableCustomLobbiesResponseEntry::release_lobby_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.lobby_name)
  if (!has_lobby_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return lobby_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgJoinableCustomLobbiesResponseEntry::set_allocated_lobby_name(::std::string* lobby_name) {
  if (lobby_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  lobby_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lobby_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.lobby_name)
}

// optional uint32 member_count = 4;
inline bool CMsgJoinableCustomLobbiesResponseEntry::has_member_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgJoinableCustomLobbiesResponseEntry::clear_member_count() {
  member_count_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 CMsgJoinableCustomLobbiesResponseEntry::member_count() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.member_count)
  return member_count_;
}
inline void CMsgJoinableCustomLobbiesResponseEntry::set_member_count(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  member_count_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.member_count)
}

// optional uint32 leader_account_id = 5;
inline bool CMsgJoinableCustomLobbiesResponseEntry::has_leader_account_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgJoinableCustomLobbiesResponseEntry::clear_leader_account_id() {
  leader_account_id_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 CMsgJoinableCustomLobbiesResponseEntry::leader_account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.leader_account_id)
  return leader_account_id_;
}
inline void CMsgJoinableCustomLobbiesResponseEntry::set_leader_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  leader_account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.leader_account_id)
}

// optional string leader_name = 6;
inline bool CMsgJoinableCustomLobbiesResponseEntry::has_leader_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgJoinableCustomLobbiesResponseEntry::clear_leader_name() {
  leader_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgJoinableCustomLobbiesResponseEntry::leader_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.leader_name)
  return leader_name_.GetNoArena();
}
inline void CMsgJoinableCustomLobbiesResponseEntry::set_leader_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  leader_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.leader_name)
}
#if LANG_CXX11
inline void CMsgJoinableCustomLobbiesResponseEntry::set_leader_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  leader_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.leader_name)
}
#endif
inline void CMsgJoinableCustomLobbiesResponseEntry::set_leader_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  leader_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.leader_name)
}
inline void CMsgJoinableCustomLobbiesResponseEntry::set_leader_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  leader_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.leader_name)
}
inline ::std::string* CMsgJoinableCustomLobbiesResponseEntry::mutable_leader_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.leader_name)
  return leader_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgJoinableCustomLobbiesResponseEntry::release_leader_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.leader_name)
  if (!has_leader_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return leader_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgJoinableCustomLobbiesResponseEntry::set_allocated_leader_name(::std::string* leader_name) {
  if (leader_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  leader_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), leader_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.leader_name)
}

// optional string custom_map_name = 7;
inline bool CMsgJoinableCustomLobbiesResponseEntry::has_custom_map_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgJoinableCustomLobbiesResponseEntry::clear_custom_map_name() {
  custom_map_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& CMsgJoinableCustomLobbiesResponseEntry::custom_map_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.custom_map_name)
  return custom_map_name_.GetNoArena();
}
inline void CMsgJoinableCustomLobbiesResponseEntry::set_custom_map_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  custom_map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.custom_map_name)
}
#if LANG_CXX11
inline void CMsgJoinableCustomLobbiesResponseEntry::set_custom_map_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  custom_map_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.custom_map_name)
}
#endif
inline void CMsgJoinableCustomLobbiesResponseEntry::set_custom_map_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  custom_map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.custom_map_name)
}
inline void CMsgJoinableCustomLobbiesResponseEntry::set_custom_map_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  custom_map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.custom_map_name)
}
inline ::std::string* CMsgJoinableCustomLobbiesResponseEntry::mutable_custom_map_name() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.custom_map_name)
  return custom_map_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgJoinableCustomLobbiesResponseEntry::release_custom_map_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.custom_map_name)
  if (!has_custom_map_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return custom_map_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgJoinableCustomLobbiesResponseEntry::set_allocated_custom_map_name(::std::string* custom_map_name) {
  if (custom_map_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  custom_map_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), custom_map_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.custom_map_name)
}

// optional uint32 max_player_count = 8;
inline bool CMsgJoinableCustomLobbiesResponseEntry::has_max_player_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgJoinableCustomLobbiesResponseEntry::clear_max_player_count() {
  max_player_count_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint32 CMsgJoinableCustomLobbiesResponseEntry::max_player_count() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.max_player_count)
  return max_player_count_;
}
inline void CMsgJoinableCustomLobbiesResponseEntry::set_max_player_count(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  max_player_count_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.max_player_count)
}

// optional uint32 server_region = 9;
inline bool CMsgJoinableCustomLobbiesResponseEntry::has_server_region() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgJoinableCustomLobbiesResponseEntry::clear_server_region() {
  server_region_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::google::protobuf::uint32 CMsgJoinableCustomLobbiesResponseEntry::server_region() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.server_region)
  return server_region_;
}
inline void CMsgJoinableCustomLobbiesResponseEntry::set_server_region(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  server_region_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.server_region)
}

// optional bool has_pass_key = 11;
inline bool CMsgJoinableCustomLobbiesResponseEntry::has_has_pass_key() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgJoinableCustomLobbiesResponseEntry::clear_has_pass_key() {
  has_pass_key_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool CMsgJoinableCustomLobbiesResponseEntry::has_pass_key() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.has_pass_key)
  return has_pass_key_;
}
inline void CMsgJoinableCustomLobbiesResponseEntry::set_has_pass_key(bool value) {
  _has_bits_[0] |= 0x00000400u;
  has_pass_key_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.has_pass_key)
}

// optional string lan_host_ping_location = 12;
inline bool CMsgJoinableCustomLobbiesResponseEntry::has_lan_host_ping_location() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgJoinableCustomLobbiesResponseEntry::clear_lan_host_ping_location() {
  lan_host_ping_location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& CMsgJoinableCustomLobbiesResponseEntry::lan_host_ping_location() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.lan_host_ping_location)
  return lan_host_ping_location_.GetNoArena();
}
inline void CMsgJoinableCustomLobbiesResponseEntry::set_lan_host_ping_location(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  lan_host_ping_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.lan_host_ping_location)
}
#if LANG_CXX11
inline void CMsgJoinableCustomLobbiesResponseEntry::set_lan_host_ping_location(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  lan_host_ping_location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.lan_host_ping_location)
}
#endif
inline void CMsgJoinableCustomLobbiesResponseEntry::set_lan_host_ping_location(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  lan_host_ping_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.lan_host_ping_location)
}
inline void CMsgJoinableCustomLobbiesResponseEntry::set_lan_host_ping_location(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  lan_host_ping_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.lan_host_ping_location)
}
inline ::std::string* CMsgJoinableCustomLobbiesResponseEntry::mutable_lan_host_ping_location() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.lan_host_ping_location)
  return lan_host_ping_location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgJoinableCustomLobbiesResponseEntry::release_lan_host_ping_location() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.lan_host_ping_location)
  if (!has_lan_host_ping_location()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return lan_host_ping_location_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgJoinableCustomLobbiesResponseEntry::set_allocated_lan_host_ping_location(::std::string* lan_host_ping_location) {
  if (lan_host_ping_location != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  lan_host_ping_location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lan_host_ping_location);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgJoinableCustomLobbiesResponseEntry.lan_host_ping_location)
}

// -------------------------------------------------------------------

// CMsgJoinableCustomLobbiesResponse

// repeated .proto.dota.CMsgJoinableCustomLobbiesResponseEntry lobbies = 1;
inline int CMsgJoinableCustomLobbiesResponse::lobbies_size() const {
  return lobbies_.size();
}
inline void CMsgJoinableCustomLobbiesResponse::clear_lobbies() {
  lobbies_.Clear();
}
inline ::proto::dota::CMsgJoinableCustomLobbiesResponseEntry* CMsgJoinableCustomLobbiesResponse::mutable_lobbies(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgJoinableCustomLobbiesResponse.lobbies)
  return lobbies_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgJoinableCustomLobbiesResponseEntry >*
CMsgJoinableCustomLobbiesResponse::mutable_lobbies() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgJoinableCustomLobbiesResponse.lobbies)
  return &lobbies_;
}
inline const ::proto::dota::CMsgJoinableCustomLobbiesResponseEntry& CMsgJoinableCustomLobbiesResponse::lobbies(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgJoinableCustomLobbiesResponse.lobbies)
  return lobbies_.Get(index);
}
inline ::proto::dota::CMsgJoinableCustomLobbiesResponseEntry* CMsgJoinableCustomLobbiesResponse::add_lobbies() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgJoinableCustomLobbiesResponse.lobbies)
  return lobbies_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgJoinableCustomLobbiesResponseEntry >&
CMsgJoinableCustomLobbiesResponse::lobbies() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgJoinableCustomLobbiesResponse.lobbies)
  return lobbies_;
}

// -------------------------------------------------------------------

// CMsgQuickJoinCustomLobby_LegacyRegionPing

// optional uint32 server_region = 1;
inline bool CMsgQuickJoinCustomLobby_LegacyRegionPing::has_server_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgQuickJoinCustomLobby_LegacyRegionPing::clear_server_region() {
  server_region_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgQuickJoinCustomLobby_LegacyRegionPing::server_region() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgQuickJoinCustomLobby.LegacyRegionPing.server_region)
  return server_region_;
}
inline void CMsgQuickJoinCustomLobby_LegacyRegionPing::set_server_region(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  server_region_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgQuickJoinCustomLobby.LegacyRegionPing.server_region)
}

// optional uint32 ping = 2;
inline bool CMsgQuickJoinCustomLobby_LegacyRegionPing::has_ping() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgQuickJoinCustomLobby_LegacyRegionPing::clear_ping() {
  ping_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgQuickJoinCustomLobby_LegacyRegionPing::ping() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgQuickJoinCustomLobby.LegacyRegionPing.ping)
  return ping_;
}
inline void CMsgQuickJoinCustomLobby_LegacyRegionPing::set_ping(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  ping_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgQuickJoinCustomLobby.LegacyRegionPing.ping)
}

// optional fixed32 region_code = 3;
inline bool CMsgQuickJoinCustomLobby_LegacyRegionPing::has_region_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgQuickJoinCustomLobby_LegacyRegionPing::clear_region_code() {
  region_code_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgQuickJoinCustomLobby_LegacyRegionPing::region_code() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgQuickJoinCustomLobby.LegacyRegionPing.region_code)
  return region_code_;
}
inline void CMsgQuickJoinCustomLobby_LegacyRegionPing::set_region_code(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  region_code_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgQuickJoinCustomLobby.LegacyRegionPing.region_code)
}

// -------------------------------------------------------------------

// CMsgQuickJoinCustomLobby

// optional uint32 legacy_server_region = 1;
inline bool CMsgQuickJoinCustomLobby::has_legacy_server_region() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgQuickJoinCustomLobby::clear_legacy_server_region() {
  legacy_server_region_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgQuickJoinCustomLobby::legacy_server_region() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgQuickJoinCustomLobby.legacy_server_region)
  return legacy_server_region_;
}
inline void CMsgQuickJoinCustomLobby::set_legacy_server_region(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  legacy_server_region_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgQuickJoinCustomLobby.legacy_server_region)
}

// optional uint64 custom_game_id = 2;
inline bool CMsgQuickJoinCustomLobby::has_custom_game_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgQuickJoinCustomLobby::clear_custom_game_id() {
  custom_game_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 CMsgQuickJoinCustomLobby::custom_game_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgQuickJoinCustomLobby.custom_game_id)
  return custom_game_id_;
}
inline void CMsgQuickJoinCustomLobby::set_custom_game_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  custom_game_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgQuickJoinCustomLobby.custom_game_id)
}

// optional uint32 client_version = 3;
inline bool CMsgQuickJoinCustomLobby::has_client_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgQuickJoinCustomLobby::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgQuickJoinCustomLobby::client_version() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgQuickJoinCustomLobby.client_version)
  return client_version_;
}
inline void CMsgQuickJoinCustomLobby::set_client_version(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  client_version_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgQuickJoinCustomLobby.client_version)
}

// optional .proto.dota.CMsgPracticeLobbySetDetails create_lobby_details = 4;
inline bool CMsgQuickJoinCustomLobby::has_create_lobby_details() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgQuickJoinCustomLobby::clear_create_lobby_details() {
  if (create_lobby_details_ != nullptr) create_lobby_details_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::dota::CMsgPracticeLobbySetDetails& CMsgQuickJoinCustomLobby::create_lobby_details() const {
  const ::proto::dota::CMsgPracticeLobbySetDetails* p = create_lobby_details_;
  // @@protoc_insertion_point(field_get:proto.dota.CMsgQuickJoinCustomLobby.create_lobby_details)
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::dota::CMsgPracticeLobbySetDetails*>(
      &::proto::dota::_CMsgPracticeLobbySetDetails_default_instance_);
}
inline ::proto::dota::CMsgPracticeLobbySetDetails* CMsgQuickJoinCustomLobby::release_create_lobby_details() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgQuickJoinCustomLobby.create_lobby_details)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::dota::CMsgPracticeLobbySetDetails* temp = create_lobby_details_;
  create_lobby_details_ = nullptr;
  return temp;
}
inline ::proto::dota::CMsgPracticeLobbySetDetails* CMsgQuickJoinCustomLobby::mutable_create_lobby_details() {
  _has_bits_[0] |= 0x00000001u;
  if (create_lobby_details_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::dota::CMsgPracticeLobbySetDetails>(GetArenaNoVirtual());
    create_lobby_details_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgQuickJoinCustomLobby.create_lobby_details)
  return create_lobby_details_;
}
inline void CMsgQuickJoinCustomLobby::set_allocated_create_lobby_details(::proto::dota::CMsgPracticeLobbySetDetails* create_lobby_details) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete create_lobby_details_;
  }
  if (create_lobby_details) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      create_lobby_details = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, create_lobby_details, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  create_lobby_details_ = create_lobby_details;
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgQuickJoinCustomLobby.create_lobby_details)
}

// optional bool allow_any_map = 5;
inline bool CMsgQuickJoinCustomLobby::has_allow_any_map() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgQuickJoinCustomLobby::clear_allow_any_map() {
  allow_any_map_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool CMsgQuickJoinCustomLobby::allow_any_map() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgQuickJoinCustomLobby.allow_any_map)
  return allow_any_map_;
}
inline void CMsgQuickJoinCustomLobby::set_allow_any_map(bool value) {
  _has_bits_[0] |= 0x00000020u;
  allow_any_map_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgQuickJoinCustomLobby.allow_any_map)
}

// repeated .proto.dota.CMsgQuickJoinCustomLobby.LegacyRegionPing legacy_region_pings = 6;
inline int CMsgQuickJoinCustomLobby::legacy_region_pings_size() const {
  return legacy_region_pings_.size();
}
inline void CMsgQuickJoinCustomLobby::clear_legacy_region_pings() {
  legacy_region_pings_.Clear();
}
inline ::proto::dota::CMsgQuickJoinCustomLobby_LegacyRegionPing* CMsgQuickJoinCustomLobby::mutable_legacy_region_pings(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgQuickJoinCustomLobby.legacy_region_pings)
  return legacy_region_pings_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgQuickJoinCustomLobby_LegacyRegionPing >*
CMsgQuickJoinCustomLobby::mutable_legacy_region_pings() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgQuickJoinCustomLobby.legacy_region_pings)
  return &legacy_region_pings_;
}
inline const ::proto::dota::CMsgQuickJoinCustomLobby_LegacyRegionPing& CMsgQuickJoinCustomLobby::legacy_region_pings(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgQuickJoinCustomLobby.legacy_region_pings)
  return legacy_region_pings_.Get(index);
}
inline ::proto::dota::CMsgQuickJoinCustomLobby_LegacyRegionPing* CMsgQuickJoinCustomLobby::add_legacy_region_pings() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgQuickJoinCustomLobby.legacy_region_pings)
  return legacy_region_pings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgQuickJoinCustomLobby_LegacyRegionPing >&
CMsgQuickJoinCustomLobby::legacy_region_pings() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgQuickJoinCustomLobby.legacy_region_pings)
  return legacy_region_pings_;
}

// optional .proto.dota.CMsgClientPingData ping_data = 7;
inline bool CMsgQuickJoinCustomLobby::has_ping_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::proto::dota::CMsgClientPingData& CMsgQuickJoinCustomLobby::ping_data() const {
  const ::proto::dota::CMsgClientPingData* p = ping_data_;
  // @@protoc_insertion_point(field_get:proto.dota.CMsgQuickJoinCustomLobby.ping_data)
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::dota::CMsgClientPingData*>(
      &::proto::dota::_CMsgClientPingData_default_instance_);
}
inline ::proto::dota::CMsgClientPingData* CMsgQuickJoinCustomLobby::release_ping_data() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgQuickJoinCustomLobby.ping_data)
  _has_bits_[0] &= ~0x00000002u;
  ::proto::dota::CMsgClientPingData* temp = ping_data_;
  ping_data_ = nullptr;
  return temp;
}
inline ::proto::dota::CMsgClientPingData* CMsgQuickJoinCustomLobby::mutable_ping_data() {
  _has_bits_[0] |= 0x00000002u;
  if (ping_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::dota::CMsgClientPingData>(GetArenaNoVirtual());
    ping_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgQuickJoinCustomLobby.ping_data)
  return ping_data_;
}
inline void CMsgQuickJoinCustomLobby::set_allocated_ping_data(::proto::dota::CMsgClientPingData* ping_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ping_data_);
  }
  if (ping_data) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ping_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ping_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ping_data_ = ping_data;
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgQuickJoinCustomLobby.ping_data)
}

// -------------------------------------------------------------------

// CMsgQuickJoinCustomLobbyResponse

// optional .proto.dota.DOTAJoinLobbyResult result = 1 [default = DOTA_JOIN_RESULT_SUCCESS];
inline bool CMsgQuickJoinCustomLobbyResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgQuickJoinCustomLobbyResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::DOTAJoinLobbyResult CMsgQuickJoinCustomLobbyResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgQuickJoinCustomLobbyResponse.result)
  return static_cast< ::proto::dota::DOTAJoinLobbyResult >(result_);
}
inline void CMsgQuickJoinCustomLobbyResponse::set_result(::proto::dota::DOTAJoinLobbyResult value) {
  assert(::proto::dota::DOTAJoinLobbyResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgQuickJoinCustomLobbyResponse.result)
}

// -------------------------------------------------------------------

// CMsgBotGameCreate

// optional string search_key = 1;
inline bool CMsgBotGameCreate::has_search_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgBotGameCreate::clear_search_key() {
  search_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgBotGameCreate::search_key() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgBotGameCreate.search_key)
  return search_key_.GetNoArena();
}
inline void CMsgBotGameCreate::set_search_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  search_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgBotGameCreate.search_key)
}
#if LANG_CXX11
inline void CMsgBotGameCreate::set_search_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  search_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgBotGameCreate.search_key)
}
#endif
inline void CMsgBotGameCreate::set_search_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  search_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgBotGameCreate.search_key)
}
inline void CMsgBotGameCreate::set_search_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  search_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgBotGameCreate.search_key)
}
inline ::std::string* CMsgBotGameCreate::mutable_search_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgBotGameCreate.search_key)
  return search_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgBotGameCreate::release_search_key() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgBotGameCreate.search_key)
  if (!has_search_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return search_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgBotGameCreate::set_allocated_search_key(::std::string* search_key) {
  if (search_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  search_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), search_key);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgBotGameCreate.search_key)
}

// optional uint32 client_version = 2;
inline bool CMsgBotGameCreate::has_client_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgBotGameCreate::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgBotGameCreate::client_version() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgBotGameCreate.client_version)
  return client_version_;
}
inline void CMsgBotGameCreate::set_client_version(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  client_version_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgBotGameCreate.client_version)
}

// optional .proto.dota.DOTABotDifficulty difficulty_radiant = 3 [default = BOT_DIFFICULTY_PASSIVE];
inline bool CMsgBotGameCreate::has_difficulty_radiant() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgBotGameCreate::clear_difficulty_radiant() {
  difficulty_radiant_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::proto::dota::DOTABotDifficulty CMsgBotGameCreate::difficulty_radiant() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgBotGameCreate.difficulty_radiant)
  return static_cast< ::proto::dota::DOTABotDifficulty >(difficulty_radiant_);
}
inline void CMsgBotGameCreate::set_difficulty_radiant(::proto::dota::DOTABotDifficulty value) {
  assert(::proto::dota::DOTABotDifficulty_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  difficulty_radiant_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgBotGameCreate.difficulty_radiant)
}

// optional .proto.dota.DOTA_GC_TEAM team = 4 [default = DOTA_GC_TEAM_GOOD_GUYS];
inline bool CMsgBotGameCreate::has_team() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgBotGameCreate::clear_team() {
  team_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::proto::dota::DOTA_GC_TEAM CMsgBotGameCreate::team() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgBotGameCreate.team)
  return static_cast< ::proto::dota::DOTA_GC_TEAM >(team_);
}
inline void CMsgBotGameCreate::set_team(::proto::dota::DOTA_GC_TEAM value) {
  assert(::proto::dota::DOTA_GC_TEAM_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  team_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgBotGameCreate.team)
}

// optional uint32 game_mode = 5;
inline bool CMsgBotGameCreate::has_game_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgBotGameCreate::clear_game_mode() {
  game_mode_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgBotGameCreate::game_mode() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgBotGameCreate.game_mode)
  return game_mode_;
}
inline void CMsgBotGameCreate::set_game_mode(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  game_mode_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgBotGameCreate.game_mode)
}

// optional .proto.dota.DOTABotDifficulty difficulty_dire = 6 [default = BOT_DIFFICULTY_PASSIVE];
inline bool CMsgBotGameCreate::has_difficulty_dire() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgBotGameCreate::clear_difficulty_dire() {
  difficulty_dire_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::proto::dota::DOTABotDifficulty CMsgBotGameCreate::difficulty_dire() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgBotGameCreate.difficulty_dire)
  return static_cast< ::proto::dota::DOTABotDifficulty >(difficulty_dire_);
}
inline void CMsgBotGameCreate::set_difficulty_dire(::proto::dota::DOTABotDifficulty value) {
  assert(::proto::dota::DOTABotDifficulty_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  difficulty_dire_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgBotGameCreate.difficulty_dire)
}

// -------------------------------------------------------------------

// CMsgCustomGameCreate

// optional string search_key = 1;
inline bool CMsgCustomGameCreate::has_search_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgCustomGameCreate::clear_search_key() {
  search_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgCustomGameCreate::search_key() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgCustomGameCreate.search_key)
  return search_key_.GetNoArena();
}
inline void CMsgCustomGameCreate::set_search_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  search_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgCustomGameCreate.search_key)
}
#if LANG_CXX11
inline void CMsgCustomGameCreate::set_search_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  search_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgCustomGameCreate.search_key)
}
#endif
inline void CMsgCustomGameCreate::set_search_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  search_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgCustomGameCreate.search_key)
}
inline void CMsgCustomGameCreate::set_search_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  search_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgCustomGameCreate.search_key)
}
inline ::std::string* CMsgCustomGameCreate::mutable_search_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgCustomGameCreate.search_key)
  return search_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgCustomGameCreate::release_search_key() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgCustomGameCreate.search_key)
  if (!has_search_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return search_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgCustomGameCreate::set_allocated_search_key(::std::string* search_key) {
  if (search_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  search_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), search_key);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgCustomGameCreate.search_key)
}

// optional uint32 client_version = 2;
inline bool CMsgCustomGameCreate::has_client_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgCustomGameCreate::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgCustomGameCreate::client_version() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgCustomGameCreate.client_version)
  return client_version_;
}
inline void CMsgCustomGameCreate::set_client_version(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  client_version_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgCustomGameCreate.client_version)
}

// optional uint32 difficulty = 3;
inline bool CMsgCustomGameCreate::has_difficulty() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgCustomGameCreate::clear_difficulty() {
  difficulty_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgCustomGameCreate::difficulty() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgCustomGameCreate.difficulty)
  return difficulty_;
}
inline void CMsgCustomGameCreate::set_difficulty(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  difficulty_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgCustomGameCreate.difficulty)
}

// optional string game_mode = 4;
inline bool CMsgCustomGameCreate::has_game_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgCustomGameCreate::clear_game_mode() {
  game_mode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgCustomGameCreate::game_mode() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgCustomGameCreate.game_mode)
  return game_mode_.GetNoArena();
}
inline void CMsgCustomGameCreate::set_game_mode(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  game_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgCustomGameCreate.game_mode)
}
#if LANG_CXX11
inline void CMsgCustomGameCreate::set_game_mode(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  game_mode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgCustomGameCreate.game_mode)
}
#endif
inline void CMsgCustomGameCreate::set_game_mode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  game_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgCustomGameCreate.game_mode)
}
inline void CMsgCustomGameCreate::set_game_mode(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  game_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgCustomGameCreate.game_mode)
}
inline ::std::string* CMsgCustomGameCreate::mutable_game_mode() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgCustomGameCreate.game_mode)
  return game_mode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgCustomGameCreate::release_game_mode() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgCustomGameCreate.game_mode)
  if (!has_game_mode()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return game_mode_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgCustomGameCreate::set_allocated_game_mode(::std::string* game_mode) {
  if (game_mode != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  game_mode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), game_mode);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgCustomGameCreate.game_mode)
}

// optional string map = 5;
inline bool CMsgCustomGameCreate::has_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgCustomGameCreate::clear_map() {
  map_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& CMsgCustomGameCreate::map() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgCustomGameCreate.map)
  return map_.GetNoArena();
}
inline void CMsgCustomGameCreate::set_map(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  map_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgCustomGameCreate.map)
}
#if LANG_CXX11
inline void CMsgCustomGameCreate::set_map(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  map_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgCustomGameCreate.map)
}
#endif
inline void CMsgCustomGameCreate::set_map(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  map_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgCustomGameCreate.map)
}
inline void CMsgCustomGameCreate::set_map(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  map_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgCustomGameCreate.map)
}
inline ::std::string* CMsgCustomGameCreate::mutable_map() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgCustomGameCreate.map)
  return map_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgCustomGameCreate::release_map() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgCustomGameCreate.map)
  if (!has_map()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return map_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgCustomGameCreate::set_allocated_map(::std::string* map) {
  if (map != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  map_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgCustomGameCreate.map)
}

// optional uint64 custom_game_id = 7;
inline bool CMsgCustomGameCreate::has_custom_game_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgCustomGameCreate::clear_custom_game_id() {
  custom_game_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint64 CMsgCustomGameCreate::custom_game_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgCustomGameCreate.custom_game_id)
  return custom_game_id_;
}
inline void CMsgCustomGameCreate::set_custom_game_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  custom_game_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgCustomGameCreate.custom_game_id)
}

// -------------------------------------------------------------------

// CMsgEventGameCreate

// optional string search_key = 1;
inline bool CMsgEventGameCreate::has_search_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgEventGameCreate::clear_search_key() {
  search_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgEventGameCreate::search_key() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEventGameCreate.search_key)
  return search_key_.GetNoArena();
}
inline void CMsgEventGameCreate::set_search_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  search_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgEventGameCreate.search_key)
}
#if LANG_CXX11
inline void CMsgEventGameCreate::set_search_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  search_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgEventGameCreate.search_key)
}
#endif
inline void CMsgEventGameCreate::set_search_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  search_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgEventGameCreate.search_key)
}
inline void CMsgEventGameCreate::set_search_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  search_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgEventGameCreate.search_key)
}
inline ::std::string* CMsgEventGameCreate::mutable_search_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgEventGameCreate.search_key)
  return search_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgEventGameCreate::release_search_key() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgEventGameCreate.search_key)
  if (!has_search_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return search_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgEventGameCreate::set_allocated_search_key(::std::string* search_key) {
  if (search_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  search_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), search_key);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgEventGameCreate.search_key)
}

// optional uint32 client_version = 2;
inline bool CMsgEventGameCreate::has_client_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgEventGameCreate::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgEventGameCreate::client_version() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEventGameCreate.client_version)
  return client_version_;
}
inline void CMsgEventGameCreate::set_client_version(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  client_version_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgEventGameCreate.client_version)
}

// optional uint32 difficulty = 3;
inline bool CMsgEventGameCreate::has_difficulty() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgEventGameCreate::clear_difficulty() {
  difficulty_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgEventGameCreate::difficulty() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEventGameCreate.difficulty)
  return difficulty_;
}
inline void CMsgEventGameCreate::set_difficulty(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  difficulty_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgEventGameCreate.difficulty)
}

// optional string game_mode = 4;
inline bool CMsgEventGameCreate::has_game_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgEventGameCreate::clear_game_mode() {
  game_mode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgEventGameCreate::game_mode() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEventGameCreate.game_mode)
  return game_mode_.GetNoArena();
}
inline void CMsgEventGameCreate::set_game_mode(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  game_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgEventGameCreate.game_mode)
}
#if LANG_CXX11
inline void CMsgEventGameCreate::set_game_mode(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  game_mode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgEventGameCreate.game_mode)
}
#endif
inline void CMsgEventGameCreate::set_game_mode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  game_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgEventGameCreate.game_mode)
}
inline void CMsgEventGameCreate::set_game_mode(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  game_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgEventGameCreate.game_mode)
}
inline ::std::string* CMsgEventGameCreate::mutable_game_mode() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgEventGameCreate.game_mode)
  return game_mode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgEventGameCreate::release_game_mode() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgEventGameCreate.game_mode)
  if (!has_game_mode()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return game_mode_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgEventGameCreate::set_allocated_game_mode(::std::string* game_mode) {
  if (game_mode != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  game_mode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), game_mode);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgEventGameCreate.game_mode)
}

// optional string map = 5;
inline bool CMsgEventGameCreate::has_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgEventGameCreate::clear_map() {
  map_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& CMsgEventGameCreate::map() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEventGameCreate.map)
  return map_.GetNoArena();
}
inline void CMsgEventGameCreate::set_map(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  map_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgEventGameCreate.map)
}
#if LANG_CXX11
inline void CMsgEventGameCreate::set_map(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  map_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgEventGameCreate.map)
}
#endif
inline void CMsgEventGameCreate::set_map(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  map_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgEventGameCreate.map)
}
inline void CMsgEventGameCreate::set_map(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  map_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgEventGameCreate.map)
}
inline ::std::string* CMsgEventGameCreate::mutable_map() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgEventGameCreate.map)
  return map_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgEventGameCreate::release_map() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgEventGameCreate.map)
  if (!has_map()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return map_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgEventGameCreate::set_allocated_map(::std::string* map) {
  if (map != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  map_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgEventGameCreate.map)
}

// optional uint64 custom_game_id = 7;
inline bool CMsgEventGameCreate::has_custom_game_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgEventGameCreate::clear_custom_game_id() {
  custom_game_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint64 CMsgEventGameCreate::custom_game_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgEventGameCreate.custom_game_id)
  return custom_game_id_;
}
inline void CMsgEventGameCreate::set_custom_game_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  custom_game_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgEventGameCreate.custom_game_id)
}

// -------------------------------------------------------------------

// CMsgDOTAPartyMemberSetCoach

// optional bool wants_coach = 1;
inline bool CMsgDOTAPartyMemberSetCoach::has_wants_coach() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAPartyMemberSetCoach::clear_wants_coach() {
  wants_coach_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CMsgDOTAPartyMemberSetCoach::wants_coach() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPartyMemberSetCoach.wants_coach)
  return wants_coach_;
}
inline void CMsgDOTAPartyMemberSetCoach::set_wants_coach(bool value) {
  _has_bits_[0] |= 0x00000001u;
  wants_coach_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPartyMemberSetCoach.wants_coach)
}

// -------------------------------------------------------------------

// CMsgDOTASetGroupLeader

// optional fixed64 new_leader_steamid = 1;
inline bool CMsgDOTASetGroupLeader::has_new_leader_steamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTASetGroupLeader::clear_new_leader_steamid() {
  new_leader_steamid_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 CMsgDOTASetGroupLeader::new_leader_steamid() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTASetGroupLeader.new_leader_steamid)
  return new_leader_steamid_;
}
inline void CMsgDOTASetGroupLeader::set_new_leader_steamid(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  new_leader_steamid_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTASetGroupLeader.new_leader_steamid)
}

// -------------------------------------------------------------------

// CMsgDOTACancelGroupInvites

// repeated fixed64 invited_steamids = 1;
inline int CMsgDOTACancelGroupInvites::invited_steamids_size() const {
  return invited_steamids_.size();
}
inline void CMsgDOTACancelGroupInvites::clear_invited_steamids() {
  invited_steamids_.Clear();
}
inline ::google::protobuf::uint64 CMsgDOTACancelGroupInvites::invited_steamids(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTACancelGroupInvites.invited_steamids)
  return invited_steamids_.Get(index);
}
inline void CMsgDOTACancelGroupInvites::set_invited_steamids(int index, ::google::protobuf::uint64 value) {
  invited_steamids_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTACancelGroupInvites.invited_steamids)
}
inline void CMsgDOTACancelGroupInvites::add_invited_steamids(::google::protobuf::uint64 value) {
  invited_steamids_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTACancelGroupInvites.invited_steamids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CMsgDOTACancelGroupInvites::invited_steamids() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTACancelGroupInvites.invited_steamids)
  return invited_steamids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CMsgDOTACancelGroupInvites::mutable_invited_steamids() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTACancelGroupInvites.invited_steamids)
  return &invited_steamids_;
}

// repeated fixed64 invited_groupids = 2;
inline int CMsgDOTACancelGroupInvites::invited_groupids_size() const {
  return invited_groupids_.size();
}
inline void CMsgDOTACancelGroupInvites::clear_invited_groupids() {
  invited_groupids_.Clear();
}
inline ::google::protobuf::uint64 CMsgDOTACancelGroupInvites::invited_groupids(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTACancelGroupInvites.invited_groupids)
  return invited_groupids_.Get(index);
}
inline void CMsgDOTACancelGroupInvites::set_invited_groupids(int index, ::google::protobuf::uint64 value) {
  invited_groupids_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTACancelGroupInvites.invited_groupids)
}
inline void CMsgDOTACancelGroupInvites::add_invited_groupids(::google::protobuf::uint64 value) {
  invited_groupids_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTACancelGroupInvites.invited_groupids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CMsgDOTACancelGroupInvites::invited_groupids() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTACancelGroupInvites.invited_groupids)
  return invited_groupids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CMsgDOTACancelGroupInvites::mutable_invited_groupids() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTACancelGroupInvites.invited_groupids)
  return &invited_groupids_;
}

// -------------------------------------------------------------------

// CMsgDOTASetGroupOpenStatus

// optional bool open = 1;
inline bool CMsgDOTASetGroupOpenStatus::has_open() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTASetGroupOpenStatus::clear_open() {
  open_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CMsgDOTASetGroupOpenStatus::open() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTASetGroupOpenStatus.open)
  return open_;
}
inline void CMsgDOTASetGroupOpenStatus::set_open(bool value) {
  _has_bits_[0] |= 0x00000001u;
  open_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTASetGroupOpenStatus.open)
}

// -------------------------------------------------------------------

// CMsgDOTAGroupMergeInvite

// optional fixed64 other_group_id = 1;
inline bool CMsgDOTAGroupMergeInvite::has_other_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAGroupMergeInvite::clear_other_group_id() {
  other_group_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 CMsgDOTAGroupMergeInvite::other_group_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAGroupMergeInvite.other_group_id)
  return other_group_id_;
}
inline void CMsgDOTAGroupMergeInvite::set_other_group_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  other_group_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAGroupMergeInvite.other_group_id)
}

// -------------------------------------------------------------------

// CMsgDOTAGroupMergeResponse

// optional fixed64 initiator_group_id = 1;
inline bool CMsgDOTAGroupMergeResponse::has_initiator_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAGroupMergeResponse::clear_initiator_group_id() {
  initiator_group_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 CMsgDOTAGroupMergeResponse::initiator_group_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAGroupMergeResponse.initiator_group_id)
  return initiator_group_id_;
}
inline void CMsgDOTAGroupMergeResponse::set_initiator_group_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  initiator_group_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAGroupMergeResponse.initiator_group_id)
}

// optional bool accept = 2;
inline bool CMsgDOTAGroupMergeResponse::has_accept() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAGroupMergeResponse::clear_accept() {
  accept_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CMsgDOTAGroupMergeResponse::accept() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAGroupMergeResponse.accept)
  return accept_;
}
inline void CMsgDOTAGroupMergeResponse::set_accept(bool value) {
  _has_bits_[0] |= 0x00000002u;
  accept_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAGroupMergeResponse.accept)
}

// -------------------------------------------------------------------

// CMsgDOTAGroupMergeReply

// optional .proto.dota.EDOTAGroupMergeResult result = 1 [default = k_EDOTAGroupMergeResult_OK];
inline bool CMsgDOTAGroupMergeReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAGroupMergeReply::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::EDOTAGroupMergeResult CMsgDOTAGroupMergeReply::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAGroupMergeReply.result)
  return static_cast< ::proto::dota::EDOTAGroupMergeResult >(result_);
}
inline void CMsgDOTAGroupMergeReply::set_result(::proto::dota::EDOTAGroupMergeResult value) {
  assert(::proto::dota::EDOTAGroupMergeResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAGroupMergeReply.result)
}

// -------------------------------------------------------------------

// CMsgSpectatorLobbyGameDetails_Team

// optional uint32 team_id = 1;
inline bool CMsgSpectatorLobbyGameDetails_Team::has_team_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgSpectatorLobbyGameDetails_Team::clear_team_id() {
  team_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgSpectatorLobbyGameDetails_Team::team_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgSpectatorLobbyGameDetails.Team.team_id)
  return team_id_;
}
inline void CMsgSpectatorLobbyGameDetails_Team::set_team_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  team_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgSpectatorLobbyGameDetails.Team.team_id)
}

// optional string team_name = 2;
inline bool CMsgSpectatorLobbyGameDetails_Team::has_team_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgSpectatorLobbyGameDetails_Team::clear_team_name() {
  team_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgSpectatorLobbyGameDetails_Team::team_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgSpectatorLobbyGameDetails.Team.team_name)
  return team_name_.GetNoArena();
}
inline void CMsgSpectatorLobbyGameDetails_Team::set_team_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgSpectatorLobbyGameDetails.Team.team_name)
}
#if LANG_CXX11
inline void CMsgSpectatorLobbyGameDetails_Team::set_team_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgSpectatorLobbyGameDetails.Team.team_name)
}
#endif
inline void CMsgSpectatorLobbyGameDetails_Team::set_team_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgSpectatorLobbyGameDetails.Team.team_name)
}
inline void CMsgSpectatorLobbyGameDetails_Team::set_team_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgSpectatorLobbyGameDetails.Team.team_name)
}
inline ::std::string* CMsgSpectatorLobbyGameDetails_Team::mutable_team_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgSpectatorLobbyGameDetails.Team.team_name)
  return team_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgSpectatorLobbyGameDetails_Team::release_team_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgSpectatorLobbyGameDetails.Team.team_name)
  if (!has_team_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return team_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgSpectatorLobbyGameDetails_Team::set_allocated_team_name(::std::string* team_name) {
  if (team_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  team_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgSpectatorLobbyGameDetails.Team.team_name)
}

// optional fixed64 team_logo = 3;
inline bool CMsgSpectatorLobbyGameDetails_Team::has_team_logo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgSpectatorLobbyGameDetails_Team::clear_team_logo() {
  team_logo_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 CMsgSpectatorLobbyGameDetails_Team::team_logo() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgSpectatorLobbyGameDetails.Team.team_logo)
  return team_logo_;
}
inline void CMsgSpectatorLobbyGameDetails_Team::set_team_logo(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  team_logo_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgSpectatorLobbyGameDetails.Team.team_logo)
}

// -------------------------------------------------------------------

// CMsgSpectatorLobbyGameDetails

// optional uint32 language = 1;
inline bool CMsgSpectatorLobbyGameDetails::has_language() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgSpectatorLobbyGameDetails::clear_language() {
  language_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 CMsgSpectatorLobbyGameDetails::language() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgSpectatorLobbyGameDetails.language)
  return language_;
}
inline void CMsgSpectatorLobbyGameDetails::set_language(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  language_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgSpectatorLobbyGameDetails.language)
}

// optional uint64 match_id = 2;
inline bool CMsgSpectatorLobbyGameDetails::has_match_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgSpectatorLobbyGameDetails::clear_match_id() {
  match_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint64 CMsgSpectatorLobbyGameDetails::match_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgSpectatorLobbyGameDetails.match_id)
  return match_id_;
}
inline void CMsgSpectatorLobbyGameDetails::set_match_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  match_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgSpectatorLobbyGameDetails.match_id)
}

// optional fixed64 server_steam_id = 3;
inline bool CMsgSpectatorLobbyGameDetails::has_server_steam_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgSpectatorLobbyGameDetails::clear_server_steam_id() {
  server_steam_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint64 CMsgSpectatorLobbyGameDetails::server_steam_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgSpectatorLobbyGameDetails.server_steam_id)
  return server_steam_id_;
}
inline void CMsgSpectatorLobbyGameDetails::set_server_steam_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  server_steam_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgSpectatorLobbyGameDetails.server_steam_id)
}

// optional string stream_url = 4;
inline bool CMsgSpectatorLobbyGameDetails::has_stream_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgSpectatorLobbyGameDetails::clear_stream_url() {
  stream_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgSpectatorLobbyGameDetails::stream_url() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgSpectatorLobbyGameDetails.stream_url)
  return stream_url_.GetNoArena();
}
inline void CMsgSpectatorLobbyGameDetails::set_stream_url(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  stream_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgSpectatorLobbyGameDetails.stream_url)
}
#if LANG_CXX11
inline void CMsgSpectatorLobbyGameDetails::set_stream_url(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  stream_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgSpectatorLobbyGameDetails.stream_url)
}
#endif
inline void CMsgSpectatorLobbyGameDetails::set_stream_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  stream_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgSpectatorLobbyGameDetails.stream_url)
}
inline void CMsgSpectatorLobbyGameDetails::set_stream_url(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  stream_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgSpectatorLobbyGameDetails.stream_url)
}
inline ::std::string* CMsgSpectatorLobbyGameDetails::mutable_stream_url() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgSpectatorLobbyGameDetails.stream_url)
  return stream_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgSpectatorLobbyGameDetails::release_stream_url() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgSpectatorLobbyGameDetails.stream_url)
  if (!has_stream_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return stream_url_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgSpectatorLobbyGameDetails::set_allocated_stream_url(::std::string* stream_url) {
  if (stream_url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  stream_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stream_url);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgSpectatorLobbyGameDetails.stream_url)
}

// optional string stream_name = 5;
inline bool CMsgSpectatorLobbyGameDetails::has_stream_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgSpectatorLobbyGameDetails::clear_stream_name() {
  stream_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgSpectatorLobbyGameDetails::stream_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgSpectatorLobbyGameDetails.stream_name)
  return stream_name_.GetNoArena();
}
inline void CMsgSpectatorLobbyGameDetails::set_stream_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  stream_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgSpectatorLobbyGameDetails.stream_name)
}
#if LANG_CXX11
inline void CMsgSpectatorLobbyGameDetails::set_stream_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  stream_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgSpectatorLobbyGameDetails.stream_name)
}
#endif
inline void CMsgSpectatorLobbyGameDetails::set_stream_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  stream_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgSpectatorLobbyGameDetails.stream_name)
}
inline void CMsgSpectatorLobbyGameDetails::set_stream_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  stream_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgSpectatorLobbyGameDetails.stream_name)
}
inline ::std::string* CMsgSpectatorLobbyGameDetails::mutable_stream_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgSpectatorLobbyGameDetails.stream_name)
  return stream_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgSpectatorLobbyGameDetails::release_stream_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgSpectatorLobbyGameDetails.stream_name)
  if (!has_stream_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return stream_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgSpectatorLobbyGameDetails::set_allocated_stream_name(::std::string* stream_name) {
  if (stream_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  stream_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stream_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgSpectatorLobbyGameDetails.stream_name)
}

// optional uint32 league_id = 6;
inline bool CMsgSpectatorLobbyGameDetails::has_league_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgSpectatorLobbyGameDetails::clear_league_id() {
  league_id_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 CMsgSpectatorLobbyGameDetails::league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgSpectatorLobbyGameDetails.league_id)
  return league_id_;
}
inline void CMsgSpectatorLobbyGameDetails::set_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgSpectatorLobbyGameDetails.league_id)
}

// optional uint32 series_type = 7;
inline bool CMsgSpectatorLobbyGameDetails::has_series_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgSpectatorLobbyGameDetails::clear_series_type() {
  series_type_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint32 CMsgSpectatorLobbyGameDetails::series_type() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgSpectatorLobbyGameDetails.series_type)
  return series_type_;
}
inline void CMsgSpectatorLobbyGameDetails::set_series_type(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  series_type_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgSpectatorLobbyGameDetails.series_type)
}

// optional uint32 series_game = 8;
inline bool CMsgSpectatorLobbyGameDetails::has_series_game() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgSpectatorLobbyGameDetails::clear_series_game() {
  series_game_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::google::protobuf::uint32 CMsgSpectatorLobbyGameDetails::series_game() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgSpectatorLobbyGameDetails.series_game)
  return series_game_;
}
inline void CMsgSpectatorLobbyGameDetails::set_series_game(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  series_game_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgSpectatorLobbyGameDetails.series_game)
}

// optional .proto.dota.CMsgSpectatorLobbyGameDetails.Team radiant_team = 9;
inline bool CMsgSpectatorLobbyGameDetails::has_radiant_team() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgSpectatorLobbyGameDetails::clear_radiant_team() {
  if (radiant_team_ != nullptr) radiant_team_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::proto::dota::CMsgSpectatorLobbyGameDetails_Team& CMsgSpectatorLobbyGameDetails::radiant_team() const {
  const ::proto::dota::CMsgSpectatorLobbyGameDetails_Team* p = radiant_team_;
  // @@protoc_insertion_point(field_get:proto.dota.CMsgSpectatorLobbyGameDetails.radiant_team)
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::dota::CMsgSpectatorLobbyGameDetails_Team*>(
      &::proto::dota::_CMsgSpectatorLobbyGameDetails_Team_default_instance_);
}
inline ::proto::dota::CMsgSpectatorLobbyGameDetails_Team* CMsgSpectatorLobbyGameDetails::release_radiant_team() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgSpectatorLobbyGameDetails.radiant_team)
  _has_bits_[0] &= ~0x00000004u;
  ::proto::dota::CMsgSpectatorLobbyGameDetails_Team* temp = radiant_team_;
  radiant_team_ = nullptr;
  return temp;
}
inline ::proto::dota::CMsgSpectatorLobbyGameDetails_Team* CMsgSpectatorLobbyGameDetails::mutable_radiant_team() {
  _has_bits_[0] |= 0x00000004u;
  if (radiant_team_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::dota::CMsgSpectatorLobbyGameDetails_Team>(GetArenaNoVirtual());
    radiant_team_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgSpectatorLobbyGameDetails.radiant_team)
  return radiant_team_;
}
inline void CMsgSpectatorLobbyGameDetails::set_allocated_radiant_team(::proto::dota::CMsgSpectatorLobbyGameDetails_Team* radiant_team) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete radiant_team_;
  }
  if (radiant_team) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      radiant_team = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, radiant_team, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  radiant_team_ = radiant_team;
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgSpectatorLobbyGameDetails.radiant_team)
}

// optional .proto.dota.CMsgSpectatorLobbyGameDetails.Team dire_team = 10;
inline bool CMsgSpectatorLobbyGameDetails::has_dire_team() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgSpectatorLobbyGameDetails::clear_dire_team() {
  if (dire_team_ != nullptr) dire_team_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::proto::dota::CMsgSpectatorLobbyGameDetails_Team& CMsgSpectatorLobbyGameDetails::dire_team() const {
  const ::proto::dota::CMsgSpectatorLobbyGameDetails_Team* p = dire_team_;
  // @@protoc_insertion_point(field_get:proto.dota.CMsgSpectatorLobbyGameDetails.dire_team)
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::dota::CMsgSpectatorLobbyGameDetails_Team*>(
      &::proto::dota::_CMsgSpectatorLobbyGameDetails_Team_default_instance_);
}
inline ::proto::dota::CMsgSpectatorLobbyGameDetails_Team* CMsgSpectatorLobbyGameDetails::release_dire_team() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgSpectatorLobbyGameDetails.dire_team)
  _has_bits_[0] &= ~0x00000008u;
  ::proto::dota::CMsgSpectatorLobbyGameDetails_Team* temp = dire_team_;
  dire_team_ = nullptr;
  return temp;
}
inline ::proto::dota::CMsgSpectatorLobbyGameDetails_Team* CMsgSpectatorLobbyGameDetails::mutable_dire_team() {
  _has_bits_[0] |= 0x00000008u;
  if (dire_team_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::dota::CMsgSpectatorLobbyGameDetails_Team>(GetArenaNoVirtual());
    dire_team_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgSpectatorLobbyGameDetails.dire_team)
  return dire_team_;
}
inline void CMsgSpectatorLobbyGameDetails::set_allocated_dire_team(::proto::dota::CMsgSpectatorLobbyGameDetails_Team* dire_team) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dire_team_;
  }
  if (dire_team) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dire_team = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dire_team, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  dire_team_ = dire_team;
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgSpectatorLobbyGameDetails.dire_team)
}

// -------------------------------------------------------------------

// CMsgSetSpectatorLobbyDetails

// optional uint64 lobby_id = 1;
inline bool CMsgSetSpectatorLobbyDetails::has_lobby_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgSetSpectatorLobbyDetails::clear_lobby_id() {
  lobby_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 CMsgSetSpectatorLobbyDetails::lobby_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgSetSpectatorLobbyDetails.lobby_id)
  return lobby_id_;
}
inline void CMsgSetSpectatorLobbyDetails::set_lobby_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  lobby_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgSetSpectatorLobbyDetails.lobby_id)
}

// optional string lobby_name = 2;
inline bool CMsgSetSpectatorLobbyDetails::has_lobby_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgSetSpectatorLobbyDetails::clear_lobby_name() {
  lobby_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgSetSpectatorLobbyDetails::lobby_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgSetSpectatorLobbyDetails.lobby_name)
  return lobby_name_.GetNoArena();
}
inline void CMsgSetSpectatorLobbyDetails::set_lobby_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  lobby_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgSetSpectatorLobbyDetails.lobby_name)
}
#if LANG_CXX11
inline void CMsgSetSpectatorLobbyDetails::set_lobby_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  lobby_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgSetSpectatorLobbyDetails.lobby_name)
}
#endif
inline void CMsgSetSpectatorLobbyDetails::set_lobby_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  lobby_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgSetSpectatorLobbyDetails.lobby_name)
}
inline void CMsgSetSpectatorLobbyDetails::set_lobby_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  lobby_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgSetSpectatorLobbyDetails.lobby_name)
}
inline ::std::string* CMsgSetSpectatorLobbyDetails::mutable_lobby_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgSetSpectatorLobbyDetails.lobby_name)
  return lobby_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgSetSpectatorLobbyDetails::release_lobby_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgSetSpectatorLobbyDetails.lobby_name)
  if (!has_lobby_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return lobby_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgSetSpectatorLobbyDetails::set_allocated_lobby_name(::std::string* lobby_name) {
  if (lobby_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  lobby_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lobby_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgSetSpectatorLobbyDetails.lobby_name)
}

// optional string pass_key = 3;
inline bool CMsgSetSpectatorLobbyDetails::has_pass_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgSetSpectatorLobbyDetails::clear_pass_key() {
  pass_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgSetSpectatorLobbyDetails::pass_key() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgSetSpectatorLobbyDetails.pass_key)
  return pass_key_.GetNoArena();
}
inline void CMsgSetSpectatorLobbyDetails::set_pass_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  pass_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgSetSpectatorLobbyDetails.pass_key)
}
#if LANG_CXX11
inline void CMsgSetSpectatorLobbyDetails::set_pass_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  pass_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgSetSpectatorLobbyDetails.pass_key)
}
#endif
inline void CMsgSetSpectatorLobbyDetails::set_pass_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  pass_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgSetSpectatorLobbyDetails.pass_key)
}
inline void CMsgSetSpectatorLobbyDetails::set_pass_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  pass_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgSetSpectatorLobbyDetails.pass_key)
}
inline ::std::string* CMsgSetSpectatorLobbyDetails::mutable_pass_key() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgSetSpectatorLobbyDetails.pass_key)
  return pass_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgSetSpectatorLobbyDetails::release_pass_key() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgSetSpectatorLobbyDetails.pass_key)
  if (!has_pass_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return pass_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgSetSpectatorLobbyDetails::set_allocated_pass_key(::std::string* pass_key) {
  if (pass_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  pass_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pass_key);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgSetSpectatorLobbyDetails.pass_key)
}

// optional .proto.dota.CMsgSpectatorLobbyGameDetails game_details = 4;
inline bool CMsgSetSpectatorLobbyDetails::has_game_details() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgSetSpectatorLobbyDetails::clear_game_details() {
  if (game_details_ != nullptr) game_details_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::proto::dota::CMsgSpectatorLobbyGameDetails& CMsgSetSpectatorLobbyDetails::game_details() const {
  const ::proto::dota::CMsgSpectatorLobbyGameDetails* p = game_details_;
  // @@protoc_insertion_point(field_get:proto.dota.CMsgSetSpectatorLobbyDetails.game_details)
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::dota::CMsgSpectatorLobbyGameDetails*>(
      &::proto::dota::_CMsgSpectatorLobbyGameDetails_default_instance_);
}
inline ::proto::dota::CMsgSpectatorLobbyGameDetails* CMsgSetSpectatorLobbyDetails::release_game_details() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgSetSpectatorLobbyDetails.game_details)
  _has_bits_[0] &= ~0x00000004u;
  ::proto::dota::CMsgSpectatorLobbyGameDetails* temp = game_details_;
  game_details_ = nullptr;
  return temp;
}
inline ::proto::dota::CMsgSpectatorLobbyGameDetails* CMsgSetSpectatorLobbyDetails::mutable_game_details() {
  _has_bits_[0] |= 0x00000004u;
  if (game_details_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::dota::CMsgSpectatorLobbyGameDetails>(GetArenaNoVirtual());
    game_details_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgSetSpectatorLobbyDetails.game_details)
  return game_details_;
}
inline void CMsgSetSpectatorLobbyDetails::set_allocated_game_details(::proto::dota::CMsgSpectatorLobbyGameDetails* game_details) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete game_details_;
  }
  if (game_details) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      game_details = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, game_details, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  game_details_ = game_details;
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgSetSpectatorLobbyDetails.game_details)
}

// -------------------------------------------------------------------

// CMsgCreateSpectatorLobby

// optional uint32 client_version = 1;
inline bool CMsgCreateSpectatorLobby::has_client_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgCreateSpectatorLobby::clear_client_version() {
  client_version_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgCreateSpectatorLobby::client_version() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgCreateSpectatorLobby.client_version)
  return client_version_;
}
inline void CMsgCreateSpectatorLobby::set_client_version(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  client_version_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgCreateSpectatorLobby.client_version)
}

// optional .proto.dota.CMsgSetSpectatorLobbyDetails details = 2;
inline bool CMsgCreateSpectatorLobby::has_details() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgCreateSpectatorLobby::clear_details() {
  if (details_ != nullptr) details_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::dota::CMsgSetSpectatorLobbyDetails& CMsgCreateSpectatorLobby::details() const {
  const ::proto::dota::CMsgSetSpectatorLobbyDetails* p = details_;
  // @@protoc_insertion_point(field_get:proto.dota.CMsgCreateSpectatorLobby.details)
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::dota::CMsgSetSpectatorLobbyDetails*>(
      &::proto::dota::_CMsgSetSpectatorLobbyDetails_default_instance_);
}
inline ::proto::dota::CMsgSetSpectatorLobbyDetails* CMsgCreateSpectatorLobby::release_details() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgCreateSpectatorLobby.details)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::dota::CMsgSetSpectatorLobbyDetails* temp = details_;
  details_ = nullptr;
  return temp;
}
inline ::proto::dota::CMsgSetSpectatorLobbyDetails* CMsgCreateSpectatorLobby::mutable_details() {
  _has_bits_[0] |= 0x00000001u;
  if (details_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::dota::CMsgSetSpectatorLobbyDetails>(GetArenaNoVirtual());
    details_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgCreateSpectatorLobby.details)
  return details_;
}
inline void CMsgCreateSpectatorLobby::set_allocated_details(::proto::dota::CMsgSetSpectatorLobbyDetails* details) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete details_;
  }
  if (details) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      details = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, details, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  details_ = details;
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgCreateSpectatorLobby.details)
}

// -------------------------------------------------------------------

// CMsgSpectatorLobbyList

// -------------------------------------------------------------------

// CMsgSpectatorLobbyListResponse_SpectatorLobby

// optional uint64 lobby_id = 1;
inline bool CMsgSpectatorLobbyListResponse_SpectatorLobby::has_lobby_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgSpectatorLobbyListResponse_SpectatorLobby::clear_lobby_id() {
  lobby_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 CMsgSpectatorLobbyListResponse_SpectatorLobby::lobby_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.lobby_id)
  return lobby_id_;
}
inline void CMsgSpectatorLobbyListResponse_SpectatorLobby::set_lobby_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  lobby_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.lobby_id)
}

// optional string game_name = 2;
inline bool CMsgSpectatorLobbyListResponse_SpectatorLobby::has_game_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgSpectatorLobbyListResponse_SpectatorLobby::clear_game_name() {
  game_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgSpectatorLobbyListResponse_SpectatorLobby::game_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.game_name)
  return game_name_.GetNoArena();
}
inline void CMsgSpectatorLobbyListResponse_SpectatorLobby::set_game_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  game_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.game_name)
}
#if LANG_CXX11
inline void CMsgSpectatorLobbyListResponse_SpectatorLobby::set_game_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  game_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.game_name)
}
#endif
inline void CMsgSpectatorLobbyListResponse_SpectatorLobby::set_game_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  game_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.game_name)
}
inline void CMsgSpectatorLobbyListResponse_SpectatorLobby::set_game_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  game_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.game_name)
}
inline ::std::string* CMsgSpectatorLobbyListResponse_SpectatorLobby::mutable_game_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.game_name)
  return game_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgSpectatorLobbyListResponse_SpectatorLobby::release_game_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.game_name)
  if (!has_game_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return game_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgSpectatorLobbyListResponse_SpectatorLobby::set_allocated_game_name(::std::string* game_name) {
  if (game_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  game_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), game_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.game_name)
}

// optional bool requires_pass_key = 3;
inline bool CMsgSpectatorLobbyListResponse_SpectatorLobby::has_requires_pass_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgSpectatorLobbyListResponse_SpectatorLobby::clear_requires_pass_key() {
  requires_pass_key_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool CMsgSpectatorLobbyListResponse_SpectatorLobby::requires_pass_key() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.requires_pass_key)
  return requires_pass_key_;
}
inline void CMsgSpectatorLobbyListResponse_SpectatorLobby::set_requires_pass_key(bool value) {
  _has_bits_[0] |= 0x00000008u;
  requires_pass_key_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.requires_pass_key)
}

// optional uint32 leader_account_id = 4;
inline bool CMsgSpectatorLobbyListResponse_SpectatorLobby::has_leader_account_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgSpectatorLobbyListResponse_SpectatorLobby::clear_leader_account_id() {
  leader_account_id_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgSpectatorLobbyListResponse_SpectatorLobby::leader_account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.leader_account_id)
  return leader_account_id_;
}
inline void CMsgSpectatorLobbyListResponse_SpectatorLobby::set_leader_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  leader_account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.leader_account_id)
}

// optional uint32 member_count = 5;
inline bool CMsgSpectatorLobbyListResponse_SpectatorLobby::has_member_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgSpectatorLobbyListResponse_SpectatorLobby::clear_member_count() {
  member_count_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 CMsgSpectatorLobbyListResponse_SpectatorLobby::member_count() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.member_count)
  return member_count_;
}
inline void CMsgSpectatorLobbyListResponse_SpectatorLobby::set_member_count(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  member_count_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.member_count)
}

// optional .proto.dota.CMsgSpectatorLobbyGameDetails game_details = 7;
inline bool CMsgSpectatorLobbyListResponse_SpectatorLobby::has_game_details() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgSpectatorLobbyListResponse_SpectatorLobby::clear_game_details() {
  if (game_details_ != nullptr) game_details_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::dota::CMsgSpectatorLobbyGameDetails& CMsgSpectatorLobbyListResponse_SpectatorLobby::game_details() const {
  const ::proto::dota::CMsgSpectatorLobbyGameDetails* p = game_details_;
  // @@protoc_insertion_point(field_get:proto.dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.game_details)
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::dota::CMsgSpectatorLobbyGameDetails*>(
      &::proto::dota::_CMsgSpectatorLobbyGameDetails_default_instance_);
}
inline ::proto::dota::CMsgSpectatorLobbyGameDetails* CMsgSpectatorLobbyListResponse_SpectatorLobby::release_game_details() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.game_details)
  _has_bits_[0] &= ~0x00000002u;
  ::proto::dota::CMsgSpectatorLobbyGameDetails* temp = game_details_;
  game_details_ = nullptr;
  return temp;
}
inline ::proto::dota::CMsgSpectatorLobbyGameDetails* CMsgSpectatorLobbyListResponse_SpectatorLobby::mutable_game_details() {
  _has_bits_[0] |= 0x00000002u;
  if (game_details_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::dota::CMsgSpectatorLobbyGameDetails>(GetArenaNoVirtual());
    game_details_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.game_details)
  return game_details_;
}
inline void CMsgSpectatorLobbyListResponse_SpectatorLobby::set_allocated_game_details(::proto::dota::CMsgSpectatorLobbyGameDetails* game_details) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete game_details_;
  }
  if (game_details) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      game_details = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, game_details, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  game_details_ = game_details;
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgSpectatorLobbyListResponse.SpectatorLobby.game_details)
}

// -------------------------------------------------------------------

// CMsgSpectatorLobbyListResponse

// repeated .proto.dota.CMsgSpectatorLobbyListResponse.SpectatorLobby lobbies = 1;
inline int CMsgSpectatorLobbyListResponse::lobbies_size() const {
  return lobbies_.size();
}
inline void CMsgSpectatorLobbyListResponse::clear_lobbies() {
  lobbies_.Clear();
}
inline ::proto::dota::CMsgSpectatorLobbyListResponse_SpectatorLobby* CMsgSpectatorLobbyListResponse::mutable_lobbies(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgSpectatorLobbyListResponse.lobbies)
  return lobbies_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgSpectatorLobbyListResponse_SpectatorLobby >*
CMsgSpectatorLobbyListResponse::mutable_lobbies() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgSpectatorLobbyListResponse.lobbies)
  return &lobbies_;
}
inline const ::proto::dota::CMsgSpectatorLobbyListResponse_SpectatorLobby& CMsgSpectatorLobbyListResponse::lobbies(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgSpectatorLobbyListResponse.lobbies)
  return lobbies_.Get(index);
}
inline ::proto::dota::CMsgSpectatorLobbyListResponse_SpectatorLobby* CMsgSpectatorLobbyListResponse::add_lobbies() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgSpectatorLobbyListResponse.lobbies)
  return lobbies_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgSpectatorLobbyListResponse_SpectatorLobby >&
CMsgSpectatorLobbyListResponse::lobbies() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgSpectatorLobbyListResponse.lobbies)
  return lobbies_;
}

// -------------------------------------------------------------------

// CMsgClientToGCRequestSteamDatagramTicket

// optional fixed64 server_steam_id = 1;
inline bool CMsgClientToGCRequestSteamDatagramTicket::has_server_steam_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientToGCRequestSteamDatagramTicket::clear_server_steam_id() {
  server_steam_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 CMsgClientToGCRequestSteamDatagramTicket::server_steam_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgClientToGCRequestSteamDatagramTicket.server_steam_id)
  return server_steam_id_;
}
inline void CMsgClientToGCRequestSteamDatagramTicket::set_server_steam_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  server_steam_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgClientToGCRequestSteamDatagramTicket.server_steam_id)
}

// -------------------------------------------------------------------

// CMsgClientToGCRequestSteamDatagramTicketResponse

// optional bytes serialized_ticket = 1;
inline bool CMsgClientToGCRequestSteamDatagramTicketResponse::has_serialized_ticket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientToGCRequestSteamDatagramTicketResponse::clear_serialized_ticket() {
  serialized_ticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgClientToGCRequestSteamDatagramTicketResponse::serialized_ticket() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgClientToGCRequestSteamDatagramTicketResponse.serialized_ticket)
  return serialized_ticket_.GetNoArena();
}
inline void CMsgClientToGCRequestSteamDatagramTicketResponse::set_serialized_ticket(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  serialized_ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgClientToGCRequestSteamDatagramTicketResponse.serialized_ticket)
}
#if LANG_CXX11
inline void CMsgClientToGCRequestSteamDatagramTicketResponse::set_serialized_ticket(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  serialized_ticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgClientToGCRequestSteamDatagramTicketResponse.serialized_ticket)
}
#endif
inline void CMsgClientToGCRequestSteamDatagramTicketResponse::set_serialized_ticket(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  serialized_ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgClientToGCRequestSteamDatagramTicketResponse.serialized_ticket)
}
inline void CMsgClientToGCRequestSteamDatagramTicketResponse::set_serialized_ticket(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  serialized_ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgClientToGCRequestSteamDatagramTicketResponse.serialized_ticket)
}
inline ::std::string* CMsgClientToGCRequestSteamDatagramTicketResponse::mutable_serialized_ticket() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgClientToGCRequestSteamDatagramTicketResponse.serialized_ticket)
  return serialized_ticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgClientToGCRequestSteamDatagramTicketResponse::release_serialized_ticket() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgClientToGCRequestSteamDatagramTicketResponse.serialized_ticket)
  if (!has_serialized_ticket()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return serialized_ticket_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgClientToGCRequestSteamDatagramTicketResponse::set_allocated_serialized_ticket(::std::string* serialized_ticket) {
  if (serialized_ticket != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  serialized_ticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serialized_ticket);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgClientToGCRequestSteamDatagramTicketResponse.serialized_ticket)
}

// optional string message = 2;
inline bool CMsgClientToGCRequestSteamDatagramTicketResponse::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientToGCRequestSteamDatagramTicketResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgClientToGCRequestSteamDatagramTicketResponse::message() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgClientToGCRequestSteamDatagramTicketResponse.message)
  return message_.GetNoArena();
}
inline void CMsgClientToGCRequestSteamDatagramTicketResponse::set_message(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgClientToGCRequestSteamDatagramTicketResponse.message)
}
#if LANG_CXX11
inline void CMsgClientToGCRequestSteamDatagramTicketResponse::set_message(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgClientToGCRequestSteamDatagramTicketResponse.message)
}
#endif
inline void CMsgClientToGCRequestSteamDatagramTicketResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgClientToGCRequestSteamDatagramTicketResponse.message)
}
inline void CMsgClientToGCRequestSteamDatagramTicketResponse::set_message(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgClientToGCRequestSteamDatagramTicketResponse.message)
}
inline ::std::string* CMsgClientToGCRequestSteamDatagramTicketResponse::mutable_message() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgClientToGCRequestSteamDatagramTicketResponse.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgClientToGCRequestSteamDatagramTicketResponse::release_message() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgClientToGCRequestSteamDatagramTicketResponse.message)
  if (!has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgClientToGCRequestSteamDatagramTicketResponse::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgClientToGCRequestSteamDatagramTicketResponse.message)
}

// -------------------------------------------------------------------

// CMsgGCToClientSteamDatagramTicket

// optional fixed32 legacy_time_expiry = 1;
inline bool CMsgGCToClientSteamDatagramTicket::has_legacy_time_expiry() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgGCToClientSteamDatagramTicket::clear_legacy_time_expiry() {
  legacy_time_expiry_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgGCToClientSteamDatagramTicket::legacy_time_expiry() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_time_expiry)
  return legacy_time_expiry_;
}
inline void CMsgGCToClientSteamDatagramTicket::set_legacy_time_expiry(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  legacy_time_expiry_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_time_expiry)
}

// optional fixed64 legacy_authorized_steam_id = 2;
inline bool CMsgGCToClientSteamDatagramTicket::has_legacy_authorized_steam_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgGCToClientSteamDatagramTicket::clear_legacy_authorized_steam_id() {
  legacy_authorized_steam_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 CMsgGCToClientSteamDatagramTicket::legacy_authorized_steam_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_authorized_steam_id)
  return legacy_authorized_steam_id_;
}
inline void CMsgGCToClientSteamDatagramTicket::set_legacy_authorized_steam_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  legacy_authorized_steam_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_authorized_steam_id)
}

// optional fixed32 legacy_authorized_public_ip = 3;
inline bool CMsgGCToClientSteamDatagramTicket::has_legacy_authorized_public_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgGCToClientSteamDatagramTicket::clear_legacy_authorized_public_ip() {
  legacy_authorized_public_ip_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgGCToClientSteamDatagramTicket::legacy_authorized_public_ip() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_authorized_public_ip)
  return legacy_authorized_public_ip_;
}
inline void CMsgGCToClientSteamDatagramTicket::set_legacy_authorized_public_ip(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  legacy_authorized_public_ip_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_authorized_public_ip)
}

// optional fixed64 legacy_gameserver_steam_id = 4;
inline bool CMsgGCToClientSteamDatagramTicket::has_legacy_gameserver_steam_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgGCToClientSteamDatagramTicket::clear_legacy_gameserver_steam_id() {
  legacy_gameserver_steam_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint64 CMsgGCToClientSteamDatagramTicket::legacy_gameserver_steam_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_gameserver_steam_id)
  return legacy_gameserver_steam_id_;
}
inline void CMsgGCToClientSteamDatagramTicket::set_legacy_gameserver_steam_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  legacy_gameserver_steam_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_gameserver_steam_id)
}

// optional fixed64 legacy_gameserver_net_id = 5;
inline bool CMsgGCToClientSteamDatagramTicket::has_legacy_gameserver_net_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgGCToClientSteamDatagramTicket::clear_legacy_gameserver_net_id() {
  legacy_gameserver_net_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint64 CMsgGCToClientSteamDatagramTicket::legacy_gameserver_net_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_gameserver_net_id)
  return legacy_gameserver_net_id_;
}
inline void CMsgGCToClientSteamDatagramTicket::set_legacy_gameserver_net_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  legacy_gameserver_net_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_gameserver_net_id)
}

// optional bytes legacy_signature = 6;
inline bool CMsgGCToClientSteamDatagramTicket::has_legacy_signature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgGCToClientSteamDatagramTicket::clear_legacy_signature() {
  legacy_signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgGCToClientSteamDatagramTicket::legacy_signature() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_signature)
  return legacy_signature_.GetNoArena();
}
inline void CMsgGCToClientSteamDatagramTicket::set_legacy_signature(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  legacy_signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_signature)
}
#if LANG_CXX11
inline void CMsgGCToClientSteamDatagramTicket::set_legacy_signature(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  legacy_signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_signature)
}
#endif
inline void CMsgGCToClientSteamDatagramTicket::set_legacy_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  legacy_signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_signature)
}
inline void CMsgGCToClientSteamDatagramTicket::set_legacy_signature(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  legacy_signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_signature)
}
inline ::std::string* CMsgGCToClientSteamDatagramTicket::mutable_legacy_signature() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_signature)
  return legacy_signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgGCToClientSteamDatagramTicket::release_legacy_signature() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_signature)
  if (!has_legacy_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return legacy_signature_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgGCToClientSteamDatagramTicket::set_allocated_legacy_signature(::std::string* legacy_signature) {
  if (legacy_signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  legacy_signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), legacy_signature);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_signature)
}

// optional uint32 legacy_app_id = 7;
inline bool CMsgGCToClientSteamDatagramTicket::has_legacy_app_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgGCToClientSteamDatagramTicket::clear_legacy_app_id() {
  legacy_app_id_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 CMsgGCToClientSteamDatagramTicket::legacy_app_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_app_id)
  return legacy_app_id_;
}
inline void CMsgGCToClientSteamDatagramTicket::set_legacy_app_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  legacy_app_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_app_id)
}

// repeated bytes legacy_extra_fields = 8;
inline int CMsgGCToClientSteamDatagramTicket::legacy_extra_fields_size() const {
  return legacy_extra_fields_.size();
}
inline void CMsgGCToClientSteamDatagramTicket::clear_legacy_extra_fields() {
  legacy_extra_fields_.Clear();
}
inline const ::std::string& CMsgGCToClientSteamDatagramTicket::legacy_extra_fields(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_extra_fields)
  return legacy_extra_fields_.Get(index);
}
inline ::std::string* CMsgGCToClientSteamDatagramTicket::mutable_legacy_extra_fields(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_extra_fields)
  return legacy_extra_fields_.Mutable(index);
}
inline void CMsgGCToClientSteamDatagramTicket::set_legacy_extra_fields(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_extra_fields)
  legacy_extra_fields_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CMsgGCToClientSteamDatagramTicket::set_legacy_extra_fields(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_extra_fields)
  legacy_extra_fields_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CMsgGCToClientSteamDatagramTicket::set_legacy_extra_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  legacy_extra_fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_extra_fields)
}
inline void CMsgGCToClientSteamDatagramTicket::set_legacy_extra_fields(int index, const void* value, size_t size) {
  legacy_extra_fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_extra_fields)
}
inline ::std::string* CMsgGCToClientSteamDatagramTicket::add_legacy_extra_fields() {
  // @@protoc_insertion_point(field_add_mutable:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_extra_fields)
  return legacy_extra_fields_.Add();
}
inline void CMsgGCToClientSteamDatagramTicket::add_legacy_extra_fields(const ::std::string& value) {
  legacy_extra_fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_extra_fields)
}
#if LANG_CXX11
inline void CMsgGCToClientSteamDatagramTicket::add_legacy_extra_fields(::std::string&& value) {
  legacy_extra_fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_extra_fields)
}
#endif
inline void CMsgGCToClientSteamDatagramTicket::add_legacy_extra_fields(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  legacy_extra_fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_extra_fields)
}
inline void CMsgGCToClientSteamDatagramTicket::add_legacy_extra_fields(const void* value, size_t size) {
  legacy_extra_fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_extra_fields)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
CMsgGCToClientSteamDatagramTicket::legacy_extra_fields() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_extra_fields)
  return legacy_extra_fields_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
CMsgGCToClientSteamDatagramTicket::mutable_legacy_extra_fields() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgGCToClientSteamDatagramTicket.legacy_extra_fields)
  return &legacy_extra_fields_;
}

// optional bytes serialized_ticket = 16;
inline bool CMsgGCToClientSteamDatagramTicket::has_serialized_ticket() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgGCToClientSteamDatagramTicket::clear_serialized_ticket() {
  serialized_ticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgGCToClientSteamDatagramTicket::serialized_ticket() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgGCToClientSteamDatagramTicket.serialized_ticket)
  return serialized_ticket_.GetNoArena();
}
inline void CMsgGCToClientSteamDatagramTicket::set_serialized_ticket(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  serialized_ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgGCToClientSteamDatagramTicket.serialized_ticket)
}
#if LANG_CXX11
inline void CMsgGCToClientSteamDatagramTicket::set_serialized_ticket(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  serialized_ticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgGCToClientSteamDatagramTicket.serialized_ticket)
}
#endif
inline void CMsgGCToClientSteamDatagramTicket::set_serialized_ticket(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  serialized_ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgGCToClientSteamDatagramTicket.serialized_ticket)
}
inline void CMsgGCToClientSteamDatagramTicket::set_serialized_ticket(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  serialized_ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgGCToClientSteamDatagramTicket.serialized_ticket)
}
inline ::std::string* CMsgGCToClientSteamDatagramTicket::mutable_serialized_ticket() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgGCToClientSteamDatagramTicket.serialized_ticket)
  return serialized_ticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgGCToClientSteamDatagramTicket::release_serialized_ticket() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgGCToClientSteamDatagramTicket.serialized_ticket)
  if (!has_serialized_ticket()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return serialized_ticket_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgGCToClientSteamDatagramTicket::set_allocated_serialized_ticket(::std::string* serialized_ticket) {
  if (serialized_ticket != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  serialized_ticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serialized_ticket);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgGCToClientSteamDatagramTicket.serialized_ticket)
}

// -------------------------------------------------------------------

// CMsgGCToClientRequestLaneSelection

// -------------------------------------------------------------------

// CMsgGCToClientRequestLaneSelectionResponse

// optional uint32 lane_selection_flags = 1;
inline bool CMsgGCToClientRequestLaneSelectionResponse::has_lane_selection_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgGCToClientRequestLaneSelectionResponse::clear_lane_selection_flags() {
  lane_selection_flags_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgGCToClientRequestLaneSelectionResponse::lane_selection_flags() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgGCToClientRequestLaneSelectionResponse.lane_selection_flags)
  return lane_selection_flags_;
}
inline void CMsgGCToClientRequestLaneSelectionResponse::set_lane_selection_flags(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  lane_selection_flags_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgGCToClientRequestLaneSelectionResponse.lane_selection_flags)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace dota
}  // namespace proto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::proto::dota::EStartFindingMatchResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::EStartFindingMatchResult>() {
  return ::proto::dota::EStartFindingMatchResult_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_dota_5fgcmessages_5fclient_5fmatch_5fmanagement_2eproto
