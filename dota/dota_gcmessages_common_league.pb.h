// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dota_gcmessages_common_league.proto

#ifndef PROTOBUF_INCLUDED_dota_5fgcmessages_5fcommon_5fleague_2eproto
#define PROTOBUF_INCLUDED_dota_5fgcmessages_5fcommon_5fleague_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "dota_shared_enums.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_dota_5fgcmessages_5fcommon_5fleague_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[27]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_dota_5fgcmessages_5fcommon_5fleague_2eproto();
namespace proto {
namespace dota {
class CMsgDOTALeague;
class CMsgDOTALeagueDefaultTypeInternal;
extern CMsgDOTALeagueDefaultTypeInternal _CMsgDOTALeague_default_instance_;
class CMsgDOTALeagueAvailableLobbyNodes;
class CMsgDOTALeagueAvailableLobbyNodesDefaultTypeInternal;
extern CMsgDOTALeagueAvailableLobbyNodesDefaultTypeInternal _CMsgDOTALeagueAvailableLobbyNodes_default_instance_;
class CMsgDOTALeagueAvailableLobbyNodesRequest;
class CMsgDOTALeagueAvailableLobbyNodesRequestDefaultTypeInternal;
extern CMsgDOTALeagueAvailableLobbyNodesRequestDefaultTypeInternal _CMsgDOTALeagueAvailableLobbyNodesRequest_default_instance_;
class CMsgDOTALeagueAvailableLobbyNodes_NodeInfo;
class CMsgDOTALeagueAvailableLobbyNodes_NodeInfoDefaultTypeInternal;
extern CMsgDOTALeagueAvailableLobbyNodes_NodeInfoDefaultTypeInternal _CMsgDOTALeagueAvailableLobbyNodes_NodeInfo_default_instance_;
class CMsgDOTALeagueInfo;
class CMsgDOTALeagueInfoDefaultTypeInternal;
extern CMsgDOTALeagueInfoDefaultTypeInternal _CMsgDOTALeagueInfo_default_instance_;
class CMsgDOTALeagueInfoList;
class CMsgDOTALeagueInfoListDefaultTypeInternal;
extern CMsgDOTALeagueInfoListDefaultTypeInternal _CMsgDOTALeagueInfoList_default_instance_;
class CMsgDOTALeagueInfoListAdminsRequest;
class CMsgDOTALeagueInfoListAdminsRequestDefaultTypeInternal;
extern CMsgDOTALeagueInfoListAdminsRequestDefaultTypeInternal _CMsgDOTALeagueInfoListAdminsRequest_default_instance_;
class CMsgDOTALeagueLiveGames;
class CMsgDOTALeagueLiveGamesDefaultTypeInternal;
extern CMsgDOTALeagueLiveGamesDefaultTypeInternal _CMsgDOTALeagueLiveGames_default_instance_;
class CMsgDOTALeagueLiveGames_LiveGame;
class CMsgDOTALeagueLiveGames_LiveGameDefaultTypeInternal;
extern CMsgDOTALeagueLiveGames_LiveGameDefaultTypeInternal _CMsgDOTALeagueLiveGames_LiveGame_default_instance_;
class CMsgDOTALeagueMessages;
class CMsgDOTALeagueMessagesDefaultTypeInternal;
extern CMsgDOTALeagueMessagesDefaultTypeInternal _CMsgDOTALeagueMessages_default_instance_;
class CMsgDOTALeagueMessages_Message;
class CMsgDOTALeagueMessages_MessageDefaultTypeInternal;
extern CMsgDOTALeagueMessages_MessageDefaultTypeInternal _CMsgDOTALeagueMessages_Message_default_instance_;
class CMsgDOTALeagueNode;
class CMsgDOTALeagueNodeDefaultTypeInternal;
extern CMsgDOTALeagueNodeDefaultTypeInternal _CMsgDOTALeagueNode_default_instance_;
class CMsgDOTALeagueNodeGroup;
class CMsgDOTALeagueNodeGroupDefaultTypeInternal;
extern CMsgDOTALeagueNodeGroupDefaultTypeInternal _CMsgDOTALeagueNodeGroup_default_instance_;
class CMsgDOTALeagueNodeGroup_TeamStanding;
class CMsgDOTALeagueNodeGroup_TeamStandingDefaultTypeInternal;
extern CMsgDOTALeagueNodeGroup_TeamStandingDefaultTypeInternal _CMsgDOTALeagueNodeGroup_TeamStanding_default_instance_;
class CMsgDOTALeagueNodeRequest;
class CMsgDOTALeagueNodeRequestDefaultTypeInternal;
extern CMsgDOTALeagueNodeRequestDefaultTypeInternal _CMsgDOTALeagueNodeRequest_default_instance_;
class CMsgDOTALeagueNodeResponse;
class CMsgDOTALeagueNodeResponseDefaultTypeInternal;
extern CMsgDOTALeagueNodeResponseDefaultTypeInternal _CMsgDOTALeagueNodeResponse_default_instance_;
class CMsgDOTALeagueNodeResults;
class CMsgDOTALeagueNodeResultsDefaultTypeInternal;
extern CMsgDOTALeagueNodeResultsDefaultTypeInternal _CMsgDOTALeagueNodeResults_default_instance_;
class CMsgDOTALeagueNodeResults_Result;
class CMsgDOTALeagueNodeResults_ResultDefaultTypeInternal;
extern CMsgDOTALeagueNodeResults_ResultDefaultTypeInternal _CMsgDOTALeagueNodeResults_Result_default_instance_;
class CMsgDOTALeagueNode_MatchDetails;
class CMsgDOTALeagueNode_MatchDetailsDefaultTypeInternal;
extern CMsgDOTALeagueNode_MatchDetailsDefaultTypeInternal _CMsgDOTALeagueNode_MatchDetails_default_instance_;
class CMsgDOTALeaguePrizePool;
class CMsgDOTALeaguePrizePoolDefaultTypeInternal;
extern CMsgDOTALeaguePrizePoolDefaultTypeInternal _CMsgDOTALeaguePrizePool_default_instance_;
class CMsgDOTALeague_Admin;
class CMsgDOTALeague_AdminDefaultTypeInternal;
extern CMsgDOTALeague_AdminDefaultTypeInternal _CMsgDOTALeague_Admin_default_instance_;
class CMsgDOTALeague_Info;
class CMsgDOTALeague_InfoDefaultTypeInternal;
extern CMsgDOTALeague_InfoDefaultTypeInternal _CMsgDOTALeague_Info_default_instance_;
class CMsgDOTALeague_Player;
class CMsgDOTALeague_PlayerDefaultTypeInternal;
extern CMsgDOTALeague_PlayerDefaultTypeInternal _CMsgDOTALeague_Player_default_instance_;
class CMsgDOTALeague_PrizePool;
class CMsgDOTALeague_PrizePoolDefaultTypeInternal;
extern CMsgDOTALeague_PrizePoolDefaultTypeInternal _CMsgDOTALeague_PrizePool_default_instance_;
class CMsgDOTALeague_PrizePoolItem;
class CMsgDOTALeague_PrizePoolItemDefaultTypeInternal;
extern CMsgDOTALeague_PrizePoolItemDefaultTypeInternal _CMsgDOTALeague_PrizePoolItem_default_instance_;
class CMsgDOTALeague_SeriesInfo;
class CMsgDOTALeague_SeriesInfoDefaultTypeInternal;
extern CMsgDOTALeague_SeriesInfoDefaultTypeInternal _CMsgDOTALeague_SeriesInfo_default_instance_;
class CMsgDOTALeague_Stream;
class CMsgDOTALeague_StreamDefaultTypeInternal;
extern CMsgDOTALeague_StreamDefaultTypeInternal _CMsgDOTALeague_Stream_default_instance_;
}  // namespace dota
}  // namespace proto
namespace google {
namespace protobuf {
template<> ::proto::dota::CMsgDOTALeague* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeague>(Arena*);
template<> ::proto::dota::CMsgDOTALeagueAvailableLobbyNodes* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeagueAvailableLobbyNodes>(Arena*);
template<> ::proto::dota::CMsgDOTALeagueAvailableLobbyNodesRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeagueAvailableLobbyNodesRequest>(Arena*);
template<> ::proto::dota::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo>(Arena*);
template<> ::proto::dota::CMsgDOTALeagueInfo* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeagueInfo>(Arena*);
template<> ::proto::dota::CMsgDOTALeagueInfoList* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeagueInfoList>(Arena*);
template<> ::proto::dota::CMsgDOTALeagueInfoListAdminsRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeagueInfoListAdminsRequest>(Arena*);
template<> ::proto::dota::CMsgDOTALeagueLiveGames* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeagueLiveGames>(Arena*);
template<> ::proto::dota::CMsgDOTALeagueLiveGames_LiveGame* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeagueLiveGames_LiveGame>(Arena*);
template<> ::proto::dota::CMsgDOTALeagueMessages* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeagueMessages>(Arena*);
template<> ::proto::dota::CMsgDOTALeagueMessages_Message* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeagueMessages_Message>(Arena*);
template<> ::proto::dota::CMsgDOTALeagueNode* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeagueNode>(Arena*);
template<> ::proto::dota::CMsgDOTALeagueNodeGroup* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeagueNodeGroup>(Arena*);
template<> ::proto::dota::CMsgDOTALeagueNodeGroup_TeamStanding* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeagueNodeGroup_TeamStanding>(Arena*);
template<> ::proto::dota::CMsgDOTALeagueNodeRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeagueNodeRequest>(Arena*);
template<> ::proto::dota::CMsgDOTALeagueNodeResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeagueNodeResponse>(Arena*);
template<> ::proto::dota::CMsgDOTALeagueNodeResults* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeagueNodeResults>(Arena*);
template<> ::proto::dota::CMsgDOTALeagueNodeResults_Result* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeagueNodeResults_Result>(Arena*);
template<> ::proto::dota::CMsgDOTALeagueNode_MatchDetails* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeagueNode_MatchDetails>(Arena*);
template<> ::proto::dota::CMsgDOTALeaguePrizePool* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeaguePrizePool>(Arena*);
template<> ::proto::dota::CMsgDOTALeague_Admin* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeague_Admin>(Arena*);
template<> ::proto::dota::CMsgDOTALeague_Info* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeague_Info>(Arena*);
template<> ::proto::dota::CMsgDOTALeague_Player* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeague_Player>(Arena*);
template<> ::proto::dota::CMsgDOTALeague_PrizePool* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeague_PrizePool>(Arena*);
template<> ::proto::dota::CMsgDOTALeague_PrizePoolItem* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeague_PrizePoolItem>(Arena*);
template<> ::proto::dota::CMsgDOTALeague_SeriesInfo* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeague_SeriesInfo>(Arena*);
template<> ::proto::dota::CMsgDOTALeague_Stream* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeague_Stream>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace proto {
namespace dota {

enum ELeagueNodeGroupType {
  INVALID_GROUP_TYPE = 0,
  ORGANIZATIONAL = 1,
  ROUND_ROBIN = 2,
  SWISS = 3,
  BRACKET_SINGLE = 4,
  BRACKET_DOUBLE_SEED_LOSER = 5,
  BRACKET_DOUBLE_ALL_WINNER = 6,
  SHOWMATCH = 7,
  GSL = 8
};
bool ELeagueNodeGroupType_IsValid(int value);
const ELeagueNodeGroupType ELeagueNodeGroupType_MIN = INVALID_GROUP_TYPE;
const ELeagueNodeGroupType ELeagueNodeGroupType_MAX = GSL;
const int ELeagueNodeGroupType_ARRAYSIZE = ELeagueNodeGroupType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ELeagueNodeGroupType_descriptor();
inline const ::std::string& ELeagueNodeGroupType_Name(ELeagueNodeGroupType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ELeagueNodeGroupType_descriptor(), value);
}
inline bool ELeagueNodeGroupType_Parse(
    const ::std::string& name, ELeagueNodeGroupType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ELeagueNodeGroupType>(
    ELeagueNodeGroupType_descriptor(), name, value);
}
enum ELeagueNodeType {
  INVALID_NODE_TYPE = 0,
  BEST_OF_ONE = 1,
  BEST_OF_THREE = 2,
  BEST_OF_FIVE = 3,
  BEST_OF_TWO = 4
};
bool ELeagueNodeType_IsValid(int value);
const ELeagueNodeType ELeagueNodeType_MIN = INVALID_NODE_TYPE;
const ELeagueNodeType ELeagueNodeType_MAX = BEST_OF_TWO;
const int ELeagueNodeType_ARRAYSIZE = ELeagueNodeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ELeagueNodeType_descriptor();
inline const ::std::string& ELeagueNodeType_Name(ELeagueNodeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ELeagueNodeType_descriptor(), value);
}
inline bool ELeagueNodeType_Parse(
    const ::std::string& name, ELeagueNodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ELeagueNodeType>(
    ELeagueNodeType_descriptor(), name, value);
}
// ===================================================================

class CMsgDOTALeagueNode_MatchDetails final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeagueNode.MatchDetails) */ {
 public:
  CMsgDOTALeagueNode_MatchDetails();
  virtual ~CMsgDOTALeagueNode_MatchDetails();

  CMsgDOTALeagueNode_MatchDetails(const CMsgDOTALeagueNode_MatchDetails& from);

  inline CMsgDOTALeagueNode_MatchDetails& operator=(const CMsgDOTALeagueNode_MatchDetails& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeagueNode_MatchDetails(CMsgDOTALeagueNode_MatchDetails&& from) noexcept
    : CMsgDOTALeagueNode_MatchDetails() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueNode_MatchDetails& operator=(CMsgDOTALeagueNode_MatchDetails&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeagueNode_MatchDetails& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeagueNode_MatchDetails* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueNode_MatchDetails*>(
               &_CMsgDOTALeagueNode_MatchDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CMsgDOTALeagueNode_MatchDetails* other);
  friend void swap(CMsgDOTALeagueNode_MatchDetails& a, CMsgDOTALeagueNode_MatchDetails& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeagueNode_MatchDetails* New() const final {
    return CreateMaybeMessage<CMsgDOTALeagueNode_MatchDetails>(nullptr);
  }

  CMsgDOTALeagueNode_MatchDetails* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeagueNode_MatchDetails>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeagueNode_MatchDetails& from);
  void MergeFrom(const CMsgDOTALeagueNode_MatchDetails& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueNode_MatchDetails* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 match_id = 1;
  bool has_match_id() const;
  void clear_match_id();
  static const int kMatchIdFieldNumber = 1;
  ::google::protobuf::uint64 match_id() const;
  void set_match_id(::google::protobuf::uint64 value);

  // optional uint32 winning_team_id = 2;
  bool has_winning_team_id() const;
  void clear_winning_team_id();
  static const int kWinningTeamIdFieldNumber = 2;
  ::google::protobuf::uint32 winning_team_id() const;
  void set_winning_team_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeagueNode.MatchDetails)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 match_id_;
  ::google::protobuf::uint32 winning_team_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueNode final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeagueNode) */ {
 public:
  CMsgDOTALeagueNode();
  virtual ~CMsgDOTALeagueNode();

  CMsgDOTALeagueNode(const CMsgDOTALeagueNode& from);

  inline CMsgDOTALeagueNode& operator=(const CMsgDOTALeagueNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeagueNode(CMsgDOTALeagueNode&& from) noexcept
    : CMsgDOTALeagueNode() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueNode& operator=(CMsgDOTALeagueNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeagueNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeagueNode* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueNode*>(
               &_CMsgDOTALeagueNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(CMsgDOTALeagueNode* other);
  friend void swap(CMsgDOTALeagueNode& a, CMsgDOTALeagueNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeagueNode* New() const final {
    return CreateMaybeMessage<CMsgDOTALeagueNode>(nullptr);
  }

  CMsgDOTALeagueNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeagueNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeagueNode& from);
  void MergeFrom(const CMsgDOTALeagueNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTALeagueNode_MatchDetails MatchDetails;

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTALeagueNode.MatchDetails matches = 13;
  int matches_size() const;
  void clear_matches();
  static const int kMatchesFieldNumber = 13;
  ::proto::dota::CMsgDOTALeagueNode_MatchDetails* mutable_matches(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNode_MatchDetails >*
      mutable_matches();
  const ::proto::dota::CMsgDOTALeagueNode_MatchDetails& matches(int index) const;
  ::proto::dota::CMsgDOTALeagueNode_MatchDetails* add_matches();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNode_MatchDetails >&
      matches() const;

  // repeated uint32 stream_ids = 18;
  int stream_ids_size() const;
  void clear_stream_ids();
  static const int kStreamIdsFieldNumber = 18;
  ::google::protobuf::uint32 stream_ids(int index) const;
  void set_stream_ids(int index, ::google::protobuf::uint32 value);
  void add_stream_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      stream_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_stream_ids();

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint32 node_id = 2;
  bool has_node_id() const;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  ::google::protobuf::uint32 node_id() const;
  void set_node_id(::google::protobuf::uint32 value);

  // optional uint32 node_group_id = 3;
  bool has_node_group_id() const;
  void clear_node_group_id();
  static const int kNodeGroupIdFieldNumber = 3;
  ::google::protobuf::uint32 node_group_id() const;
  void set_node_group_id(::google::protobuf::uint32 value);

  // optional uint32 winning_node_id = 4;
  bool has_winning_node_id() const;
  void clear_winning_node_id();
  static const int kWinningNodeIdFieldNumber = 4;
  ::google::protobuf::uint32 winning_node_id() const;
  void set_winning_node_id(::google::protobuf::uint32 value);

  // optional uint32 losing_node_id = 5;
  bool has_losing_node_id() const;
  void clear_losing_node_id();
  static const int kLosingNodeIdFieldNumber = 5;
  ::google::protobuf::uint32 losing_node_id() const;
  void set_losing_node_id(::google::protobuf::uint32 value);

  // optional uint32 incoming_node_id_1 = 6;
  bool has_incoming_node_id_1() const;
  void clear_incoming_node_id_1();
  static const int kIncomingNodeId1FieldNumber = 6;
  ::google::protobuf::uint32 incoming_node_id_1() const;
  void set_incoming_node_id_1(::google::protobuf::uint32 value);

  // optional uint32 incoming_node_id_2 = 7;
  bool has_incoming_node_id_2() const;
  void clear_incoming_node_id_2();
  static const int kIncomingNodeId2FieldNumber = 7;
  ::google::protobuf::uint32 incoming_node_id_2() const;
  void set_incoming_node_id_2(::google::protobuf::uint32 value);

  // optional .proto.dota.ELeagueNodeType node_type = 8 [default = INVALID_NODE_TYPE];
  bool has_node_type() const;
  void clear_node_type();
  static const int kNodeTypeFieldNumber = 8;
  ::proto::dota::ELeagueNodeType node_type() const;
  void set_node_type(::proto::dota::ELeagueNodeType value);

  // optional uint32 scheduled_time = 9;
  bool has_scheduled_time() const;
  void clear_scheduled_time();
  static const int kScheduledTimeFieldNumber = 9;
  ::google::protobuf::uint32 scheduled_time() const;
  void set_scheduled_time(::google::protobuf::uint32 value);

  // optional uint32 series_id = 10;
  bool has_series_id() const;
  void clear_series_id();
  static const int kSeriesIdFieldNumber = 10;
  ::google::protobuf::uint32 series_id() const;
  void set_series_id(::google::protobuf::uint32 value);

  // optional uint32 team_id_1 = 11;
  bool has_team_id_1() const;
  void clear_team_id_1();
  static const int kTeamId1FieldNumber = 11;
  ::google::protobuf::uint32 team_id_1() const;
  void set_team_id_1(::google::protobuf::uint32 value);

  // optional uint32 team_id_2 = 12;
  bool has_team_id_2() const;
  void clear_team_id_2();
  static const int kTeamId2FieldNumber = 12;
  ::google::protobuf::uint32 team_id_2() const;
  void set_team_id_2(::google::protobuf::uint32 value);

  // optional uint32 team_1_wins = 14;
  bool has_team_1_wins() const;
  void clear_team_1_wins();
  static const int kTeam1WinsFieldNumber = 14;
  ::google::protobuf::uint32 team_1_wins() const;
  void set_team_1_wins(::google::protobuf::uint32 value);

  // optional uint32 team_2_wins = 15;
  bool has_team_2_wins() const;
  void clear_team_2_wins();
  static const int kTeam2WinsFieldNumber = 15;
  ::google::protobuf::uint32 team_2_wins() const;
  void set_team_2_wins(::google::protobuf::uint32 value);

  // optional bool has_started = 16;
  bool has_has_started() const;
  void clear_has_started();
  static const int kHasStartedFieldNumber = 16;
  bool has_started() const;
  void set_has_started(bool value);

  // optional bool is_completed = 17;
  bool has_is_completed() const;
  void clear_is_completed();
  static const int kIsCompletedFieldNumber = 17;
  bool is_completed() const;
  void set_is_completed(bool value);

  // optional uint32 actual_time = 19;
  bool has_actual_time() const;
  void clear_actual_time();
  static const int kActualTimeFieldNumber = 19;
  ::google::protobuf::uint32 actual_time() const;
  void set_actual_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeagueNode)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNode_MatchDetails > matches_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > stream_ids_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 node_id_;
  ::google::protobuf::uint32 node_group_id_;
  ::google::protobuf::uint32 winning_node_id_;
  ::google::protobuf::uint32 losing_node_id_;
  ::google::protobuf::uint32 incoming_node_id_1_;
  ::google::protobuf::uint32 incoming_node_id_2_;
  int node_type_;
  ::google::protobuf::uint32 scheduled_time_;
  ::google::protobuf::uint32 series_id_;
  ::google::protobuf::uint32 team_id_1_;
  ::google::protobuf::uint32 team_id_2_;
  ::google::protobuf::uint32 team_1_wins_;
  ::google::protobuf::uint32 team_2_wins_;
  bool has_started_;
  bool is_completed_;
  ::google::protobuf::uint32 actual_time_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueNodeGroup_TeamStanding final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding) */ {
 public:
  CMsgDOTALeagueNodeGroup_TeamStanding();
  virtual ~CMsgDOTALeagueNodeGroup_TeamStanding();

  CMsgDOTALeagueNodeGroup_TeamStanding(const CMsgDOTALeagueNodeGroup_TeamStanding& from);

  inline CMsgDOTALeagueNodeGroup_TeamStanding& operator=(const CMsgDOTALeagueNodeGroup_TeamStanding& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeagueNodeGroup_TeamStanding(CMsgDOTALeagueNodeGroup_TeamStanding&& from) noexcept
    : CMsgDOTALeagueNodeGroup_TeamStanding() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueNodeGroup_TeamStanding& operator=(CMsgDOTALeagueNodeGroup_TeamStanding&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeagueNodeGroup_TeamStanding& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeagueNodeGroup_TeamStanding* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueNodeGroup_TeamStanding*>(
               &_CMsgDOTALeagueNodeGroup_TeamStanding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(CMsgDOTALeagueNodeGroup_TeamStanding* other);
  friend void swap(CMsgDOTALeagueNodeGroup_TeamStanding& a, CMsgDOTALeagueNodeGroup_TeamStanding& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeagueNodeGroup_TeamStanding* New() const final {
    return CreateMaybeMessage<CMsgDOTALeagueNodeGroup_TeamStanding>(nullptr);
  }

  CMsgDOTALeagueNodeGroup_TeamStanding* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeagueNodeGroup_TeamStanding>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeagueNodeGroup_TeamStanding& from);
  void MergeFrom(const CMsgDOTALeagueNodeGroup_TeamStanding& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueNodeGroup_TeamStanding* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string team_name = 3;
  bool has_team_name() const;
  void clear_team_name();
  static const int kTeamNameFieldNumber = 3;
  const ::std::string& team_name() const;
  void set_team_name(const ::std::string& value);
  #if LANG_CXX11
  void set_team_name(::std::string&& value);
  #endif
  void set_team_name(const char* value);
  void set_team_name(const char* value, size_t size);
  ::std::string* mutable_team_name();
  ::std::string* release_team_name();
  void set_allocated_team_name(::std::string* team_name);

  // optional string team_tag = 4;
  bool has_team_tag() const;
  void clear_team_tag();
  static const int kTeamTagFieldNumber = 4;
  const ::std::string& team_tag() const;
  void set_team_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_team_tag(::std::string&& value);
  #endif
  void set_team_tag(const char* value);
  void set_team_tag(const char* value, size_t size);
  ::std::string* mutable_team_tag();
  ::std::string* release_team_tag();
  void set_allocated_team_tag(::std::string* team_tag);

  // optional string team_logo_url = 6;
  bool has_team_logo_url() const;
  void clear_team_logo_url();
  static const int kTeamLogoUrlFieldNumber = 6;
  const ::std::string& team_logo_url() const;
  void set_team_logo_url(const ::std::string& value);
  #if LANG_CXX11
  void set_team_logo_url(::std::string&& value);
  #endif
  void set_team_logo_url(const char* value);
  void set_team_logo_url(const char* value, size_t size);
  ::std::string* mutable_team_logo_url();
  ::std::string* release_team_logo_url();
  void set_allocated_team_logo_url(::std::string* team_logo_url);

  // optional uint32 standing = 1;
  bool has_standing() const;
  void clear_standing();
  static const int kStandingFieldNumber = 1;
  ::google::protobuf::uint32 standing() const;
  void set_standing(::google::protobuf::uint32 value);

  // optional uint32 team_id = 2;
  bool has_team_id() const;
  void clear_team_id();
  static const int kTeamIdFieldNumber = 2;
  ::google::protobuf::uint32 team_id() const;
  void set_team_id(::google::protobuf::uint32 value);

  // optional uint64 team_logo = 5;
  bool has_team_logo() const;
  void clear_team_logo();
  static const int kTeamLogoFieldNumber = 5;
  ::google::protobuf::uint64 team_logo() const;
  void set_team_logo(::google::protobuf::uint64 value);

  // optional uint32 wins = 7;
  bool has_wins() const;
  void clear_wins();
  static const int kWinsFieldNumber = 7;
  ::google::protobuf::uint32 wins() const;
  void set_wins(::google::protobuf::uint32 value);

  // optional uint32 losses = 8;
  bool has_losses() const;
  void clear_losses();
  static const int kLossesFieldNumber = 8;
  ::google::protobuf::uint32 losses() const;
  void set_losses(::google::protobuf::uint32 value);

  // optional int64 score = 9;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 9;
  ::google::protobuf::int64 score() const;
  void set_score(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr team_name_;
  ::google::protobuf::internal::ArenaStringPtr team_tag_;
  ::google::protobuf::internal::ArenaStringPtr team_logo_url_;
  ::google::protobuf::uint32 standing_;
  ::google::protobuf::uint32 team_id_;
  ::google::protobuf::uint64 team_logo_;
  ::google::protobuf::uint32 wins_;
  ::google::protobuf::uint32 losses_;
  ::google::protobuf::int64 score_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueNodeGroup final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeagueNodeGroup) */ {
 public:
  CMsgDOTALeagueNodeGroup();
  virtual ~CMsgDOTALeagueNodeGroup();

  CMsgDOTALeagueNodeGroup(const CMsgDOTALeagueNodeGroup& from);

  inline CMsgDOTALeagueNodeGroup& operator=(const CMsgDOTALeagueNodeGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeagueNodeGroup(CMsgDOTALeagueNodeGroup&& from) noexcept
    : CMsgDOTALeagueNodeGroup() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueNodeGroup& operator=(CMsgDOTALeagueNodeGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeagueNodeGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeagueNodeGroup* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueNodeGroup*>(
               &_CMsgDOTALeagueNodeGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(CMsgDOTALeagueNodeGroup* other);
  friend void swap(CMsgDOTALeagueNodeGroup& a, CMsgDOTALeagueNodeGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeagueNodeGroup* New() const final {
    return CreateMaybeMessage<CMsgDOTALeagueNodeGroup>(nullptr);
  }

  CMsgDOTALeagueNodeGroup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeagueNodeGroup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeagueNodeGroup& from);
  void MergeFrom(const CMsgDOTALeagueNodeGroup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueNodeGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTALeagueNodeGroup_TeamStanding TeamStanding;

  // accessors -------------------------------------------------------

  // repeated uint32 incoming_node_group_ids = 4;
  int incoming_node_group_ids_size() const;
  void clear_incoming_node_group_ids();
  static const int kIncomingNodeGroupIdsFieldNumber = 4;
  ::google::protobuf::uint32 incoming_node_group_ids(int index) const;
  void set_incoming_node_group_ids(int index, ::google::protobuf::uint32 value);
  void add_incoming_node_group_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      incoming_node_group_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_incoming_node_group_ids();

  // repeated .proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding team_standings = 15;
  int team_standings_size() const;
  void clear_team_standings();
  static const int kTeamStandingsFieldNumber = 15;
  ::proto::dota::CMsgDOTALeagueNodeGroup_TeamStanding* mutable_team_standings(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNodeGroup_TeamStanding >*
      mutable_team_standings();
  const ::proto::dota::CMsgDOTALeagueNodeGroup_TeamStanding& team_standings(int index) const;
  ::proto::dota::CMsgDOTALeagueNodeGroup_TeamStanding* add_team_standings();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNodeGroup_TeamStanding >&
      team_standings() const;

  // repeated .proto.dota.CMsgDOTALeagueNode nodes = 16;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 16;
  ::proto::dota::CMsgDOTALeagueNode* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNode >*
      mutable_nodes();
  const ::proto::dota::CMsgDOTALeagueNode& nodes(int index) const;
  ::proto::dota::CMsgDOTALeagueNode* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNode >&
      nodes() const;

  // repeated .proto.dota.CMsgDOTALeagueNodeGroup node_groups = 17;
  int node_groups_size() const;
  void clear_node_groups();
  static const int kNodeGroupsFieldNumber = 17;
  ::proto::dota::CMsgDOTALeagueNodeGroup* mutable_node_groups(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNodeGroup >*
      mutable_node_groups();
  const ::proto::dota::CMsgDOTALeagueNodeGroup& node_groups(int index) const;
  ::proto::dota::CMsgDOTALeagueNodeGroup* add_node_groups();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNodeGroup >&
      node_groups() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint32 node_group_id = 2;
  bool has_node_group_id() const;
  void clear_node_group_id();
  static const int kNodeGroupIdFieldNumber = 2;
  ::google::protobuf::uint32 node_group_id() const;
  void set_node_group_id(::google::protobuf::uint32 value);

  // optional uint32 parent_node_group_id = 3;
  bool has_parent_node_group_id() const;
  void clear_parent_node_group_id();
  static const int kParentNodeGroupIdFieldNumber = 3;
  ::google::protobuf::uint32 parent_node_group_id() const;
  void set_parent_node_group_id(::google::protobuf::uint32 value);

  // optional uint32 advancing_node_group_id = 5;
  bool has_advancing_node_group_id() const;
  void clear_advancing_node_group_id();
  static const int kAdvancingNodeGroupIdFieldNumber = 5;
  ::google::protobuf::uint32 advancing_node_group_id() const;
  void set_advancing_node_group_id(::google::protobuf::uint32 value);

  // optional uint32 advancing_team_count = 6;
  bool has_advancing_team_count() const;
  void clear_advancing_team_count();
  static const int kAdvancingTeamCountFieldNumber = 6;
  ::google::protobuf::uint32 advancing_team_count() const;
  void set_advancing_team_count(::google::protobuf::uint32 value);

  // optional uint32 team_count = 7;
  bool has_team_count() const;
  void clear_team_count();
  static const int kTeamCountFieldNumber = 7;
  ::google::protobuf::uint32 team_count() const;
  void set_team_count(::google::protobuf::uint32 value);

  // optional .proto.dota.ELeagueNodeGroupType node_group_type = 8 [default = INVALID_GROUP_TYPE];
  bool has_node_group_type() const;
  void clear_node_group_type();
  static const int kNodeGroupTypeFieldNumber = 8;
  ::proto::dota::ELeagueNodeGroupType node_group_type() const;
  void set_node_group_type(::proto::dota::ELeagueNodeGroupType value);

  // optional .proto.dota.ELeagueNodeType default_node_type = 9 [default = INVALID_NODE_TYPE];
  bool has_default_node_type() const;
  void clear_default_node_type();
  static const int kDefaultNodeTypeFieldNumber = 9;
  ::proto::dota::ELeagueNodeType default_node_type() const;
  void set_default_node_type(::proto::dota::ELeagueNodeType value);

  // optional uint32 round = 10;
  bool has_round() const;
  void clear_round();
  static const int kRoundFieldNumber = 10;
  ::google::protobuf::uint32 round() const;
  void set_round(::google::protobuf::uint32 value);

  // optional uint32 max_rounds = 11;
  bool has_max_rounds() const;
  void clear_max_rounds();
  static const int kMaxRoundsFieldNumber = 11;
  ::google::protobuf::uint32 max_rounds() const;
  void set_max_rounds(::google::protobuf::uint32 value);

  // optional bool is_tiebreaker = 12;
  bool has_is_tiebreaker() const;
  void clear_is_tiebreaker();
  static const int kIsTiebreakerFieldNumber = 12;
  bool is_tiebreaker() const;
  void set_is_tiebreaker(bool value);

  // optional bool is_final_group = 13;
  bool has_is_final_group() const;
  void clear_is_final_group();
  static const int kIsFinalGroupFieldNumber = 13;
  bool is_final_group() const;
  void set_is_final_group(bool value);

  // optional bool is_completed = 14;
  bool has_is_completed() const;
  void clear_is_completed();
  static const int kIsCompletedFieldNumber = 14;
  bool is_completed() const;
  void set_is_completed(bool value);

  // optional .proto.dota.ELeaguePhase phase = 18 [default = LEAGUE_PHASE_UNSET];
  bool has_phase() const;
  void clear_phase();
  static const int kPhaseFieldNumber = 18;
  ::proto::dota::ELeaguePhase phase() const;
  void set_phase(::proto::dota::ELeaguePhase value);

  // optional .proto.dota.ELeagueRegion region = 19 [default = LEAGUE_REGION_UNSET];
  bool has_region() const;
  void clear_region();
  static const int kRegionFieldNumber = 19;
  ::proto::dota::ELeagueRegion region() const;
  void set_region(::proto::dota::ELeagueRegion value);

  // optional uint32 start_time = 20;
  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 20;
  ::google::protobuf::uint32 start_time() const;
  void set_start_time(::google::protobuf::uint32 value);

  // optional uint32 end_time = 21;
  bool has_end_time() const;
  void clear_end_time();
  static const int kEndTimeFieldNumber = 21;
  ::google::protobuf::uint32 end_time() const;
  void set_end_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeagueNodeGroup)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > incoming_node_group_ids_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNodeGroup_TeamStanding > team_standings_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNode > nodes_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNodeGroup > node_groups_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 node_group_id_;
  ::google::protobuf::uint32 parent_node_group_id_;
  ::google::protobuf::uint32 advancing_node_group_id_;
  ::google::protobuf::uint32 advancing_team_count_;
  ::google::protobuf::uint32 team_count_;
  int node_group_type_;
  int default_node_type_;
  ::google::protobuf::uint32 round_;
  ::google::protobuf::uint32 max_rounds_;
  bool is_tiebreaker_;
  bool is_final_group_;
  bool is_completed_;
  int phase_;
  int region_;
  ::google::protobuf::uint32 start_time_;
  ::google::protobuf::uint32 end_time_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeague_Info final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeague.Info) */ {
 public:
  CMsgDOTALeague_Info();
  virtual ~CMsgDOTALeague_Info();

  CMsgDOTALeague_Info(const CMsgDOTALeague_Info& from);

  inline CMsgDOTALeague_Info& operator=(const CMsgDOTALeague_Info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeague_Info(CMsgDOTALeague_Info&& from) noexcept
    : CMsgDOTALeague_Info() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeague_Info& operator=(CMsgDOTALeague_Info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeague_Info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeague_Info* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeague_Info*>(
               &_CMsgDOTALeague_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(CMsgDOTALeague_Info* other);
  friend void swap(CMsgDOTALeague_Info& a, CMsgDOTALeague_Info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeague_Info* New() const final {
    return CreateMaybeMessage<CMsgDOTALeague_Info>(nullptr);
  }

  CMsgDOTALeague_Info* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeague_Info>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeague_Info& from);
  void MergeFrom(const CMsgDOTALeague_Info& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeague_Info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string url = 5;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 5;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // optional string description = 6;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 6;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional string notes = 7;
  bool has_notes() const;
  void clear_notes();
  static const int kNotesFieldNumber = 7;
  const ::std::string& notes() const;
  void set_notes(const ::std::string& value);
  #if LANG_CXX11
  void set_notes(::std::string&& value);
  #endif
  void set_notes(const char* value);
  void set_notes(const char* value, size_t size);
  ::std::string* mutable_notes();
  ::std::string* release_notes();
  void set_allocated_notes(::std::string* notes);

  // optional uint32 league_id = 1;
  bool has_league_id() const;
  void clear_league_id();
  static const int kLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 league_id() const;
  void set_league_id(::google::protobuf::uint32 value);

  // optional .proto.dota.ELeagueTier tier = 3 [default = LEAGUE_TIER_UNSET];
  bool has_tier() const;
  void clear_tier();
  static const int kTierFieldNumber = 3;
  ::proto::dota::ELeagueTier tier() const;
  void set_tier(::proto::dota::ELeagueTier value);

  // optional .proto.dota.ELeagueRegion region = 4 [default = LEAGUE_REGION_UNSET];
  bool has_region() const;
  void clear_region();
  static const int kRegionFieldNumber = 4;
  ::proto::dota::ELeagueRegion region() const;
  void set_region(::proto::dota::ELeagueRegion value);

  // optional uint32 start_timestamp = 8;
  bool has_start_timestamp() const;
  void clear_start_timestamp();
  static const int kStartTimestampFieldNumber = 8;
  ::google::protobuf::uint32 start_timestamp() const;
  void set_start_timestamp(::google::protobuf::uint32 value);

  // optional uint32 end_timestamp = 9;
  bool has_end_timestamp() const;
  void clear_end_timestamp();
  static const int kEndTimestampFieldNumber = 9;
  ::google::protobuf::uint32 end_timestamp() const;
  void set_end_timestamp(::google::protobuf::uint32 value);

  // optional uint32 pro_circuit_points = 10;
  bool has_pro_circuit_points() const;
  void clear_pro_circuit_points();
  static const int kProCircuitPointsFieldNumber = 10;
  ::google::protobuf::uint32 pro_circuit_points() const;
  void set_pro_circuit_points(::google::protobuf::uint32 value);

  // optional uint32 image_bits = 11;
  bool has_image_bits() const;
  void clear_image_bits();
  static const int kImageBitsFieldNumber = 11;
  ::google::protobuf::uint32 image_bits() const;
  void set_image_bits(::google::protobuf::uint32 value);

  // optional .proto.dota.ELeagueStatus status = 12 [default = LEAGUE_STATUS_UNSET];
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 12;
  ::proto::dota::ELeagueStatus status() const;
  void set_status(::proto::dota::ELeagueStatus value);

  // optional uint32 most_recent_activity = 13;
  bool has_most_recent_activity() const;
  void clear_most_recent_activity();
  static const int kMostRecentActivityFieldNumber = 13;
  ::google::protobuf::uint32 most_recent_activity() const;
  void set_most_recent_activity(::google::protobuf::uint32 value);

  // optional uint32 registration_period = 14;
  bool has_registration_period() const;
  void clear_registration_period();
  static const int kRegistrationPeriodFieldNumber = 14;
  ::google::protobuf::uint32 registration_period() const;
  void set_registration_period(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeague.Info)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr notes_;
  ::google::protobuf::uint32 league_id_;
  int tier_;
  int region_;
  ::google::protobuf::uint32 start_timestamp_;
  ::google::protobuf::uint32 end_timestamp_;
  ::google::protobuf::uint32 pro_circuit_points_;
  ::google::protobuf::uint32 image_bits_;
  int status_;
  ::google::protobuf::uint32 most_recent_activity_;
  ::google::protobuf::uint32 registration_period_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeague_Admin final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeague.Admin) */ {
 public:
  CMsgDOTALeague_Admin();
  virtual ~CMsgDOTALeague_Admin();

  CMsgDOTALeague_Admin(const CMsgDOTALeague_Admin& from);

  inline CMsgDOTALeague_Admin& operator=(const CMsgDOTALeague_Admin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeague_Admin(CMsgDOTALeague_Admin&& from) noexcept
    : CMsgDOTALeague_Admin() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeague_Admin& operator=(CMsgDOTALeague_Admin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeague_Admin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeague_Admin* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeague_Admin*>(
               &_CMsgDOTALeague_Admin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(CMsgDOTALeague_Admin* other);
  friend void swap(CMsgDOTALeague_Admin& a, CMsgDOTALeague_Admin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeague_Admin* New() const final {
    return CreateMaybeMessage<CMsgDOTALeague_Admin>(nullptr);
  }

  CMsgDOTALeague_Admin* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeague_Admin>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeague_Admin& from);
  void MergeFrom(const CMsgDOTALeague_Admin& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeague_Admin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string email_address = 3;
  bool has_email_address() const;
  void clear_email_address();
  static const int kEmailAddressFieldNumber = 3;
  const ::std::string& email_address() const;
  void set_email_address(const ::std::string& value);
  #if LANG_CXX11
  void set_email_address(::std::string&& value);
  #endif
  void set_email_address(const char* value);
  void set_email_address(const char* value, size_t size);
  ::std::string* mutable_email_address();
  ::std::string* release_email_address();
  void set_allocated_email_address(::std::string* email_address);

  // optional uint32 account_id = 1;
  bool has_account_id() const;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  ::google::protobuf::uint32 account_id() const;
  void set_account_id(::google::protobuf::uint32 value);

  // optional bool is_primary = 2;
  bool has_is_primary() const;
  void clear_is_primary();
  static const int kIsPrimaryFieldNumber = 2;
  bool is_primary() const;
  void set_is_primary(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeague.Admin)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr email_address_;
  ::google::protobuf::uint32 account_id_;
  bool is_primary_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeague_PrizePoolItem final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeague.PrizePoolItem) */ {
 public:
  CMsgDOTALeague_PrizePoolItem();
  virtual ~CMsgDOTALeague_PrizePoolItem();

  CMsgDOTALeague_PrizePoolItem(const CMsgDOTALeague_PrizePoolItem& from);

  inline CMsgDOTALeague_PrizePoolItem& operator=(const CMsgDOTALeague_PrizePoolItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeague_PrizePoolItem(CMsgDOTALeague_PrizePoolItem&& from) noexcept
    : CMsgDOTALeague_PrizePoolItem() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeague_PrizePoolItem& operator=(CMsgDOTALeague_PrizePoolItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeague_PrizePoolItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeague_PrizePoolItem* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeague_PrizePoolItem*>(
               &_CMsgDOTALeague_PrizePoolItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(CMsgDOTALeague_PrizePoolItem* other);
  friend void swap(CMsgDOTALeague_PrizePoolItem& a, CMsgDOTALeague_PrizePoolItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeague_PrizePoolItem* New() const final {
    return CreateMaybeMessage<CMsgDOTALeague_PrizePoolItem>(nullptr);
  }

  CMsgDOTALeague_PrizePoolItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeague_PrizePoolItem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeague_PrizePoolItem& from);
  void MergeFrom(const CMsgDOTALeague_PrizePoolItem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeague_PrizePoolItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 item_def = 1;
  bool has_item_def() const;
  void clear_item_def();
  static const int kItemDefFieldNumber = 1;
  ::google::protobuf::uint32 item_def() const;
  void set_item_def(::google::protobuf::uint32 value);

  // optional uint32 sales_stop_timestamp = 2;
  bool has_sales_stop_timestamp() const;
  void clear_sales_stop_timestamp();
  static const int kSalesStopTimestampFieldNumber = 2;
  ::google::protobuf::uint32 sales_stop_timestamp() const;
  void set_sales_stop_timestamp(::google::protobuf::uint32 value);

  // optional uint32 revenue_pct = 3;
  bool has_revenue_pct() const;
  void clear_revenue_pct();
  static const int kRevenuePctFieldNumber = 3;
  ::google::protobuf::uint32 revenue_pct() const;
  void set_revenue_pct(::google::protobuf::uint32 value);

  // optional uint32 revenue_cents_per_sale = 4;
  bool has_revenue_cents_per_sale() const;
  void clear_revenue_cents_per_sale();
  static const int kRevenueCentsPerSaleFieldNumber = 4;
  ::google::protobuf::uint32 revenue_cents_per_sale() const;
  void set_revenue_cents_per_sale(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeague.PrizePoolItem)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 item_def_;
  ::google::protobuf::uint32 sales_stop_timestamp_;
  ::google::protobuf::uint32 revenue_pct_;
  ::google::protobuf::uint32 revenue_cents_per_sale_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeague_PrizePool final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeague.PrizePool) */ {
 public:
  CMsgDOTALeague_PrizePool();
  virtual ~CMsgDOTALeague_PrizePool();

  CMsgDOTALeague_PrizePool(const CMsgDOTALeague_PrizePool& from);

  inline CMsgDOTALeague_PrizePool& operator=(const CMsgDOTALeague_PrizePool& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeague_PrizePool(CMsgDOTALeague_PrizePool&& from) noexcept
    : CMsgDOTALeague_PrizePool() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeague_PrizePool& operator=(CMsgDOTALeague_PrizePool&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeague_PrizePool& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeague_PrizePool* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeague_PrizePool*>(
               &_CMsgDOTALeague_PrizePool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(CMsgDOTALeague_PrizePool* other);
  friend void swap(CMsgDOTALeague_PrizePool& a, CMsgDOTALeague_PrizePool& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeague_PrizePool* New() const final {
    return CreateMaybeMessage<CMsgDOTALeague_PrizePool>(nullptr);
  }

  CMsgDOTALeague_PrizePool* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeague_PrizePool>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeague_PrizePool& from);
  void MergeFrom(const CMsgDOTALeague_PrizePool& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeague_PrizePool* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 prize_split_pct_x100 = 3;
  int prize_split_pct_x100_size() const;
  void clear_prize_split_pct_x100();
  static const int kPrizeSplitPctX100FieldNumber = 3;
  ::google::protobuf::uint32 prize_split_pct_x100(int index) const;
  void set_prize_split_pct_x100(int index, ::google::protobuf::uint32 value);
  void add_prize_split_pct_x100(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      prize_split_pct_x100() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_prize_split_pct_x100();

  // repeated .proto.dota.CMsgDOTALeague.PrizePoolItem prize_pool_items = 4;
  int prize_pool_items_size() const;
  void clear_prize_pool_items();
  static const int kPrizePoolItemsFieldNumber = 4;
  ::proto::dota::CMsgDOTALeague_PrizePoolItem* mutable_prize_pool_items(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_PrizePoolItem >*
      mutable_prize_pool_items();
  const ::proto::dota::CMsgDOTALeague_PrizePoolItem& prize_pool_items(int index) const;
  ::proto::dota::CMsgDOTALeague_PrizePoolItem* add_prize_pool_items();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_PrizePoolItem >&
      prize_pool_items() const;

  // optional uint32 base_prize_pool = 1;
  bool has_base_prize_pool() const;
  void clear_base_prize_pool();
  static const int kBasePrizePoolFieldNumber = 1;
  ::google::protobuf::uint32 base_prize_pool() const;
  void set_base_prize_pool(::google::protobuf::uint32 value);

  // optional uint32 total_prize_pool = 2;
  bool has_total_prize_pool() const;
  void clear_total_prize_pool();
  static const int kTotalPrizePoolFieldNumber = 2;
  ::google::protobuf::uint32 total_prize_pool() const;
  void set_total_prize_pool(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeague.PrizePool)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > prize_split_pct_x100_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_PrizePoolItem > prize_pool_items_;
  ::google::protobuf::uint32 base_prize_pool_;
  ::google::protobuf::uint32 total_prize_pool_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeague_Stream final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeague.Stream) */ {
 public:
  CMsgDOTALeague_Stream();
  virtual ~CMsgDOTALeague_Stream();

  CMsgDOTALeague_Stream(const CMsgDOTALeague_Stream& from);

  inline CMsgDOTALeague_Stream& operator=(const CMsgDOTALeague_Stream& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeague_Stream(CMsgDOTALeague_Stream&& from) noexcept
    : CMsgDOTALeague_Stream() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeague_Stream& operator=(CMsgDOTALeague_Stream&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeague_Stream& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeague_Stream* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeague_Stream*>(
               &_CMsgDOTALeague_Stream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(CMsgDOTALeague_Stream* other);
  friend void swap(CMsgDOTALeague_Stream& a, CMsgDOTALeague_Stream& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeague_Stream* New() const final {
    return CreateMaybeMessage<CMsgDOTALeague_Stream>(nullptr);
  }

  CMsgDOTALeague_Stream* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeague_Stream>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeague_Stream& from);
  void MergeFrom(const CMsgDOTALeague_Stream& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeague_Stream* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string stream_url = 5;
  bool has_stream_url() const;
  void clear_stream_url();
  static const int kStreamUrlFieldNumber = 5;
  const ::std::string& stream_url() const;
  void set_stream_url(const ::std::string& value);
  #if LANG_CXX11
  void set_stream_url(::std::string&& value);
  #endif
  void set_stream_url(const char* value);
  void set_stream_url(const char* value, size_t size);
  ::std::string* mutable_stream_url();
  ::std::string* release_stream_url();
  void set_allocated_stream_url(::std::string* stream_url);

  // optional string vod_url = 6;
  bool has_vod_url() const;
  void clear_vod_url();
  static const int kVodUrlFieldNumber = 6;
  const ::std::string& vod_url() const;
  void set_vod_url(const ::std::string& value);
  #if LANG_CXX11
  void set_vod_url(::std::string&& value);
  #endif
  void set_vod_url(const char* value);
  void set_vod_url(const char* value, size_t size);
  ::std::string* mutable_vod_url();
  ::std::string* release_vod_url();
  void set_allocated_vod_url(::std::string* vod_url);

  // optional uint32 stream_id = 1;
  bool has_stream_id() const;
  void clear_stream_id();
  static const int kStreamIdFieldNumber = 1;
  ::google::protobuf::uint32 stream_id() const;
  void set_stream_id(::google::protobuf::uint32 value);

  // optional uint32 language = 2;
  bool has_language() const;
  void clear_language();
  static const int kLanguageFieldNumber = 2;
  ::google::protobuf::uint32 language() const;
  void set_language(::google::protobuf::uint32 value);

  // optional .proto.dota.ELeagueBroadcastProvider broadcast_provider = 4 [default = LEAGUE_BROADCAST_UNKNOWN];
  bool has_broadcast_provider() const;
  void clear_broadcast_provider();
  static const int kBroadcastProviderFieldNumber = 4;
  ::proto::dota::ELeagueBroadcastProvider broadcast_provider() const;
  void set_broadcast_provider(::proto::dota::ELeagueBroadcastProvider value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeague.Stream)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr stream_url_;
  ::google::protobuf::internal::ArenaStringPtr vod_url_;
  ::google::protobuf::uint32 stream_id_;
  ::google::protobuf::uint32 language_;
  int broadcast_provider_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeague_SeriesInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeague.SeriesInfo) */ {
 public:
  CMsgDOTALeague_SeriesInfo();
  virtual ~CMsgDOTALeague_SeriesInfo();

  CMsgDOTALeague_SeriesInfo(const CMsgDOTALeague_SeriesInfo& from);

  inline CMsgDOTALeague_SeriesInfo& operator=(const CMsgDOTALeague_SeriesInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeague_SeriesInfo(CMsgDOTALeague_SeriesInfo&& from) noexcept
    : CMsgDOTALeague_SeriesInfo() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeague_SeriesInfo& operator=(CMsgDOTALeague_SeriesInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeague_SeriesInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeague_SeriesInfo* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeague_SeriesInfo*>(
               &_CMsgDOTALeague_SeriesInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(CMsgDOTALeague_SeriesInfo* other);
  friend void swap(CMsgDOTALeague_SeriesInfo& a, CMsgDOTALeague_SeriesInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeague_SeriesInfo* New() const final {
    return CreateMaybeMessage<CMsgDOTALeague_SeriesInfo>(nullptr);
  }

  CMsgDOTALeague_SeriesInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeague_SeriesInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeague_SeriesInfo& from);
  void MergeFrom(const CMsgDOTALeague_SeriesInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeague_SeriesInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 match_ids = 4;
  int match_ids_size() const;
  void clear_match_ids();
  static const int kMatchIdsFieldNumber = 4;
  ::google::protobuf::uint64 match_ids(int index) const;
  void set_match_ids(int index, ::google::protobuf::uint64 value);
  void add_match_ids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      match_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_match_ids();

  // optional uint32 series_id = 1;
  bool has_series_id() const;
  void clear_series_id();
  static const int kSeriesIdFieldNumber = 1;
  ::google::protobuf::uint32 series_id() const;
  void set_series_id(::google::protobuf::uint32 value);

  // optional uint32 series_type = 2;
  bool has_series_type() const;
  void clear_series_type();
  static const int kSeriesTypeFieldNumber = 2;
  ::google::protobuf::uint32 series_type() const;
  void set_series_type(::google::protobuf::uint32 value);

  // optional uint32 start_time = 3;
  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  ::google::protobuf::uint32 start_time() const;
  void set_start_time(::google::protobuf::uint32 value);

  // optional uint32 team_id_1 = 5;
  bool has_team_id_1() const;
  void clear_team_id_1();
  static const int kTeamId1FieldNumber = 5;
  ::google::protobuf::uint32 team_id_1() const;
  void set_team_id_1(::google::protobuf::uint32 value);

  // optional uint32 team_id_2 = 6;
  bool has_team_id_2() const;
  void clear_team_id_2();
  static const int kTeamId2FieldNumber = 6;
  ::google::protobuf::uint32 team_id_2() const;
  void set_team_id_2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeague.SeriesInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > match_ids_;
  ::google::protobuf::uint32 series_id_;
  ::google::protobuf::uint32 series_type_;
  ::google::protobuf::uint32 start_time_;
  ::google::protobuf::uint32 team_id_1_;
  ::google::protobuf::uint32 team_id_2_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeague_Player final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeague.Player) */ {
 public:
  CMsgDOTALeague_Player();
  virtual ~CMsgDOTALeague_Player();

  CMsgDOTALeague_Player(const CMsgDOTALeague_Player& from);

  inline CMsgDOTALeague_Player& operator=(const CMsgDOTALeague_Player& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeague_Player(CMsgDOTALeague_Player&& from) noexcept
    : CMsgDOTALeague_Player() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeague_Player& operator=(CMsgDOTALeague_Player&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeague_Player& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeague_Player* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeague_Player*>(
               &_CMsgDOTALeague_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(CMsgDOTALeague_Player* other);
  friend void swap(CMsgDOTALeague_Player& a, CMsgDOTALeague_Player& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeague_Player* New() const final {
    return CreateMaybeMessage<CMsgDOTALeague_Player>(nullptr);
  }

  CMsgDOTALeague_Player* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeague_Player>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeague_Player& from);
  void MergeFrom(const CMsgDOTALeague_Player& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeague_Player* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint32 account_id = 1;
  bool has_account_id() const;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  ::google::protobuf::uint32 account_id() const;
  void set_account_id(::google::protobuf::uint32 value);

  // optional uint32 team_id = 3;
  bool has_team_id() const;
  void clear_team_id();
  static const int kTeamIdFieldNumber = 3;
  ::google::protobuf::uint32 team_id() const;
  void set_team_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeague.Player)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 account_id_;
  ::google::protobuf::uint32 team_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeague final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeague) */ {
 public:
  CMsgDOTALeague();
  virtual ~CMsgDOTALeague();

  CMsgDOTALeague(const CMsgDOTALeague& from);

  inline CMsgDOTALeague& operator=(const CMsgDOTALeague& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeague(CMsgDOTALeague&& from) noexcept
    : CMsgDOTALeague() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeague& operator=(CMsgDOTALeague&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeague& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeague* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeague*>(
               &_CMsgDOTALeague_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(CMsgDOTALeague* other);
  friend void swap(CMsgDOTALeague& a, CMsgDOTALeague& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeague* New() const final {
    return CreateMaybeMessage<CMsgDOTALeague>(nullptr);
  }

  CMsgDOTALeague* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeague>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeague& from);
  void MergeFrom(const CMsgDOTALeague& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeague* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTALeague_Info Info;
  typedef CMsgDOTALeague_Admin Admin;
  typedef CMsgDOTALeague_PrizePoolItem PrizePoolItem;
  typedef CMsgDOTALeague_PrizePool PrizePool;
  typedef CMsgDOTALeague_Stream Stream;
  typedef CMsgDOTALeague_SeriesInfo SeriesInfo;
  typedef CMsgDOTALeague_Player Player;

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTALeague.Admin admins = 3;
  int admins_size() const;
  void clear_admins();
  static const int kAdminsFieldNumber = 3;
  ::proto::dota::CMsgDOTALeague_Admin* mutable_admins(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_Admin >*
      mutable_admins();
  const ::proto::dota::CMsgDOTALeague_Admin& admins(int index) const;
  ::proto::dota::CMsgDOTALeague_Admin* add_admins();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_Admin >&
      admins() const;

  // repeated .proto.dota.CMsgDOTALeague.Stream streams = 4;
  int streams_size() const;
  void clear_streams();
  static const int kStreamsFieldNumber = 4;
  ::proto::dota::CMsgDOTALeague_Stream* mutable_streams(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_Stream >*
      mutable_streams();
  const ::proto::dota::CMsgDOTALeague_Stream& streams(int index) const;
  ::proto::dota::CMsgDOTALeague_Stream* add_streams();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_Stream >&
      streams() const;

  // repeated .proto.dota.CMsgDOTALeagueNodeGroup node_groups = 5;
  int node_groups_size() const;
  void clear_node_groups();
  static const int kNodeGroupsFieldNumber = 5;
  ::proto::dota::CMsgDOTALeagueNodeGroup* mutable_node_groups(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNodeGroup >*
      mutable_node_groups();
  const ::proto::dota::CMsgDOTALeagueNodeGroup& node_groups(int index) const;
  ::proto::dota::CMsgDOTALeagueNodeGroup* add_node_groups();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNodeGroup >&
      node_groups() const;

  // repeated .proto.dota.CMsgDOTALeague.SeriesInfo series_infos = 6;
  int series_infos_size() const;
  void clear_series_infos();
  static const int kSeriesInfosFieldNumber = 6;
  ::proto::dota::CMsgDOTALeague_SeriesInfo* mutable_series_infos(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_SeriesInfo >*
      mutable_series_infos();
  const ::proto::dota::CMsgDOTALeague_SeriesInfo& series_infos(int index) const;
  ::proto::dota::CMsgDOTALeague_SeriesInfo* add_series_infos();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_SeriesInfo >&
      series_infos() const;

  // repeated .proto.dota.CMsgDOTALeague.Player registered_players = 7;
  int registered_players_size() const;
  void clear_registered_players();
  static const int kRegisteredPlayersFieldNumber = 7;
  ::proto::dota::CMsgDOTALeague_Player* mutable_registered_players(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_Player >*
      mutable_registered_players();
  const ::proto::dota::CMsgDOTALeague_Player& registered_players(int index) const;
  ::proto::dota::CMsgDOTALeague_Player* add_registered_players();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_Player >&
      registered_players() const;

  // optional .proto.dota.CMsgDOTALeague.Info info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::proto::dota::CMsgDOTALeague_Info& info() const;
  ::proto::dota::CMsgDOTALeague_Info* release_info();
  ::proto::dota::CMsgDOTALeague_Info* mutable_info();
  void set_allocated_info(::proto::dota::CMsgDOTALeague_Info* info);

  // optional .proto.dota.CMsgDOTALeague.PrizePool prize_pool = 2;
  bool has_prize_pool() const;
  void clear_prize_pool();
  static const int kPrizePoolFieldNumber = 2;
  const ::proto::dota::CMsgDOTALeague_PrizePool& prize_pool() const;
  ::proto::dota::CMsgDOTALeague_PrizePool* release_prize_pool();
  ::proto::dota::CMsgDOTALeague_PrizePool* mutable_prize_pool();
  void set_allocated_prize_pool(::proto::dota::CMsgDOTALeague_PrizePool* prize_pool);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeague)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_Admin > admins_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_Stream > streams_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNodeGroup > node_groups_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_SeriesInfo > series_infos_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_Player > registered_players_;
  ::proto::dota::CMsgDOTALeague_Info* info_;
  ::proto::dota::CMsgDOTALeague_PrizePool* prize_pool_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeagueInfo) */ {
 public:
  CMsgDOTALeagueInfo();
  virtual ~CMsgDOTALeagueInfo();

  CMsgDOTALeagueInfo(const CMsgDOTALeagueInfo& from);

  inline CMsgDOTALeagueInfo& operator=(const CMsgDOTALeagueInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeagueInfo(CMsgDOTALeagueInfo&& from) noexcept
    : CMsgDOTALeagueInfo() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueInfo& operator=(CMsgDOTALeagueInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeagueInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeagueInfo* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueInfo*>(
               &_CMsgDOTALeagueInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(CMsgDOTALeagueInfo* other);
  friend void swap(CMsgDOTALeagueInfo& a, CMsgDOTALeagueInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeagueInfo* New() const final {
    return CreateMaybeMessage<CMsgDOTALeagueInfo>(nullptr);
  }

  CMsgDOTALeagueInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeagueInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeagueInfo& from);
  void MergeFrom(const CMsgDOTALeagueInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint32 league_id = 1;
  bool has_league_id() const;
  void clear_league_id();
  static const int kLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 league_id() const;
  void set_league_id(::google::protobuf::uint32 value);

  // optional .proto.dota.ELeagueTier tier = 3 [default = LEAGUE_TIER_UNSET];
  bool has_tier() const;
  void clear_tier();
  static const int kTierFieldNumber = 3;
  ::proto::dota::ELeagueTier tier() const;
  void set_tier(::proto::dota::ELeagueTier value);

  // optional .proto.dota.ELeagueRegion region = 4 [default = LEAGUE_REGION_UNSET];
  bool has_region() const;
  void clear_region();
  static const int kRegionFieldNumber = 4;
  ::proto::dota::ELeagueRegion region() const;
  void set_region(::proto::dota::ELeagueRegion value);

  // optional uint32 most_recent_activity = 5;
  bool has_most_recent_activity() const;
  void clear_most_recent_activity();
  static const int kMostRecentActivityFieldNumber = 5;
  ::google::protobuf::uint32 most_recent_activity() const;
  void set_most_recent_activity(::google::protobuf::uint32 value);

  // optional uint32 total_prize_pool = 6;
  bool has_total_prize_pool() const;
  void clear_total_prize_pool();
  static const int kTotalPrizePoolFieldNumber = 6;
  ::google::protobuf::uint32 total_prize_pool() const;
  void set_total_prize_pool(::google::protobuf::uint32 value);

  // optional uint32 start_timestamp = 7;
  bool has_start_timestamp() const;
  void clear_start_timestamp();
  static const int kStartTimestampFieldNumber = 7;
  ::google::protobuf::uint32 start_timestamp() const;
  void set_start_timestamp(::google::protobuf::uint32 value);

  // optional uint32 end_timestamp = 8;
  bool has_end_timestamp() const;
  void clear_end_timestamp();
  static const int kEndTimestampFieldNumber = 8;
  ::google::protobuf::uint32 end_timestamp() const;
  void set_end_timestamp(::google::protobuf::uint32 value);

  // optional uint32 status = 9;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 9;
  ::google::protobuf::uint32 status() const;
  void set_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeagueInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 league_id_;
  int tier_;
  int region_;
  ::google::protobuf::uint32 most_recent_activity_;
  ::google::protobuf::uint32 total_prize_pool_;
  ::google::protobuf::uint32 start_timestamp_;
  ::google::protobuf::uint32 end_timestamp_;
  ::google::protobuf::uint32 status_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueInfoList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeagueInfoList) */ {
 public:
  CMsgDOTALeagueInfoList();
  virtual ~CMsgDOTALeagueInfoList();

  CMsgDOTALeagueInfoList(const CMsgDOTALeagueInfoList& from);

  inline CMsgDOTALeagueInfoList& operator=(const CMsgDOTALeagueInfoList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeagueInfoList(CMsgDOTALeagueInfoList&& from) noexcept
    : CMsgDOTALeagueInfoList() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueInfoList& operator=(CMsgDOTALeagueInfoList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeagueInfoList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeagueInfoList* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueInfoList*>(
               &_CMsgDOTALeagueInfoList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(CMsgDOTALeagueInfoList* other);
  friend void swap(CMsgDOTALeagueInfoList& a, CMsgDOTALeagueInfoList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeagueInfoList* New() const final {
    return CreateMaybeMessage<CMsgDOTALeagueInfoList>(nullptr);
  }

  CMsgDOTALeagueInfoList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeagueInfoList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeagueInfoList& from);
  void MergeFrom(const CMsgDOTALeagueInfoList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueInfoList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTALeagueInfo infos = 1;
  int infos_size() const;
  void clear_infos();
  static const int kInfosFieldNumber = 1;
  ::proto::dota::CMsgDOTALeagueInfo* mutable_infos(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueInfo >*
      mutable_infos();
  const ::proto::dota::CMsgDOTALeagueInfo& infos(int index) const;
  ::proto::dota::CMsgDOTALeagueInfo* add_infos();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueInfo >&
      infos() const;

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeagueInfoList)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueInfo > infos_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueLiveGames_LiveGame final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeagueLiveGames.LiveGame) */ {
 public:
  CMsgDOTALeagueLiveGames_LiveGame();
  virtual ~CMsgDOTALeagueLiveGames_LiveGame();

  CMsgDOTALeagueLiveGames_LiveGame(const CMsgDOTALeagueLiveGames_LiveGame& from);

  inline CMsgDOTALeagueLiveGames_LiveGame& operator=(const CMsgDOTALeagueLiveGames_LiveGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeagueLiveGames_LiveGame(CMsgDOTALeagueLiveGames_LiveGame&& from) noexcept
    : CMsgDOTALeagueLiveGames_LiveGame() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueLiveGames_LiveGame& operator=(CMsgDOTALeagueLiveGames_LiveGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeagueLiveGames_LiveGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeagueLiveGames_LiveGame* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueLiveGames_LiveGame*>(
               &_CMsgDOTALeagueLiveGames_LiveGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(CMsgDOTALeagueLiveGames_LiveGame* other);
  friend void swap(CMsgDOTALeagueLiveGames_LiveGame& a, CMsgDOTALeagueLiveGames_LiveGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeagueLiveGames_LiveGame* New() const final {
    return CreateMaybeMessage<CMsgDOTALeagueLiveGames_LiveGame>(nullptr);
  }

  CMsgDOTALeagueLiveGames_LiveGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeagueLiveGames_LiveGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeagueLiveGames_LiveGame& from);
  void MergeFrom(const CMsgDOTALeagueLiveGames_LiveGame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueLiveGames_LiveGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string radiant_name = 3;
  bool has_radiant_name() const;
  void clear_radiant_name();
  static const int kRadiantNameFieldNumber = 3;
  const ::std::string& radiant_name() const;
  void set_radiant_name(const ::std::string& value);
  #if LANG_CXX11
  void set_radiant_name(::std::string&& value);
  #endif
  void set_radiant_name(const char* value);
  void set_radiant_name(const char* value, size_t size);
  ::std::string* mutable_radiant_name();
  ::std::string* release_radiant_name();
  void set_allocated_radiant_name(::std::string* radiant_name);

  // optional string dire_name = 5;
  bool has_dire_name() const;
  void clear_dire_name();
  static const int kDireNameFieldNumber = 5;
  const ::std::string& dire_name() const;
  void set_dire_name(const ::std::string& value);
  #if LANG_CXX11
  void set_dire_name(::std::string&& value);
  #endif
  void set_dire_name(const char* value);
  void set_dire_name(const char* value, size_t size);
  ::std::string* mutable_dire_name();
  ::std::string* release_dire_name();
  void set_allocated_dire_name(::std::string* dire_name);

  // optional uint64 server_steam_id = 2;
  bool has_server_steam_id() const;
  void clear_server_steam_id();
  static const int kServerSteamIdFieldNumber = 2;
  ::google::protobuf::uint64 server_steam_id() const;
  void set_server_steam_id(::google::protobuf::uint64 value);

  // optional uint64 radiant_logo = 4;
  bool has_radiant_logo() const;
  void clear_radiant_logo();
  static const int kRadiantLogoFieldNumber = 4;
  ::google::protobuf::uint64 radiant_logo() const;
  void set_radiant_logo(::google::protobuf::uint64 value);

  // optional uint32 league_id = 1;
  bool has_league_id() const;
  void clear_league_id();
  static const int kLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 league_id() const;
  void set_league_id(::google::protobuf::uint32 value);

  // optional uint32 time = 7;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 7;
  ::google::protobuf::uint32 time() const;
  void set_time(::google::protobuf::uint32 value);

  // optional uint64 dire_logo = 6;
  bool has_dire_logo() const;
  void clear_dire_logo();
  static const int kDireLogoFieldNumber = 6;
  ::google::protobuf::uint64 dire_logo() const;
  void set_dire_logo(::google::protobuf::uint64 value);

  // optional uint32 spectators = 8;
  bool has_spectators() const;
  void clear_spectators();
  static const int kSpectatorsFieldNumber = 8;
  ::google::protobuf::uint32 spectators() const;
  void set_spectators(::google::protobuf::uint32 value);

  // optional uint32 radiant_team_id = 9;
  bool has_radiant_team_id() const;
  void clear_radiant_team_id();
  static const int kRadiantTeamIdFieldNumber = 9;
  ::google::protobuf::uint32 radiant_team_id() const;
  void set_radiant_team_id(::google::protobuf::uint32 value);

  // optional uint32 dire_team_id = 10;
  bool has_dire_team_id() const;
  void clear_dire_team_id();
  static const int kDireTeamIdFieldNumber = 10;
  ::google::protobuf::uint32 dire_team_id() const;
  void set_dire_team_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeagueLiveGames.LiveGame)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr radiant_name_;
  ::google::protobuf::internal::ArenaStringPtr dire_name_;
  ::google::protobuf::uint64 server_steam_id_;
  ::google::protobuf::uint64 radiant_logo_;
  ::google::protobuf::uint32 league_id_;
  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint64 dire_logo_;
  ::google::protobuf::uint32 spectators_;
  ::google::protobuf::uint32 radiant_team_id_;
  ::google::protobuf::uint32 dire_team_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueLiveGames final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeagueLiveGames) */ {
 public:
  CMsgDOTALeagueLiveGames();
  virtual ~CMsgDOTALeagueLiveGames();

  CMsgDOTALeagueLiveGames(const CMsgDOTALeagueLiveGames& from);

  inline CMsgDOTALeagueLiveGames& operator=(const CMsgDOTALeagueLiveGames& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeagueLiveGames(CMsgDOTALeagueLiveGames&& from) noexcept
    : CMsgDOTALeagueLiveGames() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueLiveGames& operator=(CMsgDOTALeagueLiveGames&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeagueLiveGames& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeagueLiveGames* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueLiveGames*>(
               &_CMsgDOTALeagueLiveGames_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(CMsgDOTALeagueLiveGames* other);
  friend void swap(CMsgDOTALeagueLiveGames& a, CMsgDOTALeagueLiveGames& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeagueLiveGames* New() const final {
    return CreateMaybeMessage<CMsgDOTALeagueLiveGames>(nullptr);
  }

  CMsgDOTALeagueLiveGames* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeagueLiveGames>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeagueLiveGames& from);
  void MergeFrom(const CMsgDOTALeagueLiveGames& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueLiveGames* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTALeagueLiveGames_LiveGame LiveGame;

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTALeagueLiveGames.LiveGame games = 1;
  int games_size() const;
  void clear_games();
  static const int kGamesFieldNumber = 1;
  ::proto::dota::CMsgDOTALeagueLiveGames_LiveGame* mutable_games(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueLiveGames_LiveGame >*
      mutable_games();
  const ::proto::dota::CMsgDOTALeagueLiveGames_LiveGame& games(int index) const;
  ::proto::dota::CMsgDOTALeagueLiveGames_LiveGame* add_games();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueLiveGames_LiveGame >&
      games() const;

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeagueLiveGames)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueLiveGames_LiveGame > games_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueMessages_Message final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeagueMessages.Message) */ {
 public:
  CMsgDOTALeagueMessages_Message();
  virtual ~CMsgDOTALeagueMessages_Message();

  CMsgDOTALeagueMessages_Message(const CMsgDOTALeagueMessages_Message& from);

  inline CMsgDOTALeagueMessages_Message& operator=(const CMsgDOTALeagueMessages_Message& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeagueMessages_Message(CMsgDOTALeagueMessages_Message&& from) noexcept
    : CMsgDOTALeagueMessages_Message() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueMessages_Message& operator=(CMsgDOTALeagueMessages_Message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeagueMessages_Message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeagueMessages_Message* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueMessages_Message*>(
               &_CMsgDOTALeagueMessages_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(CMsgDOTALeagueMessages_Message* other);
  friend void swap(CMsgDOTALeagueMessages_Message& a, CMsgDOTALeagueMessages_Message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeagueMessages_Message* New() const final {
    return CreateMaybeMessage<CMsgDOTALeagueMessages_Message>(nullptr);
  }

  CMsgDOTALeagueMessages_Message* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeagueMessages_Message>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeagueMessages_Message& from);
  void MergeFrom(const CMsgDOTALeagueMessages_Message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueMessages_Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 3;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 3;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional uint32 author_account_id = 1;
  bool has_author_account_id() const;
  void clear_author_account_id();
  static const int kAuthorAccountIdFieldNumber = 1;
  ::google::protobuf::uint32 author_account_id() const;
  void set_author_account_id(::google::protobuf::uint32 value);

  // optional uint32 timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeagueMessages.Message)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::uint32 author_account_id_;
  ::google::protobuf::uint32 timestamp_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueMessages final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeagueMessages) */ {
 public:
  CMsgDOTALeagueMessages();
  virtual ~CMsgDOTALeagueMessages();

  CMsgDOTALeagueMessages(const CMsgDOTALeagueMessages& from);

  inline CMsgDOTALeagueMessages& operator=(const CMsgDOTALeagueMessages& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeagueMessages(CMsgDOTALeagueMessages&& from) noexcept
    : CMsgDOTALeagueMessages() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueMessages& operator=(CMsgDOTALeagueMessages&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeagueMessages& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeagueMessages* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueMessages*>(
               &_CMsgDOTALeagueMessages_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(CMsgDOTALeagueMessages* other);
  friend void swap(CMsgDOTALeagueMessages& a, CMsgDOTALeagueMessages& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeagueMessages* New() const final {
    return CreateMaybeMessage<CMsgDOTALeagueMessages>(nullptr);
  }

  CMsgDOTALeagueMessages* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeagueMessages>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeagueMessages& from);
  void MergeFrom(const CMsgDOTALeagueMessages& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueMessages* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTALeagueMessages_Message Message;

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTALeagueMessages.Message messages = 1;
  int messages_size() const;
  void clear_messages();
  static const int kMessagesFieldNumber = 1;
  ::proto::dota::CMsgDOTALeagueMessages_Message* mutable_messages(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueMessages_Message >*
      mutable_messages();
  const ::proto::dota::CMsgDOTALeagueMessages_Message& messages(int index) const;
  ::proto::dota::CMsgDOTALeagueMessages_Message* add_messages();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueMessages_Message >&
      messages() const;

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeagueMessages)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueMessages_Message > messages_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeaguePrizePool final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeaguePrizePool) */ {
 public:
  CMsgDOTALeaguePrizePool();
  virtual ~CMsgDOTALeaguePrizePool();

  CMsgDOTALeaguePrizePool(const CMsgDOTALeaguePrizePool& from);

  inline CMsgDOTALeaguePrizePool& operator=(const CMsgDOTALeaguePrizePool& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeaguePrizePool(CMsgDOTALeaguePrizePool&& from) noexcept
    : CMsgDOTALeaguePrizePool() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeaguePrizePool& operator=(CMsgDOTALeaguePrizePool&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeaguePrizePool& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeaguePrizePool* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeaguePrizePool*>(
               &_CMsgDOTALeaguePrizePool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(CMsgDOTALeaguePrizePool* other);
  friend void swap(CMsgDOTALeaguePrizePool& a, CMsgDOTALeaguePrizePool& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeaguePrizePool* New() const final {
    return CreateMaybeMessage<CMsgDOTALeaguePrizePool>(nullptr);
  }

  CMsgDOTALeaguePrizePool* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeaguePrizePool>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeaguePrizePool& from);
  void MergeFrom(const CMsgDOTALeaguePrizePool& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeaguePrizePool* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 prize_pool = 1;
  bool has_prize_pool() const;
  void clear_prize_pool();
  static const int kPrizePoolFieldNumber = 1;
  ::google::protobuf::uint32 prize_pool() const;
  void set_prize_pool(::google::protobuf::uint32 value);

  // optional float increment_per_second = 2;
  bool has_increment_per_second() const;
  void clear_increment_per_second();
  static const int kIncrementPerSecondFieldNumber = 2;
  float increment_per_second() const;
  void set_increment_per_second(float value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeaguePrizePool)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 prize_pool_;
  float increment_per_second_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueInfoListAdminsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeagueInfoListAdminsRequest) */ {
 public:
  CMsgDOTALeagueInfoListAdminsRequest();
  virtual ~CMsgDOTALeagueInfoListAdminsRequest();

  CMsgDOTALeagueInfoListAdminsRequest(const CMsgDOTALeagueInfoListAdminsRequest& from);

  inline CMsgDOTALeagueInfoListAdminsRequest& operator=(const CMsgDOTALeagueInfoListAdminsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeagueInfoListAdminsRequest(CMsgDOTALeagueInfoListAdminsRequest&& from) noexcept
    : CMsgDOTALeagueInfoListAdminsRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueInfoListAdminsRequest& operator=(CMsgDOTALeagueInfoListAdminsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeagueInfoListAdminsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeagueInfoListAdminsRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueInfoListAdminsRequest*>(
               &_CMsgDOTALeagueInfoListAdminsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(CMsgDOTALeagueInfoListAdminsRequest* other);
  friend void swap(CMsgDOTALeagueInfoListAdminsRequest& a, CMsgDOTALeagueInfoListAdminsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeagueInfoListAdminsRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTALeagueInfoListAdminsRequest>(nullptr);
  }

  CMsgDOTALeagueInfoListAdminsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeagueInfoListAdminsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeagueInfoListAdminsRequest& from);
  void MergeFrom(const CMsgDOTALeagueInfoListAdminsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueInfoListAdminsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeagueInfoListAdminsRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueNodeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeagueNodeRequest) */ {
 public:
  CMsgDOTALeagueNodeRequest();
  virtual ~CMsgDOTALeagueNodeRequest();

  CMsgDOTALeagueNodeRequest(const CMsgDOTALeagueNodeRequest& from);

  inline CMsgDOTALeagueNodeRequest& operator=(const CMsgDOTALeagueNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeagueNodeRequest(CMsgDOTALeagueNodeRequest&& from) noexcept
    : CMsgDOTALeagueNodeRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueNodeRequest& operator=(CMsgDOTALeagueNodeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeagueNodeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeagueNodeRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueNodeRequest*>(
               &_CMsgDOTALeagueNodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(CMsgDOTALeagueNodeRequest* other);
  friend void swap(CMsgDOTALeagueNodeRequest& a, CMsgDOTALeagueNodeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeagueNodeRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTALeagueNodeRequest>(nullptr);
  }

  CMsgDOTALeagueNodeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeagueNodeRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeagueNodeRequest& from);
  void MergeFrom(const CMsgDOTALeagueNodeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueNodeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 league_id = 1;
  bool has_league_id() const;
  void clear_league_id();
  static const int kLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 league_id() const;
  void set_league_id(::google::protobuf::uint32 value);

  // optional uint32 node_id = 2;
  bool has_node_id() const;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  ::google::protobuf::uint32 node_id() const;
  void set_node_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeagueNodeRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 league_id_;
  ::google::protobuf::uint32 node_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueNodeResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeagueNodeResponse) */ {
 public:
  CMsgDOTALeagueNodeResponse();
  virtual ~CMsgDOTALeagueNodeResponse();

  CMsgDOTALeagueNodeResponse(const CMsgDOTALeagueNodeResponse& from);

  inline CMsgDOTALeagueNodeResponse& operator=(const CMsgDOTALeagueNodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeagueNodeResponse(CMsgDOTALeagueNodeResponse&& from) noexcept
    : CMsgDOTALeagueNodeResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueNodeResponse& operator=(CMsgDOTALeagueNodeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeagueNodeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeagueNodeResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueNodeResponse*>(
               &_CMsgDOTALeagueNodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(CMsgDOTALeagueNodeResponse* other);
  friend void swap(CMsgDOTALeagueNodeResponse& a, CMsgDOTALeagueNodeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeagueNodeResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTALeagueNodeResponse>(nullptr);
  }

  CMsgDOTALeagueNodeResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeagueNodeResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeagueNodeResponse& from);
  void MergeFrom(const CMsgDOTALeagueNodeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueNodeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgDOTALeagueNode node = 1;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  const ::proto::dota::CMsgDOTALeagueNode& node() const;
  ::proto::dota::CMsgDOTALeagueNode* release_node();
  ::proto::dota::CMsgDOTALeagueNode* mutable_node();
  void set_allocated_node(::proto::dota::CMsgDOTALeagueNode* node);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeagueNodeResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::proto::dota::CMsgDOTALeagueNode* node_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueAvailableLobbyNodesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeagueAvailableLobbyNodesRequest) */ {
 public:
  CMsgDOTALeagueAvailableLobbyNodesRequest();
  virtual ~CMsgDOTALeagueAvailableLobbyNodesRequest();

  CMsgDOTALeagueAvailableLobbyNodesRequest(const CMsgDOTALeagueAvailableLobbyNodesRequest& from);

  inline CMsgDOTALeagueAvailableLobbyNodesRequest& operator=(const CMsgDOTALeagueAvailableLobbyNodesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeagueAvailableLobbyNodesRequest(CMsgDOTALeagueAvailableLobbyNodesRequest&& from) noexcept
    : CMsgDOTALeagueAvailableLobbyNodesRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueAvailableLobbyNodesRequest& operator=(CMsgDOTALeagueAvailableLobbyNodesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeagueAvailableLobbyNodesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeagueAvailableLobbyNodesRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueAvailableLobbyNodesRequest*>(
               &_CMsgDOTALeagueAvailableLobbyNodesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(CMsgDOTALeagueAvailableLobbyNodesRequest* other);
  friend void swap(CMsgDOTALeagueAvailableLobbyNodesRequest& a, CMsgDOTALeagueAvailableLobbyNodesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeagueAvailableLobbyNodesRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTALeagueAvailableLobbyNodesRequest>(nullptr);
  }

  CMsgDOTALeagueAvailableLobbyNodesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeagueAvailableLobbyNodesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeagueAvailableLobbyNodesRequest& from);
  void MergeFrom(const CMsgDOTALeagueAvailableLobbyNodesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueAvailableLobbyNodesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 league_id = 1;
  bool has_league_id() const;
  void clear_league_id();
  static const int kLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 league_id() const;
  void set_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeagueAvailableLobbyNodesRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 league_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueAvailableLobbyNodes_NodeInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo) */ {
 public:
  CMsgDOTALeagueAvailableLobbyNodes_NodeInfo();
  virtual ~CMsgDOTALeagueAvailableLobbyNodes_NodeInfo();

  CMsgDOTALeagueAvailableLobbyNodes_NodeInfo(const CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& from);

  inline CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& operator=(const CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeagueAvailableLobbyNodes_NodeInfo(CMsgDOTALeagueAvailableLobbyNodes_NodeInfo&& from) noexcept
    : CMsgDOTALeagueAvailableLobbyNodes_NodeInfo() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& operator=(CMsgDOTALeagueAvailableLobbyNodes_NodeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueAvailableLobbyNodes_NodeInfo*>(
               &_CMsgDOTALeagueAvailableLobbyNodes_NodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* other);
  friend void swap(CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& a, CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* New() const final {
    return CreateMaybeMessage<CMsgDOTALeagueAvailableLobbyNodes_NodeInfo>(nullptr);
  }

  CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeagueAvailableLobbyNodes_NodeInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& from);
  void MergeFrom(const CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string node_name = 2;
  bool has_node_name() const;
  void clear_node_name();
  static const int kNodeNameFieldNumber = 2;
  const ::std::string& node_name() const;
  void set_node_name(const ::std::string& value);
  #if LANG_CXX11
  void set_node_name(::std::string&& value);
  #endif
  void set_node_name(const char* value);
  void set_node_name(const char* value, size_t size);
  ::std::string* mutable_node_name();
  ::std::string* release_node_name();
  void set_allocated_node_name(::std::string* node_name);

  // optional string node_group_name = 3;
  bool has_node_group_name() const;
  void clear_node_group_name();
  static const int kNodeGroupNameFieldNumber = 3;
  const ::std::string& node_group_name() const;
  void set_node_group_name(const ::std::string& value);
  #if LANG_CXX11
  void set_node_group_name(::std::string&& value);
  #endif
  void set_node_group_name(const char* value);
  void set_node_group_name(const char* value, size_t size);
  ::std::string* mutable_node_group_name();
  ::std::string* release_node_group_name();
  void set_allocated_node_group_name(::std::string* node_group_name);

  // optional uint32 node_id = 1;
  bool has_node_id() const;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  ::google::protobuf::uint32 node_id() const;
  void set_node_id(::google::protobuf::uint32 value);

  // optional uint32 team_id_1 = 4;
  bool has_team_id_1() const;
  void clear_team_id_1();
  static const int kTeamId1FieldNumber = 4;
  ::google::protobuf::uint32 team_id_1() const;
  void set_team_id_1(::google::protobuf::uint32 value);

  // optional uint32 team_id_2 = 5;
  bool has_team_id_2() const;
  void clear_team_id_2();
  static const int kTeamId2FieldNumber = 5;
  ::google::protobuf::uint32 team_id_2() const;
  void set_team_id_2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr node_name_;
  ::google::protobuf::internal::ArenaStringPtr node_group_name_;
  ::google::protobuf::uint32 node_id_;
  ::google::protobuf::uint32 team_id_1_;
  ::google::protobuf::uint32 team_id_2_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueAvailableLobbyNodes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeagueAvailableLobbyNodes) */ {
 public:
  CMsgDOTALeagueAvailableLobbyNodes();
  virtual ~CMsgDOTALeagueAvailableLobbyNodes();

  CMsgDOTALeagueAvailableLobbyNodes(const CMsgDOTALeagueAvailableLobbyNodes& from);

  inline CMsgDOTALeagueAvailableLobbyNodes& operator=(const CMsgDOTALeagueAvailableLobbyNodes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeagueAvailableLobbyNodes(CMsgDOTALeagueAvailableLobbyNodes&& from) noexcept
    : CMsgDOTALeagueAvailableLobbyNodes() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueAvailableLobbyNodes& operator=(CMsgDOTALeagueAvailableLobbyNodes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeagueAvailableLobbyNodes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeagueAvailableLobbyNodes* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueAvailableLobbyNodes*>(
               &_CMsgDOTALeagueAvailableLobbyNodes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(CMsgDOTALeagueAvailableLobbyNodes* other);
  friend void swap(CMsgDOTALeagueAvailableLobbyNodes& a, CMsgDOTALeagueAvailableLobbyNodes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeagueAvailableLobbyNodes* New() const final {
    return CreateMaybeMessage<CMsgDOTALeagueAvailableLobbyNodes>(nullptr);
  }

  CMsgDOTALeagueAvailableLobbyNodes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeagueAvailableLobbyNodes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeagueAvailableLobbyNodes& from);
  void MergeFrom(const CMsgDOTALeagueAvailableLobbyNodes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueAvailableLobbyNodes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTALeagueAvailableLobbyNodes_NodeInfo NodeInfo;

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo node_infos = 1;
  int node_infos_size() const;
  void clear_node_infos();
  static const int kNodeInfosFieldNumber = 1;
  ::proto::dota::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* mutable_node_infos(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo >*
      mutable_node_infos();
  const ::proto::dota::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& node_infos(int index) const;
  ::proto::dota::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* add_node_infos();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo >&
      node_infos() const;

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeagueAvailableLobbyNodes)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo > node_infos_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueNodeResults_Result final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeagueNodeResults.Result) */ {
 public:
  CMsgDOTALeagueNodeResults_Result();
  virtual ~CMsgDOTALeagueNodeResults_Result();

  CMsgDOTALeagueNodeResults_Result(const CMsgDOTALeagueNodeResults_Result& from);

  inline CMsgDOTALeagueNodeResults_Result& operator=(const CMsgDOTALeagueNodeResults_Result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeagueNodeResults_Result(CMsgDOTALeagueNodeResults_Result&& from) noexcept
    : CMsgDOTALeagueNodeResults_Result() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueNodeResults_Result& operator=(CMsgDOTALeagueNodeResults_Result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeagueNodeResults_Result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeagueNodeResults_Result* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueNodeResults_Result*>(
               &_CMsgDOTALeagueNodeResults_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(CMsgDOTALeagueNodeResults_Result* other);
  friend void swap(CMsgDOTALeagueNodeResults_Result& a, CMsgDOTALeagueNodeResults_Result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeagueNodeResults_Result* New() const final {
    return CreateMaybeMessage<CMsgDOTALeagueNodeResults_Result>(nullptr);
  }

  CMsgDOTALeagueNodeResults_Result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeagueNodeResults_Result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeagueNodeResults_Result& from);
  void MergeFrom(const CMsgDOTALeagueNodeResults_Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueNodeResults_Result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 match_ids = 17;
  int match_ids_size() const;
  void clear_match_ids();
  static const int kMatchIdsFieldNumber = 17;
  ::google::protobuf::uint64 match_ids(int index) const;
  void set_match_ids(int index, ::google::protobuf::uint64 value);
  void add_match_ids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      match_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_match_ids();

  // optional string team_1_name = 8;
  bool has_team_1_name() const;
  void clear_team_1_name();
  static const int kTeam1NameFieldNumber = 8;
  const ::std::string& team_1_name() const;
  void set_team_1_name(const ::std::string& value);
  #if LANG_CXX11
  void set_team_1_name(::std::string&& value);
  #endif
  void set_team_1_name(const char* value);
  void set_team_1_name(const char* value, size_t size);
  ::std::string* mutable_team_1_name();
  ::std::string* release_team_1_name();
  void set_allocated_team_1_name(::std::string* team_1_name);

  // optional string team_2_name = 9;
  bool has_team_2_name() const;
  void clear_team_2_name();
  static const int kTeam2NameFieldNumber = 9;
  const ::std::string& team_2_name() const;
  void set_team_2_name(const ::std::string& value);
  #if LANG_CXX11
  void set_team_2_name(::std::string&& value);
  #endif
  void set_team_2_name(const char* value);
  void set_team_2_name(const char* value, size_t size);
  ::std::string* mutable_team_2_name();
  ::std::string* release_team_2_name();
  void set_allocated_team_2_name(::std::string* team_2_name);

  // optional uint32 node_id = 1;
  bool has_node_id() const;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  ::google::protobuf::uint32 node_id() const;
  void set_node_id(::google::protobuf::uint32 value);

  // optional uint32 winning_node_id = 2;
  bool has_winning_node_id() const;
  void clear_winning_node_id();
  static const int kWinningNodeIdFieldNumber = 2;
  ::google::protobuf::uint32 winning_node_id() const;
  void set_winning_node_id(::google::protobuf::uint32 value);

  // optional uint32 losing_node_id = 3;
  bool has_losing_node_id() const;
  void clear_losing_node_id();
  static const int kLosingNodeIdFieldNumber = 3;
  ::google::protobuf::uint32 losing_node_id() const;
  void set_losing_node_id(::google::protobuf::uint32 value);

  // optional uint32 incoming_node_id_1 = 4;
  bool has_incoming_node_id_1() const;
  void clear_incoming_node_id_1();
  static const int kIncomingNodeId1FieldNumber = 4;
  ::google::protobuf::uint32 incoming_node_id_1() const;
  void set_incoming_node_id_1(::google::protobuf::uint32 value);

  // optional uint32 incoming_node_id_2 = 5;
  bool has_incoming_node_id_2() const;
  void clear_incoming_node_id_2();
  static const int kIncomingNodeId2FieldNumber = 5;
  ::google::protobuf::uint32 incoming_node_id_2() const;
  void set_incoming_node_id_2(::google::protobuf::uint32 value);

  // optional uint32 team_id_1 = 6;
  bool has_team_id_1() const;
  void clear_team_id_1();
  static const int kTeamId1FieldNumber = 6;
  ::google::protobuf::uint32 team_id_1() const;
  void set_team_id_1(::google::protobuf::uint32 value);

  // optional uint32 team_id_2 = 7;
  bool has_team_id_2() const;
  void clear_team_id_2();
  static const int kTeamId2FieldNumber = 7;
  ::google::protobuf::uint32 team_id_2() const;
  void set_team_id_2(::google::protobuf::uint32 value);

  // optional uint32 team_1_wins = 10;
  bool has_team_1_wins() const;
  void clear_team_1_wins();
  static const int kTeam1WinsFieldNumber = 10;
  ::google::protobuf::uint32 team_1_wins() const;
  void set_team_1_wins(::google::protobuf::uint32 value);

  // optional uint32 team_2_wins = 11;
  bool has_team_2_wins() const;
  void clear_team_2_wins();
  static const int kTeam2WinsFieldNumber = 11;
  ::google::protobuf::uint32 team_2_wins() const;
  void set_team_2_wins(::google::protobuf::uint32 value);

  // optional uint32 winning_team_id = 12;
  bool has_winning_team_id() const;
  void clear_winning_team_id();
  static const int kWinningTeamIdFieldNumber = 12;
  ::google::protobuf::uint32 winning_team_id() const;
  void set_winning_team_id(::google::protobuf::uint32 value);

  // optional uint32 losing_team_id = 13;
  bool has_losing_team_id() const;
  void clear_losing_team_id();
  static const int kLosingTeamIdFieldNumber = 13;
  ::google::protobuf::uint32 losing_team_id() const;
  void set_losing_team_id(::google::protobuf::uint32 value);

  // optional bool has_started = 14;
  bool has_has_started() const;
  void clear_has_started();
  static const int kHasStartedFieldNumber = 14;
  bool has_started() const;
  void set_has_started(bool value);

  // optional bool is_completed = 15;
  bool has_is_completed() const;
  void clear_is_completed();
  static const int kIsCompletedFieldNumber = 15;
  bool is_completed() const;
  void set_is_completed(bool value);

  // optional uint32 scheduled_time = 16;
  bool has_scheduled_time() const;
  void clear_scheduled_time();
  static const int kScheduledTimeFieldNumber = 16;
  ::google::protobuf::uint32 scheduled_time() const;
  void set_scheduled_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeagueNodeResults.Result)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > match_ids_;
  ::google::protobuf::internal::ArenaStringPtr team_1_name_;
  ::google::protobuf::internal::ArenaStringPtr team_2_name_;
  ::google::protobuf::uint32 node_id_;
  ::google::protobuf::uint32 winning_node_id_;
  ::google::protobuf::uint32 losing_node_id_;
  ::google::protobuf::uint32 incoming_node_id_1_;
  ::google::protobuf::uint32 incoming_node_id_2_;
  ::google::protobuf::uint32 team_id_1_;
  ::google::protobuf::uint32 team_id_2_;
  ::google::protobuf::uint32 team_1_wins_;
  ::google::protobuf::uint32 team_2_wins_;
  ::google::protobuf::uint32 winning_team_id_;
  ::google::protobuf::uint32 losing_team_id_;
  bool has_started_;
  bool is_completed_;
  ::google::protobuf::uint32 scheduled_time_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeagueNodeResults final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeagueNodeResults) */ {
 public:
  CMsgDOTALeagueNodeResults();
  virtual ~CMsgDOTALeagueNodeResults();

  CMsgDOTALeagueNodeResults(const CMsgDOTALeagueNodeResults& from);

  inline CMsgDOTALeagueNodeResults& operator=(const CMsgDOTALeagueNodeResults& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeagueNodeResults(CMsgDOTALeagueNodeResults&& from) noexcept
    : CMsgDOTALeagueNodeResults() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeagueNodeResults& operator=(CMsgDOTALeagueNodeResults&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeagueNodeResults& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeagueNodeResults* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeagueNodeResults*>(
               &_CMsgDOTALeagueNodeResults_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(CMsgDOTALeagueNodeResults* other);
  friend void swap(CMsgDOTALeagueNodeResults& a, CMsgDOTALeagueNodeResults& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeagueNodeResults* New() const final {
    return CreateMaybeMessage<CMsgDOTALeagueNodeResults>(nullptr);
  }

  CMsgDOTALeagueNodeResults* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeagueNodeResults>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeagueNodeResults& from);
  void MergeFrom(const CMsgDOTALeagueNodeResults& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeagueNodeResults* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTALeagueNodeResults_Result Result;

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTALeagueNodeResults.Result node_results = 1;
  int node_results_size() const;
  void clear_node_results();
  static const int kNodeResultsFieldNumber = 1;
  ::proto::dota::CMsgDOTALeagueNodeResults_Result* mutable_node_results(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNodeResults_Result >*
      mutable_node_results();
  const ::proto::dota::CMsgDOTALeagueNodeResults_Result& node_results(int index) const;
  ::proto::dota::CMsgDOTALeagueNodeResults_Result* add_node_results();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNodeResults_Result >&
      node_results() const;

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeagueNodeResults)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNodeResults_Result > node_results_;
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5fleague_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CMsgDOTALeagueNode_MatchDetails

// optional uint64 match_id = 1;
inline bool CMsgDOTALeagueNode_MatchDetails::has_match_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTALeagueNode_MatchDetails::clear_match_id() {
  match_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 CMsgDOTALeagueNode_MatchDetails::match_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNode.MatchDetails.match_id)
  return match_id_;
}
inline void CMsgDOTALeagueNode_MatchDetails::set_match_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  match_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNode.MatchDetails.match_id)
}

// optional uint32 winning_team_id = 2;
inline bool CMsgDOTALeagueNode_MatchDetails::has_winning_team_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTALeagueNode_MatchDetails::clear_winning_team_id() {
  winning_team_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNode_MatchDetails::winning_team_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNode.MatchDetails.winning_team_id)
  return winning_team_id_;
}
inline void CMsgDOTALeagueNode_MatchDetails::set_winning_team_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  winning_team_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNode.MatchDetails.winning_team_id)
}

// -------------------------------------------------------------------

// CMsgDOTALeagueNode

// optional string name = 1;
inline bool CMsgDOTALeagueNode::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTALeagueNode::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTALeagueNode::name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNode.name)
  return name_.GetNoArena();
}
inline void CMsgDOTALeagueNode::set_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNode.name)
}
#if LANG_CXX11
inline void CMsgDOTALeagueNode::set_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTALeagueNode.name)
}
#endif
inline void CMsgDOTALeagueNode::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTALeagueNode.name)
}
inline void CMsgDOTALeagueNode::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTALeagueNode.name)
}
inline ::std::string* CMsgDOTALeagueNode::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeagueNode.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTALeagueNode::release_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeagueNode.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTALeagueNode::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeagueNode.name)
}

// optional uint32 node_id = 2;
inline bool CMsgDOTALeagueNode::has_node_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTALeagueNode::clear_node_id() {
  node_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNode::node_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNode.node_id)
  return node_id_;
}
inline void CMsgDOTALeagueNode::set_node_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  node_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNode.node_id)
}

// optional uint32 node_group_id = 3;
inline bool CMsgDOTALeagueNode::has_node_group_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTALeagueNode::clear_node_group_id() {
  node_group_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNode::node_group_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNode.node_group_id)
  return node_group_id_;
}
inline void CMsgDOTALeagueNode::set_node_group_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  node_group_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNode.node_group_id)
}

// optional uint32 winning_node_id = 4;
inline bool CMsgDOTALeagueNode::has_winning_node_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTALeagueNode::clear_winning_node_id() {
  winning_node_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNode::winning_node_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNode.winning_node_id)
  return winning_node_id_;
}
inline void CMsgDOTALeagueNode::set_winning_node_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  winning_node_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNode.winning_node_id)
}

// optional uint32 losing_node_id = 5;
inline bool CMsgDOTALeagueNode::has_losing_node_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTALeagueNode::clear_losing_node_id() {
  losing_node_id_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNode::losing_node_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNode.losing_node_id)
  return losing_node_id_;
}
inline void CMsgDOTALeagueNode::set_losing_node_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  losing_node_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNode.losing_node_id)
}

// optional uint32 incoming_node_id_1 = 6;
inline bool CMsgDOTALeagueNode::has_incoming_node_id_1() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTALeagueNode::clear_incoming_node_id_1() {
  incoming_node_id_1_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNode::incoming_node_id_1() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNode.incoming_node_id_1)
  return incoming_node_id_1_;
}
inline void CMsgDOTALeagueNode::set_incoming_node_id_1(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  incoming_node_id_1_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNode.incoming_node_id_1)
}

// optional uint32 incoming_node_id_2 = 7;
inline bool CMsgDOTALeagueNode::has_incoming_node_id_2() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTALeagueNode::clear_incoming_node_id_2() {
  incoming_node_id_2_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNode::incoming_node_id_2() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNode.incoming_node_id_2)
  return incoming_node_id_2_;
}
inline void CMsgDOTALeagueNode::set_incoming_node_id_2(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  incoming_node_id_2_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNode.incoming_node_id_2)
}

// optional .proto.dota.ELeagueNodeType node_type = 8 [default = INVALID_NODE_TYPE];
inline bool CMsgDOTALeagueNode::has_node_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgDOTALeagueNode::clear_node_type() {
  node_type_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::proto::dota::ELeagueNodeType CMsgDOTALeagueNode::node_type() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNode.node_type)
  return static_cast< ::proto::dota::ELeagueNodeType >(node_type_);
}
inline void CMsgDOTALeagueNode::set_node_type(::proto::dota::ELeagueNodeType value) {
  assert(::proto::dota::ELeagueNodeType_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  node_type_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNode.node_type)
}

// optional uint32 scheduled_time = 9;
inline bool CMsgDOTALeagueNode::has_scheduled_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgDOTALeagueNode::clear_scheduled_time() {
  scheduled_time_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNode::scheduled_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNode.scheduled_time)
  return scheduled_time_;
}
inline void CMsgDOTALeagueNode::set_scheduled_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  scheduled_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNode.scheduled_time)
}

// optional uint32 actual_time = 19;
inline bool CMsgDOTALeagueNode::has_actual_time() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CMsgDOTALeagueNode::clear_actual_time() {
  actual_time_ = 0u;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNode::actual_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNode.actual_time)
  return actual_time_;
}
inline void CMsgDOTALeagueNode::set_actual_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00010000u;
  actual_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNode.actual_time)
}

// optional uint32 series_id = 10;
inline bool CMsgDOTALeagueNode::has_series_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgDOTALeagueNode::clear_series_id() {
  series_id_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNode::series_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNode.series_id)
  return series_id_;
}
inline void CMsgDOTALeagueNode::set_series_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  series_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNode.series_id)
}

// optional uint32 team_id_1 = 11;
inline bool CMsgDOTALeagueNode::has_team_id_1() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgDOTALeagueNode::clear_team_id_1() {
  team_id_1_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNode::team_id_1() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNode.team_id_1)
  return team_id_1_;
}
inline void CMsgDOTALeagueNode::set_team_id_1(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000400u;
  team_id_1_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNode.team_id_1)
}

// optional uint32 team_id_2 = 12;
inline bool CMsgDOTALeagueNode::has_team_id_2() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgDOTALeagueNode::clear_team_id_2() {
  team_id_2_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNode::team_id_2() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNode.team_id_2)
  return team_id_2_;
}
inline void CMsgDOTALeagueNode::set_team_id_2(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000800u;
  team_id_2_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNode.team_id_2)
}

// repeated .proto.dota.CMsgDOTALeagueNode.MatchDetails matches = 13;
inline int CMsgDOTALeagueNode::matches_size() const {
  return matches_.size();
}
inline void CMsgDOTALeagueNode::clear_matches() {
  matches_.Clear();
}
inline ::proto::dota::CMsgDOTALeagueNode_MatchDetails* CMsgDOTALeagueNode::mutable_matches(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeagueNode.matches)
  return matches_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNode_MatchDetails >*
CMsgDOTALeagueNode::mutable_matches() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTALeagueNode.matches)
  return &matches_;
}
inline const ::proto::dota::CMsgDOTALeagueNode_MatchDetails& CMsgDOTALeagueNode::matches(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNode.matches)
  return matches_.Get(index);
}
inline ::proto::dota::CMsgDOTALeagueNode_MatchDetails* CMsgDOTALeagueNode::add_matches() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTALeagueNode.matches)
  return matches_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNode_MatchDetails >&
CMsgDOTALeagueNode::matches() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTALeagueNode.matches)
  return matches_;
}

// optional uint32 team_1_wins = 14;
inline bool CMsgDOTALeagueNode::has_team_1_wins() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgDOTALeagueNode::clear_team_1_wins() {
  team_1_wins_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNode::team_1_wins() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNode.team_1_wins)
  return team_1_wins_;
}
inline void CMsgDOTALeagueNode::set_team_1_wins(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00001000u;
  team_1_wins_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNode.team_1_wins)
}

// optional uint32 team_2_wins = 15;
inline bool CMsgDOTALeagueNode::has_team_2_wins() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgDOTALeagueNode::clear_team_2_wins() {
  team_2_wins_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNode::team_2_wins() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNode.team_2_wins)
  return team_2_wins_;
}
inline void CMsgDOTALeagueNode::set_team_2_wins(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00002000u;
  team_2_wins_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNode.team_2_wins)
}

// optional bool has_started = 16;
inline bool CMsgDOTALeagueNode::has_has_started() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CMsgDOTALeagueNode::clear_has_started() {
  has_started_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool CMsgDOTALeagueNode::has_started() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNode.has_started)
  return has_started_;
}
inline void CMsgDOTALeagueNode::set_has_started(bool value) {
  _has_bits_[0] |= 0x00004000u;
  has_started_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNode.has_started)
}

// optional bool is_completed = 17;
inline bool CMsgDOTALeagueNode::has_is_completed() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CMsgDOTALeagueNode::clear_is_completed() {
  is_completed_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool CMsgDOTALeagueNode::is_completed() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNode.is_completed)
  return is_completed_;
}
inline void CMsgDOTALeagueNode::set_is_completed(bool value) {
  _has_bits_[0] |= 0x00008000u;
  is_completed_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNode.is_completed)
}

// repeated uint32 stream_ids = 18;
inline int CMsgDOTALeagueNode::stream_ids_size() const {
  return stream_ids_.size();
}
inline void CMsgDOTALeagueNode::clear_stream_ids() {
  stream_ids_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNode::stream_ids(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNode.stream_ids)
  return stream_ids_.Get(index);
}
inline void CMsgDOTALeagueNode::set_stream_ids(int index, ::google::protobuf::uint32 value) {
  stream_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNode.stream_ids)
}
inline void CMsgDOTALeagueNode::add_stream_ids(::google::protobuf::uint32 value) {
  stream_ids_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTALeagueNode.stream_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTALeagueNode::stream_ids() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTALeagueNode.stream_ids)
  return stream_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTALeagueNode::mutable_stream_ids() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTALeagueNode.stream_ids)
  return &stream_ids_;
}

// -------------------------------------------------------------------

// CMsgDOTALeagueNodeGroup_TeamStanding

// optional uint32 standing = 1;
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::has_standing() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::clear_standing() {
  standing_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeGroup_TeamStanding::standing() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.standing)
  return standing_;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_standing(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  standing_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.standing)
}

// optional uint32 team_id = 2;
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::has_team_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::clear_team_id() {
  team_id_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeGroup_TeamStanding::team_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_id)
  return team_id_;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_team_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  team_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_id)
}

// optional string team_name = 3;
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::has_team_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::clear_team_name() {
  team_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTALeagueNodeGroup_TeamStanding::team_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_name)
  return team_name_.GetNoArena();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_team_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_name)
}
#if LANG_CXX11
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_team_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_name)
}
#endif
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_team_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_name)
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_team_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_name)
}
inline ::std::string* CMsgDOTALeagueNodeGroup_TeamStanding::mutable_team_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_name)
  return team_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTALeagueNodeGroup_TeamStanding::release_team_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_name)
  if (!has_team_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return team_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_allocated_team_name(::std::string* team_name) {
  if (team_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  team_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_name)
}

// optional string team_tag = 4;
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::has_team_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::clear_team_tag() {
  team_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgDOTALeagueNodeGroup_TeamStanding::team_tag() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_tag)
  return team_tag_.GetNoArena();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_team_tag(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  team_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_tag)
}
#if LANG_CXX11
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_team_tag(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  team_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_tag)
}
#endif
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_team_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  team_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_tag)
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_team_tag(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  team_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_tag)
}
inline ::std::string* CMsgDOTALeagueNodeGroup_TeamStanding::mutable_team_tag() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_tag)
  return team_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTALeagueNodeGroup_TeamStanding::release_team_tag() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_tag)
  if (!has_team_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return team_tag_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_allocated_team_tag(::std::string* team_tag) {
  if (team_tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  team_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team_tag);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_tag)
}

// optional uint64 team_logo = 5;
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::has_team_logo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::clear_team_logo() {
  team_logo_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint64 CMsgDOTALeagueNodeGroup_TeamStanding::team_logo() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_logo)
  return team_logo_;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_team_logo(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  team_logo_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_logo)
}

// optional string team_logo_url = 6;
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::has_team_logo_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::clear_team_logo_url() {
  team_logo_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& CMsgDOTALeagueNodeGroup_TeamStanding::team_logo_url() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_logo_url)
  return team_logo_url_.GetNoArena();
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_team_logo_url(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  team_logo_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_logo_url)
}
#if LANG_CXX11
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_team_logo_url(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  team_logo_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_logo_url)
}
#endif
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_team_logo_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  team_logo_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_logo_url)
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_team_logo_url(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  team_logo_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_logo_url)
}
inline ::std::string* CMsgDOTALeagueNodeGroup_TeamStanding::mutable_team_logo_url() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_logo_url)
  return team_logo_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTALeagueNodeGroup_TeamStanding::release_team_logo_url() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_logo_url)
  if (!has_team_logo_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return team_logo_url_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_allocated_team_logo_url(::std::string* team_logo_url) {
  if (team_logo_url != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  team_logo_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team_logo_url);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.team_logo_url)
}

// optional uint32 wins = 7;
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::has_wins() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::clear_wins() {
  wins_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeGroup_TeamStanding::wins() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.wins)
  return wins_;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_wins(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  wins_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.wins)
}

// optional uint32 losses = 8;
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::has_losses() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::clear_losses() {
  losses_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeGroup_TeamStanding::losses() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.losses)
  return losses_;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_losses(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  losses_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.losses)
}

// optional int64 score = 9;
inline bool CMsgDOTALeagueNodeGroup_TeamStanding::has_score() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::clear_score() {
  score_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::int64 CMsgDOTALeagueNodeGroup_TeamStanding::score() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.score)
  return score_;
}
inline void CMsgDOTALeagueNodeGroup_TeamStanding::set_score(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000100u;
  score_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding.score)
}

// -------------------------------------------------------------------

// CMsgDOTALeagueNodeGroup

// optional string name = 1;
inline bool CMsgDOTALeagueNodeGroup::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTALeagueNodeGroup::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTALeagueNodeGroup::name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.name)
  return name_.GetNoArena();
}
inline void CMsgDOTALeagueNodeGroup::set_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.name)
}
#if LANG_CXX11
inline void CMsgDOTALeagueNodeGroup::set_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTALeagueNodeGroup.name)
}
#endif
inline void CMsgDOTALeagueNodeGroup::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTALeagueNodeGroup.name)
}
inline void CMsgDOTALeagueNodeGroup::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTALeagueNodeGroup.name)
}
inline ::std::string* CMsgDOTALeagueNodeGroup::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeagueNodeGroup.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTALeagueNodeGroup::release_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeagueNodeGroup.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTALeagueNodeGroup::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeagueNodeGroup.name)
}

// optional uint32 node_group_id = 2;
inline bool CMsgDOTALeagueNodeGroup::has_node_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTALeagueNodeGroup::clear_node_group_id() {
  node_group_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeGroup::node_group_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.node_group_id)
  return node_group_id_;
}
inline void CMsgDOTALeagueNodeGroup::set_node_group_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  node_group_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.node_group_id)
}

// optional uint32 parent_node_group_id = 3;
inline bool CMsgDOTALeagueNodeGroup::has_parent_node_group_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTALeagueNodeGroup::clear_parent_node_group_id() {
  parent_node_group_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeGroup::parent_node_group_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.parent_node_group_id)
  return parent_node_group_id_;
}
inline void CMsgDOTALeagueNodeGroup::set_parent_node_group_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  parent_node_group_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.parent_node_group_id)
}

// repeated uint32 incoming_node_group_ids = 4;
inline int CMsgDOTALeagueNodeGroup::incoming_node_group_ids_size() const {
  return incoming_node_group_ids_.size();
}
inline void CMsgDOTALeagueNodeGroup::clear_incoming_node_group_ids() {
  incoming_node_group_ids_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeGroup::incoming_node_group_ids(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.incoming_node_group_ids)
  return incoming_node_group_ids_.Get(index);
}
inline void CMsgDOTALeagueNodeGroup::set_incoming_node_group_ids(int index, ::google::protobuf::uint32 value) {
  incoming_node_group_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.incoming_node_group_ids)
}
inline void CMsgDOTALeagueNodeGroup::add_incoming_node_group_ids(::google::protobuf::uint32 value) {
  incoming_node_group_ids_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTALeagueNodeGroup.incoming_node_group_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTALeagueNodeGroup::incoming_node_group_ids() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTALeagueNodeGroup.incoming_node_group_ids)
  return incoming_node_group_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTALeagueNodeGroup::mutable_incoming_node_group_ids() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTALeagueNodeGroup.incoming_node_group_ids)
  return &incoming_node_group_ids_;
}

// optional uint32 advancing_node_group_id = 5;
inline bool CMsgDOTALeagueNodeGroup::has_advancing_node_group_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTALeagueNodeGroup::clear_advancing_node_group_id() {
  advancing_node_group_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeGroup::advancing_node_group_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.advancing_node_group_id)
  return advancing_node_group_id_;
}
inline void CMsgDOTALeagueNodeGroup::set_advancing_node_group_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  advancing_node_group_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.advancing_node_group_id)
}

// optional uint32 advancing_team_count = 6;
inline bool CMsgDOTALeagueNodeGroup::has_advancing_team_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTALeagueNodeGroup::clear_advancing_team_count() {
  advancing_team_count_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeGroup::advancing_team_count() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.advancing_team_count)
  return advancing_team_count_;
}
inline void CMsgDOTALeagueNodeGroup::set_advancing_team_count(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  advancing_team_count_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.advancing_team_count)
}

// optional uint32 team_count = 7;
inline bool CMsgDOTALeagueNodeGroup::has_team_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTALeagueNodeGroup::clear_team_count() {
  team_count_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeGroup::team_count() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.team_count)
  return team_count_;
}
inline void CMsgDOTALeagueNodeGroup::set_team_count(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  team_count_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.team_count)
}

// optional .proto.dota.ELeagueNodeGroupType node_group_type = 8 [default = INVALID_GROUP_TYPE];
inline bool CMsgDOTALeagueNodeGroup::has_node_group_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTALeagueNodeGroup::clear_node_group_type() {
  node_group_type_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::proto::dota::ELeagueNodeGroupType CMsgDOTALeagueNodeGroup::node_group_type() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.node_group_type)
  return static_cast< ::proto::dota::ELeagueNodeGroupType >(node_group_type_);
}
inline void CMsgDOTALeagueNodeGroup::set_node_group_type(::proto::dota::ELeagueNodeGroupType value) {
  assert(::proto::dota::ELeagueNodeGroupType_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  node_group_type_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.node_group_type)
}

// optional .proto.dota.ELeagueNodeType default_node_type = 9 [default = INVALID_NODE_TYPE];
inline bool CMsgDOTALeagueNodeGroup::has_default_node_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgDOTALeagueNodeGroup::clear_default_node_type() {
  default_node_type_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::proto::dota::ELeagueNodeType CMsgDOTALeagueNodeGroup::default_node_type() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.default_node_type)
  return static_cast< ::proto::dota::ELeagueNodeType >(default_node_type_);
}
inline void CMsgDOTALeagueNodeGroup::set_default_node_type(::proto::dota::ELeagueNodeType value) {
  assert(::proto::dota::ELeagueNodeType_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  default_node_type_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.default_node_type)
}

// optional uint32 round = 10;
inline bool CMsgDOTALeagueNodeGroup::has_round() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgDOTALeagueNodeGroup::clear_round() {
  round_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeGroup::round() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.round)
  return round_;
}
inline void CMsgDOTALeagueNodeGroup::set_round(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  round_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.round)
}

// optional uint32 max_rounds = 11;
inline bool CMsgDOTALeagueNodeGroup::has_max_rounds() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgDOTALeagueNodeGroup::clear_max_rounds() {
  max_rounds_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeGroup::max_rounds() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.max_rounds)
  return max_rounds_;
}
inline void CMsgDOTALeagueNodeGroup::set_max_rounds(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  max_rounds_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.max_rounds)
}

// optional bool is_tiebreaker = 12;
inline bool CMsgDOTALeagueNodeGroup::has_is_tiebreaker() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgDOTALeagueNodeGroup::clear_is_tiebreaker() {
  is_tiebreaker_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool CMsgDOTALeagueNodeGroup::is_tiebreaker() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.is_tiebreaker)
  return is_tiebreaker_;
}
inline void CMsgDOTALeagueNodeGroup::set_is_tiebreaker(bool value) {
  _has_bits_[0] |= 0x00000400u;
  is_tiebreaker_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.is_tiebreaker)
}

// optional bool is_final_group = 13;
inline bool CMsgDOTALeagueNodeGroup::has_is_final_group() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgDOTALeagueNodeGroup::clear_is_final_group() {
  is_final_group_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool CMsgDOTALeagueNodeGroup::is_final_group() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.is_final_group)
  return is_final_group_;
}
inline void CMsgDOTALeagueNodeGroup::set_is_final_group(bool value) {
  _has_bits_[0] |= 0x00000800u;
  is_final_group_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.is_final_group)
}

// optional bool is_completed = 14;
inline bool CMsgDOTALeagueNodeGroup::has_is_completed() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgDOTALeagueNodeGroup::clear_is_completed() {
  is_completed_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool CMsgDOTALeagueNodeGroup::is_completed() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.is_completed)
  return is_completed_;
}
inline void CMsgDOTALeagueNodeGroup::set_is_completed(bool value) {
  _has_bits_[0] |= 0x00001000u;
  is_completed_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.is_completed)
}

// optional .proto.dota.ELeaguePhase phase = 18 [default = LEAGUE_PHASE_UNSET];
inline bool CMsgDOTALeagueNodeGroup::has_phase() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgDOTALeagueNodeGroup::clear_phase() {
  phase_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::proto::dota::ELeaguePhase CMsgDOTALeagueNodeGroup::phase() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.phase)
  return static_cast< ::proto::dota::ELeaguePhase >(phase_);
}
inline void CMsgDOTALeagueNodeGroup::set_phase(::proto::dota::ELeaguePhase value) {
  assert(::proto::dota::ELeaguePhase_IsValid(value));
  _has_bits_[0] |= 0x00002000u;
  phase_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.phase)
}

// optional .proto.dota.ELeagueRegion region = 19 [default = LEAGUE_REGION_UNSET];
inline bool CMsgDOTALeagueNodeGroup::has_region() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CMsgDOTALeagueNodeGroup::clear_region() {
  region_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::proto::dota::ELeagueRegion CMsgDOTALeagueNodeGroup::region() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.region)
  return static_cast< ::proto::dota::ELeagueRegion >(region_);
}
inline void CMsgDOTALeagueNodeGroup::set_region(::proto::dota::ELeagueRegion value) {
  assert(::proto::dota::ELeagueRegion_IsValid(value));
  _has_bits_[0] |= 0x00004000u;
  region_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.region)
}

// optional uint32 start_time = 20;
inline bool CMsgDOTALeagueNodeGroup::has_start_time() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CMsgDOTALeagueNodeGroup::clear_start_time() {
  start_time_ = 0u;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeGroup::start_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.start_time)
  return start_time_;
}
inline void CMsgDOTALeagueNodeGroup::set_start_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00008000u;
  start_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.start_time)
}

// optional uint32 end_time = 21;
inline bool CMsgDOTALeagueNodeGroup::has_end_time() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CMsgDOTALeagueNodeGroup::clear_end_time() {
  end_time_ = 0u;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeGroup::end_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.end_time)
  return end_time_;
}
inline void CMsgDOTALeagueNodeGroup::set_end_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00010000u;
  end_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeGroup.end_time)
}

// repeated .proto.dota.CMsgDOTALeagueNodeGroup.TeamStanding team_standings = 15;
inline int CMsgDOTALeagueNodeGroup::team_standings_size() const {
  return team_standings_.size();
}
inline void CMsgDOTALeagueNodeGroup::clear_team_standings() {
  team_standings_.Clear();
}
inline ::proto::dota::CMsgDOTALeagueNodeGroup_TeamStanding* CMsgDOTALeagueNodeGroup::mutable_team_standings(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeagueNodeGroup.team_standings)
  return team_standings_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNodeGroup_TeamStanding >*
CMsgDOTALeagueNodeGroup::mutable_team_standings() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTALeagueNodeGroup.team_standings)
  return &team_standings_;
}
inline const ::proto::dota::CMsgDOTALeagueNodeGroup_TeamStanding& CMsgDOTALeagueNodeGroup::team_standings(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.team_standings)
  return team_standings_.Get(index);
}
inline ::proto::dota::CMsgDOTALeagueNodeGroup_TeamStanding* CMsgDOTALeagueNodeGroup::add_team_standings() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTALeagueNodeGroup.team_standings)
  return team_standings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNodeGroup_TeamStanding >&
CMsgDOTALeagueNodeGroup::team_standings() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTALeagueNodeGroup.team_standings)
  return team_standings_;
}

// repeated .proto.dota.CMsgDOTALeagueNode nodes = 16;
inline int CMsgDOTALeagueNodeGroup::nodes_size() const {
  return nodes_.size();
}
inline void CMsgDOTALeagueNodeGroup::clear_nodes() {
  nodes_.Clear();
}
inline ::proto::dota::CMsgDOTALeagueNode* CMsgDOTALeagueNodeGroup::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeagueNodeGroup.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNode >*
CMsgDOTALeagueNodeGroup::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTALeagueNodeGroup.nodes)
  return &nodes_;
}
inline const ::proto::dota::CMsgDOTALeagueNode& CMsgDOTALeagueNodeGroup::nodes(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.nodes)
  return nodes_.Get(index);
}
inline ::proto::dota::CMsgDOTALeagueNode* CMsgDOTALeagueNodeGroup::add_nodes() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTALeagueNodeGroup.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNode >&
CMsgDOTALeagueNodeGroup::nodes() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTALeagueNodeGroup.nodes)
  return nodes_;
}

// repeated .proto.dota.CMsgDOTALeagueNodeGroup node_groups = 17;
inline int CMsgDOTALeagueNodeGroup::node_groups_size() const {
  return node_groups_.size();
}
inline void CMsgDOTALeagueNodeGroup::clear_node_groups() {
  node_groups_.Clear();
}
inline ::proto::dota::CMsgDOTALeagueNodeGroup* CMsgDOTALeagueNodeGroup::mutable_node_groups(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeagueNodeGroup.node_groups)
  return node_groups_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNodeGroup >*
CMsgDOTALeagueNodeGroup::mutable_node_groups() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTALeagueNodeGroup.node_groups)
  return &node_groups_;
}
inline const ::proto::dota::CMsgDOTALeagueNodeGroup& CMsgDOTALeagueNodeGroup::node_groups(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeGroup.node_groups)
  return node_groups_.Get(index);
}
inline ::proto::dota::CMsgDOTALeagueNodeGroup* CMsgDOTALeagueNodeGroup::add_node_groups() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTALeagueNodeGroup.node_groups)
  return node_groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNodeGroup >&
CMsgDOTALeagueNodeGroup::node_groups() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTALeagueNodeGroup.node_groups)
  return node_groups_;
}

// -------------------------------------------------------------------

// CMsgDOTALeague_Info

// optional uint32 league_id = 1;
inline bool CMsgDOTALeague_Info::has_league_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTALeague_Info::clear_league_id() {
  league_id_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgDOTALeague_Info::league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Info.league_id)
  return league_id_;
}
inline void CMsgDOTALeague_Info::set_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Info.league_id)
}

// optional string name = 2;
inline bool CMsgDOTALeague_Info::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTALeague_Info::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTALeague_Info::name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Info.name)
  return name_.GetNoArena();
}
inline void CMsgDOTALeague_Info::set_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Info.name)
}
#if LANG_CXX11
inline void CMsgDOTALeague_Info::set_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTALeague.Info.name)
}
#endif
inline void CMsgDOTALeague_Info::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTALeague.Info.name)
}
inline void CMsgDOTALeague_Info::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTALeague.Info.name)
}
inline ::std::string* CMsgDOTALeague_Info::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeague.Info.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTALeague_Info::release_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeague.Info.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTALeague_Info::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeague.Info.name)
}

// optional .proto.dota.ELeagueTier tier = 3 [default = LEAGUE_TIER_UNSET];
inline bool CMsgDOTALeague_Info::has_tier() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTALeague_Info::clear_tier() {
  tier_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::proto::dota::ELeagueTier CMsgDOTALeague_Info::tier() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Info.tier)
  return static_cast< ::proto::dota::ELeagueTier >(tier_);
}
inline void CMsgDOTALeague_Info::set_tier(::proto::dota::ELeagueTier value) {
  assert(::proto::dota::ELeagueTier_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  tier_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Info.tier)
}

// optional .proto.dota.ELeagueRegion region = 4 [default = LEAGUE_REGION_UNSET];
inline bool CMsgDOTALeague_Info::has_region() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTALeague_Info::clear_region() {
  region_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::proto::dota::ELeagueRegion CMsgDOTALeague_Info::region() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Info.region)
  return static_cast< ::proto::dota::ELeagueRegion >(region_);
}
inline void CMsgDOTALeague_Info::set_region(::proto::dota::ELeagueRegion value) {
  assert(::proto::dota::ELeagueRegion_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  region_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Info.region)
}

// optional string url = 5;
inline bool CMsgDOTALeague_Info::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTALeague_Info::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgDOTALeague_Info::url() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Info.url)
  return url_.GetNoArena();
}
inline void CMsgDOTALeague_Info::set_url(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Info.url)
}
#if LANG_CXX11
inline void CMsgDOTALeague_Info::set_url(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTALeague.Info.url)
}
#endif
inline void CMsgDOTALeague_Info::set_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTALeague.Info.url)
}
inline void CMsgDOTALeague_Info::set_url(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTALeague.Info.url)
}
inline ::std::string* CMsgDOTALeague_Info::mutable_url() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeague.Info.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTALeague_Info::release_url() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeague.Info.url)
  if (!has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return url_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTALeague_Info::set_allocated_url(::std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeague.Info.url)
}

// optional string description = 6;
inline bool CMsgDOTALeague_Info::has_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTALeague_Info::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& CMsgDOTALeague_Info::description() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Info.description)
  return description_.GetNoArena();
}
inline void CMsgDOTALeague_Info::set_description(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Info.description)
}
#if LANG_CXX11
inline void CMsgDOTALeague_Info::set_description(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTALeague.Info.description)
}
#endif
inline void CMsgDOTALeague_Info::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTALeague.Info.description)
}
inline void CMsgDOTALeague_Info::set_description(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTALeague.Info.description)
}
inline ::std::string* CMsgDOTALeague_Info::mutable_description() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeague.Info.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTALeague_Info::release_description() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeague.Info.description)
  if (!has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return description_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTALeague_Info::set_allocated_description(::std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeague.Info.description)
}

// optional string notes = 7;
inline bool CMsgDOTALeague_Info::has_notes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTALeague_Info::clear_notes() {
  notes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& CMsgDOTALeague_Info::notes() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Info.notes)
  return notes_.GetNoArena();
}
inline void CMsgDOTALeague_Info::set_notes(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  notes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Info.notes)
}
#if LANG_CXX11
inline void CMsgDOTALeague_Info::set_notes(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  notes_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTALeague.Info.notes)
}
#endif
inline void CMsgDOTALeague_Info::set_notes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  notes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTALeague.Info.notes)
}
inline void CMsgDOTALeague_Info::set_notes(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  notes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTALeague.Info.notes)
}
inline ::std::string* CMsgDOTALeague_Info::mutable_notes() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeague.Info.notes)
  return notes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTALeague_Info::release_notes() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeague.Info.notes)
  if (!has_notes()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return notes_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTALeague_Info::set_allocated_notes(::std::string* notes) {
  if (notes != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  notes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), notes);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeague.Info.notes)
}

// optional uint32 start_timestamp = 8;
inline bool CMsgDOTALeague_Info::has_start_timestamp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgDOTALeague_Info::clear_start_timestamp() {
  start_timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 CMsgDOTALeague_Info::start_timestamp() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Info.start_timestamp)
  return start_timestamp_;
}
inline void CMsgDOTALeague_Info::set_start_timestamp(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  start_timestamp_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Info.start_timestamp)
}

// optional uint32 end_timestamp = 9;
inline bool CMsgDOTALeague_Info::has_end_timestamp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgDOTALeague_Info::clear_end_timestamp() {
  end_timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint32 CMsgDOTALeague_Info::end_timestamp() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Info.end_timestamp)
  return end_timestamp_;
}
inline void CMsgDOTALeague_Info::set_end_timestamp(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  end_timestamp_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Info.end_timestamp)
}

// optional uint32 pro_circuit_points = 10;
inline bool CMsgDOTALeague_Info::has_pro_circuit_points() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgDOTALeague_Info::clear_pro_circuit_points() {
  pro_circuit_points_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::google::protobuf::uint32 CMsgDOTALeague_Info::pro_circuit_points() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Info.pro_circuit_points)
  return pro_circuit_points_;
}
inline void CMsgDOTALeague_Info::set_pro_circuit_points(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  pro_circuit_points_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Info.pro_circuit_points)
}

// optional uint32 image_bits = 11;
inline bool CMsgDOTALeague_Info::has_image_bits() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgDOTALeague_Info::clear_image_bits() {
  image_bits_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::google::protobuf::uint32 CMsgDOTALeague_Info::image_bits() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Info.image_bits)
  return image_bits_;
}
inline void CMsgDOTALeague_Info::set_image_bits(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000400u;
  image_bits_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Info.image_bits)
}

// optional .proto.dota.ELeagueStatus status = 12 [default = LEAGUE_STATUS_UNSET];
inline bool CMsgDOTALeague_Info::has_status() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgDOTALeague_Info::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::proto::dota::ELeagueStatus CMsgDOTALeague_Info::status() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Info.status)
  return static_cast< ::proto::dota::ELeagueStatus >(status_);
}
inline void CMsgDOTALeague_Info::set_status(::proto::dota::ELeagueStatus value) {
  assert(::proto::dota::ELeagueStatus_IsValid(value));
  _has_bits_[0] |= 0x00000800u;
  status_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Info.status)
}

// optional uint32 most_recent_activity = 13;
inline bool CMsgDOTALeague_Info::has_most_recent_activity() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgDOTALeague_Info::clear_most_recent_activity() {
  most_recent_activity_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::google::protobuf::uint32 CMsgDOTALeague_Info::most_recent_activity() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Info.most_recent_activity)
  return most_recent_activity_;
}
inline void CMsgDOTALeague_Info::set_most_recent_activity(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00001000u;
  most_recent_activity_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Info.most_recent_activity)
}

// optional uint32 registration_period = 14;
inline bool CMsgDOTALeague_Info::has_registration_period() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgDOTALeague_Info::clear_registration_period() {
  registration_period_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::google::protobuf::uint32 CMsgDOTALeague_Info::registration_period() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Info.registration_period)
  return registration_period_;
}
inline void CMsgDOTALeague_Info::set_registration_period(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00002000u;
  registration_period_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Info.registration_period)
}

// -------------------------------------------------------------------

// CMsgDOTALeague_Admin

// optional uint32 account_id = 1;
inline bool CMsgDOTALeague_Admin::has_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTALeague_Admin::clear_account_id() {
  account_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTALeague_Admin::account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Admin.account_id)
  return account_id_;
}
inline void CMsgDOTALeague_Admin::set_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Admin.account_id)
}

// optional bool is_primary = 2;
inline bool CMsgDOTALeague_Admin::has_is_primary() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTALeague_Admin::clear_is_primary() {
  is_primary_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CMsgDOTALeague_Admin::is_primary() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Admin.is_primary)
  return is_primary_;
}
inline void CMsgDOTALeague_Admin::set_is_primary(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_primary_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Admin.is_primary)
}

// optional string email_address = 3;
inline bool CMsgDOTALeague_Admin::has_email_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTALeague_Admin::clear_email_address() {
  email_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTALeague_Admin::email_address() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Admin.email_address)
  return email_address_.GetNoArena();
}
inline void CMsgDOTALeague_Admin::set_email_address(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  email_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Admin.email_address)
}
#if LANG_CXX11
inline void CMsgDOTALeague_Admin::set_email_address(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  email_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTALeague.Admin.email_address)
}
#endif
inline void CMsgDOTALeague_Admin::set_email_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  email_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTALeague.Admin.email_address)
}
inline void CMsgDOTALeague_Admin::set_email_address(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  email_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTALeague.Admin.email_address)
}
inline ::std::string* CMsgDOTALeague_Admin::mutable_email_address() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeague.Admin.email_address)
  return email_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTALeague_Admin::release_email_address() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeague.Admin.email_address)
  if (!has_email_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return email_address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTALeague_Admin::set_allocated_email_address(::std::string* email_address) {
  if (email_address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  email_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email_address);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeague.Admin.email_address)
}

// -------------------------------------------------------------------

// CMsgDOTALeague_PrizePoolItem

// optional uint32 item_def = 1;
inline bool CMsgDOTALeague_PrizePoolItem::has_item_def() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTALeague_PrizePoolItem::clear_item_def() {
  item_def_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTALeague_PrizePoolItem::item_def() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.PrizePoolItem.item_def)
  return item_def_;
}
inline void CMsgDOTALeague_PrizePoolItem::set_item_def(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  item_def_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.PrizePoolItem.item_def)
}

// optional uint32 sales_stop_timestamp = 2;
inline bool CMsgDOTALeague_PrizePoolItem::has_sales_stop_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTALeague_PrizePoolItem::clear_sales_stop_timestamp() {
  sales_stop_timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTALeague_PrizePoolItem::sales_stop_timestamp() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.PrizePoolItem.sales_stop_timestamp)
  return sales_stop_timestamp_;
}
inline void CMsgDOTALeague_PrizePoolItem::set_sales_stop_timestamp(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  sales_stop_timestamp_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.PrizePoolItem.sales_stop_timestamp)
}

// optional uint32 revenue_pct = 3;
inline bool CMsgDOTALeague_PrizePoolItem::has_revenue_pct() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTALeague_PrizePoolItem::clear_revenue_pct() {
  revenue_pct_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTALeague_PrizePoolItem::revenue_pct() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.PrizePoolItem.revenue_pct)
  return revenue_pct_;
}
inline void CMsgDOTALeague_PrizePoolItem::set_revenue_pct(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  revenue_pct_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.PrizePoolItem.revenue_pct)
}

// optional uint32 revenue_cents_per_sale = 4;
inline bool CMsgDOTALeague_PrizePoolItem::has_revenue_cents_per_sale() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTALeague_PrizePoolItem::clear_revenue_cents_per_sale() {
  revenue_cents_per_sale_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTALeague_PrizePoolItem::revenue_cents_per_sale() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.PrizePoolItem.revenue_cents_per_sale)
  return revenue_cents_per_sale_;
}
inline void CMsgDOTALeague_PrizePoolItem::set_revenue_cents_per_sale(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  revenue_cents_per_sale_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.PrizePoolItem.revenue_cents_per_sale)
}

// -------------------------------------------------------------------

// CMsgDOTALeague_PrizePool

// optional uint32 base_prize_pool = 1;
inline bool CMsgDOTALeague_PrizePool::has_base_prize_pool() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTALeague_PrizePool::clear_base_prize_pool() {
  base_prize_pool_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTALeague_PrizePool::base_prize_pool() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.PrizePool.base_prize_pool)
  return base_prize_pool_;
}
inline void CMsgDOTALeague_PrizePool::set_base_prize_pool(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  base_prize_pool_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.PrizePool.base_prize_pool)
}

// optional uint32 total_prize_pool = 2;
inline bool CMsgDOTALeague_PrizePool::has_total_prize_pool() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTALeague_PrizePool::clear_total_prize_pool() {
  total_prize_pool_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTALeague_PrizePool::total_prize_pool() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.PrizePool.total_prize_pool)
  return total_prize_pool_;
}
inline void CMsgDOTALeague_PrizePool::set_total_prize_pool(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  total_prize_pool_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.PrizePool.total_prize_pool)
}

// repeated uint32 prize_split_pct_x100 = 3;
inline int CMsgDOTALeague_PrizePool::prize_split_pct_x100_size() const {
  return prize_split_pct_x100_.size();
}
inline void CMsgDOTALeague_PrizePool::clear_prize_split_pct_x100() {
  prize_split_pct_x100_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTALeague_PrizePool::prize_split_pct_x100(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.PrizePool.prize_split_pct_x100)
  return prize_split_pct_x100_.Get(index);
}
inline void CMsgDOTALeague_PrizePool::set_prize_split_pct_x100(int index, ::google::protobuf::uint32 value) {
  prize_split_pct_x100_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.PrizePool.prize_split_pct_x100)
}
inline void CMsgDOTALeague_PrizePool::add_prize_split_pct_x100(::google::protobuf::uint32 value) {
  prize_split_pct_x100_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTALeague.PrizePool.prize_split_pct_x100)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTALeague_PrizePool::prize_split_pct_x100() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTALeague.PrizePool.prize_split_pct_x100)
  return prize_split_pct_x100_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTALeague_PrizePool::mutable_prize_split_pct_x100() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTALeague.PrizePool.prize_split_pct_x100)
  return &prize_split_pct_x100_;
}

// repeated .proto.dota.CMsgDOTALeague.PrizePoolItem prize_pool_items = 4;
inline int CMsgDOTALeague_PrizePool::prize_pool_items_size() const {
  return prize_pool_items_.size();
}
inline void CMsgDOTALeague_PrizePool::clear_prize_pool_items() {
  prize_pool_items_.Clear();
}
inline ::proto::dota::CMsgDOTALeague_PrizePoolItem* CMsgDOTALeague_PrizePool::mutable_prize_pool_items(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeague.PrizePool.prize_pool_items)
  return prize_pool_items_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_PrizePoolItem >*
CMsgDOTALeague_PrizePool::mutable_prize_pool_items() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTALeague.PrizePool.prize_pool_items)
  return &prize_pool_items_;
}
inline const ::proto::dota::CMsgDOTALeague_PrizePoolItem& CMsgDOTALeague_PrizePool::prize_pool_items(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.PrizePool.prize_pool_items)
  return prize_pool_items_.Get(index);
}
inline ::proto::dota::CMsgDOTALeague_PrizePoolItem* CMsgDOTALeague_PrizePool::add_prize_pool_items() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTALeague.PrizePool.prize_pool_items)
  return prize_pool_items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_PrizePoolItem >&
CMsgDOTALeague_PrizePool::prize_pool_items() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTALeague.PrizePool.prize_pool_items)
  return prize_pool_items_;
}

// -------------------------------------------------------------------

// CMsgDOTALeague_Stream

// optional uint32 stream_id = 1;
inline bool CMsgDOTALeague_Stream::has_stream_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTALeague_Stream::clear_stream_id() {
  stream_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTALeague_Stream::stream_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Stream.stream_id)
  return stream_id_;
}
inline void CMsgDOTALeague_Stream::set_stream_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  stream_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Stream.stream_id)
}

// optional uint32 language = 2;
inline bool CMsgDOTALeague_Stream::has_language() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTALeague_Stream::clear_language() {
  language_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgDOTALeague_Stream::language() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Stream.language)
  return language_;
}
inline void CMsgDOTALeague_Stream::set_language(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  language_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Stream.language)
}

// optional string name = 3;
inline bool CMsgDOTALeague_Stream::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTALeague_Stream::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTALeague_Stream::name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Stream.name)
  return name_.GetNoArena();
}
inline void CMsgDOTALeague_Stream::set_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Stream.name)
}
#if LANG_CXX11
inline void CMsgDOTALeague_Stream::set_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTALeague.Stream.name)
}
#endif
inline void CMsgDOTALeague_Stream::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTALeague.Stream.name)
}
inline void CMsgDOTALeague_Stream::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTALeague.Stream.name)
}
inline ::std::string* CMsgDOTALeague_Stream::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeague.Stream.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTALeague_Stream::release_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeague.Stream.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTALeague_Stream::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeague.Stream.name)
}

// optional .proto.dota.ELeagueBroadcastProvider broadcast_provider = 4 [default = LEAGUE_BROADCAST_UNKNOWN];
inline bool CMsgDOTALeague_Stream::has_broadcast_provider() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTALeague_Stream::clear_broadcast_provider() {
  broadcast_provider_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::proto::dota::ELeagueBroadcastProvider CMsgDOTALeague_Stream::broadcast_provider() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Stream.broadcast_provider)
  return static_cast< ::proto::dota::ELeagueBroadcastProvider >(broadcast_provider_);
}
inline void CMsgDOTALeague_Stream::set_broadcast_provider(::proto::dota::ELeagueBroadcastProvider value) {
  assert(::proto::dota::ELeagueBroadcastProvider_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  broadcast_provider_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Stream.broadcast_provider)
}

// optional string stream_url = 5;
inline bool CMsgDOTALeague_Stream::has_stream_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTALeague_Stream::clear_stream_url() {
  stream_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgDOTALeague_Stream::stream_url() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Stream.stream_url)
  return stream_url_.GetNoArena();
}
inline void CMsgDOTALeague_Stream::set_stream_url(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  stream_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Stream.stream_url)
}
#if LANG_CXX11
inline void CMsgDOTALeague_Stream::set_stream_url(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  stream_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTALeague.Stream.stream_url)
}
#endif
inline void CMsgDOTALeague_Stream::set_stream_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  stream_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTALeague.Stream.stream_url)
}
inline void CMsgDOTALeague_Stream::set_stream_url(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  stream_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTALeague.Stream.stream_url)
}
inline ::std::string* CMsgDOTALeague_Stream::mutable_stream_url() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeague.Stream.stream_url)
  return stream_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTALeague_Stream::release_stream_url() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeague.Stream.stream_url)
  if (!has_stream_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return stream_url_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTALeague_Stream::set_allocated_stream_url(::std::string* stream_url) {
  if (stream_url != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  stream_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stream_url);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeague.Stream.stream_url)
}

// optional string vod_url = 6;
inline bool CMsgDOTALeague_Stream::has_vod_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTALeague_Stream::clear_vod_url() {
  vod_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& CMsgDOTALeague_Stream::vod_url() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Stream.vod_url)
  return vod_url_.GetNoArena();
}
inline void CMsgDOTALeague_Stream::set_vod_url(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  vod_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Stream.vod_url)
}
#if LANG_CXX11
inline void CMsgDOTALeague_Stream::set_vod_url(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  vod_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTALeague.Stream.vod_url)
}
#endif
inline void CMsgDOTALeague_Stream::set_vod_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  vod_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTALeague.Stream.vod_url)
}
inline void CMsgDOTALeague_Stream::set_vod_url(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  vod_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTALeague.Stream.vod_url)
}
inline ::std::string* CMsgDOTALeague_Stream::mutable_vod_url() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeague.Stream.vod_url)
  return vod_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTALeague_Stream::release_vod_url() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeague.Stream.vod_url)
  if (!has_vod_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return vod_url_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTALeague_Stream::set_allocated_vod_url(::std::string* vod_url) {
  if (vod_url != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  vod_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vod_url);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeague.Stream.vod_url)
}

// -------------------------------------------------------------------

// CMsgDOTALeague_SeriesInfo

// optional uint32 series_id = 1;
inline bool CMsgDOTALeague_SeriesInfo::has_series_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTALeague_SeriesInfo::clear_series_id() {
  series_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTALeague_SeriesInfo::series_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.SeriesInfo.series_id)
  return series_id_;
}
inline void CMsgDOTALeague_SeriesInfo::set_series_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  series_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.SeriesInfo.series_id)
}

// optional uint32 series_type = 2;
inline bool CMsgDOTALeague_SeriesInfo::has_series_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTALeague_SeriesInfo::clear_series_type() {
  series_type_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTALeague_SeriesInfo::series_type() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.SeriesInfo.series_type)
  return series_type_;
}
inline void CMsgDOTALeague_SeriesInfo::set_series_type(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  series_type_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.SeriesInfo.series_type)
}

// optional uint32 start_time = 3;
inline bool CMsgDOTALeague_SeriesInfo::has_start_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTALeague_SeriesInfo::clear_start_time() {
  start_time_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTALeague_SeriesInfo::start_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.SeriesInfo.start_time)
  return start_time_;
}
inline void CMsgDOTALeague_SeriesInfo::set_start_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  start_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.SeriesInfo.start_time)
}

// repeated uint64 match_ids = 4;
inline int CMsgDOTALeague_SeriesInfo::match_ids_size() const {
  return match_ids_.size();
}
inline void CMsgDOTALeague_SeriesInfo::clear_match_ids() {
  match_ids_.Clear();
}
inline ::google::protobuf::uint64 CMsgDOTALeague_SeriesInfo::match_ids(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.SeriesInfo.match_ids)
  return match_ids_.Get(index);
}
inline void CMsgDOTALeague_SeriesInfo::set_match_ids(int index, ::google::protobuf::uint64 value) {
  match_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.SeriesInfo.match_ids)
}
inline void CMsgDOTALeague_SeriesInfo::add_match_ids(::google::protobuf::uint64 value) {
  match_ids_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTALeague.SeriesInfo.match_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CMsgDOTALeague_SeriesInfo::match_ids() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTALeague.SeriesInfo.match_ids)
  return match_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CMsgDOTALeague_SeriesInfo::mutable_match_ids() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTALeague.SeriesInfo.match_ids)
  return &match_ids_;
}

// optional uint32 team_id_1 = 5;
inline bool CMsgDOTALeague_SeriesInfo::has_team_id_1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTALeague_SeriesInfo::clear_team_id_1() {
  team_id_1_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTALeague_SeriesInfo::team_id_1() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.SeriesInfo.team_id_1)
  return team_id_1_;
}
inline void CMsgDOTALeague_SeriesInfo::set_team_id_1(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  team_id_1_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.SeriesInfo.team_id_1)
}

// optional uint32 team_id_2 = 6;
inline bool CMsgDOTALeague_SeriesInfo::has_team_id_2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTALeague_SeriesInfo::clear_team_id_2() {
  team_id_2_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgDOTALeague_SeriesInfo::team_id_2() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.SeriesInfo.team_id_2)
  return team_id_2_;
}
inline void CMsgDOTALeague_SeriesInfo::set_team_id_2(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  team_id_2_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.SeriesInfo.team_id_2)
}

// -------------------------------------------------------------------

// CMsgDOTALeague_Player

// optional uint32 account_id = 1;
inline bool CMsgDOTALeague_Player::has_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTALeague_Player::clear_account_id() {
  account_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTALeague_Player::account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Player.account_id)
  return account_id_;
}
inline void CMsgDOTALeague_Player::set_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Player.account_id)
}

// optional string name = 2;
inline bool CMsgDOTALeague_Player::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTALeague_Player::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTALeague_Player::name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Player.name)
  return name_.GetNoArena();
}
inline void CMsgDOTALeague_Player::set_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Player.name)
}
#if LANG_CXX11
inline void CMsgDOTALeague_Player::set_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTALeague.Player.name)
}
#endif
inline void CMsgDOTALeague_Player::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTALeague.Player.name)
}
inline void CMsgDOTALeague_Player::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTALeague.Player.name)
}
inline ::std::string* CMsgDOTALeague_Player::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeague.Player.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTALeague_Player::release_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeague.Player.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTALeague_Player::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeague.Player.name)
}

// optional uint32 team_id = 3;
inline bool CMsgDOTALeague_Player::has_team_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTALeague_Player::clear_team_id() {
  team_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTALeague_Player::team_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.Player.team_id)
  return team_id_;
}
inline void CMsgDOTALeague_Player::set_team_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  team_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeague.Player.team_id)
}

// -------------------------------------------------------------------

// CMsgDOTALeague

// optional .proto.dota.CMsgDOTALeague.Info info = 1;
inline bool CMsgDOTALeague::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTALeague::clear_info() {
  if (info_ != nullptr) info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::dota::CMsgDOTALeague_Info& CMsgDOTALeague::info() const {
  const ::proto::dota::CMsgDOTALeague_Info* p = info_;
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.info)
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::dota::CMsgDOTALeague_Info*>(
      &::proto::dota::_CMsgDOTALeague_Info_default_instance_);
}
inline ::proto::dota::CMsgDOTALeague_Info* CMsgDOTALeague::release_info() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeague.info)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::dota::CMsgDOTALeague_Info* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::proto::dota::CMsgDOTALeague_Info* CMsgDOTALeague::mutable_info() {
  _has_bits_[0] |= 0x00000001u;
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::dota::CMsgDOTALeague_Info>(GetArenaNoVirtual());
    info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeague.info)
  return info_;
}
inline void CMsgDOTALeague::set_allocated_info(::proto::dota::CMsgDOTALeague_Info* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeague.info)
}

// optional .proto.dota.CMsgDOTALeague.PrizePool prize_pool = 2;
inline bool CMsgDOTALeague::has_prize_pool() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTALeague::clear_prize_pool() {
  if (prize_pool_ != nullptr) prize_pool_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::dota::CMsgDOTALeague_PrizePool& CMsgDOTALeague::prize_pool() const {
  const ::proto::dota::CMsgDOTALeague_PrizePool* p = prize_pool_;
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.prize_pool)
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::dota::CMsgDOTALeague_PrizePool*>(
      &::proto::dota::_CMsgDOTALeague_PrizePool_default_instance_);
}
inline ::proto::dota::CMsgDOTALeague_PrizePool* CMsgDOTALeague::release_prize_pool() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeague.prize_pool)
  _has_bits_[0] &= ~0x00000002u;
  ::proto::dota::CMsgDOTALeague_PrizePool* temp = prize_pool_;
  prize_pool_ = nullptr;
  return temp;
}
inline ::proto::dota::CMsgDOTALeague_PrizePool* CMsgDOTALeague::mutable_prize_pool() {
  _has_bits_[0] |= 0x00000002u;
  if (prize_pool_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::dota::CMsgDOTALeague_PrizePool>(GetArenaNoVirtual());
    prize_pool_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeague.prize_pool)
  return prize_pool_;
}
inline void CMsgDOTALeague::set_allocated_prize_pool(::proto::dota::CMsgDOTALeague_PrizePool* prize_pool) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete prize_pool_;
  }
  if (prize_pool) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      prize_pool = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, prize_pool, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  prize_pool_ = prize_pool;
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeague.prize_pool)
}

// repeated .proto.dota.CMsgDOTALeague.Admin admins = 3;
inline int CMsgDOTALeague::admins_size() const {
  return admins_.size();
}
inline void CMsgDOTALeague::clear_admins() {
  admins_.Clear();
}
inline ::proto::dota::CMsgDOTALeague_Admin* CMsgDOTALeague::mutable_admins(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeague.admins)
  return admins_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_Admin >*
CMsgDOTALeague::mutable_admins() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTALeague.admins)
  return &admins_;
}
inline const ::proto::dota::CMsgDOTALeague_Admin& CMsgDOTALeague::admins(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.admins)
  return admins_.Get(index);
}
inline ::proto::dota::CMsgDOTALeague_Admin* CMsgDOTALeague::add_admins() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTALeague.admins)
  return admins_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_Admin >&
CMsgDOTALeague::admins() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTALeague.admins)
  return admins_;
}

// repeated .proto.dota.CMsgDOTALeague.Stream streams = 4;
inline int CMsgDOTALeague::streams_size() const {
  return streams_.size();
}
inline void CMsgDOTALeague::clear_streams() {
  streams_.Clear();
}
inline ::proto::dota::CMsgDOTALeague_Stream* CMsgDOTALeague::mutable_streams(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeague.streams)
  return streams_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_Stream >*
CMsgDOTALeague::mutable_streams() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTALeague.streams)
  return &streams_;
}
inline const ::proto::dota::CMsgDOTALeague_Stream& CMsgDOTALeague::streams(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.streams)
  return streams_.Get(index);
}
inline ::proto::dota::CMsgDOTALeague_Stream* CMsgDOTALeague::add_streams() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTALeague.streams)
  return streams_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_Stream >&
CMsgDOTALeague::streams() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTALeague.streams)
  return streams_;
}

// repeated .proto.dota.CMsgDOTALeagueNodeGroup node_groups = 5;
inline int CMsgDOTALeague::node_groups_size() const {
  return node_groups_.size();
}
inline void CMsgDOTALeague::clear_node_groups() {
  node_groups_.Clear();
}
inline ::proto::dota::CMsgDOTALeagueNodeGroup* CMsgDOTALeague::mutable_node_groups(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeague.node_groups)
  return node_groups_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNodeGroup >*
CMsgDOTALeague::mutable_node_groups() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTALeague.node_groups)
  return &node_groups_;
}
inline const ::proto::dota::CMsgDOTALeagueNodeGroup& CMsgDOTALeague::node_groups(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.node_groups)
  return node_groups_.Get(index);
}
inline ::proto::dota::CMsgDOTALeagueNodeGroup* CMsgDOTALeague::add_node_groups() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTALeague.node_groups)
  return node_groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNodeGroup >&
CMsgDOTALeague::node_groups() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTALeague.node_groups)
  return node_groups_;
}

// repeated .proto.dota.CMsgDOTALeague.SeriesInfo series_infos = 6;
inline int CMsgDOTALeague::series_infos_size() const {
  return series_infos_.size();
}
inline void CMsgDOTALeague::clear_series_infos() {
  series_infos_.Clear();
}
inline ::proto::dota::CMsgDOTALeague_SeriesInfo* CMsgDOTALeague::mutable_series_infos(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeague.series_infos)
  return series_infos_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_SeriesInfo >*
CMsgDOTALeague::mutable_series_infos() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTALeague.series_infos)
  return &series_infos_;
}
inline const ::proto::dota::CMsgDOTALeague_SeriesInfo& CMsgDOTALeague::series_infos(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.series_infos)
  return series_infos_.Get(index);
}
inline ::proto::dota::CMsgDOTALeague_SeriesInfo* CMsgDOTALeague::add_series_infos() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTALeague.series_infos)
  return series_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_SeriesInfo >&
CMsgDOTALeague::series_infos() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTALeague.series_infos)
  return series_infos_;
}

// repeated .proto.dota.CMsgDOTALeague.Player registered_players = 7;
inline int CMsgDOTALeague::registered_players_size() const {
  return registered_players_.size();
}
inline void CMsgDOTALeague::clear_registered_players() {
  registered_players_.Clear();
}
inline ::proto::dota::CMsgDOTALeague_Player* CMsgDOTALeague::mutable_registered_players(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeague.registered_players)
  return registered_players_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_Player >*
CMsgDOTALeague::mutable_registered_players() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTALeague.registered_players)
  return &registered_players_;
}
inline const ::proto::dota::CMsgDOTALeague_Player& CMsgDOTALeague::registered_players(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeague.registered_players)
  return registered_players_.Get(index);
}
inline ::proto::dota::CMsgDOTALeague_Player* CMsgDOTALeague::add_registered_players() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTALeague.registered_players)
  return registered_players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeague_Player >&
CMsgDOTALeague::registered_players() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTALeague.registered_players)
  return registered_players_;
}

// -------------------------------------------------------------------

// CMsgDOTALeagueInfo

// optional uint32 league_id = 1;
inline bool CMsgDOTALeagueInfo::has_league_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTALeagueInfo::clear_league_id() {
  league_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueInfo::league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueInfo.league_id)
  return league_id_;
}
inline void CMsgDOTALeagueInfo::set_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueInfo.league_id)
}

// optional string name = 2;
inline bool CMsgDOTALeagueInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTALeagueInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTALeagueInfo::name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueInfo.name)
  return name_.GetNoArena();
}
inline void CMsgDOTALeagueInfo::set_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueInfo.name)
}
#if LANG_CXX11
inline void CMsgDOTALeagueInfo::set_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTALeagueInfo.name)
}
#endif
inline void CMsgDOTALeagueInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTALeagueInfo.name)
}
inline void CMsgDOTALeagueInfo::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTALeagueInfo.name)
}
inline ::std::string* CMsgDOTALeagueInfo::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeagueInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTALeagueInfo::release_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeagueInfo.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTALeagueInfo::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeagueInfo.name)
}

// optional .proto.dota.ELeagueTier tier = 3 [default = LEAGUE_TIER_UNSET];
inline bool CMsgDOTALeagueInfo::has_tier() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTALeagueInfo::clear_tier() {
  tier_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::proto::dota::ELeagueTier CMsgDOTALeagueInfo::tier() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueInfo.tier)
  return static_cast< ::proto::dota::ELeagueTier >(tier_);
}
inline void CMsgDOTALeagueInfo::set_tier(::proto::dota::ELeagueTier value) {
  assert(::proto::dota::ELeagueTier_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  tier_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueInfo.tier)
}

// optional .proto.dota.ELeagueRegion region = 4 [default = LEAGUE_REGION_UNSET];
inline bool CMsgDOTALeagueInfo::has_region() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTALeagueInfo::clear_region() {
  region_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::proto::dota::ELeagueRegion CMsgDOTALeagueInfo::region() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueInfo.region)
  return static_cast< ::proto::dota::ELeagueRegion >(region_);
}
inline void CMsgDOTALeagueInfo::set_region(::proto::dota::ELeagueRegion value) {
  assert(::proto::dota::ELeagueRegion_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  region_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueInfo.region)
}

// optional uint32 most_recent_activity = 5;
inline bool CMsgDOTALeagueInfo::has_most_recent_activity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTALeagueInfo::clear_most_recent_activity() {
  most_recent_activity_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueInfo::most_recent_activity() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueInfo.most_recent_activity)
  return most_recent_activity_;
}
inline void CMsgDOTALeagueInfo::set_most_recent_activity(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  most_recent_activity_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueInfo.most_recent_activity)
}

// optional uint32 total_prize_pool = 6;
inline bool CMsgDOTALeagueInfo::has_total_prize_pool() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTALeagueInfo::clear_total_prize_pool() {
  total_prize_pool_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueInfo::total_prize_pool() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueInfo.total_prize_pool)
  return total_prize_pool_;
}
inline void CMsgDOTALeagueInfo::set_total_prize_pool(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  total_prize_pool_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueInfo.total_prize_pool)
}

// optional uint32 start_timestamp = 7;
inline bool CMsgDOTALeagueInfo::has_start_timestamp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTALeagueInfo::clear_start_timestamp() {
  start_timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueInfo::start_timestamp() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueInfo.start_timestamp)
  return start_timestamp_;
}
inline void CMsgDOTALeagueInfo::set_start_timestamp(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  start_timestamp_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueInfo.start_timestamp)
}

// optional uint32 end_timestamp = 8;
inline bool CMsgDOTALeagueInfo::has_end_timestamp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgDOTALeagueInfo::clear_end_timestamp() {
  end_timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueInfo::end_timestamp() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueInfo.end_timestamp)
  return end_timestamp_;
}
inline void CMsgDOTALeagueInfo::set_end_timestamp(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  end_timestamp_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueInfo.end_timestamp)
}

// optional uint32 status = 9;
inline bool CMsgDOTALeagueInfo::has_status() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgDOTALeagueInfo::clear_status() {
  status_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueInfo::status() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueInfo.status)
  return status_;
}
inline void CMsgDOTALeagueInfo::set_status(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  status_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueInfo.status)
}

// -------------------------------------------------------------------

// CMsgDOTALeagueInfoList

// repeated .proto.dota.CMsgDOTALeagueInfo infos = 1;
inline int CMsgDOTALeagueInfoList::infos_size() const {
  return infos_.size();
}
inline void CMsgDOTALeagueInfoList::clear_infos() {
  infos_.Clear();
}
inline ::proto::dota::CMsgDOTALeagueInfo* CMsgDOTALeagueInfoList::mutable_infos(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeagueInfoList.infos)
  return infos_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueInfo >*
CMsgDOTALeagueInfoList::mutable_infos() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTALeagueInfoList.infos)
  return &infos_;
}
inline const ::proto::dota::CMsgDOTALeagueInfo& CMsgDOTALeagueInfoList::infos(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueInfoList.infos)
  return infos_.Get(index);
}
inline ::proto::dota::CMsgDOTALeagueInfo* CMsgDOTALeagueInfoList::add_infos() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTALeagueInfoList.infos)
  return infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueInfo >&
CMsgDOTALeagueInfoList::infos() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTALeagueInfoList.infos)
  return infos_;
}

// -------------------------------------------------------------------

// CMsgDOTALeagueLiveGames_LiveGame

// optional uint32 league_id = 1;
inline bool CMsgDOTALeagueLiveGames_LiveGame::has_league_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::clear_league_id() {
  league_id_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueLiveGames_LiveGame::league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.league_id)
  return league_id_;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.league_id)
}

// optional uint64 server_steam_id = 2;
inline bool CMsgDOTALeagueLiveGames_LiveGame::has_server_steam_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::clear_server_steam_id() {
  server_steam_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 CMsgDOTALeagueLiveGames_LiveGame::server_steam_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.server_steam_id)
  return server_steam_id_;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_server_steam_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  server_steam_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.server_steam_id)
}

// optional string radiant_name = 3;
inline bool CMsgDOTALeagueLiveGames_LiveGame::has_radiant_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::clear_radiant_name() {
  radiant_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTALeagueLiveGames_LiveGame::radiant_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.radiant_name)
  return radiant_name_.GetNoArena();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_radiant_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  radiant_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.radiant_name)
}
#if LANG_CXX11
inline void CMsgDOTALeagueLiveGames_LiveGame::set_radiant_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  radiant_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.radiant_name)
}
#endif
inline void CMsgDOTALeagueLiveGames_LiveGame::set_radiant_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  radiant_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.radiant_name)
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_radiant_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  radiant_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.radiant_name)
}
inline ::std::string* CMsgDOTALeagueLiveGames_LiveGame::mutable_radiant_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.radiant_name)
  return radiant_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTALeagueLiveGames_LiveGame::release_radiant_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.radiant_name)
  if (!has_radiant_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return radiant_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_allocated_radiant_name(::std::string* radiant_name) {
  if (radiant_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  radiant_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), radiant_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.radiant_name)
}

// optional uint64 radiant_logo = 4;
inline bool CMsgDOTALeagueLiveGames_LiveGame::has_radiant_logo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::clear_radiant_logo() {
  radiant_logo_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 CMsgDOTALeagueLiveGames_LiveGame::radiant_logo() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.radiant_logo)
  return radiant_logo_;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_radiant_logo(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  radiant_logo_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.radiant_logo)
}

// optional uint32 radiant_team_id = 9;
inline bool CMsgDOTALeagueLiveGames_LiveGame::has_radiant_team_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::clear_radiant_team_id() {
  radiant_team_id_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueLiveGames_LiveGame::radiant_team_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.radiant_team_id)
  return radiant_team_id_;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_radiant_team_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  radiant_team_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.radiant_team_id)
}

// optional string dire_name = 5;
inline bool CMsgDOTALeagueLiveGames_LiveGame::has_dire_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::clear_dire_name() {
  dire_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgDOTALeagueLiveGames_LiveGame::dire_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.dire_name)
  return dire_name_.GetNoArena();
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_dire_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  dire_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.dire_name)
}
#if LANG_CXX11
inline void CMsgDOTALeagueLiveGames_LiveGame::set_dire_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  dire_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.dire_name)
}
#endif
inline void CMsgDOTALeagueLiveGames_LiveGame::set_dire_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  dire_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.dire_name)
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_dire_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  dire_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.dire_name)
}
inline ::std::string* CMsgDOTALeagueLiveGames_LiveGame::mutable_dire_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.dire_name)
  return dire_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTALeagueLiveGames_LiveGame::release_dire_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.dire_name)
  if (!has_dire_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return dire_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_allocated_dire_name(::std::string* dire_name) {
  if (dire_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  dire_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dire_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.dire_name)
}

// optional uint64 dire_logo = 6;
inline bool CMsgDOTALeagueLiveGames_LiveGame::has_dire_logo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::clear_dire_logo() {
  dire_logo_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint64 CMsgDOTALeagueLiveGames_LiveGame::dire_logo() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.dire_logo)
  return dire_logo_;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_dire_logo(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  dire_logo_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.dire_logo)
}

// optional uint32 dire_team_id = 10;
inline bool CMsgDOTALeagueLiveGames_LiveGame::has_dire_team_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::clear_dire_team_id() {
  dire_team_id_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueLiveGames_LiveGame::dire_team_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.dire_team_id)
  return dire_team_id_;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_dire_team_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  dire_team_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.dire_team_id)
}

// optional uint32 time = 7;
inline bool CMsgDOTALeagueLiveGames_LiveGame::has_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::clear_time() {
  time_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueLiveGames_LiveGame::time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.time)
  return time_;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.time)
}

// optional uint32 spectators = 8;
inline bool CMsgDOTALeagueLiveGames_LiveGame::has_spectators() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::clear_spectators() {
  spectators_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueLiveGames_LiveGame::spectators() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.spectators)
  return spectators_;
}
inline void CMsgDOTALeagueLiveGames_LiveGame::set_spectators(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  spectators_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueLiveGames.LiveGame.spectators)
}

// -------------------------------------------------------------------

// CMsgDOTALeagueLiveGames

// repeated .proto.dota.CMsgDOTALeagueLiveGames.LiveGame games = 1;
inline int CMsgDOTALeagueLiveGames::games_size() const {
  return games_.size();
}
inline void CMsgDOTALeagueLiveGames::clear_games() {
  games_.Clear();
}
inline ::proto::dota::CMsgDOTALeagueLiveGames_LiveGame* CMsgDOTALeagueLiveGames::mutable_games(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeagueLiveGames.games)
  return games_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueLiveGames_LiveGame >*
CMsgDOTALeagueLiveGames::mutable_games() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTALeagueLiveGames.games)
  return &games_;
}
inline const ::proto::dota::CMsgDOTALeagueLiveGames_LiveGame& CMsgDOTALeagueLiveGames::games(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueLiveGames.games)
  return games_.Get(index);
}
inline ::proto::dota::CMsgDOTALeagueLiveGames_LiveGame* CMsgDOTALeagueLiveGames::add_games() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTALeagueLiveGames.games)
  return games_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueLiveGames_LiveGame >&
CMsgDOTALeagueLiveGames::games() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTALeagueLiveGames.games)
  return games_;
}

// -------------------------------------------------------------------

// CMsgDOTALeagueMessages_Message

// optional uint32 author_account_id = 1;
inline bool CMsgDOTALeagueMessages_Message::has_author_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTALeagueMessages_Message::clear_author_account_id() {
  author_account_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueMessages_Message::author_account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueMessages.Message.author_account_id)
  return author_account_id_;
}
inline void CMsgDOTALeagueMessages_Message::set_author_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  author_account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueMessages.Message.author_account_id)
}

// optional uint32 timestamp = 2;
inline bool CMsgDOTALeagueMessages_Message::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTALeagueMessages_Message::clear_timestamp() {
  timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueMessages_Message::timestamp() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueMessages.Message.timestamp)
  return timestamp_;
}
inline void CMsgDOTALeagueMessages_Message::set_timestamp(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueMessages.Message.timestamp)
}

// optional string message = 3;
inline bool CMsgDOTALeagueMessages_Message::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTALeagueMessages_Message::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTALeagueMessages_Message::message() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueMessages.Message.message)
  return message_.GetNoArena();
}
inline void CMsgDOTALeagueMessages_Message::set_message(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueMessages.Message.message)
}
#if LANG_CXX11
inline void CMsgDOTALeagueMessages_Message::set_message(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTALeagueMessages.Message.message)
}
#endif
inline void CMsgDOTALeagueMessages_Message::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTALeagueMessages.Message.message)
}
inline void CMsgDOTALeagueMessages_Message::set_message(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTALeagueMessages.Message.message)
}
inline ::std::string* CMsgDOTALeagueMessages_Message::mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeagueMessages.Message.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTALeagueMessages_Message::release_message() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeagueMessages.Message.message)
  if (!has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTALeagueMessages_Message::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeagueMessages.Message.message)
}

// -------------------------------------------------------------------

// CMsgDOTALeagueMessages

// repeated .proto.dota.CMsgDOTALeagueMessages.Message messages = 1;
inline int CMsgDOTALeagueMessages::messages_size() const {
  return messages_.size();
}
inline void CMsgDOTALeagueMessages::clear_messages() {
  messages_.Clear();
}
inline ::proto::dota::CMsgDOTALeagueMessages_Message* CMsgDOTALeagueMessages::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeagueMessages.messages)
  return messages_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueMessages_Message >*
CMsgDOTALeagueMessages::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTALeagueMessages.messages)
  return &messages_;
}
inline const ::proto::dota::CMsgDOTALeagueMessages_Message& CMsgDOTALeagueMessages::messages(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueMessages.messages)
  return messages_.Get(index);
}
inline ::proto::dota::CMsgDOTALeagueMessages_Message* CMsgDOTALeagueMessages::add_messages() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTALeagueMessages.messages)
  return messages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueMessages_Message >&
CMsgDOTALeagueMessages::messages() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTALeagueMessages.messages)
  return messages_;
}

// -------------------------------------------------------------------

// CMsgDOTALeaguePrizePool

// optional uint32 prize_pool = 1;
inline bool CMsgDOTALeaguePrizePool::has_prize_pool() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTALeaguePrizePool::clear_prize_pool() {
  prize_pool_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTALeaguePrizePool::prize_pool() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeaguePrizePool.prize_pool)
  return prize_pool_;
}
inline void CMsgDOTALeaguePrizePool::set_prize_pool(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  prize_pool_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeaguePrizePool.prize_pool)
}

// optional float increment_per_second = 2;
inline bool CMsgDOTALeaguePrizePool::has_increment_per_second() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTALeaguePrizePool::clear_increment_per_second() {
  increment_per_second_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float CMsgDOTALeaguePrizePool::increment_per_second() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeaguePrizePool.increment_per_second)
  return increment_per_second_;
}
inline void CMsgDOTALeaguePrizePool::set_increment_per_second(float value) {
  _has_bits_[0] |= 0x00000002u;
  increment_per_second_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeaguePrizePool.increment_per_second)
}

// -------------------------------------------------------------------

// CMsgDOTALeagueInfoListAdminsRequest

// -------------------------------------------------------------------

// CMsgDOTALeagueNodeRequest

// optional uint32 league_id = 1;
inline bool CMsgDOTALeagueNodeRequest::has_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTALeagueNodeRequest::clear_league_id() {
  league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeRequest::league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeRequest.league_id)
  return league_id_;
}
inline void CMsgDOTALeagueNodeRequest::set_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeRequest.league_id)
}

// optional uint32 node_id = 2;
inline bool CMsgDOTALeagueNodeRequest::has_node_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTALeagueNodeRequest::clear_node_id() {
  node_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeRequest::node_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeRequest.node_id)
  return node_id_;
}
inline void CMsgDOTALeagueNodeRequest::set_node_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  node_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeRequest.node_id)
}

// -------------------------------------------------------------------

// CMsgDOTALeagueNodeResponse

// optional .proto.dota.CMsgDOTALeagueNode node = 1;
inline bool CMsgDOTALeagueNodeResponse::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTALeagueNodeResponse::clear_node() {
  if (node_ != nullptr) node_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::dota::CMsgDOTALeagueNode& CMsgDOTALeagueNodeResponse::node() const {
  const ::proto::dota::CMsgDOTALeagueNode* p = node_;
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeResponse.node)
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::dota::CMsgDOTALeagueNode*>(
      &::proto::dota::_CMsgDOTALeagueNode_default_instance_);
}
inline ::proto::dota::CMsgDOTALeagueNode* CMsgDOTALeagueNodeResponse::release_node() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeagueNodeResponse.node)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::dota::CMsgDOTALeagueNode* temp = node_;
  node_ = nullptr;
  return temp;
}
inline ::proto::dota::CMsgDOTALeagueNode* CMsgDOTALeagueNodeResponse::mutable_node() {
  _has_bits_[0] |= 0x00000001u;
  if (node_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::dota::CMsgDOTALeagueNode>(GetArenaNoVirtual());
    node_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeagueNodeResponse.node)
  return node_;
}
inline void CMsgDOTALeagueNodeResponse::set_allocated_node(::proto::dota::CMsgDOTALeagueNode* node) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete node_;
  }
  if (node) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      node = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeagueNodeResponse.node)
}

// -------------------------------------------------------------------

// CMsgDOTALeagueAvailableLobbyNodesRequest

// optional uint32 league_id = 1;
inline bool CMsgDOTALeagueAvailableLobbyNodesRequest::has_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTALeagueAvailableLobbyNodesRequest::clear_league_id() {
  league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueAvailableLobbyNodesRequest::league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueAvailableLobbyNodesRequest.league_id)
  return league_id_;
}
inline void CMsgDOTALeagueAvailableLobbyNodesRequest::set_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueAvailableLobbyNodesRequest.league_id)
}

// -------------------------------------------------------------------

// CMsgDOTALeagueAvailableLobbyNodes_NodeInfo

// optional uint32 node_id = 1;
inline bool CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::has_node_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::clear_node_id() {
  node_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::node_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_id)
  return node_id_;
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::set_node_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  node_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_id)
}

// optional string node_name = 2;
inline bool CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::has_node_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::clear_node_name() {
  node_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::node_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_name)
  return node_name_.GetNoArena();
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::set_node_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  node_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_name)
}
#if LANG_CXX11
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::set_node_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  node_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_name)
}
#endif
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::set_node_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  node_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_name)
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::set_node_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  node_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_name)
}
inline ::std::string* CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::mutable_node_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_name)
  return node_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::release_node_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_name)
  if (!has_node_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return node_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::set_allocated_node_name(::std::string* node_name) {
  if (node_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  node_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_name)
}

// optional string node_group_name = 3;
inline bool CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::has_node_group_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::clear_node_group_name() {
  node_group_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::node_group_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_group_name)
  return node_group_name_.GetNoArena();
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::set_node_group_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  node_group_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_group_name)
}
#if LANG_CXX11
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::set_node_group_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  node_group_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_group_name)
}
#endif
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::set_node_group_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  node_group_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_group_name)
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::set_node_group_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  node_group_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_group_name)
}
inline ::std::string* CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::mutable_node_group_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_group_name)
  return node_group_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::release_node_group_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_group_name)
  if (!has_node_group_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return node_group_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::set_allocated_node_group_name(::std::string* node_group_name) {
  if (node_group_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  node_group_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_group_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.node_group_name)
}

// optional uint32 team_id_1 = 4;
inline bool CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::has_team_id_1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::clear_team_id_1() {
  team_id_1_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::team_id_1() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.team_id_1)
  return team_id_1_;
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::set_team_id_1(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  team_id_1_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.team_id_1)
}

// optional uint32 team_id_2 = 5;
inline bool CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::has_team_id_2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::clear_team_id_2() {
  team_id_2_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::team_id_2() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.team_id_2)
  return team_id_2_;
}
inline void CMsgDOTALeagueAvailableLobbyNodes_NodeInfo::set_team_id_2(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  team_id_2_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo.team_id_2)
}

// -------------------------------------------------------------------

// CMsgDOTALeagueAvailableLobbyNodes

// repeated .proto.dota.CMsgDOTALeagueAvailableLobbyNodes.NodeInfo node_infos = 1;
inline int CMsgDOTALeagueAvailableLobbyNodes::node_infos_size() const {
  return node_infos_.size();
}
inline void CMsgDOTALeagueAvailableLobbyNodes::clear_node_infos() {
  node_infos_.Clear();
}
inline ::proto::dota::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* CMsgDOTALeagueAvailableLobbyNodes::mutable_node_infos(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.node_infos)
  return node_infos_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo >*
CMsgDOTALeagueAvailableLobbyNodes::mutable_node_infos() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.node_infos)
  return &node_infos_;
}
inline const ::proto::dota::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo& CMsgDOTALeagueAvailableLobbyNodes::node_infos(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.node_infos)
  return node_infos_.Get(index);
}
inline ::proto::dota::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo* CMsgDOTALeagueAvailableLobbyNodes::add_node_infos() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.node_infos)
  return node_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueAvailableLobbyNodes_NodeInfo >&
CMsgDOTALeagueAvailableLobbyNodes::node_infos() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTALeagueAvailableLobbyNodes.node_infos)
  return node_infos_;
}

// -------------------------------------------------------------------

// CMsgDOTALeagueNodeResults_Result

// optional uint32 node_id = 1;
inline bool CMsgDOTALeagueNodeResults_Result::has_node_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTALeagueNodeResults_Result::clear_node_id() {
  node_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeResults_Result::node_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeResults.Result.node_id)
  return node_id_;
}
inline void CMsgDOTALeagueNodeResults_Result::set_node_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  node_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeResults.Result.node_id)
}

// optional uint32 winning_node_id = 2;
inline bool CMsgDOTALeagueNodeResults_Result::has_winning_node_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTALeagueNodeResults_Result::clear_winning_node_id() {
  winning_node_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeResults_Result::winning_node_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeResults.Result.winning_node_id)
  return winning_node_id_;
}
inline void CMsgDOTALeagueNodeResults_Result::set_winning_node_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  winning_node_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeResults.Result.winning_node_id)
}

// optional uint32 losing_node_id = 3;
inline bool CMsgDOTALeagueNodeResults_Result::has_losing_node_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTALeagueNodeResults_Result::clear_losing_node_id() {
  losing_node_id_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeResults_Result::losing_node_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeResults.Result.losing_node_id)
  return losing_node_id_;
}
inline void CMsgDOTALeagueNodeResults_Result::set_losing_node_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  losing_node_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeResults.Result.losing_node_id)
}

// optional uint32 incoming_node_id_1 = 4;
inline bool CMsgDOTALeagueNodeResults_Result::has_incoming_node_id_1() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTALeagueNodeResults_Result::clear_incoming_node_id_1() {
  incoming_node_id_1_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeResults_Result::incoming_node_id_1() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeResults.Result.incoming_node_id_1)
  return incoming_node_id_1_;
}
inline void CMsgDOTALeagueNodeResults_Result::set_incoming_node_id_1(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  incoming_node_id_1_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeResults.Result.incoming_node_id_1)
}

// optional uint32 incoming_node_id_2 = 5;
inline bool CMsgDOTALeagueNodeResults_Result::has_incoming_node_id_2() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTALeagueNodeResults_Result::clear_incoming_node_id_2() {
  incoming_node_id_2_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeResults_Result::incoming_node_id_2() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeResults.Result.incoming_node_id_2)
  return incoming_node_id_2_;
}
inline void CMsgDOTALeagueNodeResults_Result::set_incoming_node_id_2(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  incoming_node_id_2_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeResults.Result.incoming_node_id_2)
}

// optional uint32 team_id_1 = 6;
inline bool CMsgDOTALeagueNodeResults_Result::has_team_id_1() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgDOTALeagueNodeResults_Result::clear_team_id_1() {
  team_id_1_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeResults_Result::team_id_1() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeResults.Result.team_id_1)
  return team_id_1_;
}
inline void CMsgDOTALeagueNodeResults_Result::set_team_id_1(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  team_id_1_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeResults.Result.team_id_1)
}

// optional uint32 team_id_2 = 7;
inline bool CMsgDOTALeagueNodeResults_Result::has_team_id_2() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgDOTALeagueNodeResults_Result::clear_team_id_2() {
  team_id_2_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeResults_Result::team_id_2() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeResults.Result.team_id_2)
  return team_id_2_;
}
inline void CMsgDOTALeagueNodeResults_Result::set_team_id_2(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  team_id_2_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeResults.Result.team_id_2)
}

// optional string team_1_name = 8;
inline bool CMsgDOTALeagueNodeResults_Result::has_team_1_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTALeagueNodeResults_Result::clear_team_1_name() {
  team_1_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTALeagueNodeResults_Result::team_1_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeResults.Result.team_1_name)
  return team_1_name_.GetNoArena();
}
inline void CMsgDOTALeagueNodeResults_Result::set_team_1_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  team_1_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeResults.Result.team_1_name)
}
#if LANG_CXX11
inline void CMsgDOTALeagueNodeResults_Result::set_team_1_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  team_1_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTALeagueNodeResults.Result.team_1_name)
}
#endif
inline void CMsgDOTALeagueNodeResults_Result::set_team_1_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  team_1_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTALeagueNodeResults.Result.team_1_name)
}
inline void CMsgDOTALeagueNodeResults_Result::set_team_1_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  team_1_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTALeagueNodeResults.Result.team_1_name)
}
inline ::std::string* CMsgDOTALeagueNodeResults_Result::mutable_team_1_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeagueNodeResults.Result.team_1_name)
  return team_1_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTALeagueNodeResults_Result::release_team_1_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeagueNodeResults.Result.team_1_name)
  if (!has_team_1_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return team_1_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTALeagueNodeResults_Result::set_allocated_team_1_name(::std::string* team_1_name) {
  if (team_1_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  team_1_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team_1_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeagueNodeResults.Result.team_1_name)
}

// optional string team_2_name = 9;
inline bool CMsgDOTALeagueNodeResults_Result::has_team_2_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTALeagueNodeResults_Result::clear_team_2_name() {
  team_2_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgDOTALeagueNodeResults_Result::team_2_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeResults.Result.team_2_name)
  return team_2_name_.GetNoArena();
}
inline void CMsgDOTALeagueNodeResults_Result::set_team_2_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  team_2_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeResults.Result.team_2_name)
}
#if LANG_CXX11
inline void CMsgDOTALeagueNodeResults_Result::set_team_2_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  team_2_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTALeagueNodeResults.Result.team_2_name)
}
#endif
inline void CMsgDOTALeagueNodeResults_Result::set_team_2_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  team_2_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTALeagueNodeResults.Result.team_2_name)
}
inline void CMsgDOTALeagueNodeResults_Result::set_team_2_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  team_2_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTALeagueNodeResults.Result.team_2_name)
}
inline ::std::string* CMsgDOTALeagueNodeResults_Result::mutable_team_2_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeagueNodeResults.Result.team_2_name)
  return team_2_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTALeagueNodeResults_Result::release_team_2_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTALeagueNodeResults.Result.team_2_name)
  if (!has_team_2_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return team_2_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTALeagueNodeResults_Result::set_allocated_team_2_name(::std::string* team_2_name) {
  if (team_2_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  team_2_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team_2_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTALeagueNodeResults.Result.team_2_name)
}

// optional uint32 team_1_wins = 10;
inline bool CMsgDOTALeagueNodeResults_Result::has_team_1_wins() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgDOTALeagueNodeResults_Result::clear_team_1_wins() {
  team_1_wins_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeResults_Result::team_1_wins() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeResults.Result.team_1_wins)
  return team_1_wins_;
}
inline void CMsgDOTALeagueNodeResults_Result::set_team_1_wins(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  team_1_wins_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeResults.Result.team_1_wins)
}

// optional uint32 team_2_wins = 11;
inline bool CMsgDOTALeagueNodeResults_Result::has_team_2_wins() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgDOTALeagueNodeResults_Result::clear_team_2_wins() {
  team_2_wins_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeResults_Result::team_2_wins() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeResults.Result.team_2_wins)
  return team_2_wins_;
}
inline void CMsgDOTALeagueNodeResults_Result::set_team_2_wins(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000400u;
  team_2_wins_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeResults.Result.team_2_wins)
}

// optional uint32 winning_team_id = 12;
inline bool CMsgDOTALeagueNodeResults_Result::has_winning_team_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgDOTALeagueNodeResults_Result::clear_winning_team_id() {
  winning_team_id_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeResults_Result::winning_team_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeResults.Result.winning_team_id)
  return winning_team_id_;
}
inline void CMsgDOTALeagueNodeResults_Result::set_winning_team_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000800u;
  winning_team_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeResults.Result.winning_team_id)
}

// optional uint32 losing_team_id = 13;
inline bool CMsgDOTALeagueNodeResults_Result::has_losing_team_id() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgDOTALeagueNodeResults_Result::clear_losing_team_id() {
  losing_team_id_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeResults_Result::losing_team_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeResults.Result.losing_team_id)
  return losing_team_id_;
}
inline void CMsgDOTALeagueNodeResults_Result::set_losing_team_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00001000u;
  losing_team_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeResults.Result.losing_team_id)
}

// optional bool has_started = 14;
inline bool CMsgDOTALeagueNodeResults_Result::has_has_started() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgDOTALeagueNodeResults_Result::clear_has_started() {
  has_started_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool CMsgDOTALeagueNodeResults_Result::has_started() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeResults.Result.has_started)
  return has_started_;
}
inline void CMsgDOTALeagueNodeResults_Result::set_has_started(bool value) {
  _has_bits_[0] |= 0x00002000u;
  has_started_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeResults.Result.has_started)
}

// optional bool is_completed = 15;
inline bool CMsgDOTALeagueNodeResults_Result::has_is_completed() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CMsgDOTALeagueNodeResults_Result::clear_is_completed() {
  is_completed_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool CMsgDOTALeagueNodeResults_Result::is_completed() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeResults.Result.is_completed)
  return is_completed_;
}
inline void CMsgDOTALeagueNodeResults_Result::set_is_completed(bool value) {
  _has_bits_[0] |= 0x00004000u;
  is_completed_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeResults.Result.is_completed)
}

// optional uint32 scheduled_time = 16;
inline bool CMsgDOTALeagueNodeResults_Result::has_scheduled_time() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CMsgDOTALeagueNodeResults_Result::clear_scheduled_time() {
  scheduled_time_ = 0u;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::google::protobuf::uint32 CMsgDOTALeagueNodeResults_Result::scheduled_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeResults.Result.scheduled_time)
  return scheduled_time_;
}
inline void CMsgDOTALeagueNodeResults_Result::set_scheduled_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00008000u;
  scheduled_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeResults.Result.scheduled_time)
}

// repeated uint64 match_ids = 17;
inline int CMsgDOTALeagueNodeResults_Result::match_ids_size() const {
  return match_ids_.size();
}
inline void CMsgDOTALeagueNodeResults_Result::clear_match_ids() {
  match_ids_.Clear();
}
inline ::google::protobuf::uint64 CMsgDOTALeagueNodeResults_Result::match_ids(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeResults.Result.match_ids)
  return match_ids_.Get(index);
}
inline void CMsgDOTALeagueNodeResults_Result::set_match_ids(int index, ::google::protobuf::uint64 value) {
  match_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeagueNodeResults.Result.match_ids)
}
inline void CMsgDOTALeagueNodeResults_Result::add_match_ids(::google::protobuf::uint64 value) {
  match_ids_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTALeagueNodeResults.Result.match_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CMsgDOTALeagueNodeResults_Result::match_ids() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTALeagueNodeResults.Result.match_ids)
  return match_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CMsgDOTALeagueNodeResults_Result::mutable_match_ids() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTALeagueNodeResults.Result.match_ids)
  return &match_ids_;
}

// -------------------------------------------------------------------

// CMsgDOTALeagueNodeResults

// repeated .proto.dota.CMsgDOTALeagueNodeResults.Result node_results = 1;
inline int CMsgDOTALeagueNodeResults::node_results_size() const {
  return node_results_.size();
}
inline void CMsgDOTALeagueNodeResults::clear_node_results() {
  node_results_.Clear();
}
inline ::proto::dota::CMsgDOTALeagueNodeResults_Result* CMsgDOTALeagueNodeResults::mutable_node_results(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeagueNodeResults.node_results)
  return node_results_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNodeResults_Result >*
CMsgDOTALeagueNodeResults::mutable_node_results() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTALeagueNodeResults.node_results)
  return &node_results_;
}
inline const ::proto::dota::CMsgDOTALeagueNodeResults_Result& CMsgDOTALeagueNodeResults::node_results(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeagueNodeResults.node_results)
  return node_results_.Get(index);
}
inline ::proto::dota::CMsgDOTALeagueNodeResults_Result* CMsgDOTALeagueNodeResults::add_node_results() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTALeagueNodeResults.node_results)
  return node_results_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeagueNodeResults_Result >&
CMsgDOTALeagueNodeResults::node_results() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTALeagueNodeResults.node_results)
  return node_results_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace dota
}  // namespace proto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::proto::dota::ELeagueNodeGroupType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::ELeagueNodeGroupType>() {
  return ::proto::dota::ELeagueNodeGroupType_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::ELeagueNodeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::ELeagueNodeType>() {
  return ::proto::dota::ELeagueNodeType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_dota_5fgcmessages_5fcommon_5fleague_2eproto
