// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dota_gcmessages_client_tournament.proto

#ifndef PROTOBUF_INCLUDED_dota_5fgcmessages_5fclient_5ftournament_2eproto
#define PROTOBUF_INCLUDED_dota_5fgcmessages_5fclient_5ftournament_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "dota_client_enums.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_dota_5fgcmessages_5fclient_5ftournament_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[30]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_dota_5fgcmessages_5fclient_5ftournament_2eproto();
namespace proto {
namespace dota {
class CMsgDOTAClearTournamentGame;
class CMsgDOTAClearTournamentGameDefaultTypeInternal;
extern CMsgDOTAClearTournamentGameDefaultTypeInternal _CMsgDOTAClearTournamentGame_default_instance_;
class CMsgDOTATournament;
class CMsgDOTATournamentDefaultTypeInternal;
extern CMsgDOTATournamentDefaultTypeInternal _CMsgDOTATournament_default_instance_;
class CMsgDOTATournamentInfo;
class CMsgDOTATournamentInfoDefaultTypeInternal;
extern CMsgDOTATournamentInfoDefaultTypeInternal _CMsgDOTATournamentInfo_default_instance_;
class CMsgDOTATournamentInfo_News;
class CMsgDOTATournamentInfo_NewsDefaultTypeInternal;
extern CMsgDOTATournamentInfo_NewsDefaultTypeInternal _CMsgDOTATournamentInfo_News_default_instance_;
class CMsgDOTATournamentInfo_Phase;
class CMsgDOTATournamentInfo_PhaseDefaultTypeInternal;
extern CMsgDOTATournamentInfo_PhaseDefaultTypeInternal _CMsgDOTATournamentInfo_Phase_default_instance_;
class CMsgDOTATournamentInfo_PhaseGroup;
class CMsgDOTATournamentInfo_PhaseGroupDefaultTypeInternal;
extern CMsgDOTATournamentInfo_PhaseGroupDefaultTypeInternal _CMsgDOTATournamentInfo_PhaseGroup_default_instance_;
class CMsgDOTATournamentInfo_Team;
class CMsgDOTATournamentInfo_TeamDefaultTypeInternal;
extern CMsgDOTATournamentInfo_TeamDefaultTypeInternal _CMsgDOTATournamentInfo_Team_default_instance_;
class CMsgDOTATournamentInfo_UpcomingMatch;
class CMsgDOTATournamentInfo_UpcomingMatchDefaultTypeInternal;
extern CMsgDOTATournamentInfo_UpcomingMatchDefaultTypeInternal _CMsgDOTATournamentInfo_UpcomingMatch_default_instance_;
class CMsgDOTATournamentRequest;
class CMsgDOTATournamentRequestDefaultTypeInternal;
extern CMsgDOTATournamentRequestDefaultTypeInternal _CMsgDOTATournamentRequest_default_instance_;
class CMsgDOTATournamentResponse;
class CMsgDOTATournamentResponseDefaultTypeInternal;
extern CMsgDOTATournamentResponseDefaultTypeInternal _CMsgDOTATournamentResponse_default_instance_;
class CMsgDOTATournamentStateChange;
class CMsgDOTATournamentStateChangeDefaultTypeInternal;
extern CMsgDOTATournamentStateChangeDefaultTypeInternal _CMsgDOTATournamentStateChange_default_instance_;
class CMsgDOTATournamentStateChange_GameChange;
class CMsgDOTATournamentStateChange_GameChangeDefaultTypeInternal;
extern CMsgDOTATournamentStateChange_GameChangeDefaultTypeInternal _CMsgDOTATournamentStateChange_GameChange_default_instance_;
class CMsgDOTATournamentStateChange_TeamChange;
class CMsgDOTATournamentStateChange_TeamChangeDefaultTypeInternal;
extern CMsgDOTATournamentStateChange_TeamChangeDefaultTypeInternal _CMsgDOTATournamentStateChange_TeamChange_default_instance_;
class CMsgDOTATournament_Game;
class CMsgDOTATournament_GameDefaultTypeInternal;
extern CMsgDOTATournament_GameDefaultTypeInternal _CMsgDOTATournament_Game_default_instance_;
class CMsgDOTATournament_Node;
class CMsgDOTATournament_NodeDefaultTypeInternal;
extern CMsgDOTATournament_NodeDefaultTypeInternal _CMsgDOTATournament_Node_default_instance_;
class CMsgDOTATournament_Team;
class CMsgDOTATournament_TeamDefaultTypeInternal;
extern CMsgDOTATournament_TeamDefaultTypeInternal _CMsgDOTATournament_Team_default_instance_;
class CMsgDOTAWeekendTourneyParticipationDetails;
class CMsgDOTAWeekendTourneyParticipationDetailsDefaultTypeInternal;
extern CMsgDOTAWeekendTourneyParticipationDetailsDefaultTypeInternal _CMsgDOTAWeekendTourneyParticipationDetails_default_instance_;
class CMsgDOTAWeekendTourneyParticipationDetails_Division;
class CMsgDOTAWeekendTourneyParticipationDetails_DivisionDefaultTypeInternal;
extern CMsgDOTAWeekendTourneyParticipationDetails_DivisionDefaultTypeInternal _CMsgDOTAWeekendTourneyParticipationDetails_Division_default_instance_;
class CMsgDOTAWeekendTourneyParticipationDetails_Tier;
class CMsgDOTAWeekendTourneyParticipationDetails_TierDefaultTypeInternal;
extern CMsgDOTAWeekendTourneyParticipationDetails_TierDefaultTypeInternal _CMsgDOTAWeekendTourneyParticipationDetails_Tier_default_instance_;
class CMsgDOTAWeekendTourneyPlayerHistory;
class CMsgDOTAWeekendTourneyPlayerHistoryDefaultTypeInternal;
extern CMsgDOTAWeekendTourneyPlayerHistoryDefaultTypeInternal _CMsgDOTAWeekendTourneyPlayerHistory_default_instance_;
class CMsgDOTAWeekendTourneyPlayerHistoryRequest;
class CMsgDOTAWeekendTourneyPlayerHistoryRequestDefaultTypeInternal;
extern CMsgDOTAWeekendTourneyPlayerHistoryRequestDefaultTypeInternal _CMsgDOTAWeekendTourneyPlayerHistoryRequest_default_instance_;
class CMsgDOTAWeekendTourneyPlayerHistory_Tournament;
class CMsgDOTAWeekendTourneyPlayerHistory_TournamentDefaultTypeInternal;
extern CMsgDOTAWeekendTourneyPlayerHistory_TournamentDefaultTypeInternal _CMsgDOTAWeekendTourneyPlayerHistory_Tournament_default_instance_;
class CMsgDOTAWeekendTourneyPlayerSkillLevelStats;
class CMsgDOTAWeekendTourneyPlayerSkillLevelStatsDefaultTypeInternal;
extern CMsgDOTAWeekendTourneyPlayerSkillLevelStatsDefaultTypeInternal _CMsgDOTAWeekendTourneyPlayerSkillLevelStats_default_instance_;
class CMsgDOTAWeekendTourneyPlayerStats;
class CMsgDOTAWeekendTourneyPlayerStatsDefaultTypeInternal;
extern CMsgDOTAWeekendTourneyPlayerStatsDefaultTypeInternal _CMsgDOTAWeekendTourneyPlayerStats_default_instance_;
class CMsgDOTAWeekendTourneyPlayerStatsRequest;
class CMsgDOTAWeekendTourneyPlayerStatsRequestDefaultTypeInternal;
extern CMsgDOTAWeekendTourneyPlayerStatsRequestDefaultTypeInternal _CMsgDOTAWeekendTourneyPlayerStatsRequest_default_instance_;
class CMsgRequestWeekendTourneySchedule;
class CMsgRequestWeekendTourneyScheduleDefaultTypeInternal;
extern CMsgRequestWeekendTourneyScheduleDefaultTypeInternal _CMsgRequestWeekendTourneySchedule_default_instance_;
class CMsgWeekendTourneyLeave;
class CMsgWeekendTourneyLeaveDefaultTypeInternal;
extern CMsgWeekendTourneyLeaveDefaultTypeInternal _CMsgWeekendTourneyLeave_default_instance_;
class CMsgWeekendTourneyOpts;
class CMsgWeekendTourneyOptsDefaultTypeInternal;
extern CMsgWeekendTourneyOptsDefaultTypeInternal _CMsgWeekendTourneyOpts_default_instance_;
class CMsgWeekendTourneySchedule;
class CMsgWeekendTourneyScheduleDefaultTypeInternal;
extern CMsgWeekendTourneyScheduleDefaultTypeInternal _CMsgWeekendTourneySchedule_default_instance_;
class CMsgWeekendTourneySchedule_Division;
class CMsgWeekendTourneySchedule_DivisionDefaultTypeInternal;
extern CMsgWeekendTourneySchedule_DivisionDefaultTypeInternal _CMsgWeekendTourneySchedule_Division_default_instance_;
}  // namespace dota
}  // namespace proto
namespace google {
namespace protobuf {
template<> ::proto::dota::CMsgDOTAClearTournamentGame* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAClearTournamentGame>(Arena*);
template<> ::proto::dota::CMsgDOTATournament* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTATournament>(Arena*);
template<> ::proto::dota::CMsgDOTATournamentInfo* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTATournamentInfo>(Arena*);
template<> ::proto::dota::CMsgDOTATournamentInfo_News* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTATournamentInfo_News>(Arena*);
template<> ::proto::dota::CMsgDOTATournamentInfo_Phase* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTATournamentInfo_Phase>(Arena*);
template<> ::proto::dota::CMsgDOTATournamentInfo_PhaseGroup* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTATournamentInfo_PhaseGroup>(Arena*);
template<> ::proto::dota::CMsgDOTATournamentInfo_Team* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTATournamentInfo_Team>(Arena*);
template<> ::proto::dota::CMsgDOTATournamentInfo_UpcomingMatch* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTATournamentInfo_UpcomingMatch>(Arena*);
template<> ::proto::dota::CMsgDOTATournamentRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTATournamentRequest>(Arena*);
template<> ::proto::dota::CMsgDOTATournamentResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTATournamentResponse>(Arena*);
template<> ::proto::dota::CMsgDOTATournamentStateChange* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTATournamentStateChange>(Arena*);
template<> ::proto::dota::CMsgDOTATournamentStateChange_GameChange* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTATournamentStateChange_GameChange>(Arena*);
template<> ::proto::dota::CMsgDOTATournamentStateChange_TeamChange* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTATournamentStateChange_TeamChange>(Arena*);
template<> ::proto::dota::CMsgDOTATournament_Game* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTATournament_Game>(Arena*);
template<> ::proto::dota::CMsgDOTATournament_Node* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTATournament_Node>(Arena*);
template<> ::proto::dota::CMsgDOTATournament_Team* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTATournament_Team>(Arena*);
template<> ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails>(Arena*);
template<> ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Division* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Division>(Arena*);
template<> ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Tier* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Tier>(Arena*);
template<> ::proto::dota::CMsgDOTAWeekendTourneyPlayerHistory* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAWeekendTourneyPlayerHistory>(Arena*);
template<> ::proto::dota::CMsgDOTAWeekendTourneyPlayerHistoryRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAWeekendTourneyPlayerHistoryRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAWeekendTourneyPlayerHistory_Tournament* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAWeekendTourneyPlayerHistory_Tournament>(Arena*);
template<> ::proto::dota::CMsgDOTAWeekendTourneyPlayerSkillLevelStats* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAWeekendTourneyPlayerSkillLevelStats>(Arena*);
template<> ::proto::dota::CMsgDOTAWeekendTourneyPlayerStats* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAWeekendTourneyPlayerStats>(Arena*);
template<> ::proto::dota::CMsgDOTAWeekendTourneyPlayerStatsRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAWeekendTourneyPlayerStatsRequest>(Arena*);
template<> ::proto::dota::CMsgRequestWeekendTourneySchedule* Arena::CreateMaybeMessage<::proto::dota::CMsgRequestWeekendTourneySchedule>(Arena*);
template<> ::proto::dota::CMsgWeekendTourneyLeave* Arena::CreateMaybeMessage<::proto::dota::CMsgWeekendTourneyLeave>(Arena*);
template<> ::proto::dota::CMsgWeekendTourneyOpts* Arena::CreateMaybeMessage<::proto::dota::CMsgWeekendTourneyOpts>(Arena*);
template<> ::proto::dota::CMsgWeekendTourneySchedule* Arena::CreateMaybeMessage<::proto::dota::CMsgWeekendTourneySchedule>(Arena*);
template<> ::proto::dota::CMsgWeekendTourneySchedule_Division* Arena::CreateMaybeMessage<::proto::dota::CMsgWeekendTourneySchedule_Division>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace proto {
namespace dota {

enum ETournamentEvent {
  k_ETournamentEvent_None = 0,
  k_ETournamentEvent_TournamentCreated = 1,
  k_ETournamentEvent_TournamentsMerged = 2,
  k_ETournamentEvent_GameOutcome = 3,
  k_ETournamentEvent_TeamGivenBye = 4,
  k_ETournamentEvent_TournamentCanceledByAdmin = 5,
  k_ETournamentEvent_TeamAbandoned = 6,
  k_ETournamentEvent_ScheduledGameStarted = 7,
  k_ETournamentEvent_Canceled = 8,
  k_ETournamentEvent_TeamParticipationTimedOut_EntryFeeRefund = 9,
  k_ETournamentEvent_TeamParticipationTimedOut_EntryFeeForfeit = 10,
  k_ETournamentEvent_TeamParticipationTimedOut_GrantedVictory = 11
};
bool ETournamentEvent_IsValid(int value);
const ETournamentEvent ETournamentEvent_MIN = k_ETournamentEvent_None;
const ETournamentEvent ETournamentEvent_MAX = k_ETournamentEvent_TeamParticipationTimedOut_GrantedVictory;
const int ETournamentEvent_ARRAYSIZE = ETournamentEvent_MAX + 1;

const ::google::protobuf::EnumDescriptor* ETournamentEvent_descriptor();
inline const ::std::string& ETournamentEvent_Name(ETournamentEvent value) {
  return ::google::protobuf::internal::NameOfEnum(
    ETournamentEvent_descriptor(), value);
}
inline bool ETournamentEvent_Parse(
    const ::std::string& name, ETournamentEvent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ETournamentEvent>(
    ETournamentEvent_descriptor(), name, value);
}
// ===================================================================

class CMsgDOTATournamentInfo_PhaseGroup final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTATournamentInfo.PhaseGroup) */ {
 public:
  CMsgDOTATournamentInfo_PhaseGroup();
  virtual ~CMsgDOTATournamentInfo_PhaseGroup();

  CMsgDOTATournamentInfo_PhaseGroup(const CMsgDOTATournamentInfo_PhaseGroup& from);

  inline CMsgDOTATournamentInfo_PhaseGroup& operator=(const CMsgDOTATournamentInfo_PhaseGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTATournamentInfo_PhaseGroup(CMsgDOTATournamentInfo_PhaseGroup&& from) noexcept
    : CMsgDOTATournamentInfo_PhaseGroup() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATournamentInfo_PhaseGroup& operator=(CMsgDOTATournamentInfo_PhaseGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTATournamentInfo_PhaseGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTATournamentInfo_PhaseGroup* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATournamentInfo_PhaseGroup*>(
               &_CMsgDOTATournamentInfo_PhaseGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CMsgDOTATournamentInfo_PhaseGroup* other);
  friend void swap(CMsgDOTATournamentInfo_PhaseGroup& a, CMsgDOTATournamentInfo_PhaseGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTATournamentInfo_PhaseGroup* New() const final {
    return CreateMaybeMessage<CMsgDOTATournamentInfo_PhaseGroup>(nullptr);
  }

  CMsgDOTATournamentInfo_PhaseGroup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTATournamentInfo_PhaseGroup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTATournamentInfo_PhaseGroup& from);
  void MergeFrom(const CMsgDOTATournamentInfo_PhaseGroup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATournamentInfo_PhaseGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string group_name = 2;
  bool has_group_name() const;
  void clear_group_name();
  static const int kGroupNameFieldNumber = 2;
  const ::std::string& group_name() const;
  void set_group_name(const ::std::string& value);
  #if LANG_CXX11
  void set_group_name(::std::string&& value);
  #endif
  void set_group_name(const char* value);
  void set_group_name(const char* value, size_t size);
  ::std::string* mutable_group_name();
  ::std::string* release_group_name();
  void set_allocated_group_name(::std::string* group_name);

  // optional uint32 group_id = 1;
  bool has_group_id() const;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  ::google::protobuf::uint32 group_id() const;
  void set_group_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTATournamentInfo.PhaseGroup)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr group_name_;
  ::google::protobuf::uint32 group_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATournamentInfo_Phase final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTATournamentInfo.Phase) */ {
 public:
  CMsgDOTATournamentInfo_Phase();
  virtual ~CMsgDOTATournamentInfo_Phase();

  CMsgDOTATournamentInfo_Phase(const CMsgDOTATournamentInfo_Phase& from);

  inline CMsgDOTATournamentInfo_Phase& operator=(const CMsgDOTATournamentInfo_Phase& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTATournamentInfo_Phase(CMsgDOTATournamentInfo_Phase&& from) noexcept
    : CMsgDOTATournamentInfo_Phase() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATournamentInfo_Phase& operator=(CMsgDOTATournamentInfo_Phase&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTATournamentInfo_Phase& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTATournamentInfo_Phase* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATournamentInfo_Phase*>(
               &_CMsgDOTATournamentInfo_Phase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(CMsgDOTATournamentInfo_Phase* other);
  friend void swap(CMsgDOTATournamentInfo_Phase& a, CMsgDOTATournamentInfo_Phase& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTATournamentInfo_Phase* New() const final {
    return CreateMaybeMessage<CMsgDOTATournamentInfo_Phase>(nullptr);
  }

  CMsgDOTATournamentInfo_Phase* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTATournamentInfo_Phase>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTATournamentInfo_Phase& from);
  void MergeFrom(const CMsgDOTATournamentInfo_Phase& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATournamentInfo_Phase* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTATournamentInfo.PhaseGroup group_list = 7;
  int group_list_size() const;
  void clear_group_list();
  static const int kGroupListFieldNumber = 7;
  ::proto::dota::CMsgDOTATournamentInfo_PhaseGroup* mutable_group_list(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_PhaseGroup >*
      mutable_group_list();
  const ::proto::dota::CMsgDOTATournamentInfo_PhaseGroup& group_list(int index) const;
  ::proto::dota::CMsgDOTATournamentInfo_PhaseGroup* add_group_list();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_PhaseGroup >&
      group_list() const;

  // optional string phase_name = 2;
  bool has_phase_name() const;
  void clear_phase_name();
  static const int kPhaseNameFieldNumber = 2;
  const ::std::string& phase_name() const;
  void set_phase_name(const ::std::string& value);
  #if LANG_CXX11
  void set_phase_name(::std::string&& value);
  #endif
  void set_phase_name(const char* value);
  void set_phase_name(const char* value, size_t size);
  ::std::string* mutable_phase_name();
  ::std::string* release_phase_name();
  void set_allocated_phase_name(::std::string* phase_name);

  // optional uint32 phase_id = 1;
  bool has_phase_id() const;
  void clear_phase_id();
  static const int kPhaseIdFieldNumber = 1;
  ::google::protobuf::uint32 phase_id() const;
  void set_phase_id(::google::protobuf::uint32 value);

  // optional uint32 type_id = 3;
  bool has_type_id() const;
  void clear_type_id();
  static const int kTypeIdFieldNumber = 3;
  ::google::protobuf::uint32 type_id() const;
  void set_type_id(::google::protobuf::uint32 value);

  // optional uint32 iterations = 4;
  bool has_iterations() const;
  void clear_iterations();
  static const int kIterationsFieldNumber = 4;
  ::google::protobuf::uint32 iterations() const;
  void set_iterations(::google::protobuf::uint32 value);

  // optional uint32 min_start_time = 5;
  bool has_min_start_time() const;
  void clear_min_start_time();
  static const int kMinStartTimeFieldNumber = 5;
  ::google::protobuf::uint32 min_start_time() const;
  void set_min_start_time(::google::protobuf::uint32 value);

  // optional uint32 max_start_time = 6;
  bool has_max_start_time() const;
  void clear_max_start_time();
  static const int kMaxStartTimeFieldNumber = 6;
  ::google::protobuf::uint32 max_start_time() const;
  void set_max_start_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTATournamentInfo.Phase)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_PhaseGroup > group_list_;
  ::google::protobuf::internal::ArenaStringPtr phase_name_;
  ::google::protobuf::uint32 phase_id_;
  ::google::protobuf::uint32 type_id_;
  ::google::protobuf::uint32 iterations_;
  ::google::protobuf::uint32 min_start_time_;
  ::google::protobuf::uint32 max_start_time_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATournamentInfo_Team final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTATournamentInfo.Team) */ {
 public:
  CMsgDOTATournamentInfo_Team();
  virtual ~CMsgDOTATournamentInfo_Team();

  CMsgDOTATournamentInfo_Team(const CMsgDOTATournamentInfo_Team& from);

  inline CMsgDOTATournamentInfo_Team& operator=(const CMsgDOTATournamentInfo_Team& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTATournamentInfo_Team(CMsgDOTATournamentInfo_Team&& from) noexcept
    : CMsgDOTATournamentInfo_Team() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATournamentInfo_Team& operator=(CMsgDOTATournamentInfo_Team&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTATournamentInfo_Team& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTATournamentInfo_Team* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATournamentInfo_Team*>(
               &_CMsgDOTATournamentInfo_Team_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(CMsgDOTATournamentInfo_Team* other);
  friend void swap(CMsgDOTATournamentInfo_Team& a, CMsgDOTATournamentInfo_Team& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTATournamentInfo_Team* New() const final {
    return CreateMaybeMessage<CMsgDOTATournamentInfo_Team>(nullptr);
  }

  CMsgDOTATournamentInfo_Team* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTATournamentInfo_Team>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTATournamentInfo_Team& from);
  void MergeFrom(const CMsgDOTATournamentInfo_Team& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATournamentInfo_Team* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string tag = 3;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 3;
  const ::std::string& tag() const;
  void set_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_tag(::std::string&& value);
  #endif
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  ::std::string* mutable_tag();
  ::std::string* release_tag();
  void set_allocated_tag(::std::string* tag);

  // optional uint32 team_id = 1;
  bool has_team_id() const;
  void clear_team_id();
  static const int kTeamIdFieldNumber = 1;
  ::google::protobuf::uint32 team_id() const;
  void set_team_id(::google::protobuf::uint32 value);

  // optional bool eliminated = 5;
  bool has_eliminated() const;
  void clear_eliminated();
  static const int kEliminatedFieldNumber = 5;
  bool eliminated() const;
  void set_eliminated(bool value);

  // optional uint64 team_logo = 4;
  bool has_team_logo() const;
  void clear_team_logo();
  static const int kTeamLogoFieldNumber = 4;
  ::google::protobuf::uint64 team_logo() const;
  void set_team_logo(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTATournamentInfo.Team)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr tag_;
  ::google::protobuf::uint32 team_id_;
  bool eliminated_;
  ::google::protobuf::uint64 team_logo_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATournamentInfo_UpcomingMatch final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch) */ {
 public:
  CMsgDOTATournamentInfo_UpcomingMatch();
  virtual ~CMsgDOTATournamentInfo_UpcomingMatch();

  CMsgDOTATournamentInfo_UpcomingMatch(const CMsgDOTATournamentInfo_UpcomingMatch& from);

  inline CMsgDOTATournamentInfo_UpcomingMatch& operator=(const CMsgDOTATournamentInfo_UpcomingMatch& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTATournamentInfo_UpcomingMatch(CMsgDOTATournamentInfo_UpcomingMatch&& from) noexcept
    : CMsgDOTATournamentInfo_UpcomingMatch() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATournamentInfo_UpcomingMatch& operator=(CMsgDOTATournamentInfo_UpcomingMatch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTATournamentInfo_UpcomingMatch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTATournamentInfo_UpcomingMatch* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATournamentInfo_UpcomingMatch*>(
               &_CMsgDOTATournamentInfo_UpcomingMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(CMsgDOTATournamentInfo_UpcomingMatch* other);
  friend void swap(CMsgDOTATournamentInfo_UpcomingMatch& a, CMsgDOTATournamentInfo_UpcomingMatch& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTATournamentInfo_UpcomingMatch* New() const final {
    return CreateMaybeMessage<CMsgDOTATournamentInfo_UpcomingMatch>(nullptr);
  }

  CMsgDOTATournamentInfo_UpcomingMatch* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTATournamentInfo_UpcomingMatch>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTATournamentInfo_UpcomingMatch& from);
  void MergeFrom(const CMsgDOTATournamentInfo_UpcomingMatch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATournamentInfo_UpcomingMatch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string stage_name = 5;
  bool has_stage_name() const;
  void clear_stage_name();
  static const int kStageNameFieldNumber = 5;
  const ::std::string& stage_name() const;
  void set_stage_name(const ::std::string& value);
  #if LANG_CXX11
  void set_stage_name(::std::string&& value);
  #endif
  void set_stage_name(const char* value);
  void set_stage_name(const char* value, size_t size);
  ::std::string* mutable_stage_name();
  ::std::string* release_stage_name();
  void set_allocated_stage_name(::std::string* stage_name);

  // optional string winner_stage = 7;
  bool has_winner_stage() const;
  void clear_winner_stage();
  static const int kWinnerStageFieldNumber = 7;
  const ::std::string& winner_stage() const;
  void set_winner_stage(const ::std::string& value);
  #if LANG_CXX11
  void set_winner_stage(::std::string&& value);
  #endif
  void set_winner_stage(const char* value);
  void set_winner_stage(const char* value, size_t size);
  ::std::string* mutable_winner_stage();
  ::std::string* release_winner_stage();
  void set_allocated_winner_stage(::std::string* winner_stage);

  // optional string loser_stage = 8;
  bool has_loser_stage() const;
  void clear_loser_stage();
  static const int kLoserStageFieldNumber = 8;
  const ::std::string& loser_stage() const;
  void set_loser_stage(const ::std::string& value);
  #if LANG_CXX11
  void set_loser_stage(::std::string&& value);
  #endif
  void set_loser_stage(const char* value);
  void set_loser_stage(const char* value, size_t size);
  ::std::string* mutable_loser_stage();
  ::std::string* release_loser_stage();
  void set_allocated_loser_stage(::std::string* loser_stage);

  // optional string team1_tag = 9;
  bool has_team1_tag() const;
  void clear_team1_tag();
  static const int kTeam1TagFieldNumber = 9;
  const ::std::string& team1_tag() const;
  void set_team1_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_team1_tag(::std::string&& value);
  #endif
  void set_team1_tag(const char* value);
  void set_team1_tag(const char* value, size_t size);
  ::std::string* mutable_team1_tag();
  ::std::string* release_team1_tag();
  void set_allocated_team1_tag(::std::string* team1_tag);

  // optional string team2_tag = 10;
  bool has_team2_tag() const;
  void clear_team2_tag();
  static const int kTeam2TagFieldNumber = 10;
  const ::std::string& team2_tag() const;
  void set_team2_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_team2_tag(::std::string&& value);
  #endif
  void set_team2_tag(const char* value);
  void set_team2_tag(const char* value, size_t size);
  ::std::string* mutable_team2_tag();
  ::std::string* release_team2_tag();
  void set_allocated_team2_tag(::std::string* team2_tag);

  // optional string team1_prev_opponent_tag = 11;
  bool has_team1_prev_opponent_tag() const;
  void clear_team1_prev_opponent_tag();
  static const int kTeam1PrevOpponentTagFieldNumber = 11;
  const ::std::string& team1_prev_opponent_tag() const;
  void set_team1_prev_opponent_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_team1_prev_opponent_tag(::std::string&& value);
  #endif
  void set_team1_prev_opponent_tag(const char* value);
  void set_team1_prev_opponent_tag(const char* value, size_t size);
  ::std::string* mutable_team1_prev_opponent_tag();
  ::std::string* release_team1_prev_opponent_tag();
  void set_allocated_team1_prev_opponent_tag(::std::string* team1_prev_opponent_tag);

  // optional string team2_prev_opponent_tag = 12;
  bool has_team2_prev_opponent_tag() const;
  void clear_team2_prev_opponent_tag();
  static const int kTeam2PrevOpponentTagFieldNumber = 12;
  const ::std::string& team2_prev_opponent_tag() const;
  void set_team2_prev_opponent_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_team2_prev_opponent_tag(::std::string&& value);
  #endif
  void set_team2_prev_opponent_tag(const char* value);
  void set_team2_prev_opponent_tag(const char* value, size_t size);
  ::std::string* mutable_team2_prev_opponent_tag();
  ::std::string* release_team2_prev_opponent_tag();
  void set_allocated_team2_prev_opponent_tag(::std::string* team2_prev_opponent_tag);

  // optional uint32 series_id = 1;
  bool has_series_id() const;
  void clear_series_id();
  static const int kSeriesIdFieldNumber = 1;
  ::google::protobuf::uint32 series_id() const;
  void set_series_id(::google::protobuf::uint32 value);

  // optional uint32 team1_id = 2;
  bool has_team1_id() const;
  void clear_team1_id();
  static const int kTeam1IdFieldNumber = 2;
  ::google::protobuf::uint32 team1_id() const;
  void set_team1_id(::google::protobuf::uint32 value);

  // optional uint32 team2_id = 3;
  bool has_team2_id() const;
  void clear_team2_id();
  static const int kTeam2IdFieldNumber = 3;
  ::google::protobuf::uint32 team2_id() const;
  void set_team2_id(::google::protobuf::uint32 value);

  // optional uint32 bo = 4;
  bool has_bo() const;
  void clear_bo();
  static const int kBoFieldNumber = 4;
  ::google::protobuf::uint32 bo() const;
  void set_bo(::google::protobuf::uint32 value);

  // optional uint32 start_time = 6;
  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 6;
  ::google::protobuf::uint32 start_time() const;
  void set_start_time(::google::protobuf::uint32 value);

  // optional uint32 team1_prev_opponent_id = 17;
  bool has_team1_prev_opponent_id() const;
  void clear_team1_prev_opponent_id();
  static const int kTeam1PrevOpponentIdFieldNumber = 17;
  ::google::protobuf::uint32 team1_prev_opponent_id() const;
  void set_team1_prev_opponent_id(::google::protobuf::uint32 value);

  // optional uint64 team1_logo = 13;
  bool has_team1_logo() const;
  void clear_team1_logo();
  static const int kTeam1LogoFieldNumber = 13;
  ::google::protobuf::uint64 team1_logo() const;
  void set_team1_logo(::google::protobuf::uint64 value);

  // optional uint64 team2_logo = 14;
  bool has_team2_logo() const;
  void clear_team2_logo();
  static const int kTeam2LogoFieldNumber = 14;
  ::google::protobuf::uint64 team2_logo() const;
  void set_team2_logo(::google::protobuf::uint64 value);

  // optional uint64 team1_prev_opponent_logo = 15;
  bool has_team1_prev_opponent_logo() const;
  void clear_team1_prev_opponent_logo();
  static const int kTeam1PrevOpponentLogoFieldNumber = 15;
  ::google::protobuf::uint64 team1_prev_opponent_logo() const;
  void set_team1_prev_opponent_logo(::google::protobuf::uint64 value);

  // optional uint64 team2_prev_opponent_logo = 16;
  bool has_team2_prev_opponent_logo() const;
  void clear_team2_prev_opponent_logo();
  static const int kTeam2PrevOpponentLogoFieldNumber = 16;
  ::google::protobuf::uint64 team2_prev_opponent_logo() const;
  void set_team2_prev_opponent_logo(::google::protobuf::uint64 value);

  // optional uint32 team2_prev_opponent_id = 18;
  bool has_team2_prev_opponent_id() const;
  void clear_team2_prev_opponent_id();
  static const int kTeam2PrevOpponentIdFieldNumber = 18;
  ::google::protobuf::uint32 team2_prev_opponent_id() const;
  void set_team2_prev_opponent_id(::google::protobuf::uint32 value);

  // optional uint32 team1_prev_match_score = 19;
  bool has_team1_prev_match_score() const;
  void clear_team1_prev_match_score();
  static const int kTeam1PrevMatchScoreFieldNumber = 19;
  ::google::protobuf::uint32 team1_prev_match_score() const;
  void set_team1_prev_match_score(::google::protobuf::uint32 value);

  // optional uint32 team1_prev_match_opponent_score = 20;
  bool has_team1_prev_match_opponent_score() const;
  void clear_team1_prev_match_opponent_score();
  static const int kTeam1PrevMatchOpponentScoreFieldNumber = 20;
  ::google::protobuf::uint32 team1_prev_match_opponent_score() const;
  void set_team1_prev_match_opponent_score(::google::protobuf::uint32 value);

  // optional uint32 team2_prev_match_score = 21;
  bool has_team2_prev_match_score() const;
  void clear_team2_prev_match_score();
  static const int kTeam2PrevMatchScoreFieldNumber = 21;
  ::google::protobuf::uint32 team2_prev_match_score() const;
  void set_team2_prev_match_score(::google::protobuf::uint32 value);

  // optional uint32 team2_prev_match_opponent_score = 22;
  bool has_team2_prev_match_opponent_score() const;
  void clear_team2_prev_match_opponent_score();
  static const int kTeam2PrevMatchOpponentScoreFieldNumber = 22;
  ::google::protobuf::uint32 team2_prev_match_opponent_score() const;
  void set_team2_prev_match_opponent_score(::google::protobuf::uint32 value);

  // optional uint32 phase_type = 23;
  bool has_phase_type() const;
  void clear_phase_type();
  static const int kPhaseTypeFieldNumber = 23;
  ::google::protobuf::uint32 phase_type() const;
  void set_phase_type(::google::protobuf::uint32 value);

  // optional uint32 team1_score = 24;
  bool has_team1_score() const;
  void clear_team1_score();
  static const int kTeam1ScoreFieldNumber = 24;
  ::google::protobuf::uint32 team1_score() const;
  void set_team1_score(::google::protobuf::uint32 value);

  // optional uint32 team2_score = 25;
  bool has_team2_score() const;
  void clear_team2_score();
  static const int kTeam2ScoreFieldNumber = 25;
  ::google::protobuf::uint32 team2_score() const;
  void set_team2_score(::google::protobuf::uint32 value);

  // optional uint32 phase_id = 26;
  bool has_phase_id() const;
  void clear_phase_id();
  static const int kPhaseIdFieldNumber = 26;
  ::google::protobuf::uint32 phase_id() const;
  void set_phase_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr stage_name_;
  ::google::protobuf::internal::ArenaStringPtr winner_stage_;
  ::google::protobuf::internal::ArenaStringPtr loser_stage_;
  ::google::protobuf::internal::ArenaStringPtr team1_tag_;
  ::google::protobuf::internal::ArenaStringPtr team2_tag_;
  ::google::protobuf::internal::ArenaStringPtr team1_prev_opponent_tag_;
  ::google::protobuf::internal::ArenaStringPtr team2_prev_opponent_tag_;
  ::google::protobuf::uint32 series_id_;
  ::google::protobuf::uint32 team1_id_;
  ::google::protobuf::uint32 team2_id_;
  ::google::protobuf::uint32 bo_;
  ::google::protobuf::uint32 start_time_;
  ::google::protobuf::uint32 team1_prev_opponent_id_;
  ::google::protobuf::uint64 team1_logo_;
  ::google::protobuf::uint64 team2_logo_;
  ::google::protobuf::uint64 team1_prev_opponent_logo_;
  ::google::protobuf::uint64 team2_prev_opponent_logo_;
  ::google::protobuf::uint32 team2_prev_opponent_id_;
  ::google::protobuf::uint32 team1_prev_match_score_;
  ::google::protobuf::uint32 team1_prev_match_opponent_score_;
  ::google::protobuf::uint32 team2_prev_match_score_;
  ::google::protobuf::uint32 team2_prev_match_opponent_score_;
  ::google::protobuf::uint32 phase_type_;
  ::google::protobuf::uint32 team1_score_;
  ::google::protobuf::uint32 team2_score_;
  ::google::protobuf::uint32 phase_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATournamentInfo_News final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTATournamentInfo.News) */ {
 public:
  CMsgDOTATournamentInfo_News();
  virtual ~CMsgDOTATournamentInfo_News();

  CMsgDOTATournamentInfo_News(const CMsgDOTATournamentInfo_News& from);

  inline CMsgDOTATournamentInfo_News& operator=(const CMsgDOTATournamentInfo_News& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTATournamentInfo_News(CMsgDOTATournamentInfo_News&& from) noexcept
    : CMsgDOTATournamentInfo_News() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATournamentInfo_News& operator=(CMsgDOTATournamentInfo_News&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTATournamentInfo_News& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTATournamentInfo_News* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATournamentInfo_News*>(
               &_CMsgDOTATournamentInfo_News_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(CMsgDOTATournamentInfo_News* other);
  friend void swap(CMsgDOTATournamentInfo_News& a, CMsgDOTATournamentInfo_News& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTATournamentInfo_News* New() const final {
    return CreateMaybeMessage<CMsgDOTATournamentInfo_News>(nullptr);
  }

  CMsgDOTATournamentInfo_News* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTATournamentInfo_News>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTATournamentInfo_News& from);
  void MergeFrom(const CMsgDOTATournamentInfo_News& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATournamentInfo_News* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string link = 1;
  bool has_link() const;
  void clear_link();
  static const int kLinkFieldNumber = 1;
  const ::std::string& link() const;
  void set_link(const ::std::string& value);
  #if LANG_CXX11
  void set_link(::std::string&& value);
  #endif
  void set_link(const char* value);
  void set_link(const char* value, size_t size);
  ::std::string* mutable_link();
  ::std::string* release_link();
  void set_allocated_link(::std::string* link);

  // optional string title = 2;
  bool has_title() const;
  void clear_title();
  static const int kTitleFieldNumber = 2;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  #if LANG_CXX11
  void set_title(::std::string&& value);
  #endif
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // optional string image = 3;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 3;
  const ::std::string& image() const;
  void set_image(const ::std::string& value);
  #if LANG_CXX11
  void set_image(::std::string&& value);
  #endif
  void set_image(const char* value);
  void set_image(const char* value, size_t size);
  ::std::string* mutable_image();
  ::std::string* release_image();
  void set_allocated_image(::std::string* image);

  // optional uint32 timestamp = 4;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTATournamentInfo.News)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr link_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  ::google::protobuf::internal::ArenaStringPtr image_;
  ::google::protobuf::uint32 timestamp_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATournamentInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTATournamentInfo) */ {
 public:
  CMsgDOTATournamentInfo();
  virtual ~CMsgDOTATournamentInfo();

  CMsgDOTATournamentInfo(const CMsgDOTATournamentInfo& from);

  inline CMsgDOTATournamentInfo& operator=(const CMsgDOTATournamentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTATournamentInfo(CMsgDOTATournamentInfo&& from) noexcept
    : CMsgDOTATournamentInfo() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATournamentInfo& operator=(CMsgDOTATournamentInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTATournamentInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTATournamentInfo* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATournamentInfo*>(
               &_CMsgDOTATournamentInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(CMsgDOTATournamentInfo* other);
  friend void swap(CMsgDOTATournamentInfo& a, CMsgDOTATournamentInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTATournamentInfo* New() const final {
    return CreateMaybeMessage<CMsgDOTATournamentInfo>(nullptr);
  }

  CMsgDOTATournamentInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTATournamentInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTATournamentInfo& from);
  void MergeFrom(const CMsgDOTATournamentInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATournamentInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTATournamentInfo_PhaseGroup PhaseGroup;
  typedef CMsgDOTATournamentInfo_Phase Phase;
  typedef CMsgDOTATournamentInfo_Team Team;
  typedef CMsgDOTATournamentInfo_UpcomingMatch UpcomingMatch;
  typedef CMsgDOTATournamentInfo_News News;

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTATournamentInfo.Phase phase_list = 2;
  int phase_list_size() const;
  void clear_phase_list();
  static const int kPhaseListFieldNumber = 2;
  ::proto::dota::CMsgDOTATournamentInfo_Phase* mutable_phase_list(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_Phase >*
      mutable_phase_list();
  const ::proto::dota::CMsgDOTATournamentInfo_Phase& phase_list(int index) const;
  ::proto::dota::CMsgDOTATournamentInfo_Phase* add_phase_list();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_Phase >&
      phase_list() const;

  // repeated .proto.dota.CMsgDOTATournamentInfo.Team teams_list = 3;
  int teams_list_size() const;
  void clear_teams_list();
  static const int kTeamsListFieldNumber = 3;
  ::proto::dota::CMsgDOTATournamentInfo_Team* mutable_teams_list(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_Team >*
      mutable_teams_list();
  const ::proto::dota::CMsgDOTATournamentInfo_Team& teams_list(int index) const;
  ::proto::dota::CMsgDOTATournamentInfo_Team* add_teams_list();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_Team >&
      teams_list() const;

  // repeated .proto.dota.CMsgDOTATournamentInfo.UpcomingMatch upcoming_matches_list = 4;
  int upcoming_matches_list_size() const;
  void clear_upcoming_matches_list();
  static const int kUpcomingMatchesListFieldNumber = 4;
  ::proto::dota::CMsgDOTATournamentInfo_UpcomingMatch* mutable_upcoming_matches_list(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_UpcomingMatch >*
      mutable_upcoming_matches_list();
  const ::proto::dota::CMsgDOTATournamentInfo_UpcomingMatch& upcoming_matches_list(int index) const;
  ::proto::dota::CMsgDOTATournamentInfo_UpcomingMatch* add_upcoming_matches_list();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_UpcomingMatch >&
      upcoming_matches_list() const;

  // repeated .proto.dota.CMsgDOTATournamentInfo.News news_list = 5;
  int news_list_size() const;
  void clear_news_list();
  static const int kNewsListFieldNumber = 5;
  ::proto::dota::CMsgDOTATournamentInfo_News* mutable_news_list(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_News >*
      mutable_news_list();
  const ::proto::dota::CMsgDOTATournamentInfo_News& news_list(int index) const;
  ::proto::dota::CMsgDOTATournamentInfo_News* add_news_list();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_News >&
      news_list() const;

  // optional uint32 league_id = 1;
  bool has_league_id() const;
  void clear_league_id();
  static const int kLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 league_id() const;
  void set_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTATournamentInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_Phase > phase_list_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_Team > teams_list_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_UpcomingMatch > upcoming_matches_list_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_News > news_list_;
  ::google::protobuf::uint32 league_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgRequestWeekendTourneySchedule final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgRequestWeekendTourneySchedule) */ {
 public:
  CMsgRequestWeekendTourneySchedule();
  virtual ~CMsgRequestWeekendTourneySchedule();

  CMsgRequestWeekendTourneySchedule(const CMsgRequestWeekendTourneySchedule& from);

  inline CMsgRequestWeekendTourneySchedule& operator=(const CMsgRequestWeekendTourneySchedule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgRequestWeekendTourneySchedule(CMsgRequestWeekendTourneySchedule&& from) noexcept
    : CMsgRequestWeekendTourneySchedule() {
    *this = ::std::move(from);
  }

  inline CMsgRequestWeekendTourneySchedule& operator=(CMsgRequestWeekendTourneySchedule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgRequestWeekendTourneySchedule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgRequestWeekendTourneySchedule* internal_default_instance() {
    return reinterpret_cast<const CMsgRequestWeekendTourneySchedule*>(
               &_CMsgRequestWeekendTourneySchedule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(CMsgRequestWeekendTourneySchedule* other);
  friend void swap(CMsgRequestWeekendTourneySchedule& a, CMsgRequestWeekendTourneySchedule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgRequestWeekendTourneySchedule* New() const final {
    return CreateMaybeMessage<CMsgRequestWeekendTourneySchedule>(nullptr);
  }

  CMsgRequestWeekendTourneySchedule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgRequestWeekendTourneySchedule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgRequestWeekendTourneySchedule& from);
  void MergeFrom(const CMsgRequestWeekendTourneySchedule& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgRequestWeekendTourneySchedule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgRequestWeekendTourneySchedule)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgWeekendTourneySchedule_Division final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgWeekendTourneySchedule.Division) */ {
 public:
  CMsgWeekendTourneySchedule_Division();
  virtual ~CMsgWeekendTourneySchedule_Division();

  CMsgWeekendTourneySchedule_Division(const CMsgWeekendTourneySchedule_Division& from);

  inline CMsgWeekendTourneySchedule_Division& operator=(const CMsgWeekendTourneySchedule_Division& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgWeekendTourneySchedule_Division(CMsgWeekendTourneySchedule_Division&& from) noexcept
    : CMsgWeekendTourneySchedule_Division() {
    *this = ::std::move(from);
  }

  inline CMsgWeekendTourneySchedule_Division& operator=(CMsgWeekendTourneySchedule_Division&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgWeekendTourneySchedule_Division& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgWeekendTourneySchedule_Division* internal_default_instance() {
    return reinterpret_cast<const CMsgWeekendTourneySchedule_Division*>(
               &_CMsgWeekendTourneySchedule_Division_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(CMsgWeekendTourneySchedule_Division* other);
  friend void swap(CMsgWeekendTourneySchedule_Division& a, CMsgWeekendTourneySchedule_Division& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgWeekendTourneySchedule_Division* New() const final {
    return CreateMaybeMessage<CMsgWeekendTourneySchedule_Division>(nullptr);
  }

  CMsgWeekendTourneySchedule_Division* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgWeekendTourneySchedule_Division>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgWeekendTourneySchedule_Division& from);
  void MergeFrom(const CMsgWeekendTourneySchedule_Division& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgWeekendTourneySchedule_Division* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 division_code = 1;
  bool has_division_code() const;
  void clear_division_code();
  static const int kDivisionCodeFieldNumber = 1;
  ::google::protobuf::uint32 division_code() const;
  void set_division_code(::google::protobuf::uint32 value);

  // optional uint32 time_window_open = 2;
  bool has_time_window_open() const;
  void clear_time_window_open();
  static const int kTimeWindowOpenFieldNumber = 2;
  ::google::protobuf::uint32 time_window_open() const;
  void set_time_window_open(::google::protobuf::uint32 value);

  // optional uint32 time_window_close = 3;
  bool has_time_window_close() const;
  void clear_time_window_close();
  static const int kTimeWindowCloseFieldNumber = 3;
  ::google::protobuf::uint32 time_window_close() const;
  void set_time_window_close(::google::protobuf::uint32 value);

  // optional uint32 time_window_open_next = 4;
  bool has_time_window_open_next() const;
  void clear_time_window_open_next();
  static const int kTimeWindowOpenNextFieldNumber = 4;
  ::google::protobuf::uint32 time_window_open_next() const;
  void set_time_window_open_next(::google::protobuf::uint32 value);

  // optional uint32 trophy_id = 5;
  bool has_trophy_id() const;
  void clear_trophy_id();
  static const int kTrophyIdFieldNumber = 5;
  ::google::protobuf::uint32 trophy_id() const;
  void set_trophy_id(::google::protobuf::uint32 value);

  // optional bool free_weekend = 6;
  bool has_free_weekend() const;
  void clear_free_weekend();
  static const int kFreeWeekendFieldNumber = 6;
  bool free_weekend() const;
  void set_free_weekend(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgWeekendTourneySchedule.Division)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 division_code_;
  ::google::protobuf::uint32 time_window_open_;
  ::google::protobuf::uint32 time_window_close_;
  ::google::protobuf::uint32 time_window_open_next_;
  ::google::protobuf::uint32 trophy_id_;
  bool free_weekend_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgWeekendTourneySchedule final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgWeekendTourneySchedule) */ {
 public:
  CMsgWeekendTourneySchedule();
  virtual ~CMsgWeekendTourneySchedule();

  CMsgWeekendTourneySchedule(const CMsgWeekendTourneySchedule& from);

  inline CMsgWeekendTourneySchedule& operator=(const CMsgWeekendTourneySchedule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgWeekendTourneySchedule(CMsgWeekendTourneySchedule&& from) noexcept
    : CMsgWeekendTourneySchedule() {
    *this = ::std::move(from);
  }

  inline CMsgWeekendTourneySchedule& operator=(CMsgWeekendTourneySchedule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgWeekendTourneySchedule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgWeekendTourneySchedule* internal_default_instance() {
    return reinterpret_cast<const CMsgWeekendTourneySchedule*>(
               &_CMsgWeekendTourneySchedule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(CMsgWeekendTourneySchedule* other);
  friend void swap(CMsgWeekendTourneySchedule& a, CMsgWeekendTourneySchedule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgWeekendTourneySchedule* New() const final {
    return CreateMaybeMessage<CMsgWeekendTourneySchedule>(nullptr);
  }

  CMsgWeekendTourneySchedule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgWeekendTourneySchedule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgWeekendTourneySchedule& from);
  void MergeFrom(const CMsgWeekendTourneySchedule& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgWeekendTourneySchedule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgWeekendTourneySchedule_Division Division;

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgWeekendTourneySchedule.Division divisions = 1;
  int divisions_size() const;
  void clear_divisions();
  static const int kDivisionsFieldNumber = 1;
  ::proto::dota::CMsgWeekendTourneySchedule_Division* mutable_divisions(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgWeekendTourneySchedule_Division >*
      mutable_divisions();
  const ::proto::dota::CMsgWeekendTourneySchedule_Division& divisions(int index) const;
  ::proto::dota::CMsgWeekendTourneySchedule_Division* add_divisions();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgWeekendTourneySchedule_Division >&
      divisions() const;

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgWeekendTourneySchedule)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgWeekendTourneySchedule_Division > divisions_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgWeekendTourneyOpts final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgWeekendTourneyOpts) */ {
 public:
  CMsgWeekendTourneyOpts();
  virtual ~CMsgWeekendTourneyOpts();

  CMsgWeekendTourneyOpts(const CMsgWeekendTourneyOpts& from);

  inline CMsgWeekendTourneyOpts& operator=(const CMsgWeekendTourneyOpts& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgWeekendTourneyOpts(CMsgWeekendTourneyOpts&& from) noexcept
    : CMsgWeekendTourneyOpts() {
    *this = ::std::move(from);
  }

  inline CMsgWeekendTourneyOpts& operator=(CMsgWeekendTourneyOpts&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgWeekendTourneyOpts& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgWeekendTourneyOpts* internal_default_instance() {
    return reinterpret_cast<const CMsgWeekendTourneyOpts*>(
               &_CMsgWeekendTourneyOpts_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(CMsgWeekendTourneyOpts* other);
  friend void swap(CMsgWeekendTourneyOpts& a, CMsgWeekendTourneyOpts& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgWeekendTourneyOpts* New() const final {
    return CreateMaybeMessage<CMsgWeekendTourneyOpts>(nullptr);
  }

  CMsgWeekendTourneyOpts* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgWeekendTourneyOpts>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgWeekendTourneyOpts& from);
  void MergeFrom(const CMsgWeekendTourneyOpts& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgWeekendTourneyOpts* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string pickup_team_name = 7;
  bool has_pickup_team_name() const;
  void clear_pickup_team_name();
  static const int kPickupTeamNameFieldNumber = 7;
  const ::std::string& pickup_team_name() const;
  void set_pickup_team_name(const ::std::string& value);
  #if LANG_CXX11
  void set_pickup_team_name(::std::string&& value);
  #endif
  void set_pickup_team_name(const char* value);
  void set_pickup_team_name(const char* value, size_t size);
  ::std::string* mutable_pickup_team_name();
  ::std::string* release_pickup_team_name();
  void set_allocated_pickup_team_name(::std::string* pickup_team_name);

  // optional bool participating = 1;
  bool has_participating() const;
  void clear_participating();
  static const int kParticipatingFieldNumber = 1;
  bool participating() const;
  void set_participating(bool value);

  // optional uint32 division_id = 2;
  bool has_division_id() const;
  void clear_division_id();
  static const int kDivisionIdFieldNumber = 2;
  ::google::protobuf::uint32 division_id() const;
  void set_division_id(::google::protobuf::uint32 value);

  // optional uint32 buyin = 3;
  bool has_buyin() const;
  void clear_buyin();
  static const int kBuyinFieldNumber = 3;
  ::google::protobuf::uint32 buyin() const;
  void set_buyin(::google::protobuf::uint32 value);

  // optional uint32 skill_level = 4;
  bool has_skill_level() const;
  void clear_skill_level();
  static const int kSkillLevelFieldNumber = 4;
  ::google::protobuf::uint32 skill_level() const;
  void set_skill_level(::google::protobuf::uint32 value);

  // optional uint32 match_groups = 5;
  bool has_match_groups() const;
  void clear_match_groups();
  static const int kMatchGroupsFieldNumber = 5;
  ::google::protobuf::uint32 match_groups() const;
  void set_match_groups(::google::protobuf::uint32 value);

  // optional uint32 team_id = 6;
  bool has_team_id() const;
  void clear_team_id();
  static const int kTeamIdFieldNumber = 6;
  ::google::protobuf::uint32 team_id() const;
  void set_team_id(::google::protobuf::uint32 value);

  // optional uint64 pickup_team_logo = 8;
  bool has_pickup_team_logo() const;
  void clear_pickup_team_logo();
  static const int kPickupTeamLogoFieldNumber = 8;
  ::google::protobuf::uint64 pickup_team_logo() const;
  void set_pickup_team_logo(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgWeekendTourneyOpts)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr pickup_team_name_;
  bool participating_;
  ::google::protobuf::uint32 division_id_;
  ::google::protobuf::uint32 buyin_;
  ::google::protobuf::uint32 skill_level_;
  ::google::protobuf::uint32 match_groups_;
  ::google::protobuf::uint32 team_id_;
  ::google::protobuf::uint64 pickup_team_logo_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgWeekendTourneyLeave final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgWeekendTourneyLeave) */ {
 public:
  CMsgWeekendTourneyLeave();
  virtual ~CMsgWeekendTourneyLeave();

  CMsgWeekendTourneyLeave(const CMsgWeekendTourneyLeave& from);

  inline CMsgWeekendTourneyLeave& operator=(const CMsgWeekendTourneyLeave& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgWeekendTourneyLeave(CMsgWeekendTourneyLeave&& from) noexcept
    : CMsgWeekendTourneyLeave() {
    *this = ::std::move(from);
  }

  inline CMsgWeekendTourneyLeave& operator=(CMsgWeekendTourneyLeave&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgWeekendTourneyLeave& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgWeekendTourneyLeave* internal_default_instance() {
    return reinterpret_cast<const CMsgWeekendTourneyLeave*>(
               &_CMsgWeekendTourneyLeave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(CMsgWeekendTourneyLeave* other);
  friend void swap(CMsgWeekendTourneyLeave& a, CMsgWeekendTourneyLeave& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgWeekendTourneyLeave* New() const final {
    return CreateMaybeMessage<CMsgWeekendTourneyLeave>(nullptr);
  }

  CMsgWeekendTourneyLeave* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgWeekendTourneyLeave>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgWeekendTourneyLeave& from);
  void MergeFrom(const CMsgWeekendTourneyLeave& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgWeekendTourneyLeave* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgWeekendTourneyLeave)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATournament_Team final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTATournament.Team) */ {
 public:
  CMsgDOTATournament_Team();
  virtual ~CMsgDOTATournament_Team();

  CMsgDOTATournament_Team(const CMsgDOTATournament_Team& from);

  inline CMsgDOTATournament_Team& operator=(const CMsgDOTATournament_Team& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTATournament_Team(CMsgDOTATournament_Team&& from) noexcept
    : CMsgDOTATournament_Team() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATournament_Team& operator=(CMsgDOTATournament_Team&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTATournament_Team& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTATournament_Team* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATournament_Team*>(
               &_CMsgDOTATournament_Team_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(CMsgDOTATournament_Team* other);
  friend void swap(CMsgDOTATournament_Team& a, CMsgDOTATournament_Team& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTATournament_Team* New() const final {
    return CreateMaybeMessage<CMsgDOTATournament_Team>(nullptr);
  }

  CMsgDOTATournament_Team* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTATournament_Team>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTATournament_Team& from);
  void MergeFrom(const CMsgDOTATournament_Team& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATournament_Team* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 players = 3 [packed = true];
  int players_size() const;
  void clear_players();
  static const int kPlayersFieldNumber = 3;
  ::google::protobuf::uint32 players(int index) const;
  void set_players(int index, ::google::protobuf::uint32 value);
  void add_players(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      players() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_players();

  // repeated uint32 player_buyin = 9 [packed = true];
  int player_buyin_size() const;
  void clear_player_buyin();
  static const int kPlayerBuyinFieldNumber = 9;
  ::google::protobuf::uint32 player_buyin(int index) const;
  void set_player_buyin(int index, ::google::protobuf::uint32 value);
  void add_player_buyin(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      player_buyin() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_player_buyin();

  // repeated uint32 player_skill_level = 10 [packed = true];
  int player_skill_level_size() const;
  void clear_player_skill_level();
  static const int kPlayerSkillLevelFieldNumber = 10;
  ::google::protobuf::uint32 player_skill_level(int index) const;
  void set_player_skill_level(int index, ::google::protobuf::uint32 value);
  void add_player_skill_level(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      player_skill_level() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_player_skill_level();

  // optional string team_name = 5;
  bool has_team_name() const;
  void clear_team_name();
  static const int kTeamNameFieldNumber = 5;
  const ::std::string& team_name() const;
  void set_team_name(const ::std::string& value);
  #if LANG_CXX11
  void set_team_name(::std::string&& value);
  #endif
  void set_team_name(const char* value);
  void set_team_name(const char* value, size_t size);
  ::std::string* mutable_team_name();
  ::std::string* release_team_name();
  void set_allocated_team_name(::std::string* team_name);

  // optional fixed64 team_gid = 1;
  bool has_team_gid() const;
  void clear_team_gid();
  static const int kTeamGidFieldNumber = 1;
  ::google::protobuf::uint64 team_gid() const;
  void set_team_gid(::google::protobuf::uint64 value);

  // optional uint32 node_or_state = 2;
  bool has_node_or_state() const;
  void clear_node_or_state();
  static const int kNodeOrStateFieldNumber = 2;
  ::google::protobuf::uint32 node_or_state() const;
  void set_node_or_state(::google::protobuf::uint32 value);

  // optional uint32 team_id = 4;
  bool has_team_id() const;
  void clear_team_id();
  static const int kTeamIdFieldNumber = 4;
  ::google::protobuf::uint32 team_id() const;
  void set_team_id(::google::protobuf::uint32 value);

  // optional uint64 team_base_logo = 7;
  bool has_team_base_logo() const;
  void clear_team_base_logo();
  static const int kTeamBaseLogoFieldNumber = 7;
  ::google::protobuf::uint64 team_base_logo() const;
  void set_team_base_logo(::google::protobuf::uint64 value);

  // optional uint64 team_ui_logo = 8;
  bool has_team_ui_logo() const;
  void clear_team_ui_logo();
  static const int kTeamUiLogoFieldNumber = 8;
  ::google::protobuf::uint64 team_ui_logo() const;
  void set_team_ui_logo(::google::protobuf::uint64 value);

  // optional uint32 match_group_mask = 12;
  bool has_match_group_mask() const;
  void clear_match_group_mask();
  static const int kMatchGroupMaskFieldNumber = 12;
  ::google::protobuf::uint32 match_group_mask() const;
  void set_match_group_mask(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTATournament.Team)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > players_;
  mutable std::atomic<int> _players_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > player_buyin_;
  mutable std::atomic<int> _player_buyin_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > player_skill_level_;
  mutable std::atomic<int> _player_skill_level_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr team_name_;
  ::google::protobuf::uint64 team_gid_;
  ::google::protobuf::uint32 node_or_state_;
  ::google::protobuf::uint32 team_id_;
  ::google::protobuf::uint64 team_base_logo_;
  ::google::protobuf::uint64 team_ui_logo_;
  ::google::protobuf::uint32 match_group_mask_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATournament_Game final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTATournament.Game) */ {
 public:
  CMsgDOTATournament_Game();
  virtual ~CMsgDOTATournament_Game();

  CMsgDOTATournament_Game(const CMsgDOTATournament_Game& from);

  inline CMsgDOTATournament_Game& operator=(const CMsgDOTATournament_Game& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTATournament_Game(CMsgDOTATournament_Game&& from) noexcept
    : CMsgDOTATournament_Game() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATournament_Game& operator=(CMsgDOTATournament_Game&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTATournament_Game& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTATournament_Game* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATournament_Game*>(
               &_CMsgDOTATournament_Game_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(CMsgDOTATournament_Game* other);
  friend void swap(CMsgDOTATournament_Game& a, CMsgDOTATournament_Game& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTATournament_Game* New() const final {
    return CreateMaybeMessage<CMsgDOTATournament_Game>(nullptr);
  }

  CMsgDOTATournament_Game* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTATournament_Game>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTATournament_Game& from);
  void MergeFrom(const CMsgDOTATournament_Game& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATournament_Game* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 lobby_id = 2;
  bool has_lobby_id() const;
  void clear_lobby_id();
  static const int kLobbyIdFieldNumber = 2;
  ::google::protobuf::uint64 lobby_id() const;
  void set_lobby_id(::google::protobuf::uint64 value);

  // optional uint32 node_idx = 1;
  bool has_node_idx() const;
  void clear_node_idx();
  static const int kNodeIdxFieldNumber = 1;
  ::google::protobuf::uint32 node_idx() const;
  void set_node_idx(::google::protobuf::uint32 value);

  // optional bool team_a_good = 4;
  bool has_team_a_good() const;
  void clear_team_a_good();
  static const int kTeamAGoodFieldNumber = 4;
  bool team_a_good() const;
  void set_team_a_good(bool value);

  // optional uint64 match_id = 3;
  bool has_match_id() const;
  void clear_match_id();
  static const int kMatchIdFieldNumber = 3;
  ::google::protobuf::uint64 match_id() const;
  void set_match_id(::google::protobuf::uint64 value);

  // optional .proto.dota.ETournamentGameState state = 5 [default = k_ETournamentGameState_Unknown];
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 5;
  ::proto::dota::ETournamentGameState state() const;
  void set_state(::proto::dota::ETournamentGameState value);

  // optional uint32 start_time = 6;
  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 6;
  ::google::protobuf::uint32 start_time() const;
  void set_start_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTATournament.Game)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 lobby_id_;
  ::google::protobuf::uint32 node_idx_;
  bool team_a_good_;
  ::google::protobuf::uint64 match_id_;
  int state_;
  ::google::protobuf::uint32 start_time_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATournament_Node final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTATournament.Node) */ {
 public:
  CMsgDOTATournament_Node();
  virtual ~CMsgDOTATournament_Node();

  CMsgDOTATournament_Node(const CMsgDOTATournament_Node& from);

  inline CMsgDOTATournament_Node& operator=(const CMsgDOTATournament_Node& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTATournament_Node(CMsgDOTATournament_Node&& from) noexcept
    : CMsgDOTATournament_Node() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATournament_Node& operator=(CMsgDOTATournament_Node&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTATournament_Node& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTATournament_Node* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATournament_Node*>(
               &_CMsgDOTATournament_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(CMsgDOTATournament_Node* other);
  friend void swap(CMsgDOTATournament_Node& a, CMsgDOTATournament_Node& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTATournament_Node* New() const final {
    return CreateMaybeMessage<CMsgDOTATournament_Node>(nullptr);
  }

  CMsgDOTATournament_Node* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTATournament_Node>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTATournament_Node& from);
  void MergeFrom(const CMsgDOTATournament_Node& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATournament_Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 node_id = 1;
  bool has_node_id() const;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  ::google::protobuf::uint32 node_id() const;
  void set_node_id(::google::protobuf::uint32 value);

  // optional uint32 team_idx_a = 2;
  bool has_team_idx_a() const;
  void clear_team_idx_a();
  static const int kTeamIdxAFieldNumber = 2;
  ::google::protobuf::uint32 team_idx_a() const;
  void set_team_idx_a(::google::protobuf::uint32 value);

  // optional uint32 team_idx_b = 3;
  bool has_team_idx_b() const;
  void clear_team_idx_b();
  static const int kTeamIdxBFieldNumber = 3;
  ::google::protobuf::uint32 team_idx_b() const;
  void set_team_idx_b(::google::protobuf::uint32 value);

  // optional .proto.dota.ETournamentNodeState node_state = 4 [default = k_ETournamentNodeState_Unknown];
  bool has_node_state() const;
  void clear_node_state();
  static const int kNodeStateFieldNumber = 4;
  ::proto::dota::ETournamentNodeState node_state() const;
  void set_node_state(::proto::dota::ETournamentNodeState value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTATournament.Node)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 node_id_;
  ::google::protobuf::uint32 team_idx_a_;
  ::google::protobuf::uint32 team_idx_b_;
  int node_state_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATournament final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTATournament) */ {
 public:
  CMsgDOTATournament();
  virtual ~CMsgDOTATournament();

  CMsgDOTATournament(const CMsgDOTATournament& from);

  inline CMsgDOTATournament& operator=(const CMsgDOTATournament& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTATournament(CMsgDOTATournament&& from) noexcept
    : CMsgDOTATournament() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATournament& operator=(CMsgDOTATournament&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTATournament& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTATournament* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATournament*>(
               &_CMsgDOTATournament_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(CMsgDOTATournament* other);
  friend void swap(CMsgDOTATournament& a, CMsgDOTATournament& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTATournament* New() const final {
    return CreateMaybeMessage<CMsgDOTATournament>(nullptr);
  }

  CMsgDOTATournament* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTATournament>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTATournament& from);
  void MergeFrom(const CMsgDOTATournament& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATournament* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTATournament_Team Team;
  typedef CMsgDOTATournament_Game Game;
  typedef CMsgDOTATournament_Node Node;

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTATournament.Team teams = 7;
  int teams_size() const;
  void clear_teams();
  static const int kTeamsFieldNumber = 7;
  ::proto::dota::CMsgDOTATournament_Team* mutable_teams(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournament_Team >*
      mutable_teams();
  const ::proto::dota::CMsgDOTATournament_Team& teams(int index) const;
  ::proto::dota::CMsgDOTATournament_Team* add_teams();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournament_Team >&
      teams() const;

  // repeated .proto.dota.CMsgDOTATournament.Game games = 8;
  int games_size() const;
  void clear_games();
  static const int kGamesFieldNumber = 8;
  ::proto::dota::CMsgDOTATournament_Game* mutable_games(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournament_Game >*
      mutable_games();
  const ::proto::dota::CMsgDOTATournament_Game& games(int index) const;
  ::proto::dota::CMsgDOTATournament_Game* add_games();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournament_Game >&
      games() const;

  // repeated .proto.dota.CMsgDOTATournament.Node nodes = 9;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 9;
  ::proto::dota::CMsgDOTATournament_Node* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournament_Node >*
      mutable_nodes();
  const ::proto::dota::CMsgDOTATournament_Node& nodes(int index) const;
  ::proto::dota::CMsgDOTATournament_Node* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournament_Node >&
      nodes() const;

  // optional uint32 tournament_id = 1;
  bool has_tournament_id() const;
  void clear_tournament_id();
  static const int kTournamentIdFieldNumber = 1;
  ::google::protobuf::uint32 tournament_id() const;
  void set_tournament_id(::google::protobuf::uint32 value);

  // optional uint32 division_id = 2;
  bool has_division_id() const;
  void clear_division_id();
  static const int kDivisionIdFieldNumber = 2;
  ::google::protobuf::uint32 division_id() const;
  void set_division_id(::google::protobuf::uint32 value);

  // optional uint32 schedule_time = 3;
  bool has_schedule_time() const;
  void clear_schedule_time();
  static const int kScheduleTimeFieldNumber = 3;
  ::google::protobuf::uint32 schedule_time() const;
  void set_schedule_time(::google::protobuf::uint32 value);

  // optional uint32 skill_level = 4;
  bool has_skill_level() const;
  void clear_skill_level();
  static const int kSkillLevelFieldNumber = 4;
  ::google::protobuf::uint32 skill_level() const;
  void set_skill_level(::google::protobuf::uint32 value);

  // optional .proto.dota.ETournamentTemplate tournament_template = 5 [default = k_ETournamentTemplate_None];
  bool has_tournament_template() const;
  void clear_tournament_template();
  static const int kTournamentTemplateFieldNumber = 5;
  ::proto::dota::ETournamentTemplate tournament_template() const;
  void set_tournament_template(::proto::dota::ETournamentTemplate value);

  // optional .proto.dota.ETournamentState state = 6 [default = k_ETournamentState_Unknown];
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 6;
  ::proto::dota::ETournamentState state() const;
  void set_state(::proto::dota::ETournamentState value);

  // optional uint32 state_seq_num = 10;
  bool has_state_seq_num() const;
  void clear_state_seq_num();
  static const int kStateSeqNumFieldNumber = 10;
  ::google::protobuf::uint32 state_seq_num() const;
  void set_state_seq_num(::google::protobuf::uint32 value);

  // optional uint32 season_trophy_id = 11;
  bool has_season_trophy_id() const;
  void clear_season_trophy_id();
  static const int kSeasonTrophyIdFieldNumber = 11;
  ::google::protobuf::uint32 season_trophy_id() const;
  void set_season_trophy_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTATournament)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournament_Team > teams_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournament_Game > games_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournament_Node > nodes_;
  ::google::protobuf::uint32 tournament_id_;
  ::google::protobuf::uint32 division_id_;
  ::google::protobuf::uint32 schedule_time_;
  ::google::protobuf::uint32 skill_level_;
  int tournament_template_;
  int state_;
  ::google::protobuf::uint32 state_seq_num_;
  ::google::protobuf::uint32 season_trophy_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATournamentStateChange_GameChange final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTATournamentStateChange.GameChange) */ {
 public:
  CMsgDOTATournamentStateChange_GameChange();
  virtual ~CMsgDOTATournamentStateChange_GameChange();

  CMsgDOTATournamentStateChange_GameChange(const CMsgDOTATournamentStateChange_GameChange& from);

  inline CMsgDOTATournamentStateChange_GameChange& operator=(const CMsgDOTATournamentStateChange_GameChange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTATournamentStateChange_GameChange(CMsgDOTATournamentStateChange_GameChange&& from) noexcept
    : CMsgDOTATournamentStateChange_GameChange() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATournamentStateChange_GameChange& operator=(CMsgDOTATournamentStateChange_GameChange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTATournamentStateChange_GameChange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTATournamentStateChange_GameChange* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATournamentStateChange_GameChange*>(
               &_CMsgDOTATournamentStateChange_GameChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(CMsgDOTATournamentStateChange_GameChange* other);
  friend void swap(CMsgDOTATournamentStateChange_GameChange& a, CMsgDOTATournamentStateChange_GameChange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTATournamentStateChange_GameChange* New() const final {
    return CreateMaybeMessage<CMsgDOTATournamentStateChange_GameChange>(nullptr);
  }

  CMsgDOTATournamentStateChange_GameChange* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTATournamentStateChange_GameChange>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTATournamentStateChange_GameChange& from);
  void MergeFrom(const CMsgDOTATournamentStateChange_GameChange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATournamentStateChange_GameChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 match_id = 1;
  bool has_match_id() const;
  void clear_match_id();
  static const int kMatchIdFieldNumber = 1;
  ::google::protobuf::uint64 match_id() const;
  void set_match_id(::google::protobuf::uint64 value);

  // optional .proto.dota.ETournamentGameState new_state = 2 [default = k_ETournamentGameState_Unknown];
  bool has_new_state() const;
  void clear_new_state();
  static const int kNewStateFieldNumber = 2;
  ::proto::dota::ETournamentGameState new_state() const;
  void set_new_state(::proto::dota::ETournamentGameState value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTATournamentStateChange.GameChange)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 match_id_;
  int new_state_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATournamentStateChange_TeamChange final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTATournamentStateChange.TeamChange) */ {
 public:
  CMsgDOTATournamentStateChange_TeamChange();
  virtual ~CMsgDOTATournamentStateChange_TeamChange();

  CMsgDOTATournamentStateChange_TeamChange(const CMsgDOTATournamentStateChange_TeamChange& from);

  inline CMsgDOTATournamentStateChange_TeamChange& operator=(const CMsgDOTATournamentStateChange_TeamChange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTATournamentStateChange_TeamChange(CMsgDOTATournamentStateChange_TeamChange&& from) noexcept
    : CMsgDOTATournamentStateChange_TeamChange() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATournamentStateChange_TeamChange& operator=(CMsgDOTATournamentStateChange_TeamChange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTATournamentStateChange_TeamChange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTATournamentStateChange_TeamChange* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATournamentStateChange_TeamChange*>(
               &_CMsgDOTATournamentStateChange_TeamChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(CMsgDOTATournamentStateChange_TeamChange* other);
  friend void swap(CMsgDOTATournamentStateChange_TeamChange& a, CMsgDOTATournamentStateChange_TeamChange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTATournamentStateChange_TeamChange* New() const final {
    return CreateMaybeMessage<CMsgDOTATournamentStateChange_TeamChange>(nullptr);
  }

  CMsgDOTATournamentStateChange_TeamChange* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTATournamentStateChange_TeamChange>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTATournamentStateChange_TeamChange& from);
  void MergeFrom(const CMsgDOTATournamentStateChange_TeamChange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATournamentStateChange_TeamChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 team_gid = 1;
  bool has_team_gid() const;
  void clear_team_gid();
  static const int kTeamGidFieldNumber = 1;
  ::google::protobuf::uint64 team_gid() const;
  void set_team_gid(::google::protobuf::uint64 value);

  // optional uint32 new_node_or_state = 2;
  bool has_new_node_or_state() const;
  void clear_new_node_or_state();
  static const int kNewNodeOrStateFieldNumber = 2;
  ::google::protobuf::uint32 new_node_or_state() const;
  void set_new_node_or_state(::google::protobuf::uint32 value);

  // optional uint32 old_node_or_state = 3;
  bool has_old_node_or_state() const;
  void clear_old_node_or_state();
  static const int kOldNodeOrStateFieldNumber = 3;
  ::google::protobuf::uint32 old_node_or_state() const;
  void set_old_node_or_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTATournamentStateChange.TeamChange)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 team_gid_;
  ::google::protobuf::uint32 new_node_or_state_;
  ::google::protobuf::uint32 old_node_or_state_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATournamentStateChange final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTATournamentStateChange) */ {
 public:
  CMsgDOTATournamentStateChange();
  virtual ~CMsgDOTATournamentStateChange();

  CMsgDOTATournamentStateChange(const CMsgDOTATournamentStateChange& from);

  inline CMsgDOTATournamentStateChange& operator=(const CMsgDOTATournamentStateChange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTATournamentStateChange(CMsgDOTATournamentStateChange&& from) noexcept
    : CMsgDOTATournamentStateChange() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATournamentStateChange& operator=(CMsgDOTATournamentStateChange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTATournamentStateChange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTATournamentStateChange* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATournamentStateChange*>(
               &_CMsgDOTATournamentStateChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(CMsgDOTATournamentStateChange* other);
  friend void swap(CMsgDOTATournamentStateChange& a, CMsgDOTATournamentStateChange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTATournamentStateChange* New() const final {
    return CreateMaybeMessage<CMsgDOTATournamentStateChange>(nullptr);
  }

  CMsgDOTATournamentStateChange* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTATournamentStateChange>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTATournamentStateChange& from);
  void MergeFrom(const CMsgDOTATournamentStateChange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATournamentStateChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTATournamentStateChange_GameChange GameChange;
  typedef CMsgDOTATournamentStateChange_TeamChange TeamChange;

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTATournamentStateChange.GameChange game_changes = 4;
  int game_changes_size() const;
  void clear_game_changes();
  static const int kGameChangesFieldNumber = 4;
  ::proto::dota::CMsgDOTATournamentStateChange_GameChange* mutable_game_changes(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentStateChange_GameChange >*
      mutable_game_changes();
  const ::proto::dota::CMsgDOTATournamentStateChange_GameChange& game_changes(int index) const;
  ::proto::dota::CMsgDOTATournamentStateChange_GameChange* add_game_changes();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentStateChange_GameChange >&
      game_changes() const;

  // repeated .proto.dota.CMsgDOTATournamentStateChange.TeamChange team_changes = 5;
  int team_changes_size() const;
  void clear_team_changes();
  static const int kTeamChangesFieldNumber = 5;
  ::proto::dota::CMsgDOTATournamentStateChange_TeamChange* mutable_team_changes(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentStateChange_TeamChange >*
      mutable_team_changes();
  const ::proto::dota::CMsgDOTATournamentStateChange_TeamChange& team_changes(int index) const;
  ::proto::dota::CMsgDOTATournamentStateChange_TeamChange* add_team_changes();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentStateChange_TeamChange >&
      team_changes() const;

  // repeated uint32 merged_tournament_ids = 6 [packed = true];
  int merged_tournament_ids_size() const;
  void clear_merged_tournament_ids();
  static const int kMergedTournamentIdsFieldNumber = 6;
  ::google::protobuf::uint32 merged_tournament_ids(int index) const;
  void set_merged_tournament_ids(int index, ::google::protobuf::uint32 value);
  void add_merged_tournament_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      merged_tournament_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_merged_tournament_ids();

  // optional uint32 new_tournament_id = 1;
  bool has_new_tournament_id() const;
  void clear_new_tournament_id();
  static const int kNewTournamentIdFieldNumber = 1;
  ::google::protobuf::uint32 new_tournament_id() const;
  void set_new_tournament_id(::google::protobuf::uint32 value);

  // optional .proto.dota.ETournamentEvent event = 2 [default = k_ETournamentEvent_None];
  bool has_event() const;
  void clear_event();
  static const int kEventFieldNumber = 2;
  ::proto::dota::ETournamentEvent event() const;
  void set_event(::proto::dota::ETournamentEvent value);

  // optional .proto.dota.ETournamentState new_tournament_state = 3 [default = k_ETournamentState_Unknown];
  bool has_new_tournament_state() const;
  void clear_new_tournament_state();
  static const int kNewTournamentStateFieldNumber = 3;
  ::proto::dota::ETournamentState new_tournament_state() const;
  void set_new_tournament_state(::proto::dota::ETournamentState value);

  // optional uint32 state_seq_num = 7;
  bool has_state_seq_num() const;
  void clear_state_seq_num();
  static const int kStateSeqNumFieldNumber = 7;
  ::google::protobuf::uint32 state_seq_num() const;
  void set_state_seq_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTATournamentStateChange)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentStateChange_GameChange > game_changes_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentStateChange_TeamChange > team_changes_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > merged_tournament_ids_;
  mutable std::atomic<int> _merged_tournament_ids_cached_byte_size_;
  ::google::protobuf::uint32 new_tournament_id_;
  int event_;
  int new_tournament_state_;
  ::google::protobuf::uint32 state_seq_num_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATournamentRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTATournamentRequest) */ {
 public:
  CMsgDOTATournamentRequest();
  virtual ~CMsgDOTATournamentRequest();

  CMsgDOTATournamentRequest(const CMsgDOTATournamentRequest& from);

  inline CMsgDOTATournamentRequest& operator=(const CMsgDOTATournamentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTATournamentRequest(CMsgDOTATournamentRequest&& from) noexcept
    : CMsgDOTATournamentRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATournamentRequest& operator=(CMsgDOTATournamentRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTATournamentRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTATournamentRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATournamentRequest*>(
               &_CMsgDOTATournamentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(CMsgDOTATournamentRequest* other);
  friend void swap(CMsgDOTATournamentRequest& a, CMsgDOTATournamentRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTATournamentRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTATournamentRequest>(nullptr);
  }

  CMsgDOTATournamentRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTATournamentRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTATournamentRequest& from);
  void MergeFrom(const CMsgDOTATournamentRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATournamentRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 client_tournament_gid = 2;
  bool has_client_tournament_gid() const;
  void clear_client_tournament_gid();
  static const int kClientTournamentGidFieldNumber = 2;
  ::google::protobuf::uint64 client_tournament_gid() const;
  void set_client_tournament_gid(::google::protobuf::uint64 value);

  // optional uint32 tournament_id = 1;
  bool has_tournament_id() const;
  void clear_tournament_id();
  static const int kTournamentIdFieldNumber = 1;
  ::google::protobuf::uint32 tournament_id() const;
  void set_tournament_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTATournamentRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 client_tournament_gid_;
  ::google::protobuf::uint32 tournament_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTATournamentResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTATournamentResponse) */ {
 public:
  CMsgDOTATournamentResponse();
  virtual ~CMsgDOTATournamentResponse();

  CMsgDOTATournamentResponse(const CMsgDOTATournamentResponse& from);

  inline CMsgDOTATournamentResponse& operator=(const CMsgDOTATournamentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTATournamentResponse(CMsgDOTATournamentResponse&& from) noexcept
    : CMsgDOTATournamentResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTATournamentResponse& operator=(CMsgDOTATournamentResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTATournamentResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTATournamentResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTATournamentResponse*>(
               &_CMsgDOTATournamentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(CMsgDOTATournamentResponse* other);
  friend void swap(CMsgDOTATournamentResponse& a, CMsgDOTATournamentResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTATournamentResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTATournamentResponse>(nullptr);
  }

  CMsgDOTATournamentResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTATournamentResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTATournamentResponse& from);
  void MergeFrom(const CMsgDOTATournamentResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTATournamentResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgDOTATournament tournament = 2;
  bool has_tournament() const;
  void clear_tournament();
  static const int kTournamentFieldNumber = 2;
  const ::proto::dota::CMsgDOTATournament& tournament() const;
  ::proto::dota::CMsgDOTATournament* release_tournament();
  ::proto::dota::CMsgDOTATournament* mutable_tournament();
  void set_allocated_tournament(::proto::dota::CMsgDOTATournament* tournament);

  // optional uint32 result = 1 [default = 2];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::uint32 result() const;
  void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTATournamentResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::proto::dota::CMsgDOTATournament* tournament_;
  ::google::protobuf::uint32 result_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAClearTournamentGame final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAClearTournamentGame) */ {
 public:
  CMsgDOTAClearTournamentGame();
  virtual ~CMsgDOTAClearTournamentGame();

  CMsgDOTAClearTournamentGame(const CMsgDOTAClearTournamentGame& from);

  inline CMsgDOTAClearTournamentGame& operator=(const CMsgDOTAClearTournamentGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAClearTournamentGame(CMsgDOTAClearTournamentGame&& from) noexcept
    : CMsgDOTAClearTournamentGame() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAClearTournamentGame& operator=(CMsgDOTAClearTournamentGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAClearTournamentGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAClearTournamentGame* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAClearTournamentGame*>(
               &_CMsgDOTAClearTournamentGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(CMsgDOTAClearTournamentGame* other);
  friend void swap(CMsgDOTAClearTournamentGame& a, CMsgDOTAClearTournamentGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAClearTournamentGame* New() const final {
    return CreateMaybeMessage<CMsgDOTAClearTournamentGame>(nullptr);
  }

  CMsgDOTAClearTournamentGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAClearTournamentGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAClearTournamentGame& from);
  void MergeFrom(const CMsgDOTAClearTournamentGame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAClearTournamentGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 tournament_id = 1;
  bool has_tournament_id() const;
  void clear_tournament_id();
  static const int kTournamentIdFieldNumber = 1;
  ::google::protobuf::uint32 tournament_id() const;
  void set_tournament_id(::google::protobuf::uint32 value);

  // optional uint32 game_id = 2;
  bool has_game_id() const;
  void clear_game_id();
  static const int kGameIdFieldNumber = 2;
  ::google::protobuf::uint32 game_id() const;
  void set_game_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAClearTournamentGame)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 tournament_id_;
  ::google::protobuf::uint32 game_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAWeekendTourneyPlayerSkillLevelStats final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAWeekendTourneyPlayerSkillLevelStats) */ {
 public:
  CMsgDOTAWeekendTourneyPlayerSkillLevelStats();
  virtual ~CMsgDOTAWeekendTourneyPlayerSkillLevelStats();

  CMsgDOTAWeekendTourneyPlayerSkillLevelStats(const CMsgDOTAWeekendTourneyPlayerSkillLevelStats& from);

  inline CMsgDOTAWeekendTourneyPlayerSkillLevelStats& operator=(const CMsgDOTAWeekendTourneyPlayerSkillLevelStats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAWeekendTourneyPlayerSkillLevelStats(CMsgDOTAWeekendTourneyPlayerSkillLevelStats&& from) noexcept
    : CMsgDOTAWeekendTourneyPlayerSkillLevelStats() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAWeekendTourneyPlayerSkillLevelStats& operator=(CMsgDOTAWeekendTourneyPlayerSkillLevelStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAWeekendTourneyPlayerSkillLevelStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAWeekendTourneyPlayerSkillLevelStats* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAWeekendTourneyPlayerSkillLevelStats*>(
               &_CMsgDOTAWeekendTourneyPlayerSkillLevelStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(CMsgDOTAWeekendTourneyPlayerSkillLevelStats* other);
  friend void swap(CMsgDOTAWeekendTourneyPlayerSkillLevelStats& a, CMsgDOTAWeekendTourneyPlayerSkillLevelStats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAWeekendTourneyPlayerSkillLevelStats* New() const final {
    return CreateMaybeMessage<CMsgDOTAWeekendTourneyPlayerSkillLevelStats>(nullptr);
  }

  CMsgDOTAWeekendTourneyPlayerSkillLevelStats* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAWeekendTourneyPlayerSkillLevelStats>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAWeekendTourneyPlayerSkillLevelStats& from);
  void MergeFrom(const CMsgDOTAWeekendTourneyPlayerSkillLevelStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAWeekendTourneyPlayerSkillLevelStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 skill_level = 1;
  bool has_skill_level() const;
  void clear_skill_level();
  static const int kSkillLevelFieldNumber = 1;
  ::google::protobuf::uint32 skill_level() const;
  void set_skill_level(::google::protobuf::uint32 value);

  // optional uint32 times_won_0 = 2;
  bool has_times_won_0() const;
  void clear_times_won_0();
  static const int kTimesWon0FieldNumber = 2;
  ::google::protobuf::uint32 times_won_0() const;
  void set_times_won_0(::google::protobuf::uint32 value);

  // optional uint32 times_won_1 = 3;
  bool has_times_won_1() const;
  void clear_times_won_1();
  static const int kTimesWon1FieldNumber = 3;
  ::google::protobuf::uint32 times_won_1() const;
  void set_times_won_1(::google::protobuf::uint32 value);

  // optional uint32 times_won_2 = 4;
  bool has_times_won_2() const;
  void clear_times_won_2();
  static const int kTimesWon2FieldNumber = 4;
  ::google::protobuf::uint32 times_won_2() const;
  void set_times_won_2(::google::protobuf::uint32 value);

  // optional uint32 times_won_3 = 5;
  bool has_times_won_3() const;
  void clear_times_won_3();
  static const int kTimesWon3FieldNumber = 5;
  ::google::protobuf::uint32 times_won_3() const;
  void set_times_won_3(::google::protobuf::uint32 value);

  // optional uint32 times_bye_and_lost = 6;
  bool has_times_bye_and_lost() const;
  void clear_times_bye_and_lost();
  static const int kTimesByeAndLostFieldNumber = 6;
  ::google::protobuf::uint32 times_bye_and_lost() const;
  void set_times_bye_and_lost(::google::protobuf::uint32 value);

  // optional uint32 times_bye_and_won = 7;
  bool has_times_bye_and_won() const;
  void clear_times_bye_and_won();
  static const int kTimesByeAndWonFieldNumber = 7;
  ::google::protobuf::uint32 times_bye_and_won() const;
  void set_times_bye_and_won(::google::protobuf::uint32 value);

  // optional uint32 total_games_won = 8;
  bool has_total_games_won() const;
  void clear_total_games_won();
  static const int kTotalGamesWonFieldNumber = 8;
  ::google::protobuf::uint32 total_games_won() const;
  void set_total_games_won(::google::protobuf::uint32 value);

  // optional uint32 score = 9;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 9;
  ::google::protobuf::uint32 score() const;
  void set_score(::google::protobuf::uint32 value);

  // optional uint32 times_unusual_champ = 10;
  bool has_times_unusual_champ() const;
  void clear_times_unusual_champ();
  static const int kTimesUnusualChampFieldNumber = 10;
  ::google::protobuf::uint32 times_unusual_champ() const;
  void set_times_unusual_champ(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAWeekendTourneyPlayerSkillLevelStats)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 skill_level_;
  ::google::protobuf::uint32 times_won_0_;
  ::google::protobuf::uint32 times_won_1_;
  ::google::protobuf::uint32 times_won_2_;
  ::google::protobuf::uint32 times_won_3_;
  ::google::protobuf::uint32 times_bye_and_lost_;
  ::google::protobuf::uint32 times_bye_and_won_;
  ::google::protobuf::uint32 total_games_won_;
  ::google::protobuf::uint32 score_;
  ::google::protobuf::uint32 times_unusual_champ_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAWeekendTourneyPlayerStats final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAWeekendTourneyPlayerStats) */ {
 public:
  CMsgDOTAWeekendTourneyPlayerStats();
  virtual ~CMsgDOTAWeekendTourneyPlayerStats();

  CMsgDOTAWeekendTourneyPlayerStats(const CMsgDOTAWeekendTourneyPlayerStats& from);

  inline CMsgDOTAWeekendTourneyPlayerStats& operator=(const CMsgDOTAWeekendTourneyPlayerStats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAWeekendTourneyPlayerStats(CMsgDOTAWeekendTourneyPlayerStats&& from) noexcept
    : CMsgDOTAWeekendTourneyPlayerStats() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAWeekendTourneyPlayerStats& operator=(CMsgDOTAWeekendTourneyPlayerStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAWeekendTourneyPlayerStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAWeekendTourneyPlayerStats* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAWeekendTourneyPlayerStats*>(
               &_CMsgDOTAWeekendTourneyPlayerStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(CMsgDOTAWeekendTourneyPlayerStats* other);
  friend void swap(CMsgDOTAWeekendTourneyPlayerStats& a, CMsgDOTAWeekendTourneyPlayerStats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAWeekendTourneyPlayerStats* New() const final {
    return CreateMaybeMessage<CMsgDOTAWeekendTourneyPlayerStats>(nullptr);
  }

  CMsgDOTAWeekendTourneyPlayerStats* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAWeekendTourneyPlayerStats>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAWeekendTourneyPlayerStats& from);
  void MergeFrom(const CMsgDOTAWeekendTourneyPlayerStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAWeekendTourneyPlayerStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTAWeekendTourneyPlayerSkillLevelStats skill_levels = 3;
  int skill_levels_size() const;
  void clear_skill_levels();
  static const int kSkillLevelsFieldNumber = 3;
  ::proto::dota::CMsgDOTAWeekendTourneyPlayerSkillLevelStats* mutable_skill_levels(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAWeekendTourneyPlayerSkillLevelStats >*
      mutable_skill_levels();
  const ::proto::dota::CMsgDOTAWeekendTourneyPlayerSkillLevelStats& skill_levels(int index) const;
  ::proto::dota::CMsgDOTAWeekendTourneyPlayerSkillLevelStats* add_skill_levels();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAWeekendTourneyPlayerSkillLevelStats >&
      skill_levels() const;

  // optional uint32 account_id = 1;
  bool has_account_id() const;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  ::google::protobuf::uint32 account_id() const;
  void set_account_id(::google::protobuf::uint32 value);

  // optional uint32 season_trophy_id = 2;
  bool has_season_trophy_id() const;
  void clear_season_trophy_id();
  static const int kSeasonTrophyIdFieldNumber = 2;
  ::google::protobuf::uint32 season_trophy_id() const;
  void set_season_trophy_id(::google::protobuf::uint32 value);

  // optional uint32 current_tier = 4;
  bool has_current_tier() const;
  void clear_current_tier();
  static const int kCurrentTierFieldNumber = 4;
  ::google::protobuf::uint32 current_tier() const;
  void set_current_tier(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAWeekendTourneyPlayerStats)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAWeekendTourneyPlayerSkillLevelStats > skill_levels_;
  ::google::protobuf::uint32 account_id_;
  ::google::protobuf::uint32 season_trophy_id_;
  ::google::protobuf::uint32 current_tier_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAWeekendTourneyPlayerStatsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAWeekendTourneyPlayerStatsRequest) */ {
 public:
  CMsgDOTAWeekendTourneyPlayerStatsRequest();
  virtual ~CMsgDOTAWeekendTourneyPlayerStatsRequest();

  CMsgDOTAWeekendTourneyPlayerStatsRequest(const CMsgDOTAWeekendTourneyPlayerStatsRequest& from);

  inline CMsgDOTAWeekendTourneyPlayerStatsRequest& operator=(const CMsgDOTAWeekendTourneyPlayerStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAWeekendTourneyPlayerStatsRequest(CMsgDOTAWeekendTourneyPlayerStatsRequest&& from) noexcept
    : CMsgDOTAWeekendTourneyPlayerStatsRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAWeekendTourneyPlayerStatsRequest& operator=(CMsgDOTAWeekendTourneyPlayerStatsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAWeekendTourneyPlayerStatsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAWeekendTourneyPlayerStatsRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAWeekendTourneyPlayerStatsRequest*>(
               &_CMsgDOTAWeekendTourneyPlayerStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(CMsgDOTAWeekendTourneyPlayerStatsRequest* other);
  friend void swap(CMsgDOTAWeekendTourneyPlayerStatsRequest& a, CMsgDOTAWeekendTourneyPlayerStatsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAWeekendTourneyPlayerStatsRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAWeekendTourneyPlayerStatsRequest>(nullptr);
  }

  CMsgDOTAWeekendTourneyPlayerStatsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAWeekendTourneyPlayerStatsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAWeekendTourneyPlayerStatsRequest& from);
  void MergeFrom(const CMsgDOTAWeekendTourneyPlayerStatsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAWeekendTourneyPlayerStatsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 account_id = 1;
  bool has_account_id() const;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  ::google::protobuf::uint32 account_id() const;
  void set_account_id(::google::protobuf::uint32 value);

  // optional uint32 season_trophy_id = 2;
  bool has_season_trophy_id() const;
  void clear_season_trophy_id();
  static const int kSeasonTrophyIdFieldNumber = 2;
  ::google::protobuf::uint32 season_trophy_id() const;
  void set_season_trophy_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAWeekendTourneyPlayerStatsRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 account_id_;
  ::google::protobuf::uint32 season_trophy_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAWeekendTourneyPlayerHistoryRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAWeekendTourneyPlayerHistoryRequest) */ {
 public:
  CMsgDOTAWeekendTourneyPlayerHistoryRequest();
  virtual ~CMsgDOTAWeekendTourneyPlayerHistoryRequest();

  CMsgDOTAWeekendTourneyPlayerHistoryRequest(const CMsgDOTAWeekendTourneyPlayerHistoryRequest& from);

  inline CMsgDOTAWeekendTourneyPlayerHistoryRequest& operator=(const CMsgDOTAWeekendTourneyPlayerHistoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAWeekendTourneyPlayerHistoryRequest(CMsgDOTAWeekendTourneyPlayerHistoryRequest&& from) noexcept
    : CMsgDOTAWeekendTourneyPlayerHistoryRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAWeekendTourneyPlayerHistoryRequest& operator=(CMsgDOTAWeekendTourneyPlayerHistoryRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAWeekendTourneyPlayerHistoryRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAWeekendTourneyPlayerHistoryRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAWeekendTourneyPlayerHistoryRequest*>(
               &_CMsgDOTAWeekendTourneyPlayerHistoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(CMsgDOTAWeekendTourneyPlayerHistoryRequest* other);
  friend void swap(CMsgDOTAWeekendTourneyPlayerHistoryRequest& a, CMsgDOTAWeekendTourneyPlayerHistoryRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAWeekendTourneyPlayerHistoryRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAWeekendTourneyPlayerHistoryRequest>(nullptr);
  }

  CMsgDOTAWeekendTourneyPlayerHistoryRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAWeekendTourneyPlayerHistoryRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAWeekendTourneyPlayerHistoryRequest& from);
  void MergeFrom(const CMsgDOTAWeekendTourneyPlayerHistoryRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAWeekendTourneyPlayerHistoryRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 account_id = 1;
  bool has_account_id() const;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  ::google::protobuf::uint32 account_id() const;
  void set_account_id(::google::protobuf::uint32 value);

  // optional uint32 season_trophy_id = 2;
  bool has_season_trophy_id() const;
  void clear_season_trophy_id();
  static const int kSeasonTrophyIdFieldNumber = 2;
  ::google::protobuf::uint32 season_trophy_id() const;
  void set_season_trophy_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAWeekendTourneyPlayerHistoryRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 account_id_;
  ::google::protobuf::uint32 season_trophy_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAWeekendTourneyPlayerHistory_Tournament final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament) */ {
 public:
  CMsgDOTAWeekendTourneyPlayerHistory_Tournament();
  virtual ~CMsgDOTAWeekendTourneyPlayerHistory_Tournament();

  CMsgDOTAWeekendTourneyPlayerHistory_Tournament(const CMsgDOTAWeekendTourneyPlayerHistory_Tournament& from);

  inline CMsgDOTAWeekendTourneyPlayerHistory_Tournament& operator=(const CMsgDOTAWeekendTourneyPlayerHistory_Tournament& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAWeekendTourneyPlayerHistory_Tournament(CMsgDOTAWeekendTourneyPlayerHistory_Tournament&& from) noexcept
    : CMsgDOTAWeekendTourneyPlayerHistory_Tournament() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAWeekendTourneyPlayerHistory_Tournament& operator=(CMsgDOTAWeekendTourneyPlayerHistory_Tournament&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAWeekendTourneyPlayerHistory_Tournament& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAWeekendTourneyPlayerHistory_Tournament* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAWeekendTourneyPlayerHistory_Tournament*>(
               &_CMsgDOTAWeekendTourneyPlayerHistory_Tournament_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(CMsgDOTAWeekendTourneyPlayerHistory_Tournament* other);
  friend void swap(CMsgDOTAWeekendTourneyPlayerHistory_Tournament& a, CMsgDOTAWeekendTourneyPlayerHistory_Tournament& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAWeekendTourneyPlayerHistory_Tournament* New() const final {
    return CreateMaybeMessage<CMsgDOTAWeekendTourneyPlayerHistory_Tournament>(nullptr);
  }

  CMsgDOTAWeekendTourneyPlayerHistory_Tournament* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAWeekendTourneyPlayerHistory_Tournament>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAWeekendTourneyPlayerHistory_Tournament& from);
  void MergeFrom(const CMsgDOTAWeekendTourneyPlayerHistory_Tournament& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAWeekendTourneyPlayerHistory_Tournament* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 account_id = 7;
  int account_id_size() const;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 7;
  ::google::protobuf::uint32 account_id(int index) const;
  void set_account_id(int index, ::google::protobuf::uint32 value);
  void add_account_id(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      account_id() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_account_id();

  // optional string team_name = 8;
  bool has_team_name() const;
  void clear_team_name();
  static const int kTeamNameFieldNumber = 8;
  const ::std::string& team_name() const;
  void set_team_name(const ::std::string& value);
  #if LANG_CXX11
  void set_team_name(::std::string&& value);
  #endif
  void set_team_name(const char* value);
  void set_team_name(const char* value, size_t size);
  ::std::string* mutable_team_name();
  ::std::string* release_team_name();
  void set_allocated_team_name(::std::string* team_name);

  // optional uint32 tournament_id = 1;
  bool has_tournament_id() const;
  void clear_tournament_id();
  static const int kTournamentIdFieldNumber = 1;
  ::google::protobuf::uint32 tournament_id() const;
  void set_tournament_id(::google::protobuf::uint32 value);

  // optional uint32 start_time = 2;
  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 2;
  ::google::protobuf::uint32 start_time() const;
  void set_start_time(::google::protobuf::uint32 value);

  // optional uint32 tournament_tier = 3;
  bool has_tournament_tier() const;
  void clear_tournament_tier();
  static const int kTournamentTierFieldNumber = 3;
  ::google::protobuf::uint32 tournament_tier() const;
  void set_tournament_tier(::google::protobuf::uint32 value);

  // optional uint32 team_id = 4;
  bool has_team_id() const;
  void clear_team_id();
  static const int kTeamIdFieldNumber = 4;
  ::google::protobuf::uint32 team_id() const;
  void set_team_id(::google::protobuf::uint32 value);

  // optional uint32 team_date = 5;
  bool has_team_date() const;
  void clear_team_date();
  static const int kTeamDateFieldNumber = 5;
  ::google::protobuf::uint32 team_date() const;
  void set_team_date(::google::protobuf::uint32 value);

  // optional uint32 team_result = 6;
  bool has_team_result() const;
  void clear_team_result();
  static const int kTeamResultFieldNumber = 6;
  ::google::protobuf::uint32 team_result() const;
  void set_team_result(::google::protobuf::uint32 value);

  // optional uint32 season_trophy_id = 9;
  bool has_season_trophy_id() const;
  void clear_season_trophy_id();
  static const int kSeasonTrophyIdFieldNumber = 9;
  ::google::protobuf::uint32 season_trophy_id() const;
  void set_season_trophy_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > account_id_;
  ::google::protobuf::internal::ArenaStringPtr team_name_;
  ::google::protobuf::uint32 tournament_id_;
  ::google::protobuf::uint32 start_time_;
  ::google::protobuf::uint32 tournament_tier_;
  ::google::protobuf::uint32 team_id_;
  ::google::protobuf::uint32 team_date_;
  ::google::protobuf::uint32 team_result_;
  ::google::protobuf::uint32 season_trophy_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAWeekendTourneyPlayerHistory final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory) */ {
 public:
  CMsgDOTAWeekendTourneyPlayerHistory();
  virtual ~CMsgDOTAWeekendTourneyPlayerHistory();

  CMsgDOTAWeekendTourneyPlayerHistory(const CMsgDOTAWeekendTourneyPlayerHistory& from);

  inline CMsgDOTAWeekendTourneyPlayerHistory& operator=(const CMsgDOTAWeekendTourneyPlayerHistory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAWeekendTourneyPlayerHistory(CMsgDOTAWeekendTourneyPlayerHistory&& from) noexcept
    : CMsgDOTAWeekendTourneyPlayerHistory() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAWeekendTourneyPlayerHistory& operator=(CMsgDOTAWeekendTourneyPlayerHistory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAWeekendTourneyPlayerHistory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAWeekendTourneyPlayerHistory* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAWeekendTourneyPlayerHistory*>(
               &_CMsgDOTAWeekendTourneyPlayerHistory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(CMsgDOTAWeekendTourneyPlayerHistory* other);
  friend void swap(CMsgDOTAWeekendTourneyPlayerHistory& a, CMsgDOTAWeekendTourneyPlayerHistory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAWeekendTourneyPlayerHistory* New() const final {
    return CreateMaybeMessage<CMsgDOTAWeekendTourneyPlayerHistory>(nullptr);
  }

  CMsgDOTAWeekendTourneyPlayerHistory* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAWeekendTourneyPlayerHistory>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAWeekendTourneyPlayerHistory& from);
  void MergeFrom(const CMsgDOTAWeekendTourneyPlayerHistory& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAWeekendTourneyPlayerHistory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAWeekendTourneyPlayerHistory_Tournament Tournament;

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament tournaments = 3;
  int tournaments_size() const;
  void clear_tournaments();
  static const int kTournamentsFieldNumber = 3;
  ::proto::dota::CMsgDOTAWeekendTourneyPlayerHistory_Tournament* mutable_tournaments(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAWeekendTourneyPlayerHistory_Tournament >*
      mutable_tournaments();
  const ::proto::dota::CMsgDOTAWeekendTourneyPlayerHistory_Tournament& tournaments(int index) const;
  ::proto::dota::CMsgDOTAWeekendTourneyPlayerHistory_Tournament* add_tournaments();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAWeekendTourneyPlayerHistory_Tournament >&
      tournaments() const;

  // optional uint32 account_id = 1;
  bool has_account_id() const;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  ::google::protobuf::uint32 account_id() const;
  void set_account_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAWeekendTourneyPlayerHistory_Tournament > tournaments_;
  ::google::protobuf::uint32 account_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAWeekendTourneyParticipationDetails_Tier final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Tier) */ {
 public:
  CMsgDOTAWeekendTourneyParticipationDetails_Tier();
  virtual ~CMsgDOTAWeekendTourneyParticipationDetails_Tier();

  CMsgDOTAWeekendTourneyParticipationDetails_Tier(const CMsgDOTAWeekendTourneyParticipationDetails_Tier& from);

  inline CMsgDOTAWeekendTourneyParticipationDetails_Tier& operator=(const CMsgDOTAWeekendTourneyParticipationDetails_Tier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAWeekendTourneyParticipationDetails_Tier(CMsgDOTAWeekendTourneyParticipationDetails_Tier&& from) noexcept
    : CMsgDOTAWeekendTourneyParticipationDetails_Tier() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAWeekendTourneyParticipationDetails_Tier& operator=(CMsgDOTAWeekendTourneyParticipationDetails_Tier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAWeekendTourneyParticipationDetails_Tier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAWeekendTourneyParticipationDetails_Tier* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAWeekendTourneyParticipationDetails_Tier*>(
               &_CMsgDOTAWeekendTourneyParticipationDetails_Tier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(CMsgDOTAWeekendTourneyParticipationDetails_Tier* other);
  friend void swap(CMsgDOTAWeekendTourneyParticipationDetails_Tier& a, CMsgDOTAWeekendTourneyParticipationDetails_Tier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAWeekendTourneyParticipationDetails_Tier* New() const final {
    return CreateMaybeMessage<CMsgDOTAWeekendTourneyParticipationDetails_Tier>(nullptr);
  }

  CMsgDOTAWeekendTourneyParticipationDetails_Tier* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAWeekendTourneyParticipationDetails_Tier>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAWeekendTourneyParticipationDetails_Tier& from);
  void MergeFrom(const CMsgDOTAWeekendTourneyParticipationDetails_Tier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAWeekendTourneyParticipationDetails_Tier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 tier = 1;
  bool has_tier() const;
  void clear_tier();
  static const int kTierFieldNumber = 1;
  ::google::protobuf::uint32 tier() const;
  void set_tier(::google::protobuf::uint32 value);

  // optional uint32 players = 2;
  bool has_players() const;
  void clear_players();
  static const int kPlayersFieldNumber = 2;
  ::google::protobuf::uint32 players() const;
  void set_players(::google::protobuf::uint32 value);

  // optional uint32 teams = 3;
  bool has_teams() const;
  void clear_teams();
  static const int kTeamsFieldNumber = 3;
  ::google::protobuf::uint32 teams() const;
  void set_teams(::google::protobuf::uint32 value);

  // optional uint32 winning_teams = 4;
  bool has_winning_teams() const;
  void clear_winning_teams();
  static const int kWinningTeamsFieldNumber = 4;
  ::google::protobuf::uint32 winning_teams() const;
  void set_winning_teams(::google::protobuf::uint32 value);

  // optional uint32 players_streak_2 = 5;
  bool has_players_streak_2() const;
  void clear_players_streak_2();
  static const int kPlayersStreak2FieldNumber = 5;
  ::google::protobuf::uint32 players_streak_2() const;
  void set_players_streak_2(::google::protobuf::uint32 value);

  // optional uint32 players_streak_3 = 6;
  bool has_players_streak_3() const;
  void clear_players_streak_3();
  static const int kPlayersStreak3FieldNumber = 6;
  ::google::protobuf::uint32 players_streak_3() const;
  void set_players_streak_3(::google::protobuf::uint32 value);

  // optional uint32 players_streak_4 = 7;
  bool has_players_streak_4() const;
  void clear_players_streak_4();
  static const int kPlayersStreak4FieldNumber = 7;
  ::google::protobuf::uint32 players_streak_4() const;
  void set_players_streak_4(::google::protobuf::uint32 value);

  // optional uint32 players_streak_5 = 8;
  bool has_players_streak_5() const;
  void clear_players_streak_5();
  static const int kPlayersStreak5FieldNumber = 8;
  ::google::protobuf::uint32 players_streak_5() const;
  void set_players_streak_5(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Tier)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 tier_;
  ::google::protobuf::uint32 players_;
  ::google::protobuf::uint32 teams_;
  ::google::protobuf::uint32 winning_teams_;
  ::google::protobuf::uint32 players_streak_2_;
  ::google::protobuf::uint32 players_streak_3_;
  ::google::protobuf::uint32 players_streak_4_;
  ::google::protobuf::uint32 players_streak_5_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAWeekendTourneyParticipationDetails_Division final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Division) */ {
 public:
  CMsgDOTAWeekendTourneyParticipationDetails_Division();
  virtual ~CMsgDOTAWeekendTourneyParticipationDetails_Division();

  CMsgDOTAWeekendTourneyParticipationDetails_Division(const CMsgDOTAWeekendTourneyParticipationDetails_Division& from);

  inline CMsgDOTAWeekendTourneyParticipationDetails_Division& operator=(const CMsgDOTAWeekendTourneyParticipationDetails_Division& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAWeekendTourneyParticipationDetails_Division(CMsgDOTAWeekendTourneyParticipationDetails_Division&& from) noexcept
    : CMsgDOTAWeekendTourneyParticipationDetails_Division() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAWeekendTourneyParticipationDetails_Division& operator=(CMsgDOTAWeekendTourneyParticipationDetails_Division&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAWeekendTourneyParticipationDetails_Division& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAWeekendTourneyParticipationDetails_Division* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAWeekendTourneyParticipationDetails_Division*>(
               &_CMsgDOTAWeekendTourneyParticipationDetails_Division_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(CMsgDOTAWeekendTourneyParticipationDetails_Division* other);
  friend void swap(CMsgDOTAWeekendTourneyParticipationDetails_Division& a, CMsgDOTAWeekendTourneyParticipationDetails_Division& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAWeekendTourneyParticipationDetails_Division* New() const final {
    return CreateMaybeMessage<CMsgDOTAWeekendTourneyParticipationDetails_Division>(nullptr);
  }

  CMsgDOTAWeekendTourneyParticipationDetails_Division* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAWeekendTourneyParticipationDetails_Division>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAWeekendTourneyParticipationDetails_Division& from);
  void MergeFrom(const CMsgDOTAWeekendTourneyParticipationDetails_Division& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAWeekendTourneyParticipationDetails_Division* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Tier tiers = 3;
  int tiers_size() const;
  void clear_tiers();
  static const int kTiersFieldNumber = 3;
  ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Tier* mutable_tiers(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Tier >*
      mutable_tiers();
  const ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Tier& tiers(int index) const;
  ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Tier* add_tiers();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Tier >&
      tiers() const;

  // optional uint32 division_id = 1;
  bool has_division_id() const;
  void clear_division_id();
  static const int kDivisionIdFieldNumber = 1;
  ::google::protobuf::uint32 division_id() const;
  void set_division_id(::google::protobuf::uint32 value);

  // optional uint32 schedule_time = 2;
  bool has_schedule_time() const;
  void clear_schedule_time();
  static const int kScheduleTimeFieldNumber = 2;
  ::google::protobuf::uint32 schedule_time() const;
  void set_schedule_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Division)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Tier > tiers_;
  ::google::protobuf::uint32 division_id_;
  ::google::protobuf::uint32 schedule_time_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAWeekendTourneyParticipationDetails final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails) */ {
 public:
  CMsgDOTAWeekendTourneyParticipationDetails();
  virtual ~CMsgDOTAWeekendTourneyParticipationDetails();

  CMsgDOTAWeekendTourneyParticipationDetails(const CMsgDOTAWeekendTourneyParticipationDetails& from);

  inline CMsgDOTAWeekendTourneyParticipationDetails& operator=(const CMsgDOTAWeekendTourneyParticipationDetails& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAWeekendTourneyParticipationDetails(CMsgDOTAWeekendTourneyParticipationDetails&& from) noexcept
    : CMsgDOTAWeekendTourneyParticipationDetails() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAWeekendTourneyParticipationDetails& operator=(CMsgDOTAWeekendTourneyParticipationDetails&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAWeekendTourneyParticipationDetails& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAWeekendTourneyParticipationDetails* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAWeekendTourneyParticipationDetails*>(
               &_CMsgDOTAWeekendTourneyParticipationDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(CMsgDOTAWeekendTourneyParticipationDetails* other);
  friend void swap(CMsgDOTAWeekendTourneyParticipationDetails& a, CMsgDOTAWeekendTourneyParticipationDetails& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAWeekendTourneyParticipationDetails* New() const final {
    return CreateMaybeMessage<CMsgDOTAWeekendTourneyParticipationDetails>(nullptr);
  }

  CMsgDOTAWeekendTourneyParticipationDetails* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAWeekendTourneyParticipationDetails>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAWeekendTourneyParticipationDetails& from);
  void MergeFrom(const CMsgDOTAWeekendTourneyParticipationDetails& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAWeekendTourneyParticipationDetails* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAWeekendTourneyParticipationDetails_Tier Tier;
  typedef CMsgDOTAWeekendTourneyParticipationDetails_Division Division;

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Division divisions = 1;
  int divisions_size() const;
  void clear_divisions();
  static const int kDivisionsFieldNumber = 1;
  ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Division* mutable_divisions(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Division >*
      mutable_divisions();
  const ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Division& divisions(int index) const;
  ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Division* add_divisions();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Division >&
      divisions() const;

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Division > divisions_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ftournament_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CMsgDOTATournamentInfo_PhaseGroup

// optional uint32 group_id = 1;
inline bool CMsgDOTATournamentInfo_PhaseGroup::has_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTATournamentInfo_PhaseGroup::clear_group_id() {
  group_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentInfo_PhaseGroup::group_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.PhaseGroup.group_id)
  return group_id_;
}
inline void CMsgDOTATournamentInfo_PhaseGroup::set_group_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  group_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.PhaseGroup.group_id)
}

// optional string group_name = 2;
inline bool CMsgDOTATournamentInfo_PhaseGroup::has_group_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTATournamentInfo_PhaseGroup::clear_group_name() {
  group_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTATournamentInfo_PhaseGroup::group_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.PhaseGroup.group_name)
  return group_name_.GetNoArena();
}
inline void CMsgDOTATournamentInfo_PhaseGroup::set_group_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  group_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.PhaseGroup.group_name)
}
#if LANG_CXX11
inline void CMsgDOTATournamentInfo_PhaseGroup::set_group_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  group_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTATournamentInfo.PhaseGroup.group_name)
}
#endif
inline void CMsgDOTATournamentInfo_PhaseGroup::set_group_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  group_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTATournamentInfo.PhaseGroup.group_name)
}
inline void CMsgDOTATournamentInfo_PhaseGroup::set_group_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  group_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTATournamentInfo.PhaseGroup.group_name)
}
inline ::std::string* CMsgDOTATournamentInfo_PhaseGroup::mutable_group_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournamentInfo.PhaseGroup.group_name)
  return group_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTATournamentInfo_PhaseGroup::release_group_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTATournamentInfo.PhaseGroup.group_name)
  if (!has_group_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return group_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTATournamentInfo_PhaseGroup::set_allocated_group_name(::std::string* group_name) {
  if (group_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  group_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTATournamentInfo.PhaseGroup.group_name)
}

// -------------------------------------------------------------------

// CMsgDOTATournamentInfo_Phase

// optional uint32 phase_id = 1;
inline bool CMsgDOTATournamentInfo_Phase::has_phase_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTATournamentInfo_Phase::clear_phase_id() {
  phase_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentInfo_Phase::phase_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.Phase.phase_id)
  return phase_id_;
}
inline void CMsgDOTATournamentInfo_Phase::set_phase_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  phase_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.Phase.phase_id)
}

// optional string phase_name = 2;
inline bool CMsgDOTATournamentInfo_Phase::has_phase_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTATournamentInfo_Phase::clear_phase_name() {
  phase_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTATournamentInfo_Phase::phase_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.Phase.phase_name)
  return phase_name_.GetNoArena();
}
inline void CMsgDOTATournamentInfo_Phase::set_phase_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  phase_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.Phase.phase_name)
}
#if LANG_CXX11
inline void CMsgDOTATournamentInfo_Phase::set_phase_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  phase_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTATournamentInfo.Phase.phase_name)
}
#endif
inline void CMsgDOTATournamentInfo_Phase::set_phase_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  phase_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTATournamentInfo.Phase.phase_name)
}
inline void CMsgDOTATournamentInfo_Phase::set_phase_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  phase_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTATournamentInfo.Phase.phase_name)
}
inline ::std::string* CMsgDOTATournamentInfo_Phase::mutable_phase_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournamentInfo.Phase.phase_name)
  return phase_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTATournamentInfo_Phase::release_phase_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTATournamentInfo.Phase.phase_name)
  if (!has_phase_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return phase_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTATournamentInfo_Phase::set_allocated_phase_name(::std::string* phase_name) {
  if (phase_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  phase_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), phase_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTATournamentInfo.Phase.phase_name)
}

// optional uint32 type_id = 3;
inline bool CMsgDOTATournamentInfo_Phase::has_type_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTATournamentInfo_Phase::clear_type_id() {
  type_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentInfo_Phase::type_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.Phase.type_id)
  return type_id_;
}
inline void CMsgDOTATournamentInfo_Phase::set_type_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  type_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.Phase.type_id)
}

// optional uint32 iterations = 4;
inline bool CMsgDOTATournamentInfo_Phase::has_iterations() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTATournamentInfo_Phase::clear_iterations() {
  iterations_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentInfo_Phase::iterations() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.Phase.iterations)
  return iterations_;
}
inline void CMsgDOTATournamentInfo_Phase::set_iterations(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  iterations_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.Phase.iterations)
}

// optional uint32 min_start_time = 5;
inline bool CMsgDOTATournamentInfo_Phase::has_min_start_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTATournamentInfo_Phase::clear_min_start_time() {
  min_start_time_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentInfo_Phase::min_start_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.Phase.min_start_time)
  return min_start_time_;
}
inline void CMsgDOTATournamentInfo_Phase::set_min_start_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  min_start_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.Phase.min_start_time)
}

// optional uint32 max_start_time = 6;
inline bool CMsgDOTATournamentInfo_Phase::has_max_start_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTATournamentInfo_Phase::clear_max_start_time() {
  max_start_time_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentInfo_Phase::max_start_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.Phase.max_start_time)
  return max_start_time_;
}
inline void CMsgDOTATournamentInfo_Phase::set_max_start_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  max_start_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.Phase.max_start_time)
}

// repeated .proto.dota.CMsgDOTATournamentInfo.PhaseGroup group_list = 7;
inline int CMsgDOTATournamentInfo_Phase::group_list_size() const {
  return group_list_.size();
}
inline void CMsgDOTATournamentInfo_Phase::clear_group_list() {
  group_list_.Clear();
}
inline ::proto::dota::CMsgDOTATournamentInfo_PhaseGroup* CMsgDOTATournamentInfo_Phase::mutable_group_list(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournamentInfo.Phase.group_list)
  return group_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_PhaseGroup >*
CMsgDOTATournamentInfo_Phase::mutable_group_list() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTATournamentInfo.Phase.group_list)
  return &group_list_;
}
inline const ::proto::dota::CMsgDOTATournamentInfo_PhaseGroup& CMsgDOTATournamentInfo_Phase::group_list(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.Phase.group_list)
  return group_list_.Get(index);
}
inline ::proto::dota::CMsgDOTATournamentInfo_PhaseGroup* CMsgDOTATournamentInfo_Phase::add_group_list() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTATournamentInfo.Phase.group_list)
  return group_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_PhaseGroup >&
CMsgDOTATournamentInfo_Phase::group_list() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTATournamentInfo.Phase.group_list)
  return group_list_;
}

// -------------------------------------------------------------------

// CMsgDOTATournamentInfo_Team

// optional uint32 team_id = 1;
inline bool CMsgDOTATournamentInfo_Team::has_team_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTATournamentInfo_Team::clear_team_id() {
  team_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentInfo_Team::team_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.Team.team_id)
  return team_id_;
}
inline void CMsgDOTATournamentInfo_Team::set_team_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  team_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.Team.team_id)
}

// optional string name = 2;
inline bool CMsgDOTATournamentInfo_Team::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTATournamentInfo_Team::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTATournamentInfo_Team::name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.Team.name)
  return name_.GetNoArena();
}
inline void CMsgDOTATournamentInfo_Team::set_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.Team.name)
}
#if LANG_CXX11
inline void CMsgDOTATournamentInfo_Team::set_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTATournamentInfo.Team.name)
}
#endif
inline void CMsgDOTATournamentInfo_Team::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTATournamentInfo.Team.name)
}
inline void CMsgDOTATournamentInfo_Team::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTATournamentInfo.Team.name)
}
inline ::std::string* CMsgDOTATournamentInfo_Team::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournamentInfo.Team.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTATournamentInfo_Team::release_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTATournamentInfo.Team.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTATournamentInfo_Team::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTATournamentInfo.Team.name)
}

// optional string tag = 3;
inline bool CMsgDOTATournamentInfo_Team::has_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTATournamentInfo_Team::clear_tag() {
  tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgDOTATournamentInfo_Team::tag() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.Team.tag)
  return tag_.GetNoArena();
}
inline void CMsgDOTATournamentInfo_Team::set_tag(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.Team.tag)
}
#if LANG_CXX11
inline void CMsgDOTATournamentInfo_Team::set_tag(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTATournamentInfo.Team.tag)
}
#endif
inline void CMsgDOTATournamentInfo_Team::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTATournamentInfo.Team.tag)
}
inline void CMsgDOTATournamentInfo_Team::set_tag(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTATournamentInfo.Team.tag)
}
inline ::std::string* CMsgDOTATournamentInfo_Team::mutable_tag() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournamentInfo.Team.tag)
  return tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTATournamentInfo_Team::release_tag() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTATournamentInfo.Team.tag)
  if (!has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return tag_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTATournamentInfo_Team::set_allocated_tag(::std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTATournamentInfo.Team.tag)
}

// optional uint64 team_logo = 4;
inline bool CMsgDOTATournamentInfo_Team::has_team_logo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTATournamentInfo_Team::clear_team_logo() {
  team_logo_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint64 CMsgDOTATournamentInfo_Team::team_logo() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.Team.team_logo)
  return team_logo_;
}
inline void CMsgDOTATournamentInfo_Team::set_team_logo(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  team_logo_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.Team.team_logo)
}

// optional bool eliminated = 5;
inline bool CMsgDOTATournamentInfo_Team::has_eliminated() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTATournamentInfo_Team::clear_eliminated() {
  eliminated_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool CMsgDOTATournamentInfo_Team::eliminated() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.Team.eliminated)
  return eliminated_;
}
inline void CMsgDOTATournamentInfo_Team::set_eliminated(bool value) {
  _has_bits_[0] |= 0x00000008u;
  eliminated_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.Team.eliminated)
}

// -------------------------------------------------------------------

// CMsgDOTATournamentInfo_UpcomingMatch

// optional uint32 series_id = 1;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_series_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_series_id() {
  series_id_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentInfo_UpcomingMatch::series_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.series_id)
  return series_id_;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_series_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  series_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.series_id)
}

// optional uint32 team1_id = 2;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_team1_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_team1_id() {
  team1_id_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentInfo_UpcomingMatch::team1_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_id)
  return team1_id_;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team1_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  team1_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_id)
}

// optional uint32 team2_id = 3;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_team2_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_team2_id() {
  team2_id_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentInfo_UpcomingMatch::team2_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_id)
  return team2_id_;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team2_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  team2_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_id)
}

// optional uint32 bo = 4;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_bo() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_bo() {
  bo_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentInfo_UpcomingMatch::bo() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.bo)
  return bo_;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_bo(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000400u;
  bo_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.bo)
}

// optional string stage_name = 5;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_stage_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_stage_name() {
  stage_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTATournamentInfo_UpcomingMatch::stage_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.stage_name)
  return stage_name_.GetNoArena();
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_stage_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  stage_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.stage_name)
}
#if LANG_CXX11
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_stage_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  stage_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.stage_name)
}
#endif
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_stage_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  stage_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.stage_name)
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_stage_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  stage_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.stage_name)
}
inline ::std::string* CMsgDOTATournamentInfo_UpcomingMatch::mutable_stage_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.stage_name)
  return stage_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTATournamentInfo_UpcomingMatch::release_stage_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.stage_name)
  if (!has_stage_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return stage_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_allocated_stage_name(::std::string* stage_name) {
  if (stage_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  stage_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stage_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.stage_name)
}

// optional uint32 start_time = 6;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_start_time() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_start_time() {
  start_time_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentInfo_UpcomingMatch::start_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.start_time)
  return start_time_;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_start_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000800u;
  start_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.start_time)
}

// optional string winner_stage = 7;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_winner_stage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_winner_stage() {
  winner_stage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgDOTATournamentInfo_UpcomingMatch::winner_stage() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.winner_stage)
  return winner_stage_.GetNoArena();
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_winner_stage(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  winner_stage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.winner_stage)
}
#if LANG_CXX11
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_winner_stage(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  winner_stage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.winner_stage)
}
#endif
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_winner_stage(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  winner_stage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.winner_stage)
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_winner_stage(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  winner_stage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.winner_stage)
}
inline ::std::string* CMsgDOTATournamentInfo_UpcomingMatch::mutable_winner_stage() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.winner_stage)
  return winner_stage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTATournamentInfo_UpcomingMatch::release_winner_stage() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.winner_stage)
  if (!has_winner_stage()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return winner_stage_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_allocated_winner_stage(::std::string* winner_stage) {
  if (winner_stage != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  winner_stage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), winner_stage);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.winner_stage)
}

// optional string loser_stage = 8;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_loser_stage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_loser_stage() {
  loser_stage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& CMsgDOTATournamentInfo_UpcomingMatch::loser_stage() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.loser_stage)
  return loser_stage_.GetNoArena();
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_loser_stage(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  loser_stage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.loser_stage)
}
#if LANG_CXX11
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_loser_stage(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  loser_stage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.loser_stage)
}
#endif
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_loser_stage(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  loser_stage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.loser_stage)
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_loser_stage(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  loser_stage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.loser_stage)
}
inline ::std::string* CMsgDOTATournamentInfo_UpcomingMatch::mutable_loser_stage() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.loser_stage)
  return loser_stage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTATournamentInfo_UpcomingMatch::release_loser_stage() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.loser_stage)
  if (!has_loser_stage()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return loser_stage_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_allocated_loser_stage(::std::string* loser_stage) {
  if (loser_stage != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  loser_stage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), loser_stage);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.loser_stage)
}

// optional string team1_tag = 9;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_team1_tag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_team1_tag() {
  team1_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& CMsgDOTATournamentInfo_UpcomingMatch::team1_tag() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_tag)
  return team1_tag_.GetNoArena();
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team1_tag(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  team1_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_tag)
}
#if LANG_CXX11
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team1_tag(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  team1_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_tag)
}
#endif
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team1_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  team1_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_tag)
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team1_tag(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  team1_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_tag)
}
inline ::std::string* CMsgDOTATournamentInfo_UpcomingMatch::mutable_team1_tag() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_tag)
  return team1_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTATournamentInfo_UpcomingMatch::release_team1_tag() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_tag)
  if (!has_team1_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return team1_tag_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_allocated_team1_tag(::std::string* team1_tag) {
  if (team1_tag != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  team1_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team1_tag);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_tag)
}

// optional string team2_tag = 10;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_team2_tag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_team2_tag() {
  team2_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& CMsgDOTATournamentInfo_UpcomingMatch::team2_tag() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_tag)
  return team2_tag_.GetNoArena();
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team2_tag(const ::std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  team2_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_tag)
}
#if LANG_CXX11
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team2_tag(::std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  team2_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_tag)
}
#endif
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team2_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  team2_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_tag)
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team2_tag(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  team2_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_tag)
}
inline ::std::string* CMsgDOTATournamentInfo_UpcomingMatch::mutable_team2_tag() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_tag)
  return team2_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTATournamentInfo_UpcomingMatch::release_team2_tag() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_tag)
  if (!has_team2_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return team2_tag_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_allocated_team2_tag(::std::string* team2_tag) {
  if (team2_tag != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  team2_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team2_tag);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_tag)
}

// optional string team1_prev_opponent_tag = 11;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_team1_prev_opponent_tag() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_team1_prev_opponent_tag() {
  team1_prev_opponent_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::std::string& CMsgDOTATournamentInfo_UpcomingMatch::team1_prev_opponent_tag() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_prev_opponent_tag)
  return team1_prev_opponent_tag_.GetNoArena();
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team1_prev_opponent_tag(const ::std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  team1_prev_opponent_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_prev_opponent_tag)
}
#if LANG_CXX11
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team1_prev_opponent_tag(::std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  team1_prev_opponent_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_prev_opponent_tag)
}
#endif
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team1_prev_opponent_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  team1_prev_opponent_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_prev_opponent_tag)
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team1_prev_opponent_tag(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000020u;
  team1_prev_opponent_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_prev_opponent_tag)
}
inline ::std::string* CMsgDOTATournamentInfo_UpcomingMatch::mutable_team1_prev_opponent_tag() {
  _has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_prev_opponent_tag)
  return team1_prev_opponent_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTATournamentInfo_UpcomingMatch::release_team1_prev_opponent_tag() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_prev_opponent_tag)
  if (!has_team1_prev_opponent_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return team1_prev_opponent_tag_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_allocated_team1_prev_opponent_tag(::std::string* team1_prev_opponent_tag) {
  if (team1_prev_opponent_tag != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  team1_prev_opponent_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team1_prev_opponent_tag);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_prev_opponent_tag)
}

// optional string team2_prev_opponent_tag = 12;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_team2_prev_opponent_tag() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_team2_prev_opponent_tag() {
  team2_prev_opponent_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::std::string& CMsgDOTATournamentInfo_UpcomingMatch::team2_prev_opponent_tag() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_prev_opponent_tag)
  return team2_prev_opponent_tag_.GetNoArena();
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team2_prev_opponent_tag(const ::std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  team2_prev_opponent_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_prev_opponent_tag)
}
#if LANG_CXX11
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team2_prev_opponent_tag(::std::string&& value) {
  _has_bits_[0] |= 0x00000040u;
  team2_prev_opponent_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_prev_opponent_tag)
}
#endif
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team2_prev_opponent_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000040u;
  team2_prev_opponent_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_prev_opponent_tag)
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team2_prev_opponent_tag(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000040u;
  team2_prev_opponent_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_prev_opponent_tag)
}
inline ::std::string* CMsgDOTATournamentInfo_UpcomingMatch::mutable_team2_prev_opponent_tag() {
  _has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_prev_opponent_tag)
  return team2_prev_opponent_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTATournamentInfo_UpcomingMatch::release_team2_prev_opponent_tag() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_prev_opponent_tag)
  if (!has_team2_prev_opponent_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return team2_prev_opponent_tag_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_allocated_team2_prev_opponent_tag(::std::string* team2_prev_opponent_tag) {
  if (team2_prev_opponent_tag != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  team2_prev_opponent_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team2_prev_opponent_tag);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_prev_opponent_tag)
}

// optional uint64 team1_logo = 13;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_team1_logo() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_team1_logo() {
  team1_logo_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00002000u;
}
inline ::google::protobuf::uint64 CMsgDOTATournamentInfo_UpcomingMatch::team1_logo() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_logo)
  return team1_logo_;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team1_logo(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00002000u;
  team1_logo_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_logo)
}

// optional uint64 team2_logo = 14;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_team2_logo() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_team2_logo() {
  team2_logo_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00004000u;
}
inline ::google::protobuf::uint64 CMsgDOTATournamentInfo_UpcomingMatch::team2_logo() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_logo)
  return team2_logo_;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team2_logo(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00004000u;
  team2_logo_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_logo)
}

// optional uint64 team1_prev_opponent_logo = 15;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_team1_prev_opponent_logo() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_team1_prev_opponent_logo() {
  team1_prev_opponent_logo_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00008000u;
}
inline ::google::protobuf::uint64 CMsgDOTATournamentInfo_UpcomingMatch::team1_prev_opponent_logo() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_prev_opponent_logo)
  return team1_prev_opponent_logo_;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team1_prev_opponent_logo(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00008000u;
  team1_prev_opponent_logo_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_prev_opponent_logo)
}

// optional uint64 team2_prev_opponent_logo = 16;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_team2_prev_opponent_logo() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_team2_prev_opponent_logo() {
  team2_prev_opponent_logo_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00010000u;
}
inline ::google::protobuf::uint64 CMsgDOTATournamentInfo_UpcomingMatch::team2_prev_opponent_logo() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_prev_opponent_logo)
  return team2_prev_opponent_logo_;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team2_prev_opponent_logo(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00010000u;
  team2_prev_opponent_logo_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_prev_opponent_logo)
}

// optional uint32 team1_prev_opponent_id = 17;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_team1_prev_opponent_id() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_team1_prev_opponent_id() {
  team1_prev_opponent_id_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentInfo_UpcomingMatch::team1_prev_opponent_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_prev_opponent_id)
  return team1_prev_opponent_id_;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team1_prev_opponent_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00001000u;
  team1_prev_opponent_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_prev_opponent_id)
}

// optional uint32 team2_prev_opponent_id = 18;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_team2_prev_opponent_id() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_team2_prev_opponent_id() {
  team2_prev_opponent_id_ = 0u;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentInfo_UpcomingMatch::team2_prev_opponent_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_prev_opponent_id)
  return team2_prev_opponent_id_;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team2_prev_opponent_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00020000u;
  team2_prev_opponent_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_prev_opponent_id)
}

// optional uint32 team1_prev_match_score = 19;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_team1_prev_match_score() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_team1_prev_match_score() {
  team1_prev_match_score_ = 0u;
  _has_bits_[0] &= ~0x00040000u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentInfo_UpcomingMatch::team1_prev_match_score() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_prev_match_score)
  return team1_prev_match_score_;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team1_prev_match_score(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00040000u;
  team1_prev_match_score_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_prev_match_score)
}

// optional uint32 team1_prev_match_opponent_score = 20;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_team1_prev_match_opponent_score() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_team1_prev_match_opponent_score() {
  team1_prev_match_opponent_score_ = 0u;
  _has_bits_[0] &= ~0x00080000u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentInfo_UpcomingMatch::team1_prev_match_opponent_score() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_prev_match_opponent_score)
  return team1_prev_match_opponent_score_;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team1_prev_match_opponent_score(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00080000u;
  team1_prev_match_opponent_score_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_prev_match_opponent_score)
}

// optional uint32 team2_prev_match_score = 21;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_team2_prev_match_score() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_team2_prev_match_score() {
  team2_prev_match_score_ = 0u;
  _has_bits_[0] &= ~0x00100000u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentInfo_UpcomingMatch::team2_prev_match_score() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_prev_match_score)
  return team2_prev_match_score_;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team2_prev_match_score(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00100000u;
  team2_prev_match_score_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_prev_match_score)
}

// optional uint32 team2_prev_match_opponent_score = 22;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_team2_prev_match_opponent_score() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_team2_prev_match_opponent_score() {
  team2_prev_match_opponent_score_ = 0u;
  _has_bits_[0] &= ~0x00200000u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentInfo_UpcomingMatch::team2_prev_match_opponent_score() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_prev_match_opponent_score)
  return team2_prev_match_opponent_score_;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team2_prev_match_opponent_score(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00200000u;
  team2_prev_match_opponent_score_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_prev_match_opponent_score)
}

// optional uint32 phase_type = 23;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_phase_type() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_phase_type() {
  phase_type_ = 0u;
  _has_bits_[0] &= ~0x00400000u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentInfo_UpcomingMatch::phase_type() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.phase_type)
  return phase_type_;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_phase_type(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00400000u;
  phase_type_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.phase_type)
}

// optional uint32 team1_score = 24;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_team1_score() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_team1_score() {
  team1_score_ = 0u;
  _has_bits_[0] &= ~0x00800000u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentInfo_UpcomingMatch::team1_score() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_score)
  return team1_score_;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team1_score(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00800000u;
  team1_score_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team1_score)
}

// optional uint32 team2_score = 25;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_team2_score() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_team2_score() {
  team2_score_ = 0u;
  _has_bits_[0] &= ~0x01000000u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentInfo_UpcomingMatch::team2_score() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_score)
  return team2_score_;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_team2_score(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x01000000u;
  team2_score_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.team2_score)
}

// optional uint32 phase_id = 26;
inline bool CMsgDOTATournamentInfo_UpcomingMatch::has_phase_id() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::clear_phase_id() {
  phase_id_ = 0u;
  _has_bits_[0] &= ~0x02000000u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentInfo_UpcomingMatch::phase_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.phase_id)
  return phase_id_;
}
inline void CMsgDOTATournamentInfo_UpcomingMatch::set_phase_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x02000000u;
  phase_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.UpcomingMatch.phase_id)
}

// -------------------------------------------------------------------

// CMsgDOTATournamentInfo_News

// optional string link = 1;
inline bool CMsgDOTATournamentInfo_News::has_link() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTATournamentInfo_News::clear_link() {
  link_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTATournamentInfo_News::link() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.News.link)
  return link_.GetNoArena();
}
inline void CMsgDOTATournamentInfo_News::set_link(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.News.link)
}
#if LANG_CXX11
inline void CMsgDOTATournamentInfo_News::set_link(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  link_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTATournamentInfo.News.link)
}
#endif
inline void CMsgDOTATournamentInfo_News::set_link(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTATournamentInfo.News.link)
}
inline void CMsgDOTATournamentInfo_News::set_link(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTATournamentInfo.News.link)
}
inline ::std::string* CMsgDOTATournamentInfo_News::mutable_link() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournamentInfo.News.link)
  return link_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTATournamentInfo_News::release_link() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTATournamentInfo.News.link)
  if (!has_link()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return link_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTATournamentInfo_News::set_allocated_link(::std::string* link) {
  if (link != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  link_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTATournamentInfo.News.link)
}

// optional string title = 2;
inline bool CMsgDOTATournamentInfo_News::has_title() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTATournamentInfo_News::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgDOTATournamentInfo_News::title() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.News.title)
  return title_.GetNoArena();
}
inline void CMsgDOTATournamentInfo_News::set_title(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.News.title)
}
#if LANG_CXX11
inline void CMsgDOTATournamentInfo_News::set_title(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTATournamentInfo.News.title)
}
#endif
inline void CMsgDOTATournamentInfo_News::set_title(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTATournamentInfo.News.title)
}
inline void CMsgDOTATournamentInfo_News::set_title(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTATournamentInfo.News.title)
}
inline ::std::string* CMsgDOTATournamentInfo_News::mutable_title() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournamentInfo.News.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTATournamentInfo_News::release_title() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTATournamentInfo.News.title)
  if (!has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return title_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTATournamentInfo_News::set_allocated_title(::std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTATournamentInfo.News.title)
}

// optional string image = 3;
inline bool CMsgDOTATournamentInfo_News::has_image() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTATournamentInfo_News::clear_image() {
  image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& CMsgDOTATournamentInfo_News::image() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.News.image)
  return image_.GetNoArena();
}
inline void CMsgDOTATournamentInfo_News::set_image(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.News.image)
}
#if LANG_CXX11
inline void CMsgDOTATournamentInfo_News::set_image(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  image_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTATournamentInfo.News.image)
}
#endif
inline void CMsgDOTATournamentInfo_News::set_image(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTATournamentInfo.News.image)
}
inline void CMsgDOTATournamentInfo_News::set_image(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTATournamentInfo.News.image)
}
inline ::std::string* CMsgDOTATournamentInfo_News::mutable_image() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournamentInfo.News.image)
  return image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTATournamentInfo_News::release_image() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTATournamentInfo.News.image)
  if (!has_image()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return image_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTATournamentInfo_News::set_allocated_image(::std::string* image) {
  if (image != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTATournamentInfo.News.image)
}

// optional uint32 timestamp = 4;
inline bool CMsgDOTATournamentInfo_News::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTATournamentInfo_News::clear_timestamp() {
  timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentInfo_News::timestamp() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.News.timestamp)
  return timestamp_;
}
inline void CMsgDOTATournamentInfo_News::set_timestamp(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.News.timestamp)
}

// -------------------------------------------------------------------

// CMsgDOTATournamentInfo

// optional uint32 league_id = 1;
inline bool CMsgDOTATournamentInfo::has_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTATournamentInfo::clear_league_id() {
  league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentInfo::league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.league_id)
  return league_id_;
}
inline void CMsgDOTATournamentInfo::set_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentInfo.league_id)
}

// repeated .proto.dota.CMsgDOTATournamentInfo.Phase phase_list = 2;
inline int CMsgDOTATournamentInfo::phase_list_size() const {
  return phase_list_.size();
}
inline void CMsgDOTATournamentInfo::clear_phase_list() {
  phase_list_.Clear();
}
inline ::proto::dota::CMsgDOTATournamentInfo_Phase* CMsgDOTATournamentInfo::mutable_phase_list(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournamentInfo.phase_list)
  return phase_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_Phase >*
CMsgDOTATournamentInfo::mutable_phase_list() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTATournamentInfo.phase_list)
  return &phase_list_;
}
inline const ::proto::dota::CMsgDOTATournamentInfo_Phase& CMsgDOTATournamentInfo::phase_list(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.phase_list)
  return phase_list_.Get(index);
}
inline ::proto::dota::CMsgDOTATournamentInfo_Phase* CMsgDOTATournamentInfo::add_phase_list() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTATournamentInfo.phase_list)
  return phase_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_Phase >&
CMsgDOTATournamentInfo::phase_list() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTATournamentInfo.phase_list)
  return phase_list_;
}

// repeated .proto.dota.CMsgDOTATournamentInfo.Team teams_list = 3;
inline int CMsgDOTATournamentInfo::teams_list_size() const {
  return teams_list_.size();
}
inline void CMsgDOTATournamentInfo::clear_teams_list() {
  teams_list_.Clear();
}
inline ::proto::dota::CMsgDOTATournamentInfo_Team* CMsgDOTATournamentInfo::mutable_teams_list(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournamentInfo.teams_list)
  return teams_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_Team >*
CMsgDOTATournamentInfo::mutable_teams_list() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTATournamentInfo.teams_list)
  return &teams_list_;
}
inline const ::proto::dota::CMsgDOTATournamentInfo_Team& CMsgDOTATournamentInfo::teams_list(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.teams_list)
  return teams_list_.Get(index);
}
inline ::proto::dota::CMsgDOTATournamentInfo_Team* CMsgDOTATournamentInfo::add_teams_list() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTATournamentInfo.teams_list)
  return teams_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_Team >&
CMsgDOTATournamentInfo::teams_list() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTATournamentInfo.teams_list)
  return teams_list_;
}

// repeated .proto.dota.CMsgDOTATournamentInfo.UpcomingMatch upcoming_matches_list = 4;
inline int CMsgDOTATournamentInfo::upcoming_matches_list_size() const {
  return upcoming_matches_list_.size();
}
inline void CMsgDOTATournamentInfo::clear_upcoming_matches_list() {
  upcoming_matches_list_.Clear();
}
inline ::proto::dota::CMsgDOTATournamentInfo_UpcomingMatch* CMsgDOTATournamentInfo::mutable_upcoming_matches_list(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournamentInfo.upcoming_matches_list)
  return upcoming_matches_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_UpcomingMatch >*
CMsgDOTATournamentInfo::mutable_upcoming_matches_list() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTATournamentInfo.upcoming_matches_list)
  return &upcoming_matches_list_;
}
inline const ::proto::dota::CMsgDOTATournamentInfo_UpcomingMatch& CMsgDOTATournamentInfo::upcoming_matches_list(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.upcoming_matches_list)
  return upcoming_matches_list_.Get(index);
}
inline ::proto::dota::CMsgDOTATournamentInfo_UpcomingMatch* CMsgDOTATournamentInfo::add_upcoming_matches_list() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTATournamentInfo.upcoming_matches_list)
  return upcoming_matches_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_UpcomingMatch >&
CMsgDOTATournamentInfo::upcoming_matches_list() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTATournamentInfo.upcoming_matches_list)
  return upcoming_matches_list_;
}

// repeated .proto.dota.CMsgDOTATournamentInfo.News news_list = 5;
inline int CMsgDOTATournamentInfo::news_list_size() const {
  return news_list_.size();
}
inline void CMsgDOTATournamentInfo::clear_news_list() {
  news_list_.Clear();
}
inline ::proto::dota::CMsgDOTATournamentInfo_News* CMsgDOTATournamentInfo::mutable_news_list(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournamentInfo.news_list)
  return news_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_News >*
CMsgDOTATournamentInfo::mutable_news_list() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTATournamentInfo.news_list)
  return &news_list_;
}
inline const ::proto::dota::CMsgDOTATournamentInfo_News& CMsgDOTATournamentInfo::news_list(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentInfo.news_list)
  return news_list_.Get(index);
}
inline ::proto::dota::CMsgDOTATournamentInfo_News* CMsgDOTATournamentInfo::add_news_list() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTATournamentInfo.news_list)
  return news_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentInfo_News >&
CMsgDOTATournamentInfo::news_list() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTATournamentInfo.news_list)
  return news_list_;
}

// -------------------------------------------------------------------

// CMsgRequestWeekendTourneySchedule

// -------------------------------------------------------------------

// CMsgWeekendTourneySchedule_Division

// optional uint32 division_code = 1;
inline bool CMsgWeekendTourneySchedule_Division::has_division_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgWeekendTourneySchedule_Division::clear_division_code() {
  division_code_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgWeekendTourneySchedule_Division::division_code() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgWeekendTourneySchedule.Division.division_code)
  return division_code_;
}
inline void CMsgWeekendTourneySchedule_Division::set_division_code(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  division_code_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgWeekendTourneySchedule.Division.division_code)
}

// optional uint32 time_window_open = 2;
inline bool CMsgWeekendTourneySchedule_Division::has_time_window_open() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgWeekendTourneySchedule_Division::clear_time_window_open() {
  time_window_open_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgWeekendTourneySchedule_Division::time_window_open() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgWeekendTourneySchedule.Division.time_window_open)
  return time_window_open_;
}
inline void CMsgWeekendTourneySchedule_Division::set_time_window_open(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  time_window_open_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgWeekendTourneySchedule.Division.time_window_open)
}

// optional uint32 time_window_close = 3;
inline bool CMsgWeekendTourneySchedule_Division::has_time_window_close() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgWeekendTourneySchedule_Division::clear_time_window_close() {
  time_window_close_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgWeekendTourneySchedule_Division::time_window_close() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgWeekendTourneySchedule.Division.time_window_close)
  return time_window_close_;
}
inline void CMsgWeekendTourneySchedule_Division::set_time_window_close(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  time_window_close_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgWeekendTourneySchedule.Division.time_window_close)
}

// optional uint32 time_window_open_next = 4;
inline bool CMsgWeekendTourneySchedule_Division::has_time_window_open_next() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgWeekendTourneySchedule_Division::clear_time_window_open_next() {
  time_window_open_next_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgWeekendTourneySchedule_Division::time_window_open_next() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgWeekendTourneySchedule.Division.time_window_open_next)
  return time_window_open_next_;
}
inline void CMsgWeekendTourneySchedule_Division::set_time_window_open_next(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  time_window_open_next_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgWeekendTourneySchedule.Division.time_window_open_next)
}

// optional uint32 trophy_id = 5;
inline bool CMsgWeekendTourneySchedule_Division::has_trophy_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgWeekendTourneySchedule_Division::clear_trophy_id() {
  trophy_id_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgWeekendTourneySchedule_Division::trophy_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgWeekendTourneySchedule.Division.trophy_id)
  return trophy_id_;
}
inline void CMsgWeekendTourneySchedule_Division::set_trophy_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  trophy_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgWeekendTourneySchedule.Division.trophy_id)
}

// optional bool free_weekend = 6;
inline bool CMsgWeekendTourneySchedule_Division::has_free_weekend() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgWeekendTourneySchedule_Division::clear_free_weekend() {
  free_weekend_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool CMsgWeekendTourneySchedule_Division::free_weekend() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgWeekendTourneySchedule.Division.free_weekend)
  return free_weekend_;
}
inline void CMsgWeekendTourneySchedule_Division::set_free_weekend(bool value) {
  _has_bits_[0] |= 0x00000020u;
  free_weekend_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgWeekendTourneySchedule.Division.free_weekend)
}

// -------------------------------------------------------------------

// CMsgWeekendTourneySchedule

// repeated .proto.dota.CMsgWeekendTourneySchedule.Division divisions = 1;
inline int CMsgWeekendTourneySchedule::divisions_size() const {
  return divisions_.size();
}
inline void CMsgWeekendTourneySchedule::clear_divisions() {
  divisions_.Clear();
}
inline ::proto::dota::CMsgWeekendTourneySchedule_Division* CMsgWeekendTourneySchedule::mutable_divisions(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgWeekendTourneySchedule.divisions)
  return divisions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgWeekendTourneySchedule_Division >*
CMsgWeekendTourneySchedule::mutable_divisions() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgWeekendTourneySchedule.divisions)
  return &divisions_;
}
inline const ::proto::dota::CMsgWeekendTourneySchedule_Division& CMsgWeekendTourneySchedule::divisions(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgWeekendTourneySchedule.divisions)
  return divisions_.Get(index);
}
inline ::proto::dota::CMsgWeekendTourneySchedule_Division* CMsgWeekendTourneySchedule::add_divisions() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgWeekendTourneySchedule.divisions)
  return divisions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgWeekendTourneySchedule_Division >&
CMsgWeekendTourneySchedule::divisions() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgWeekendTourneySchedule.divisions)
  return divisions_;
}

// -------------------------------------------------------------------

// CMsgWeekendTourneyOpts

// optional bool participating = 1;
inline bool CMsgWeekendTourneyOpts::has_participating() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgWeekendTourneyOpts::clear_participating() {
  participating_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CMsgWeekendTourneyOpts::participating() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgWeekendTourneyOpts.participating)
  return participating_;
}
inline void CMsgWeekendTourneyOpts::set_participating(bool value) {
  _has_bits_[0] |= 0x00000002u;
  participating_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgWeekendTourneyOpts.participating)
}

// optional uint32 division_id = 2;
inline bool CMsgWeekendTourneyOpts::has_division_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgWeekendTourneyOpts::clear_division_id() {
  division_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgWeekendTourneyOpts::division_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgWeekendTourneyOpts.division_id)
  return division_id_;
}
inline void CMsgWeekendTourneyOpts::set_division_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  division_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgWeekendTourneyOpts.division_id)
}

// optional uint32 buyin = 3;
inline bool CMsgWeekendTourneyOpts::has_buyin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgWeekendTourneyOpts::clear_buyin() {
  buyin_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgWeekendTourneyOpts::buyin() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgWeekendTourneyOpts.buyin)
  return buyin_;
}
inline void CMsgWeekendTourneyOpts::set_buyin(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  buyin_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgWeekendTourneyOpts.buyin)
}

// optional uint32 skill_level = 4;
inline bool CMsgWeekendTourneyOpts::has_skill_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgWeekendTourneyOpts::clear_skill_level() {
  skill_level_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgWeekendTourneyOpts::skill_level() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgWeekendTourneyOpts.skill_level)
  return skill_level_;
}
inline void CMsgWeekendTourneyOpts::set_skill_level(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  skill_level_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgWeekendTourneyOpts.skill_level)
}

// optional uint32 match_groups = 5;
inline bool CMsgWeekendTourneyOpts::has_match_groups() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgWeekendTourneyOpts::clear_match_groups() {
  match_groups_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 CMsgWeekendTourneyOpts::match_groups() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgWeekendTourneyOpts.match_groups)
  return match_groups_;
}
inline void CMsgWeekendTourneyOpts::set_match_groups(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  match_groups_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgWeekendTourneyOpts.match_groups)
}

// optional uint32 team_id = 6;
inline bool CMsgWeekendTourneyOpts::has_team_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgWeekendTourneyOpts::clear_team_id() {
  team_id_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 CMsgWeekendTourneyOpts::team_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgWeekendTourneyOpts.team_id)
  return team_id_;
}
inline void CMsgWeekendTourneyOpts::set_team_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  team_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgWeekendTourneyOpts.team_id)
}

// optional string pickup_team_name = 7;
inline bool CMsgWeekendTourneyOpts::has_pickup_team_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgWeekendTourneyOpts::clear_pickup_team_name() {
  pickup_team_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgWeekendTourneyOpts::pickup_team_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgWeekendTourneyOpts.pickup_team_name)
  return pickup_team_name_.GetNoArena();
}
inline void CMsgWeekendTourneyOpts::set_pickup_team_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  pickup_team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgWeekendTourneyOpts.pickup_team_name)
}
#if LANG_CXX11
inline void CMsgWeekendTourneyOpts::set_pickup_team_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  pickup_team_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgWeekendTourneyOpts.pickup_team_name)
}
#endif
inline void CMsgWeekendTourneyOpts::set_pickup_team_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  pickup_team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgWeekendTourneyOpts.pickup_team_name)
}
inline void CMsgWeekendTourneyOpts::set_pickup_team_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  pickup_team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgWeekendTourneyOpts.pickup_team_name)
}
inline ::std::string* CMsgWeekendTourneyOpts::mutable_pickup_team_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgWeekendTourneyOpts.pickup_team_name)
  return pickup_team_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgWeekendTourneyOpts::release_pickup_team_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgWeekendTourneyOpts.pickup_team_name)
  if (!has_pickup_team_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return pickup_team_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgWeekendTourneyOpts::set_allocated_pickup_team_name(::std::string* pickup_team_name) {
  if (pickup_team_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pickup_team_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pickup_team_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgWeekendTourneyOpts.pickup_team_name)
}

// optional uint64 pickup_team_logo = 8;
inline bool CMsgWeekendTourneyOpts::has_pickup_team_logo() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgWeekendTourneyOpts::clear_pickup_team_logo() {
  pickup_team_logo_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint64 CMsgWeekendTourneyOpts::pickup_team_logo() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgWeekendTourneyOpts.pickup_team_logo)
  return pickup_team_logo_;
}
inline void CMsgWeekendTourneyOpts::set_pickup_team_logo(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000080u;
  pickup_team_logo_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgWeekendTourneyOpts.pickup_team_logo)
}

// -------------------------------------------------------------------

// CMsgWeekendTourneyLeave

// -------------------------------------------------------------------

// CMsgDOTATournament_Team

// optional fixed64 team_gid = 1;
inline bool CMsgDOTATournament_Team::has_team_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTATournament_Team::clear_team_gid() {
  team_gid_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 CMsgDOTATournament_Team::team_gid() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.Team.team_gid)
  return team_gid_;
}
inline void CMsgDOTATournament_Team::set_team_gid(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  team_gid_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.Team.team_gid)
}

// optional uint32 node_or_state = 2;
inline bool CMsgDOTATournament_Team::has_node_or_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTATournament_Team::clear_node_or_state() {
  node_or_state_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTATournament_Team::node_or_state() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.Team.node_or_state)
  return node_or_state_;
}
inline void CMsgDOTATournament_Team::set_node_or_state(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  node_or_state_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.Team.node_or_state)
}

// repeated uint32 players = 3 [packed = true];
inline int CMsgDOTATournament_Team::players_size() const {
  return players_.size();
}
inline void CMsgDOTATournament_Team::clear_players() {
  players_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTATournament_Team::players(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.Team.players)
  return players_.Get(index);
}
inline void CMsgDOTATournament_Team::set_players(int index, ::google::protobuf::uint32 value) {
  players_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.Team.players)
}
inline void CMsgDOTATournament_Team::add_players(::google::protobuf::uint32 value) {
  players_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTATournament.Team.players)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTATournament_Team::players() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTATournament.Team.players)
  return players_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTATournament_Team::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTATournament.Team.players)
  return &players_;
}

// repeated uint32 player_buyin = 9 [packed = true];
inline int CMsgDOTATournament_Team::player_buyin_size() const {
  return player_buyin_.size();
}
inline void CMsgDOTATournament_Team::clear_player_buyin() {
  player_buyin_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTATournament_Team::player_buyin(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.Team.player_buyin)
  return player_buyin_.Get(index);
}
inline void CMsgDOTATournament_Team::set_player_buyin(int index, ::google::protobuf::uint32 value) {
  player_buyin_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.Team.player_buyin)
}
inline void CMsgDOTATournament_Team::add_player_buyin(::google::protobuf::uint32 value) {
  player_buyin_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTATournament.Team.player_buyin)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTATournament_Team::player_buyin() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTATournament.Team.player_buyin)
  return player_buyin_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTATournament_Team::mutable_player_buyin() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTATournament.Team.player_buyin)
  return &player_buyin_;
}

// repeated uint32 player_skill_level = 10 [packed = true];
inline int CMsgDOTATournament_Team::player_skill_level_size() const {
  return player_skill_level_.size();
}
inline void CMsgDOTATournament_Team::clear_player_skill_level() {
  player_skill_level_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTATournament_Team::player_skill_level(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.Team.player_skill_level)
  return player_skill_level_.Get(index);
}
inline void CMsgDOTATournament_Team::set_player_skill_level(int index, ::google::protobuf::uint32 value) {
  player_skill_level_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.Team.player_skill_level)
}
inline void CMsgDOTATournament_Team::add_player_skill_level(::google::protobuf::uint32 value) {
  player_skill_level_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTATournament.Team.player_skill_level)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTATournament_Team::player_skill_level() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTATournament.Team.player_skill_level)
  return player_skill_level_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTATournament_Team::mutable_player_skill_level() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTATournament.Team.player_skill_level)
  return &player_skill_level_;
}

// optional uint32 match_group_mask = 12;
inline bool CMsgDOTATournament_Team::has_match_group_mask() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTATournament_Team::clear_match_group_mask() {
  match_group_mask_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 CMsgDOTATournament_Team::match_group_mask() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.Team.match_group_mask)
  return match_group_mask_;
}
inline void CMsgDOTATournament_Team::set_match_group_mask(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  match_group_mask_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.Team.match_group_mask)
}

// optional uint32 team_id = 4;
inline bool CMsgDOTATournament_Team::has_team_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTATournament_Team::clear_team_id() {
  team_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTATournament_Team::team_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.Team.team_id)
  return team_id_;
}
inline void CMsgDOTATournament_Team::set_team_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  team_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.Team.team_id)
}

// optional string team_name = 5;
inline bool CMsgDOTATournament_Team::has_team_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTATournament_Team::clear_team_name() {
  team_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTATournament_Team::team_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.Team.team_name)
  return team_name_.GetNoArena();
}
inline void CMsgDOTATournament_Team::set_team_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.Team.team_name)
}
#if LANG_CXX11
inline void CMsgDOTATournament_Team::set_team_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTATournament.Team.team_name)
}
#endif
inline void CMsgDOTATournament_Team::set_team_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTATournament.Team.team_name)
}
inline void CMsgDOTATournament_Team::set_team_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTATournament.Team.team_name)
}
inline ::std::string* CMsgDOTATournament_Team::mutable_team_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournament.Team.team_name)
  return team_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTATournament_Team::release_team_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTATournament.Team.team_name)
  if (!has_team_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return team_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTATournament_Team::set_allocated_team_name(::std::string* team_name) {
  if (team_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  team_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTATournament.Team.team_name)
}

// optional uint64 team_base_logo = 7;
inline bool CMsgDOTATournament_Team::has_team_base_logo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTATournament_Team::clear_team_base_logo() {
  team_base_logo_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint64 CMsgDOTATournament_Team::team_base_logo() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.Team.team_base_logo)
  return team_base_logo_;
}
inline void CMsgDOTATournament_Team::set_team_base_logo(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  team_base_logo_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.Team.team_base_logo)
}

// optional uint64 team_ui_logo = 8;
inline bool CMsgDOTATournament_Team::has_team_ui_logo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTATournament_Team::clear_team_ui_logo() {
  team_ui_logo_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint64 CMsgDOTATournament_Team::team_ui_logo() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.Team.team_ui_logo)
  return team_ui_logo_;
}
inline void CMsgDOTATournament_Team::set_team_ui_logo(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  team_ui_logo_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.Team.team_ui_logo)
}

// -------------------------------------------------------------------

// CMsgDOTATournament_Game

// optional uint32 node_idx = 1;
inline bool CMsgDOTATournament_Game::has_node_idx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTATournament_Game::clear_node_idx() {
  node_idx_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTATournament_Game::node_idx() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.Game.node_idx)
  return node_idx_;
}
inline void CMsgDOTATournament_Game::set_node_idx(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  node_idx_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.Game.node_idx)
}

// optional fixed64 lobby_id = 2;
inline bool CMsgDOTATournament_Game::has_lobby_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTATournament_Game::clear_lobby_id() {
  lobby_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 CMsgDOTATournament_Game::lobby_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.Game.lobby_id)
  return lobby_id_;
}
inline void CMsgDOTATournament_Game::set_lobby_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  lobby_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.Game.lobby_id)
}

// optional uint64 match_id = 3;
inline bool CMsgDOTATournament_Game::has_match_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTATournament_Game::clear_match_id() {
  match_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 CMsgDOTATournament_Game::match_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.Game.match_id)
  return match_id_;
}
inline void CMsgDOTATournament_Game::set_match_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  match_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.Game.match_id)
}

// optional bool team_a_good = 4;
inline bool CMsgDOTATournament_Game::has_team_a_good() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTATournament_Game::clear_team_a_good() {
  team_a_good_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CMsgDOTATournament_Game::team_a_good() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.Game.team_a_good)
  return team_a_good_;
}
inline void CMsgDOTATournament_Game::set_team_a_good(bool value) {
  _has_bits_[0] |= 0x00000004u;
  team_a_good_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.Game.team_a_good)
}

// optional .proto.dota.ETournamentGameState state = 5 [default = k_ETournamentGameState_Unknown];
inline bool CMsgDOTATournament_Game::has_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTATournament_Game::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::proto::dota::ETournamentGameState CMsgDOTATournament_Game::state() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.Game.state)
  return static_cast< ::proto::dota::ETournamentGameState >(state_);
}
inline void CMsgDOTATournament_Game::set_state(::proto::dota::ETournamentGameState value) {
  assert(::proto::dota::ETournamentGameState_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  state_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.Game.state)
}

// optional uint32 start_time = 6;
inline bool CMsgDOTATournament_Game::has_start_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTATournament_Game::clear_start_time() {
  start_time_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 CMsgDOTATournament_Game::start_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.Game.start_time)
  return start_time_;
}
inline void CMsgDOTATournament_Game::set_start_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  start_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.Game.start_time)
}

// -------------------------------------------------------------------

// CMsgDOTATournament_Node

// optional uint32 node_id = 1;
inline bool CMsgDOTATournament_Node::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTATournament_Node::clear_node_id() {
  node_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTATournament_Node::node_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.Node.node_id)
  return node_id_;
}
inline void CMsgDOTATournament_Node::set_node_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  node_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.Node.node_id)
}

// optional uint32 team_idx_a = 2;
inline bool CMsgDOTATournament_Node::has_team_idx_a() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTATournament_Node::clear_team_idx_a() {
  team_idx_a_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTATournament_Node::team_idx_a() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.Node.team_idx_a)
  return team_idx_a_;
}
inline void CMsgDOTATournament_Node::set_team_idx_a(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  team_idx_a_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.Node.team_idx_a)
}

// optional uint32 team_idx_b = 3;
inline bool CMsgDOTATournament_Node::has_team_idx_b() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTATournament_Node::clear_team_idx_b() {
  team_idx_b_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTATournament_Node::team_idx_b() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.Node.team_idx_b)
  return team_idx_b_;
}
inline void CMsgDOTATournament_Node::set_team_idx_b(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  team_idx_b_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.Node.team_idx_b)
}

// optional .proto.dota.ETournamentNodeState node_state = 4 [default = k_ETournamentNodeState_Unknown];
inline bool CMsgDOTATournament_Node::has_node_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTATournament_Node::clear_node_state() {
  node_state_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::proto::dota::ETournamentNodeState CMsgDOTATournament_Node::node_state() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.Node.node_state)
  return static_cast< ::proto::dota::ETournamentNodeState >(node_state_);
}
inline void CMsgDOTATournament_Node::set_node_state(::proto::dota::ETournamentNodeState value) {
  assert(::proto::dota::ETournamentNodeState_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  node_state_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.Node.node_state)
}

// -------------------------------------------------------------------

// CMsgDOTATournament

// optional uint32 tournament_id = 1;
inline bool CMsgDOTATournament::has_tournament_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTATournament::clear_tournament_id() {
  tournament_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTATournament::tournament_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.tournament_id)
  return tournament_id_;
}
inline void CMsgDOTATournament::set_tournament_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  tournament_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.tournament_id)
}

// optional uint32 division_id = 2;
inline bool CMsgDOTATournament::has_division_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTATournament::clear_division_id() {
  division_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTATournament::division_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.division_id)
  return division_id_;
}
inline void CMsgDOTATournament::set_division_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  division_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.division_id)
}

// optional uint32 schedule_time = 3;
inline bool CMsgDOTATournament::has_schedule_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTATournament::clear_schedule_time() {
  schedule_time_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTATournament::schedule_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.schedule_time)
  return schedule_time_;
}
inline void CMsgDOTATournament::set_schedule_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  schedule_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.schedule_time)
}

// optional uint32 skill_level = 4;
inline bool CMsgDOTATournament::has_skill_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTATournament::clear_skill_level() {
  skill_level_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTATournament::skill_level() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.skill_level)
  return skill_level_;
}
inline void CMsgDOTATournament::set_skill_level(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  skill_level_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.skill_level)
}

// optional .proto.dota.ETournamentTemplate tournament_template = 5 [default = k_ETournamentTemplate_None];
inline bool CMsgDOTATournament::has_tournament_template() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTATournament::clear_tournament_template() {
  tournament_template_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::proto::dota::ETournamentTemplate CMsgDOTATournament::tournament_template() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.tournament_template)
  return static_cast< ::proto::dota::ETournamentTemplate >(tournament_template_);
}
inline void CMsgDOTATournament::set_tournament_template(::proto::dota::ETournamentTemplate value) {
  assert(::proto::dota::ETournamentTemplate_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  tournament_template_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.tournament_template)
}

// optional .proto.dota.ETournamentState state = 6 [default = k_ETournamentState_Unknown];
inline bool CMsgDOTATournament::has_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTATournament::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::proto::dota::ETournamentState CMsgDOTATournament::state() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.state)
  return static_cast< ::proto::dota::ETournamentState >(state_);
}
inline void CMsgDOTATournament::set_state(::proto::dota::ETournamentState value) {
  assert(::proto::dota::ETournamentState_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  state_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.state)
}

// optional uint32 state_seq_num = 10;
inline bool CMsgDOTATournament::has_state_seq_num() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTATournament::clear_state_seq_num() {
  state_seq_num_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 CMsgDOTATournament::state_seq_num() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.state_seq_num)
  return state_seq_num_;
}
inline void CMsgDOTATournament::set_state_seq_num(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  state_seq_num_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.state_seq_num)
}

// optional uint32 season_trophy_id = 11;
inline bool CMsgDOTATournament::has_season_trophy_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgDOTATournament::clear_season_trophy_id() {
  season_trophy_id_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 CMsgDOTATournament::season_trophy_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.season_trophy_id)
  return season_trophy_id_;
}
inline void CMsgDOTATournament::set_season_trophy_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  season_trophy_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournament.season_trophy_id)
}

// repeated .proto.dota.CMsgDOTATournament.Team teams = 7;
inline int CMsgDOTATournament::teams_size() const {
  return teams_.size();
}
inline void CMsgDOTATournament::clear_teams() {
  teams_.Clear();
}
inline ::proto::dota::CMsgDOTATournament_Team* CMsgDOTATournament::mutable_teams(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournament.teams)
  return teams_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournament_Team >*
CMsgDOTATournament::mutable_teams() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTATournament.teams)
  return &teams_;
}
inline const ::proto::dota::CMsgDOTATournament_Team& CMsgDOTATournament::teams(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.teams)
  return teams_.Get(index);
}
inline ::proto::dota::CMsgDOTATournament_Team* CMsgDOTATournament::add_teams() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTATournament.teams)
  return teams_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournament_Team >&
CMsgDOTATournament::teams() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTATournament.teams)
  return teams_;
}

// repeated .proto.dota.CMsgDOTATournament.Game games = 8;
inline int CMsgDOTATournament::games_size() const {
  return games_.size();
}
inline void CMsgDOTATournament::clear_games() {
  games_.Clear();
}
inline ::proto::dota::CMsgDOTATournament_Game* CMsgDOTATournament::mutable_games(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournament.games)
  return games_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournament_Game >*
CMsgDOTATournament::mutable_games() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTATournament.games)
  return &games_;
}
inline const ::proto::dota::CMsgDOTATournament_Game& CMsgDOTATournament::games(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.games)
  return games_.Get(index);
}
inline ::proto::dota::CMsgDOTATournament_Game* CMsgDOTATournament::add_games() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTATournament.games)
  return games_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournament_Game >&
CMsgDOTATournament::games() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTATournament.games)
  return games_;
}

// repeated .proto.dota.CMsgDOTATournament.Node nodes = 9;
inline int CMsgDOTATournament::nodes_size() const {
  return nodes_.size();
}
inline void CMsgDOTATournament::clear_nodes() {
  nodes_.Clear();
}
inline ::proto::dota::CMsgDOTATournament_Node* CMsgDOTATournament::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournament.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournament_Node >*
CMsgDOTATournament::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTATournament.nodes)
  return &nodes_;
}
inline const ::proto::dota::CMsgDOTATournament_Node& CMsgDOTATournament::nodes(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournament.nodes)
  return nodes_.Get(index);
}
inline ::proto::dota::CMsgDOTATournament_Node* CMsgDOTATournament::add_nodes() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTATournament.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournament_Node >&
CMsgDOTATournament::nodes() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTATournament.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// CMsgDOTATournamentStateChange_GameChange

// optional uint64 match_id = 1;
inline bool CMsgDOTATournamentStateChange_GameChange::has_match_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTATournamentStateChange_GameChange::clear_match_id() {
  match_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 CMsgDOTATournamentStateChange_GameChange::match_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentStateChange.GameChange.match_id)
  return match_id_;
}
inline void CMsgDOTATournamentStateChange_GameChange::set_match_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  match_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentStateChange.GameChange.match_id)
}

// optional .proto.dota.ETournamentGameState new_state = 2 [default = k_ETournamentGameState_Unknown];
inline bool CMsgDOTATournamentStateChange_GameChange::has_new_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTATournamentStateChange_GameChange::clear_new_state() {
  new_state_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::proto::dota::ETournamentGameState CMsgDOTATournamentStateChange_GameChange::new_state() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentStateChange.GameChange.new_state)
  return static_cast< ::proto::dota::ETournamentGameState >(new_state_);
}
inline void CMsgDOTATournamentStateChange_GameChange::set_new_state(::proto::dota::ETournamentGameState value) {
  assert(::proto::dota::ETournamentGameState_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  new_state_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentStateChange.GameChange.new_state)
}

// -------------------------------------------------------------------

// CMsgDOTATournamentStateChange_TeamChange

// optional uint64 team_gid = 1;
inline bool CMsgDOTATournamentStateChange_TeamChange::has_team_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTATournamentStateChange_TeamChange::clear_team_gid() {
  team_gid_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 CMsgDOTATournamentStateChange_TeamChange::team_gid() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentStateChange.TeamChange.team_gid)
  return team_gid_;
}
inline void CMsgDOTATournamentStateChange_TeamChange::set_team_gid(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  team_gid_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentStateChange.TeamChange.team_gid)
}

// optional uint32 new_node_or_state = 2;
inline bool CMsgDOTATournamentStateChange_TeamChange::has_new_node_or_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTATournamentStateChange_TeamChange::clear_new_node_or_state() {
  new_node_or_state_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentStateChange_TeamChange::new_node_or_state() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentStateChange.TeamChange.new_node_or_state)
  return new_node_or_state_;
}
inline void CMsgDOTATournamentStateChange_TeamChange::set_new_node_or_state(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  new_node_or_state_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentStateChange.TeamChange.new_node_or_state)
}

// optional uint32 old_node_or_state = 3;
inline bool CMsgDOTATournamentStateChange_TeamChange::has_old_node_or_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTATournamentStateChange_TeamChange::clear_old_node_or_state() {
  old_node_or_state_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentStateChange_TeamChange::old_node_or_state() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentStateChange.TeamChange.old_node_or_state)
  return old_node_or_state_;
}
inline void CMsgDOTATournamentStateChange_TeamChange::set_old_node_or_state(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  old_node_or_state_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentStateChange.TeamChange.old_node_or_state)
}

// -------------------------------------------------------------------

// CMsgDOTATournamentStateChange

// optional uint32 new_tournament_id = 1;
inline bool CMsgDOTATournamentStateChange::has_new_tournament_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTATournamentStateChange::clear_new_tournament_id() {
  new_tournament_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentStateChange::new_tournament_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentStateChange.new_tournament_id)
  return new_tournament_id_;
}
inline void CMsgDOTATournamentStateChange::set_new_tournament_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  new_tournament_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentStateChange.new_tournament_id)
}

// optional .proto.dota.ETournamentEvent event = 2 [default = k_ETournamentEvent_None];
inline bool CMsgDOTATournamentStateChange::has_event() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTATournamentStateChange::clear_event() {
  event_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::proto::dota::ETournamentEvent CMsgDOTATournamentStateChange::event() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentStateChange.event)
  return static_cast< ::proto::dota::ETournamentEvent >(event_);
}
inline void CMsgDOTATournamentStateChange::set_event(::proto::dota::ETournamentEvent value) {
  assert(::proto::dota::ETournamentEvent_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  event_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentStateChange.event)
}

// optional .proto.dota.ETournamentState new_tournament_state = 3 [default = k_ETournamentState_Unknown];
inline bool CMsgDOTATournamentStateChange::has_new_tournament_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTATournamentStateChange::clear_new_tournament_state() {
  new_tournament_state_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::proto::dota::ETournamentState CMsgDOTATournamentStateChange::new_tournament_state() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentStateChange.new_tournament_state)
  return static_cast< ::proto::dota::ETournamentState >(new_tournament_state_);
}
inline void CMsgDOTATournamentStateChange::set_new_tournament_state(::proto::dota::ETournamentState value) {
  assert(::proto::dota::ETournamentState_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  new_tournament_state_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentStateChange.new_tournament_state)
}

// repeated .proto.dota.CMsgDOTATournamentStateChange.GameChange game_changes = 4;
inline int CMsgDOTATournamentStateChange::game_changes_size() const {
  return game_changes_.size();
}
inline void CMsgDOTATournamentStateChange::clear_game_changes() {
  game_changes_.Clear();
}
inline ::proto::dota::CMsgDOTATournamentStateChange_GameChange* CMsgDOTATournamentStateChange::mutable_game_changes(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournamentStateChange.game_changes)
  return game_changes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentStateChange_GameChange >*
CMsgDOTATournamentStateChange::mutable_game_changes() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTATournamentStateChange.game_changes)
  return &game_changes_;
}
inline const ::proto::dota::CMsgDOTATournamentStateChange_GameChange& CMsgDOTATournamentStateChange::game_changes(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentStateChange.game_changes)
  return game_changes_.Get(index);
}
inline ::proto::dota::CMsgDOTATournamentStateChange_GameChange* CMsgDOTATournamentStateChange::add_game_changes() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTATournamentStateChange.game_changes)
  return game_changes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentStateChange_GameChange >&
CMsgDOTATournamentStateChange::game_changes() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTATournamentStateChange.game_changes)
  return game_changes_;
}

// repeated .proto.dota.CMsgDOTATournamentStateChange.TeamChange team_changes = 5;
inline int CMsgDOTATournamentStateChange::team_changes_size() const {
  return team_changes_.size();
}
inline void CMsgDOTATournamentStateChange::clear_team_changes() {
  team_changes_.Clear();
}
inline ::proto::dota::CMsgDOTATournamentStateChange_TeamChange* CMsgDOTATournamentStateChange::mutable_team_changes(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournamentStateChange.team_changes)
  return team_changes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentStateChange_TeamChange >*
CMsgDOTATournamentStateChange::mutable_team_changes() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTATournamentStateChange.team_changes)
  return &team_changes_;
}
inline const ::proto::dota::CMsgDOTATournamentStateChange_TeamChange& CMsgDOTATournamentStateChange::team_changes(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentStateChange.team_changes)
  return team_changes_.Get(index);
}
inline ::proto::dota::CMsgDOTATournamentStateChange_TeamChange* CMsgDOTATournamentStateChange::add_team_changes() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTATournamentStateChange.team_changes)
  return team_changes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTATournamentStateChange_TeamChange >&
CMsgDOTATournamentStateChange::team_changes() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTATournamentStateChange.team_changes)
  return team_changes_;
}

// repeated uint32 merged_tournament_ids = 6 [packed = true];
inline int CMsgDOTATournamentStateChange::merged_tournament_ids_size() const {
  return merged_tournament_ids_.size();
}
inline void CMsgDOTATournamentStateChange::clear_merged_tournament_ids() {
  merged_tournament_ids_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTATournamentStateChange::merged_tournament_ids(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentStateChange.merged_tournament_ids)
  return merged_tournament_ids_.Get(index);
}
inline void CMsgDOTATournamentStateChange::set_merged_tournament_ids(int index, ::google::protobuf::uint32 value) {
  merged_tournament_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentStateChange.merged_tournament_ids)
}
inline void CMsgDOTATournamentStateChange::add_merged_tournament_ids(::google::protobuf::uint32 value) {
  merged_tournament_ids_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTATournamentStateChange.merged_tournament_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTATournamentStateChange::merged_tournament_ids() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTATournamentStateChange.merged_tournament_ids)
  return merged_tournament_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTATournamentStateChange::mutable_merged_tournament_ids() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTATournamentStateChange.merged_tournament_ids)
  return &merged_tournament_ids_;
}

// optional uint32 state_seq_num = 7;
inline bool CMsgDOTATournamentStateChange::has_state_seq_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTATournamentStateChange::clear_state_seq_num() {
  state_seq_num_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentStateChange::state_seq_num() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentStateChange.state_seq_num)
  return state_seq_num_;
}
inline void CMsgDOTATournamentStateChange::set_state_seq_num(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  state_seq_num_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentStateChange.state_seq_num)
}

// -------------------------------------------------------------------

// CMsgDOTATournamentRequest

// optional uint32 tournament_id = 1;
inline bool CMsgDOTATournamentRequest::has_tournament_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTATournamentRequest::clear_tournament_id() {
  tournament_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentRequest::tournament_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentRequest.tournament_id)
  return tournament_id_;
}
inline void CMsgDOTATournamentRequest::set_tournament_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  tournament_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentRequest.tournament_id)
}

// optional uint64 client_tournament_gid = 2;
inline bool CMsgDOTATournamentRequest::has_client_tournament_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTATournamentRequest::clear_client_tournament_gid() {
  client_tournament_gid_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 CMsgDOTATournamentRequest::client_tournament_gid() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentRequest.client_tournament_gid)
  return client_tournament_gid_;
}
inline void CMsgDOTATournamentRequest::set_client_tournament_gid(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  client_tournament_gid_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentRequest.client_tournament_gid)
}

// -------------------------------------------------------------------

// CMsgDOTATournamentResponse

// optional uint32 result = 1 [default = 2];
inline bool CMsgDOTATournamentResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTATournamentResponse::clear_result() {
  result_ = 2u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTATournamentResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentResponse.result)
  return result_;
}
inline void CMsgDOTATournamentResponse::set_result(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTATournamentResponse.result)
}

// optional .proto.dota.CMsgDOTATournament tournament = 2;
inline bool CMsgDOTATournamentResponse::has_tournament() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTATournamentResponse::clear_tournament() {
  if (tournament_ != nullptr) tournament_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::dota::CMsgDOTATournament& CMsgDOTATournamentResponse::tournament() const {
  const ::proto::dota::CMsgDOTATournament* p = tournament_;
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTATournamentResponse.tournament)
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::dota::CMsgDOTATournament*>(
      &::proto::dota::_CMsgDOTATournament_default_instance_);
}
inline ::proto::dota::CMsgDOTATournament* CMsgDOTATournamentResponse::release_tournament() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTATournamentResponse.tournament)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::dota::CMsgDOTATournament* temp = tournament_;
  tournament_ = nullptr;
  return temp;
}
inline ::proto::dota::CMsgDOTATournament* CMsgDOTATournamentResponse::mutable_tournament() {
  _has_bits_[0] |= 0x00000001u;
  if (tournament_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::dota::CMsgDOTATournament>(GetArenaNoVirtual());
    tournament_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTATournamentResponse.tournament)
  return tournament_;
}
inline void CMsgDOTATournamentResponse::set_allocated_tournament(::proto::dota::CMsgDOTATournament* tournament) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete tournament_;
  }
  if (tournament) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tournament = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tournament, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tournament_ = tournament;
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTATournamentResponse.tournament)
}

// -------------------------------------------------------------------

// CMsgDOTAClearTournamentGame

// optional uint32 tournament_id = 1;
inline bool CMsgDOTAClearTournamentGame::has_tournament_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAClearTournamentGame::clear_tournament_id() {
  tournament_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAClearTournamentGame::tournament_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAClearTournamentGame.tournament_id)
  return tournament_id_;
}
inline void CMsgDOTAClearTournamentGame::set_tournament_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  tournament_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAClearTournamentGame.tournament_id)
}

// optional uint32 game_id = 2;
inline bool CMsgDOTAClearTournamentGame::has_game_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAClearTournamentGame::clear_game_id() {
  game_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAClearTournamentGame::game_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAClearTournamentGame.game_id)
  return game_id_;
}
inline void CMsgDOTAClearTournamentGame::set_game_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  game_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAClearTournamentGame.game_id)
}

// -------------------------------------------------------------------

// CMsgDOTAWeekendTourneyPlayerSkillLevelStats

// optional uint32 skill_level = 1;
inline bool CMsgDOTAWeekendTourneyPlayerSkillLevelStats::has_skill_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::clear_skill_level() {
  skill_level_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerSkillLevelStats::skill_level() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerSkillLevelStats.skill_level)
  return skill_level_;
}
inline void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::set_skill_level(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  skill_level_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerSkillLevelStats.skill_level)
}

// optional uint32 times_won_0 = 2;
inline bool CMsgDOTAWeekendTourneyPlayerSkillLevelStats::has_times_won_0() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::clear_times_won_0() {
  times_won_0_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerSkillLevelStats::times_won_0() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerSkillLevelStats.times_won_0)
  return times_won_0_;
}
inline void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::set_times_won_0(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  times_won_0_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerSkillLevelStats.times_won_0)
}

// optional uint32 times_won_1 = 3;
inline bool CMsgDOTAWeekendTourneyPlayerSkillLevelStats::has_times_won_1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::clear_times_won_1() {
  times_won_1_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerSkillLevelStats::times_won_1() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerSkillLevelStats.times_won_1)
  return times_won_1_;
}
inline void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::set_times_won_1(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  times_won_1_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerSkillLevelStats.times_won_1)
}

// optional uint32 times_won_2 = 4;
inline bool CMsgDOTAWeekendTourneyPlayerSkillLevelStats::has_times_won_2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::clear_times_won_2() {
  times_won_2_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerSkillLevelStats::times_won_2() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerSkillLevelStats.times_won_2)
  return times_won_2_;
}
inline void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::set_times_won_2(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  times_won_2_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerSkillLevelStats.times_won_2)
}

// optional uint32 times_won_3 = 5;
inline bool CMsgDOTAWeekendTourneyPlayerSkillLevelStats::has_times_won_3() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::clear_times_won_3() {
  times_won_3_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerSkillLevelStats::times_won_3() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerSkillLevelStats.times_won_3)
  return times_won_3_;
}
inline void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::set_times_won_3(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  times_won_3_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerSkillLevelStats.times_won_3)
}

// optional uint32 times_bye_and_lost = 6;
inline bool CMsgDOTAWeekendTourneyPlayerSkillLevelStats::has_times_bye_and_lost() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::clear_times_bye_and_lost() {
  times_bye_and_lost_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerSkillLevelStats::times_bye_and_lost() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerSkillLevelStats.times_bye_and_lost)
  return times_bye_and_lost_;
}
inline void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::set_times_bye_and_lost(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  times_bye_and_lost_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerSkillLevelStats.times_bye_and_lost)
}

// optional uint32 times_bye_and_won = 7;
inline bool CMsgDOTAWeekendTourneyPlayerSkillLevelStats::has_times_bye_and_won() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::clear_times_bye_and_won() {
  times_bye_and_won_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerSkillLevelStats::times_bye_and_won() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerSkillLevelStats.times_bye_and_won)
  return times_bye_and_won_;
}
inline void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::set_times_bye_and_won(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  times_bye_and_won_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerSkillLevelStats.times_bye_and_won)
}

// optional uint32 times_unusual_champ = 10;
inline bool CMsgDOTAWeekendTourneyPlayerSkillLevelStats::has_times_unusual_champ() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::clear_times_unusual_champ() {
  times_unusual_champ_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerSkillLevelStats::times_unusual_champ() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerSkillLevelStats.times_unusual_champ)
  return times_unusual_champ_;
}
inline void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::set_times_unusual_champ(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  times_unusual_champ_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerSkillLevelStats.times_unusual_champ)
}

// optional uint32 total_games_won = 8;
inline bool CMsgDOTAWeekendTourneyPlayerSkillLevelStats::has_total_games_won() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::clear_total_games_won() {
  total_games_won_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerSkillLevelStats::total_games_won() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerSkillLevelStats.total_games_won)
  return total_games_won_;
}
inline void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::set_total_games_won(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  total_games_won_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerSkillLevelStats.total_games_won)
}

// optional uint32 score = 9;
inline bool CMsgDOTAWeekendTourneyPlayerSkillLevelStats::has_score() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::clear_score() {
  score_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerSkillLevelStats::score() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerSkillLevelStats.score)
  return score_;
}
inline void CMsgDOTAWeekendTourneyPlayerSkillLevelStats::set_score(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  score_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerSkillLevelStats.score)
}

// -------------------------------------------------------------------

// CMsgDOTAWeekendTourneyPlayerStats

// optional uint32 account_id = 1;
inline bool CMsgDOTAWeekendTourneyPlayerStats::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerStats::clear_account_id() {
  account_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerStats::account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerStats.account_id)
  return account_id_;
}
inline void CMsgDOTAWeekendTourneyPlayerStats::set_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerStats.account_id)
}

// optional uint32 season_trophy_id = 2;
inline bool CMsgDOTAWeekendTourneyPlayerStats::has_season_trophy_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerStats::clear_season_trophy_id() {
  season_trophy_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerStats::season_trophy_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerStats.season_trophy_id)
  return season_trophy_id_;
}
inline void CMsgDOTAWeekendTourneyPlayerStats::set_season_trophy_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  season_trophy_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerStats.season_trophy_id)
}

// repeated .proto.dota.CMsgDOTAWeekendTourneyPlayerSkillLevelStats skill_levels = 3;
inline int CMsgDOTAWeekendTourneyPlayerStats::skill_levels_size() const {
  return skill_levels_.size();
}
inline void CMsgDOTAWeekendTourneyPlayerStats::clear_skill_levels() {
  skill_levels_.Clear();
}
inline ::proto::dota::CMsgDOTAWeekendTourneyPlayerSkillLevelStats* CMsgDOTAWeekendTourneyPlayerStats::mutable_skill_levels(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAWeekendTourneyPlayerStats.skill_levels)
  return skill_levels_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAWeekendTourneyPlayerSkillLevelStats >*
CMsgDOTAWeekendTourneyPlayerStats::mutable_skill_levels() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAWeekendTourneyPlayerStats.skill_levels)
  return &skill_levels_;
}
inline const ::proto::dota::CMsgDOTAWeekendTourneyPlayerSkillLevelStats& CMsgDOTAWeekendTourneyPlayerStats::skill_levels(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerStats.skill_levels)
  return skill_levels_.Get(index);
}
inline ::proto::dota::CMsgDOTAWeekendTourneyPlayerSkillLevelStats* CMsgDOTAWeekendTourneyPlayerStats::add_skill_levels() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAWeekendTourneyPlayerStats.skill_levels)
  return skill_levels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAWeekendTourneyPlayerSkillLevelStats >&
CMsgDOTAWeekendTourneyPlayerStats::skill_levels() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAWeekendTourneyPlayerStats.skill_levels)
  return skill_levels_;
}

// optional uint32 current_tier = 4;
inline bool CMsgDOTAWeekendTourneyPlayerStats::has_current_tier() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerStats::clear_current_tier() {
  current_tier_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerStats::current_tier() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerStats.current_tier)
  return current_tier_;
}
inline void CMsgDOTAWeekendTourneyPlayerStats::set_current_tier(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  current_tier_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerStats.current_tier)
}

// -------------------------------------------------------------------

// CMsgDOTAWeekendTourneyPlayerStatsRequest

// optional uint32 account_id = 1;
inline bool CMsgDOTAWeekendTourneyPlayerStatsRequest::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerStatsRequest::clear_account_id() {
  account_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerStatsRequest::account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerStatsRequest.account_id)
  return account_id_;
}
inline void CMsgDOTAWeekendTourneyPlayerStatsRequest::set_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerStatsRequest.account_id)
}

// optional uint32 season_trophy_id = 2;
inline bool CMsgDOTAWeekendTourneyPlayerStatsRequest::has_season_trophy_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerStatsRequest::clear_season_trophy_id() {
  season_trophy_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerStatsRequest::season_trophy_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerStatsRequest.season_trophy_id)
  return season_trophy_id_;
}
inline void CMsgDOTAWeekendTourneyPlayerStatsRequest::set_season_trophy_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  season_trophy_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerStatsRequest.season_trophy_id)
}

// -------------------------------------------------------------------

// CMsgDOTAWeekendTourneyPlayerHistoryRequest

// optional uint32 account_id = 1;
inline bool CMsgDOTAWeekendTourneyPlayerHistoryRequest::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerHistoryRequest::clear_account_id() {
  account_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerHistoryRequest::account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerHistoryRequest.account_id)
  return account_id_;
}
inline void CMsgDOTAWeekendTourneyPlayerHistoryRequest::set_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerHistoryRequest.account_id)
}

// optional uint32 season_trophy_id = 2;
inline bool CMsgDOTAWeekendTourneyPlayerHistoryRequest::has_season_trophy_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerHistoryRequest::clear_season_trophy_id() {
  season_trophy_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerHistoryRequest::season_trophy_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerHistoryRequest.season_trophy_id)
  return season_trophy_id_;
}
inline void CMsgDOTAWeekendTourneyPlayerHistoryRequest::set_season_trophy_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  season_trophy_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerHistoryRequest.season_trophy_id)
}

// -------------------------------------------------------------------

// CMsgDOTAWeekendTourneyPlayerHistory_Tournament

// optional uint32 tournament_id = 1;
inline bool CMsgDOTAWeekendTourneyPlayerHistory_Tournament::has_tournament_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::clear_tournament_id() {
  tournament_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerHistory_Tournament::tournament_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.tournament_id)
  return tournament_id_;
}
inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::set_tournament_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  tournament_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.tournament_id)
}

// optional uint32 start_time = 2;
inline bool CMsgDOTAWeekendTourneyPlayerHistory_Tournament::has_start_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::clear_start_time() {
  start_time_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerHistory_Tournament::start_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.start_time)
  return start_time_;
}
inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::set_start_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  start_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.start_time)
}

// optional uint32 tournament_tier = 3;
inline bool CMsgDOTAWeekendTourneyPlayerHistory_Tournament::has_tournament_tier() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::clear_tournament_tier() {
  tournament_tier_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerHistory_Tournament::tournament_tier() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.tournament_tier)
  return tournament_tier_;
}
inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::set_tournament_tier(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  tournament_tier_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.tournament_tier)
}

// optional uint32 team_id = 4;
inline bool CMsgDOTAWeekendTourneyPlayerHistory_Tournament::has_team_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::clear_team_id() {
  team_id_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerHistory_Tournament::team_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.team_id)
  return team_id_;
}
inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::set_team_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  team_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.team_id)
}

// optional uint32 team_date = 5;
inline bool CMsgDOTAWeekendTourneyPlayerHistory_Tournament::has_team_date() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::clear_team_date() {
  team_date_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerHistory_Tournament::team_date() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.team_date)
  return team_date_;
}
inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::set_team_date(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  team_date_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.team_date)
}

// optional uint32 team_result = 6;
inline bool CMsgDOTAWeekendTourneyPlayerHistory_Tournament::has_team_result() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::clear_team_result() {
  team_result_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerHistory_Tournament::team_result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.team_result)
  return team_result_;
}
inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::set_team_result(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  team_result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.team_result)
}

// repeated uint32 account_id = 7;
inline int CMsgDOTAWeekendTourneyPlayerHistory_Tournament::account_id_size() const {
  return account_id_.size();
}
inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::clear_account_id() {
  account_id_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerHistory_Tournament::account_id(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.account_id)
  return account_id_.Get(index);
}
inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::set_account_id(int index, ::google::protobuf::uint32 value) {
  account_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.account_id)
}
inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::add_account_id(::google::protobuf::uint32 value) {
  account_id_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.account_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTAWeekendTourneyPlayerHistory_Tournament::account_id() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.account_id)
  return account_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTAWeekendTourneyPlayerHistory_Tournament::mutable_account_id() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.account_id)
  return &account_id_;
}

// optional string team_name = 8;
inline bool CMsgDOTAWeekendTourneyPlayerHistory_Tournament::has_team_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::clear_team_name() {
  team_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTAWeekendTourneyPlayerHistory_Tournament::team_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.team_name)
  return team_name_.GetNoArena();
}
inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::set_team_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.team_name)
}
#if LANG_CXX11
inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::set_team_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.team_name)
}
#endif
inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::set_team_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.team_name)
}
inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::set_team_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.team_name)
}
inline ::std::string* CMsgDOTAWeekendTourneyPlayerHistory_Tournament::mutable_team_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.team_name)
  return team_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAWeekendTourneyPlayerHistory_Tournament::release_team_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.team_name)
  if (!has_team_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return team_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::set_allocated_team_name(::std::string* team_name) {
  if (team_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  team_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.team_name)
}

// optional uint32 season_trophy_id = 9;
inline bool CMsgDOTAWeekendTourneyPlayerHistory_Tournament::has_season_trophy_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::clear_season_trophy_id() {
  season_trophy_id_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerHistory_Tournament::season_trophy_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.season_trophy_id)
  return season_trophy_id_;
}
inline void CMsgDOTAWeekendTourneyPlayerHistory_Tournament::set_season_trophy_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  season_trophy_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament.season_trophy_id)
}

// -------------------------------------------------------------------

// CMsgDOTAWeekendTourneyPlayerHistory

// optional uint32 account_id = 1;
inline bool CMsgDOTAWeekendTourneyPlayerHistory::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAWeekendTourneyPlayerHistory::clear_account_id() {
  account_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyPlayerHistory::account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.account_id)
  return account_id_;
}
inline void CMsgDOTAWeekendTourneyPlayerHistory::set_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.account_id)
}

// repeated .proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.Tournament tournaments = 3;
inline int CMsgDOTAWeekendTourneyPlayerHistory::tournaments_size() const {
  return tournaments_.size();
}
inline void CMsgDOTAWeekendTourneyPlayerHistory::clear_tournaments() {
  tournaments_.Clear();
}
inline ::proto::dota::CMsgDOTAWeekendTourneyPlayerHistory_Tournament* CMsgDOTAWeekendTourneyPlayerHistory::mutable_tournaments(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.tournaments)
  return tournaments_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAWeekendTourneyPlayerHistory_Tournament >*
CMsgDOTAWeekendTourneyPlayerHistory::mutable_tournaments() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.tournaments)
  return &tournaments_;
}
inline const ::proto::dota::CMsgDOTAWeekendTourneyPlayerHistory_Tournament& CMsgDOTAWeekendTourneyPlayerHistory::tournaments(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.tournaments)
  return tournaments_.Get(index);
}
inline ::proto::dota::CMsgDOTAWeekendTourneyPlayerHistory_Tournament* CMsgDOTAWeekendTourneyPlayerHistory::add_tournaments() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.tournaments)
  return tournaments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAWeekendTourneyPlayerHistory_Tournament >&
CMsgDOTAWeekendTourneyPlayerHistory::tournaments() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAWeekendTourneyPlayerHistory.tournaments)
  return tournaments_;
}

// -------------------------------------------------------------------

// CMsgDOTAWeekendTourneyParticipationDetails_Tier

// optional uint32 tier = 1;
inline bool CMsgDOTAWeekendTourneyParticipationDetails_Tier::has_tier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAWeekendTourneyParticipationDetails_Tier::clear_tier() {
  tier_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyParticipationDetails_Tier::tier() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Tier.tier)
  return tier_;
}
inline void CMsgDOTAWeekendTourneyParticipationDetails_Tier::set_tier(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  tier_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Tier.tier)
}

// optional uint32 players = 2;
inline bool CMsgDOTAWeekendTourneyParticipationDetails_Tier::has_players() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAWeekendTourneyParticipationDetails_Tier::clear_players() {
  players_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyParticipationDetails_Tier::players() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Tier.players)
  return players_;
}
inline void CMsgDOTAWeekendTourneyParticipationDetails_Tier::set_players(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  players_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Tier.players)
}

// optional uint32 teams = 3;
inline bool CMsgDOTAWeekendTourneyParticipationDetails_Tier::has_teams() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAWeekendTourneyParticipationDetails_Tier::clear_teams() {
  teams_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyParticipationDetails_Tier::teams() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Tier.teams)
  return teams_;
}
inline void CMsgDOTAWeekendTourneyParticipationDetails_Tier::set_teams(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  teams_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Tier.teams)
}

// optional uint32 winning_teams = 4;
inline bool CMsgDOTAWeekendTourneyParticipationDetails_Tier::has_winning_teams() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAWeekendTourneyParticipationDetails_Tier::clear_winning_teams() {
  winning_teams_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyParticipationDetails_Tier::winning_teams() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Tier.winning_teams)
  return winning_teams_;
}
inline void CMsgDOTAWeekendTourneyParticipationDetails_Tier::set_winning_teams(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  winning_teams_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Tier.winning_teams)
}

// optional uint32 players_streak_2 = 5;
inline bool CMsgDOTAWeekendTourneyParticipationDetails_Tier::has_players_streak_2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAWeekendTourneyParticipationDetails_Tier::clear_players_streak_2() {
  players_streak_2_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyParticipationDetails_Tier::players_streak_2() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Tier.players_streak_2)
  return players_streak_2_;
}
inline void CMsgDOTAWeekendTourneyParticipationDetails_Tier::set_players_streak_2(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  players_streak_2_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Tier.players_streak_2)
}

// optional uint32 players_streak_3 = 6;
inline bool CMsgDOTAWeekendTourneyParticipationDetails_Tier::has_players_streak_3() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAWeekendTourneyParticipationDetails_Tier::clear_players_streak_3() {
  players_streak_3_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyParticipationDetails_Tier::players_streak_3() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Tier.players_streak_3)
  return players_streak_3_;
}
inline void CMsgDOTAWeekendTourneyParticipationDetails_Tier::set_players_streak_3(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  players_streak_3_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Tier.players_streak_3)
}

// optional uint32 players_streak_4 = 7;
inline bool CMsgDOTAWeekendTourneyParticipationDetails_Tier::has_players_streak_4() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTAWeekendTourneyParticipationDetails_Tier::clear_players_streak_4() {
  players_streak_4_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyParticipationDetails_Tier::players_streak_4() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Tier.players_streak_4)
  return players_streak_4_;
}
inline void CMsgDOTAWeekendTourneyParticipationDetails_Tier::set_players_streak_4(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  players_streak_4_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Tier.players_streak_4)
}

// optional uint32 players_streak_5 = 8;
inline bool CMsgDOTAWeekendTourneyParticipationDetails_Tier::has_players_streak_5() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgDOTAWeekendTourneyParticipationDetails_Tier::clear_players_streak_5() {
  players_streak_5_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyParticipationDetails_Tier::players_streak_5() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Tier.players_streak_5)
  return players_streak_5_;
}
inline void CMsgDOTAWeekendTourneyParticipationDetails_Tier::set_players_streak_5(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  players_streak_5_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Tier.players_streak_5)
}

// -------------------------------------------------------------------

// CMsgDOTAWeekendTourneyParticipationDetails_Division

// optional uint32 division_id = 1;
inline bool CMsgDOTAWeekendTourneyParticipationDetails_Division::has_division_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAWeekendTourneyParticipationDetails_Division::clear_division_id() {
  division_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyParticipationDetails_Division::division_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Division.division_id)
  return division_id_;
}
inline void CMsgDOTAWeekendTourneyParticipationDetails_Division::set_division_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  division_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Division.division_id)
}

// optional uint32 schedule_time = 2;
inline bool CMsgDOTAWeekendTourneyParticipationDetails_Division::has_schedule_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAWeekendTourneyParticipationDetails_Division::clear_schedule_time() {
  schedule_time_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAWeekendTourneyParticipationDetails_Division::schedule_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Division.schedule_time)
  return schedule_time_;
}
inline void CMsgDOTAWeekendTourneyParticipationDetails_Division::set_schedule_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  schedule_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Division.schedule_time)
}

// repeated .proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Tier tiers = 3;
inline int CMsgDOTAWeekendTourneyParticipationDetails_Division::tiers_size() const {
  return tiers_.size();
}
inline void CMsgDOTAWeekendTourneyParticipationDetails_Division::clear_tiers() {
  tiers_.Clear();
}
inline ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Tier* CMsgDOTAWeekendTourneyParticipationDetails_Division::mutable_tiers(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Division.tiers)
  return tiers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Tier >*
CMsgDOTAWeekendTourneyParticipationDetails_Division::mutable_tiers() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Division.tiers)
  return &tiers_;
}
inline const ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Tier& CMsgDOTAWeekendTourneyParticipationDetails_Division::tiers(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Division.tiers)
  return tiers_.Get(index);
}
inline ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Tier* CMsgDOTAWeekendTourneyParticipationDetails_Division::add_tiers() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Division.tiers)
  return tiers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Tier >&
CMsgDOTAWeekendTourneyParticipationDetails_Division::tiers() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Division.tiers)
  return tiers_;
}

// -------------------------------------------------------------------

// CMsgDOTAWeekendTourneyParticipationDetails

// repeated .proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.Division divisions = 1;
inline int CMsgDOTAWeekendTourneyParticipationDetails::divisions_size() const {
  return divisions_.size();
}
inline void CMsgDOTAWeekendTourneyParticipationDetails::clear_divisions() {
  divisions_.Clear();
}
inline ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Division* CMsgDOTAWeekendTourneyParticipationDetails::mutable_divisions(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.divisions)
  return divisions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Division >*
CMsgDOTAWeekendTourneyParticipationDetails::mutable_divisions() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.divisions)
  return &divisions_;
}
inline const ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Division& CMsgDOTAWeekendTourneyParticipationDetails::divisions(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.divisions)
  return divisions_.Get(index);
}
inline ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Division* CMsgDOTAWeekendTourneyParticipationDetails::add_divisions() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.divisions)
  return divisions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAWeekendTourneyParticipationDetails_Division >&
CMsgDOTAWeekendTourneyParticipationDetails::divisions() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAWeekendTourneyParticipationDetails.divisions)
  return divisions_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace dota
}  // namespace proto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::proto::dota::ETournamentEvent> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::ETournamentEvent>() {
  return ::proto::dota::ETournamentEvent_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_dota_5fgcmessages_5fclient_5ftournament_2eproto
