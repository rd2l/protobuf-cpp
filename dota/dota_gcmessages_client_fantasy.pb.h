// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dota_gcmessages_client_fantasy.proto

#ifndef PROTOBUF_INCLUDED_dota_5fgcmessages_5fclient_5ffantasy_2eproto
#define PROTOBUF_INCLUDED_dota_5fgcmessages_5fclient_5ffantasy_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "dota_shared_enums.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_dota_5fgcmessages_5fclient_5ffantasy_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[92]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_dota_5fgcmessages_5fclient_5ffantasy_2eproto();
namespace proto {
namespace dota {
class CMsgClientToGCGetPlayerCardRosterRequest;
class CMsgClientToGCGetPlayerCardRosterRequestDefaultTypeInternal;
extern CMsgClientToGCGetPlayerCardRosterRequestDefaultTypeInternal _CMsgClientToGCGetPlayerCardRosterRequest_default_instance_;
class CMsgClientToGCGetPlayerCardRosterResponse;
class CMsgClientToGCGetPlayerCardRosterResponseDefaultTypeInternal;
extern CMsgClientToGCGetPlayerCardRosterResponseDefaultTypeInternal _CMsgClientToGCGetPlayerCardRosterResponse_default_instance_;
class CMsgClientToGCSetPlayerCardRosterRequest;
class CMsgClientToGCSetPlayerCardRosterRequestDefaultTypeInternal;
extern CMsgClientToGCSetPlayerCardRosterRequestDefaultTypeInternal _CMsgClientToGCSetPlayerCardRosterRequest_default_instance_;
class CMsgClientToGCSetPlayerCardRosterResponse;
class CMsgClientToGCSetPlayerCardRosterResponseDefaultTypeInternal;
extern CMsgClientToGCSetPlayerCardRosterResponseDefaultTypeInternal _CMsgClientToGCSetPlayerCardRosterResponse_default_instance_;
class CMsgDOTACreateFantasyLeagueRequest;
class CMsgDOTACreateFantasyLeagueRequestDefaultTypeInternal;
extern CMsgDOTACreateFantasyLeagueRequestDefaultTypeInternal _CMsgDOTACreateFantasyLeagueRequest_default_instance_;
class CMsgDOTACreateFantasyLeagueResponse;
class CMsgDOTACreateFantasyLeagueResponseDefaultTypeInternal;
extern CMsgDOTACreateFantasyLeagueResponseDefaultTypeInternal _CMsgDOTACreateFantasyLeagueResponse_default_instance_;
class CMsgDOTADPCProfileInfo;
class CMsgDOTADPCProfileInfoDefaultTypeInternal;
extern CMsgDOTADPCProfileInfoDefaultTypeInternal _CMsgDOTADPCProfileInfo_default_instance_;
class CMsgDOTADPCProfileInfo_FantasyInfo;
class CMsgDOTADPCProfileInfo_FantasyInfoDefaultTypeInternal;
extern CMsgDOTADPCProfileInfo_FantasyInfoDefaultTypeInternal _CMsgDOTADPCProfileInfo_FantasyInfo_default_instance_;
class CMsgDOTADPCProfileInfo_PredictionInfo;
class CMsgDOTADPCProfileInfo_PredictionInfoDefaultTypeInternal;
extern CMsgDOTADPCProfileInfo_PredictionInfoDefaultTypeInternal _CMsgDOTADPCProfileInfo_PredictionInfo_default_instance_;
class CMsgDOTAEditFantasyTeamRequest;
class CMsgDOTAEditFantasyTeamRequestDefaultTypeInternal;
extern CMsgDOTAEditFantasyTeamRequestDefaultTypeInternal _CMsgDOTAEditFantasyTeamRequest_default_instance_;
class CMsgDOTAEditFantasyTeamResponse;
class CMsgDOTAEditFantasyTeamResponseDefaultTypeInternal;
extern CMsgDOTAEditFantasyTeamResponseDefaultTypeInternal _CMsgDOTAEditFantasyTeamResponse_default_instance_;
class CMsgDOTAFantasyDPCLeagueStatus;
class CMsgDOTAFantasyDPCLeagueStatusDefaultTypeInternal;
extern CMsgDOTAFantasyDPCLeagueStatusDefaultTypeInternal _CMsgDOTAFantasyDPCLeagueStatus_default_instance_;
class CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo;
class CMsgDOTAFantasyDPCLeagueStatus_LeagueInfoDefaultTypeInternal;
extern CMsgDOTAFantasyDPCLeagueStatus_LeagueInfoDefaultTypeInternal _CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo_default_instance_;
class CMsgDOTAFantasyLeagueCreateRequest;
class CMsgDOTAFantasyLeagueCreateRequestDefaultTypeInternal;
extern CMsgDOTAFantasyLeagueCreateRequestDefaultTypeInternal _CMsgDOTAFantasyLeagueCreateRequest_default_instance_;
class CMsgDOTAFantasyLeagueCreateResponse;
class CMsgDOTAFantasyLeagueCreateResponseDefaultTypeInternal;
extern CMsgDOTAFantasyLeagueCreateResponseDefaultTypeInternal _CMsgDOTAFantasyLeagueCreateResponse_default_instance_;
class CMsgDOTAFantasyLeagueDraftPlayerRequest;
class CMsgDOTAFantasyLeagueDraftPlayerRequestDefaultTypeInternal;
extern CMsgDOTAFantasyLeagueDraftPlayerRequestDefaultTypeInternal _CMsgDOTAFantasyLeagueDraftPlayerRequest_default_instance_;
class CMsgDOTAFantasyLeagueDraftPlayerResponse;
class CMsgDOTAFantasyLeagueDraftPlayerResponseDefaultTypeInternal;
extern CMsgDOTAFantasyLeagueDraftPlayerResponseDefaultTypeInternal _CMsgDOTAFantasyLeagueDraftPlayerResponse_default_instance_;
class CMsgDOTAFantasyLeagueDraftStatus;
class CMsgDOTAFantasyLeagueDraftStatusDefaultTypeInternal;
extern CMsgDOTAFantasyLeagueDraftStatusDefaultTypeInternal _CMsgDOTAFantasyLeagueDraftStatus_default_instance_;
class CMsgDOTAFantasyLeagueDraftStatusRequest;
class CMsgDOTAFantasyLeagueDraftStatusRequestDefaultTypeInternal;
extern CMsgDOTAFantasyLeagueDraftStatusRequestDefaultTypeInternal _CMsgDOTAFantasyLeagueDraftStatusRequest_default_instance_;
class CMsgDOTAFantasyLeagueEditInfoRequest;
class CMsgDOTAFantasyLeagueEditInfoRequestDefaultTypeInternal;
extern CMsgDOTAFantasyLeagueEditInfoRequestDefaultTypeInternal _CMsgDOTAFantasyLeagueEditInfoRequest_default_instance_;
class CMsgDOTAFantasyLeagueEditInfoResponse;
class CMsgDOTAFantasyLeagueEditInfoResponseDefaultTypeInternal;
extern CMsgDOTAFantasyLeagueEditInfoResponseDefaultTypeInternal _CMsgDOTAFantasyLeagueEditInfoResponse_default_instance_;
class CMsgDOTAFantasyLeagueEditInvitesRequest;
class CMsgDOTAFantasyLeagueEditInvitesRequestDefaultTypeInternal;
extern CMsgDOTAFantasyLeagueEditInvitesRequestDefaultTypeInternal _CMsgDOTAFantasyLeagueEditInvitesRequest_default_instance_;
class CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange;
class CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChangeDefaultTypeInternal;
extern CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChangeDefaultTypeInternal _CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange_default_instance_;
class CMsgDOTAFantasyLeagueEditInvitesResponse;
class CMsgDOTAFantasyLeagueEditInvitesResponseDefaultTypeInternal;
extern CMsgDOTAFantasyLeagueEditInvitesResponseDefaultTypeInternal _CMsgDOTAFantasyLeagueEditInvitesResponse_default_instance_;
class CMsgDOTAFantasyLeagueFindRequest;
class CMsgDOTAFantasyLeagueFindRequestDefaultTypeInternal;
extern CMsgDOTAFantasyLeagueFindRequestDefaultTypeInternal _CMsgDOTAFantasyLeagueFindRequest_default_instance_;
class CMsgDOTAFantasyLeagueFindResponse;
class CMsgDOTAFantasyLeagueFindResponseDefaultTypeInternal;
extern CMsgDOTAFantasyLeagueFindResponseDefaultTypeInternal _CMsgDOTAFantasyLeagueFindResponse_default_instance_;
class CMsgDOTAFantasyLeagueInfo;
class CMsgDOTAFantasyLeagueInfoDefaultTypeInternal;
extern CMsgDOTAFantasyLeagueInfoDefaultTypeInternal _CMsgDOTAFantasyLeagueInfo_default_instance_;
class CMsgDOTAFantasyLeagueInfoRequest;
class CMsgDOTAFantasyLeagueInfoRequestDefaultTypeInternal;
extern CMsgDOTAFantasyLeagueInfoRequestDefaultTypeInternal _CMsgDOTAFantasyLeagueInfoRequest_default_instance_;
class CMsgDOTAFantasyLeagueInfoResponse;
class CMsgDOTAFantasyLeagueInfoResponseDefaultTypeInternal;
extern CMsgDOTAFantasyLeagueInfoResponseDefaultTypeInternal _CMsgDOTAFantasyLeagueInfoResponse_default_instance_;
class CMsgDOTAFantasyLeagueInfo_OwnerInfo;
class CMsgDOTAFantasyLeagueInfo_OwnerInfoDefaultTypeInternal;
extern CMsgDOTAFantasyLeagueInfo_OwnerInfoDefaultTypeInternal _CMsgDOTAFantasyLeagueInfo_OwnerInfo_default_instance_;
class CMsgDOTAFantasyLeagueMatchupsRequest;
class CMsgDOTAFantasyLeagueMatchupsRequestDefaultTypeInternal;
extern CMsgDOTAFantasyLeagueMatchupsRequestDefaultTypeInternal _CMsgDOTAFantasyLeagueMatchupsRequest_default_instance_;
class CMsgDOTAFantasyLeagueMatchupsResponse;
class CMsgDOTAFantasyLeagueMatchupsResponseDefaultTypeInternal;
extern CMsgDOTAFantasyLeagueMatchupsResponseDefaultTypeInternal _CMsgDOTAFantasyLeagueMatchupsResponse_default_instance_;
class CMsgDOTAFantasyLeagueMatchupsResponse_Matchup;
class CMsgDOTAFantasyLeagueMatchupsResponse_MatchupDefaultTypeInternal;
extern CMsgDOTAFantasyLeagueMatchupsResponse_MatchupDefaultTypeInternal _CMsgDOTAFantasyLeagueMatchupsResponse_Matchup_default_instance_;
class CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups;
class CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchupsDefaultTypeInternal;
extern CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchupsDefaultTypeInternal _CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups_default_instance_;
class CMsgDOTAFantasyLeaveLeagueRequest;
class CMsgDOTAFantasyLeaveLeagueRequestDefaultTypeInternal;
extern CMsgDOTAFantasyLeaveLeagueRequestDefaultTypeInternal _CMsgDOTAFantasyLeaveLeagueRequest_default_instance_;
class CMsgDOTAFantasyLeaveLeagueResponse;
class CMsgDOTAFantasyLeaveLeagueResponseDefaultTypeInternal;
extern CMsgDOTAFantasyLeaveLeagueResponseDefaultTypeInternal _CMsgDOTAFantasyLeaveLeagueResponse_default_instance_;
class CMsgDOTAFantasyMessageAdd;
class CMsgDOTAFantasyMessageAddDefaultTypeInternal;
extern CMsgDOTAFantasyMessageAddDefaultTypeInternal _CMsgDOTAFantasyMessageAdd_default_instance_;
class CMsgDOTAFantasyMessagesRequest;
class CMsgDOTAFantasyMessagesRequestDefaultTypeInternal;
extern CMsgDOTAFantasyMessagesRequestDefaultTypeInternal _CMsgDOTAFantasyMessagesRequest_default_instance_;
class CMsgDOTAFantasyMessagesResponse;
class CMsgDOTAFantasyMessagesResponseDefaultTypeInternal;
extern CMsgDOTAFantasyMessagesResponseDefaultTypeInternal _CMsgDOTAFantasyMessagesResponse_default_instance_;
class CMsgDOTAFantasyMessagesResponse_Message;
class CMsgDOTAFantasyMessagesResponse_MessageDefaultTypeInternal;
extern CMsgDOTAFantasyMessagesResponse_MessageDefaultTypeInternal _CMsgDOTAFantasyMessagesResponse_Message_default_instance_;
class CMsgDOTAFantasyPlayerHisoricalStatsRequest;
class CMsgDOTAFantasyPlayerHisoricalStatsRequestDefaultTypeInternal;
extern CMsgDOTAFantasyPlayerHisoricalStatsRequestDefaultTypeInternal _CMsgDOTAFantasyPlayerHisoricalStatsRequest_default_instance_;
class CMsgDOTAFantasyPlayerHisoricalStatsResponse;
class CMsgDOTAFantasyPlayerHisoricalStatsResponseDefaultTypeInternal;
extern CMsgDOTAFantasyPlayerHisoricalStatsResponseDefaultTypeInternal _CMsgDOTAFantasyPlayerHisoricalStatsResponse_default_instance_;
class CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator;
class CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulatorDefaultTypeInternal;
extern CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulatorDefaultTypeInternal _CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator_default_instance_;
class CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats;
class CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStatsDefaultTypeInternal;
extern CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStatsDefaultTypeInternal _CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats_default_instance_;
class CMsgDOTAFantasyPlayerScoreDetailsRequest;
class CMsgDOTAFantasyPlayerScoreDetailsRequestDefaultTypeInternal;
extern CMsgDOTAFantasyPlayerScoreDetailsRequestDefaultTypeInternal _CMsgDOTAFantasyPlayerScoreDetailsRequest_default_instance_;
class CMsgDOTAFantasyPlayerScoreDetailsResponse;
class CMsgDOTAFantasyPlayerScoreDetailsResponseDefaultTypeInternal;
extern CMsgDOTAFantasyPlayerScoreDetailsResponseDefaultTypeInternal _CMsgDOTAFantasyPlayerScoreDetailsResponse_default_instance_;
class CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData;
class CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchDataDefaultTypeInternal;
extern CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchDataDefaultTypeInternal _CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData_default_instance_;
class CMsgDOTAFantasyPlayerScoreRequest;
class CMsgDOTAFantasyPlayerScoreRequestDefaultTypeInternal;
extern CMsgDOTAFantasyPlayerScoreRequestDefaultTypeInternal _CMsgDOTAFantasyPlayerScoreRequest_default_instance_;
class CMsgDOTAFantasyPlayerScoreResponse;
class CMsgDOTAFantasyPlayerScoreResponseDefaultTypeInternal;
extern CMsgDOTAFantasyPlayerScoreResponseDefaultTypeInternal _CMsgDOTAFantasyPlayerScoreResponse_default_instance_;
class CMsgDOTAFantasyPlayerStandingsRequest;
class CMsgDOTAFantasyPlayerStandingsRequestDefaultTypeInternal;
extern CMsgDOTAFantasyPlayerStandingsRequestDefaultTypeInternal _CMsgDOTAFantasyPlayerStandingsRequest_default_instance_;
class CMsgDOTAFantasyPlayerStandingsResponse;
class CMsgDOTAFantasyPlayerStandingsResponseDefaultTypeInternal;
extern CMsgDOTAFantasyPlayerStandingsResponseDefaultTypeInternal _CMsgDOTAFantasyPlayerStandingsResponse_default_instance_;
class CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore;
class CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScoreDefaultTypeInternal;
extern CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScoreDefaultTypeInternal _CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore_default_instance_;
class CMsgDOTAFantasyRemoveOwner;
class CMsgDOTAFantasyRemoveOwnerDefaultTypeInternal;
extern CMsgDOTAFantasyRemoveOwnerDefaultTypeInternal _CMsgDOTAFantasyRemoveOwner_default_instance_;
class CMsgDOTAFantasyRemoveOwnerResponse;
class CMsgDOTAFantasyRemoveOwnerResponseDefaultTypeInternal;
extern CMsgDOTAFantasyRemoveOwnerResponseDefaultTypeInternal _CMsgDOTAFantasyRemoveOwnerResponse_default_instance_;
class CMsgDOTAFantasyScheduledMatchesRequest;
class CMsgDOTAFantasyScheduledMatchesRequestDefaultTypeInternal;
extern CMsgDOTAFantasyScheduledMatchesRequestDefaultTypeInternal _CMsgDOTAFantasyScheduledMatchesRequest_default_instance_;
class CMsgDOTAFantasyScheduledMatchesResponse;
class CMsgDOTAFantasyScheduledMatchesResponseDefaultTypeInternal;
extern CMsgDOTAFantasyScheduledMatchesResponseDefaultTypeInternal _CMsgDOTAFantasyScheduledMatchesResponse_default_instance_;
class CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays;
class CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDaysDefaultTypeInternal;
extern CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDaysDefaultTypeInternal _CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays_default_instance_;
class CMsgDOTAFantasyTeamCreateRequest;
class CMsgDOTAFantasyTeamCreateRequestDefaultTypeInternal;
extern CMsgDOTAFantasyTeamCreateRequestDefaultTypeInternal _CMsgDOTAFantasyTeamCreateRequest_default_instance_;
class CMsgDOTAFantasyTeamCreateResponse;
class CMsgDOTAFantasyTeamCreateResponseDefaultTypeInternal;
extern CMsgDOTAFantasyTeamCreateResponseDefaultTypeInternal _CMsgDOTAFantasyTeamCreateResponse_default_instance_;
class CMsgDOTAFantasyTeamInfo;
class CMsgDOTAFantasyTeamInfoDefaultTypeInternal;
extern CMsgDOTAFantasyTeamInfoDefaultTypeInternal _CMsgDOTAFantasyTeamInfo_default_instance_;
class CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID;
class CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueIDDefaultTypeInternal;
extern CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueIDDefaultTypeInternal _CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID_default_instance_;
class CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID;
class CMsgDOTAFantasyTeamInfoRequestByOwnerAccountIDDefaultTypeInternal;
extern CMsgDOTAFantasyTeamInfoRequestByOwnerAccountIDDefaultTypeInternal _CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID_default_instance_;
class CMsgDOTAFantasyTeamInfoResponse;
class CMsgDOTAFantasyTeamInfoResponseDefaultTypeInternal;
extern CMsgDOTAFantasyTeamInfoResponseDefaultTypeInternal _CMsgDOTAFantasyTeamInfoResponse_default_instance_;
class CMsgDOTAFantasyTeamRosterAddDropRequest;
class CMsgDOTAFantasyTeamRosterAddDropRequestDefaultTypeInternal;
extern CMsgDOTAFantasyTeamRosterAddDropRequestDefaultTypeInternal _CMsgDOTAFantasyTeamRosterAddDropRequest_default_instance_;
class CMsgDOTAFantasyTeamRosterAddDropResponse;
class CMsgDOTAFantasyTeamRosterAddDropResponseDefaultTypeInternal;
extern CMsgDOTAFantasyTeamRosterAddDropResponseDefaultTypeInternal _CMsgDOTAFantasyTeamRosterAddDropResponse_default_instance_;
class CMsgDOTAFantasyTeamRosterRequest;
class CMsgDOTAFantasyTeamRosterRequestDefaultTypeInternal;
extern CMsgDOTAFantasyTeamRosterRequestDefaultTypeInternal _CMsgDOTAFantasyTeamRosterRequest_default_instance_;
class CMsgDOTAFantasyTeamRosterResponse;
class CMsgDOTAFantasyTeamRosterResponseDefaultTypeInternal;
extern CMsgDOTAFantasyTeamRosterResponseDefaultTypeInternal _CMsgDOTAFantasyTeamRosterResponse_default_instance_;
class CMsgDOTAFantasyTeamRosterSwapRequest;
class CMsgDOTAFantasyTeamRosterSwapRequestDefaultTypeInternal;
extern CMsgDOTAFantasyTeamRosterSwapRequestDefaultTypeInternal _CMsgDOTAFantasyTeamRosterSwapRequest_default_instance_;
class CMsgDOTAFantasyTeamRosterSwapResponse;
class CMsgDOTAFantasyTeamRosterSwapResponseDefaultTypeInternal;
extern CMsgDOTAFantasyTeamRosterSwapResponseDefaultTypeInternal _CMsgDOTAFantasyTeamRosterSwapResponse_default_instance_;
class CMsgDOTAFantasyTeamScoreRequest;
class CMsgDOTAFantasyTeamScoreRequestDefaultTypeInternal;
extern CMsgDOTAFantasyTeamScoreRequestDefaultTypeInternal _CMsgDOTAFantasyTeamScoreRequest_default_instance_;
class CMsgDOTAFantasyTeamScoreResponse;
class CMsgDOTAFantasyTeamScoreResponseDefaultTypeInternal;
extern CMsgDOTAFantasyTeamScoreResponseDefaultTypeInternal _CMsgDOTAFantasyTeamScoreResponse_default_instance_;
class CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore;
class CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScoreDefaultTypeInternal;
extern CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScoreDefaultTypeInternal _CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore_default_instance_;
class CMsgDOTAFantasyTeamStandingsRequest;
class CMsgDOTAFantasyTeamStandingsRequestDefaultTypeInternal;
extern CMsgDOTAFantasyTeamStandingsRequestDefaultTypeInternal _CMsgDOTAFantasyTeamStandingsRequest_default_instance_;
class CMsgDOTAFantasyTeamStandingsResponse;
class CMsgDOTAFantasyTeamStandingsResponseDefaultTypeInternal;
extern CMsgDOTAFantasyTeamStandingsResponseDefaultTypeInternal _CMsgDOTAFantasyTeamStandingsResponse_default_instance_;
class CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore;
class CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScoreDefaultTypeInternal;
extern CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScoreDefaultTypeInternal _CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore_default_instance_;
class CMsgDOTAFantasyTeamTradeCancelRequest;
class CMsgDOTAFantasyTeamTradeCancelRequestDefaultTypeInternal;
extern CMsgDOTAFantasyTeamTradeCancelRequestDefaultTypeInternal _CMsgDOTAFantasyTeamTradeCancelRequest_default_instance_;
class CMsgDOTAFantasyTeamTradeCancelResponse;
class CMsgDOTAFantasyTeamTradeCancelResponseDefaultTypeInternal;
extern CMsgDOTAFantasyTeamTradeCancelResponseDefaultTypeInternal _CMsgDOTAFantasyTeamTradeCancelResponse_default_instance_;
class CMsgDOTAFantasyTeamTradesRequest;
class CMsgDOTAFantasyTeamTradesRequestDefaultTypeInternal;
extern CMsgDOTAFantasyTeamTradesRequestDefaultTypeInternal _CMsgDOTAFantasyTeamTradesRequest_default_instance_;
class CMsgDOTAFantasyTeamTradesResponse;
class CMsgDOTAFantasyTeamTradesResponseDefaultTypeInternal;
extern CMsgDOTAFantasyTeamTradesResponseDefaultTypeInternal _CMsgDOTAFantasyTeamTradesResponse_default_instance_;
class CMsgDOTAFantasyTeamTradesResponse_Trade;
class CMsgDOTAFantasyTeamTradesResponse_TradeDefaultTypeInternal;
extern CMsgDOTAFantasyTeamTradesResponse_TradeDefaultTypeInternal _CMsgDOTAFantasyTeamTradesResponse_Trade_default_instance_;
class CMsgDOTALeaderboards;
class CMsgDOTALeaderboardsDefaultTypeInternal;
extern CMsgDOTALeaderboardsDefaultTypeInternal _CMsgDOTALeaderboards_default_instance_;
class CMsgDOTALeaderboards_RegionLeaderboard;
class CMsgDOTALeaderboards_RegionLeaderboardDefaultTypeInternal;
extern CMsgDOTALeaderboards_RegionLeaderboardDefaultTypeInternal _CMsgDOTALeaderboards_RegionLeaderboard_default_instance_;
class CMsgDOTAPassportPlayerCardChallenge;
class CMsgDOTAPassportPlayerCardChallengeDefaultTypeInternal;
extern CMsgDOTAPassportPlayerCardChallengeDefaultTypeInternal _CMsgDOTAPassportPlayerCardChallenge_default_instance_;
class CMsgDOTAPassportStampedPlayer;
class CMsgDOTAPassportStampedPlayerDefaultTypeInternal;
extern CMsgDOTAPassportStampedPlayerDefaultTypeInternal _CMsgDOTAPassportStampedPlayer_default_instance_;
class CMsgDOTAPassportVote;
class CMsgDOTAPassportVoteDefaultTypeInternal;
extern CMsgDOTAPassportVoteDefaultTypeInternal _CMsgDOTAPassportVote_default_instance_;
class CMsgDOTAPassportVoteGenericSelection;
class CMsgDOTAPassportVoteGenericSelectionDefaultTypeInternal;
extern CMsgDOTAPassportVoteGenericSelectionDefaultTypeInternal _CMsgDOTAPassportVoteGenericSelection_default_instance_;
class CMsgDOTAPassportVoteTeamGuess;
class CMsgDOTAPassportVoteTeamGuessDefaultTypeInternal;
extern CMsgDOTAPassportVoteTeamGuessDefaultTypeInternal _CMsgDOTAPassportVoteTeamGuess_default_instance_;
class CMsgDOTAPlayerInfo;
class CMsgDOTAPlayerInfoDefaultTypeInternal;
extern CMsgDOTAPlayerInfoDefaultTypeInternal _CMsgDOTAPlayerInfo_default_instance_;
class CMsgDOTAPlayerInfoList;
class CMsgDOTAPlayerInfoListDefaultTypeInternal;
extern CMsgDOTAPlayerInfoListDefaultTypeInternal _CMsgDOTAPlayerInfoList_default_instance_;
class CMsgDOTAPlayerInfo_AuditEntry;
class CMsgDOTAPlayerInfo_AuditEntryDefaultTypeInternal;
extern CMsgDOTAPlayerInfo_AuditEntryDefaultTypeInternal _CMsgDOTAPlayerInfo_AuditEntry_default_instance_;
class CMsgDOTAPlayerInfo_Results;
class CMsgDOTAPlayerInfo_ResultsDefaultTypeInternal;
extern CMsgDOTAPlayerInfo_ResultsDefaultTypeInternal _CMsgDOTAPlayerInfo_Results_default_instance_;
class CMsgFantasyLeagueScoring;
class CMsgFantasyLeagueScoringDefaultTypeInternal;
extern CMsgFantasyLeagueScoringDefaultTypeInternal _CMsgFantasyLeagueScoring_default_instance_;
}  // namespace dota
}  // namespace proto
namespace google {
namespace protobuf {
template<> ::proto::dota::CMsgClientToGCGetPlayerCardRosterRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgClientToGCGetPlayerCardRosterRequest>(Arena*);
template<> ::proto::dota::CMsgClientToGCGetPlayerCardRosterResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgClientToGCGetPlayerCardRosterResponse>(Arena*);
template<> ::proto::dota::CMsgClientToGCSetPlayerCardRosterRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgClientToGCSetPlayerCardRosterRequest>(Arena*);
template<> ::proto::dota::CMsgClientToGCSetPlayerCardRosterResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgClientToGCSetPlayerCardRosterResponse>(Arena*);
template<> ::proto::dota::CMsgDOTACreateFantasyLeagueRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTACreateFantasyLeagueRequest>(Arena*);
template<> ::proto::dota::CMsgDOTACreateFantasyLeagueResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTACreateFantasyLeagueResponse>(Arena*);
template<> ::proto::dota::CMsgDOTADPCProfileInfo* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTADPCProfileInfo>(Arena*);
template<> ::proto::dota::CMsgDOTADPCProfileInfo_FantasyInfo* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTADPCProfileInfo_FantasyInfo>(Arena*);
template<> ::proto::dota::CMsgDOTADPCProfileInfo_PredictionInfo* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTADPCProfileInfo_PredictionInfo>(Arena*);
template<> ::proto::dota::CMsgDOTAEditFantasyTeamRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAEditFantasyTeamRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAEditFantasyTeamResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAEditFantasyTeamResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyDPCLeagueStatus* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyDPCLeagueStatus>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyLeagueCreateRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyLeagueCreateRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyLeagueCreateResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyLeagueCreateResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyLeagueDraftPlayerRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyLeagueDraftPlayerRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyLeagueDraftPlayerResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyLeagueDraftPlayerResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyLeagueDraftStatus* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyLeagueDraftStatus>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyLeagueDraftStatusRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyLeagueDraftStatusRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyLeagueEditInfoRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyLeagueEditInfoRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyLeagueEditInfoResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyLeagueEditInfoResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyLeagueEditInvitesRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyLeagueEditInvitesRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyLeagueEditInvitesResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyLeagueEditInvitesResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyLeagueFindRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyLeagueFindRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyLeagueFindResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyLeagueFindResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyLeagueInfo* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyLeagueInfo>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyLeagueInfoRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyLeagueInfoRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyLeagueInfoResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyLeagueInfoResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyLeagueInfo_OwnerInfo* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyLeagueInfo_OwnerInfo>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyLeagueMatchupsRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyLeagueMatchupsRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_Matchup* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_Matchup>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyLeaveLeagueRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyLeaveLeagueRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyLeaveLeagueResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyLeaveLeagueResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyMessageAdd* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyMessageAdd>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyMessagesRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyMessagesRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyMessagesResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyMessagesResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyMessagesResponse_Message* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyMessagesResponse_Message>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyPlayerScoreRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyPlayerScoreRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyPlayerScoreResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyPlayerScoreResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyPlayerStandingsRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyPlayerStandingsRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyPlayerStandingsResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyPlayerStandingsResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyRemoveOwner* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyRemoveOwner>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyRemoveOwnerResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyRemoveOwnerResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyScheduledMatchesRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyScheduledMatchesRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyScheduledMatchesResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyScheduledMatchesResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyTeamCreateRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyTeamCreateRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyTeamCreateResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyTeamCreateResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyTeamInfo* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyTeamInfo>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyTeamInfoResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyTeamInfoResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyTeamRosterAddDropRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyTeamRosterAddDropRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyTeamRosterAddDropResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyTeamRosterAddDropResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyTeamRosterRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyTeamRosterRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyTeamRosterResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyTeamRosterResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyTeamRosterSwapRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyTeamRosterSwapRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyTeamRosterSwapResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyTeamRosterSwapResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyTeamScoreRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyTeamScoreRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyTeamScoreResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyTeamScoreResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyTeamStandingsRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyTeamStandingsRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyTeamStandingsResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyTeamStandingsResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyTeamTradeCancelRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyTeamTradeCancelRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyTeamTradeCancelResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyTeamTradeCancelResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyTeamTradesRequest* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyTeamTradesRequest>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyTeamTradesResponse* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyTeamTradesResponse>(Arena*);
template<> ::proto::dota::CMsgDOTAFantasyTeamTradesResponse_Trade* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyTeamTradesResponse_Trade>(Arena*);
template<> ::proto::dota::CMsgDOTALeaderboards* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeaderboards>(Arena*);
template<> ::proto::dota::CMsgDOTALeaderboards_RegionLeaderboard* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTALeaderboards_RegionLeaderboard>(Arena*);
template<> ::proto::dota::CMsgDOTAPassportPlayerCardChallenge* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAPassportPlayerCardChallenge>(Arena*);
template<> ::proto::dota::CMsgDOTAPassportStampedPlayer* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAPassportStampedPlayer>(Arena*);
template<> ::proto::dota::CMsgDOTAPassportVote* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAPassportVote>(Arena*);
template<> ::proto::dota::CMsgDOTAPassportVoteGenericSelection* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAPassportVoteGenericSelection>(Arena*);
template<> ::proto::dota::CMsgDOTAPassportVoteTeamGuess* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAPassportVoteTeamGuess>(Arena*);
template<> ::proto::dota::CMsgDOTAPlayerInfo* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAPlayerInfo>(Arena*);
template<> ::proto::dota::CMsgDOTAPlayerInfoList* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAPlayerInfoList>(Arena*);
template<> ::proto::dota::CMsgDOTAPlayerInfo_AuditEntry* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAPlayerInfo_AuditEntry>(Arena*);
template<> ::proto::dota::CMsgDOTAPlayerInfo_Results* Arena::CreateMaybeMessage<::proto::dota::CMsgDOTAPlayerInfo_Results>(Arena*);
template<> ::proto::dota::CMsgFantasyLeagueScoring* Arena::CreateMaybeMessage<::proto::dota::CMsgFantasyLeagueScoring>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace proto {
namespace dota {

enum CMsgDOTACreateFantasyLeagueResponse_EResult {
  CMsgDOTACreateFantasyLeagueResponse_EResult_SUCCESS = 0,
  CMsgDOTACreateFantasyLeagueResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTACreateFantasyLeagueResponse_EResult_ERROR_TOO_MANY_LEAGUES = 2,
  CMsgDOTACreateFantasyLeagueResponse_EResult_ERROR_INVALID_TEAM_COUNT = 3,
  CMsgDOTACreateFantasyLeagueResponse_EResult_ERROR_CREATION_DISABLED = 4
};
bool CMsgDOTACreateFantasyLeagueResponse_EResult_IsValid(int value);
const CMsgDOTACreateFantasyLeagueResponse_EResult CMsgDOTACreateFantasyLeagueResponse_EResult_EResult_MIN = CMsgDOTACreateFantasyLeagueResponse_EResult_SUCCESS;
const CMsgDOTACreateFantasyLeagueResponse_EResult CMsgDOTACreateFantasyLeagueResponse_EResult_EResult_MAX = CMsgDOTACreateFantasyLeagueResponse_EResult_ERROR_CREATION_DISABLED;
const int CMsgDOTACreateFantasyLeagueResponse_EResult_EResult_ARRAYSIZE = CMsgDOTACreateFantasyLeagueResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTACreateFantasyLeagueResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTACreateFantasyLeagueResponse_EResult_Name(CMsgDOTACreateFantasyLeagueResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTACreateFantasyLeagueResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTACreateFantasyLeagueResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTACreateFantasyLeagueResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTACreateFantasyLeagueResponse_EResult>(
    CMsgDOTACreateFantasyLeagueResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyLeagueEditInfoResponse_EResult {
  CMsgDOTAFantasyLeagueEditInfoResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyLeagueEditInfoResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyLeagueEditInfoResponse_EResult_ERROR_NO_PERMISSION = 2
};
bool CMsgDOTAFantasyLeagueEditInfoResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyLeagueEditInfoResponse_EResult CMsgDOTAFantasyLeagueEditInfoResponse_EResult_EResult_MIN = CMsgDOTAFantasyLeagueEditInfoResponse_EResult_SUCCESS;
const CMsgDOTAFantasyLeagueEditInfoResponse_EResult CMsgDOTAFantasyLeagueEditInfoResponse_EResult_EResult_MAX = CMsgDOTAFantasyLeagueEditInfoResponse_EResult_ERROR_NO_PERMISSION;
const int CMsgDOTAFantasyLeagueEditInfoResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyLeagueEditInfoResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyLeagueEditInfoResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyLeagueEditInfoResponse_EResult_Name(CMsgDOTAFantasyLeagueEditInfoResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyLeagueEditInfoResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyLeagueEditInfoResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyLeagueEditInfoResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyLeagueEditInfoResponse_EResult>(
    CMsgDOTAFantasyLeagueEditInfoResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyLeagueFindResponse_EResult {
  CMsgDOTAFantasyLeagueFindResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_LEAGUE_NOT_FOUND = 1,
  CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_BAD_PASSWORD = 2,
  CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_UNSPECIFIED = 3,
  CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_FULL = 4,
  CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_ALREADY_MEMBER = 5,
  CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_LEAGUE_LOCKED = 6
};
bool CMsgDOTAFantasyLeagueFindResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyLeagueFindResponse_EResult CMsgDOTAFantasyLeagueFindResponse_EResult_EResult_MIN = CMsgDOTAFantasyLeagueFindResponse_EResult_SUCCESS;
const CMsgDOTAFantasyLeagueFindResponse_EResult CMsgDOTAFantasyLeagueFindResponse_EResult_EResult_MAX = CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_LEAGUE_LOCKED;
const int CMsgDOTAFantasyLeagueFindResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyLeagueFindResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyLeagueFindResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyLeagueFindResponse_EResult_Name(CMsgDOTAFantasyLeagueFindResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyLeagueFindResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyLeagueFindResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyLeagueFindResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyLeagueFindResponse_EResult>(
    CMsgDOTAFantasyLeagueFindResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyLeagueInfoResponse_EResult {
  CMsgDOTAFantasyLeagueInfoResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyLeagueInfoResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyLeagueInfoResponse_EResult_ERROR_BAD_LEAGUE_ID = 2
};
bool CMsgDOTAFantasyLeagueInfoResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyLeagueInfoResponse_EResult CMsgDOTAFantasyLeagueInfoResponse_EResult_EResult_MIN = CMsgDOTAFantasyLeagueInfoResponse_EResult_SUCCESS;
const CMsgDOTAFantasyLeagueInfoResponse_EResult CMsgDOTAFantasyLeagueInfoResponse_EResult_EResult_MAX = CMsgDOTAFantasyLeagueInfoResponse_EResult_ERROR_BAD_LEAGUE_ID;
const int CMsgDOTAFantasyLeagueInfoResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyLeagueInfoResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyLeagueInfoResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyLeagueInfoResponse_EResult_Name(CMsgDOTAFantasyLeagueInfoResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyLeagueInfoResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyLeagueInfoResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyLeagueInfoResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyLeagueInfoResponse_EResult>(
    CMsgDOTAFantasyLeagueInfoResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyLeagueMatchupsResponse_EResult {
  CMsgDOTAFantasyLeagueMatchupsResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyLeagueMatchupsResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyLeagueMatchupsResponse_EResult_ERROR_BAD_LEAGUE_ID = 2,
  CMsgDOTAFantasyLeagueMatchupsResponse_EResult_ERROR_NO_PERMISSION = 3
};
bool CMsgDOTAFantasyLeagueMatchupsResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyLeagueMatchupsResponse_EResult CMsgDOTAFantasyLeagueMatchupsResponse_EResult_EResult_MIN = CMsgDOTAFantasyLeagueMatchupsResponse_EResult_SUCCESS;
const CMsgDOTAFantasyLeagueMatchupsResponse_EResult CMsgDOTAFantasyLeagueMatchupsResponse_EResult_EResult_MAX = CMsgDOTAFantasyLeagueMatchupsResponse_EResult_ERROR_NO_PERMISSION;
const int CMsgDOTAFantasyLeagueMatchupsResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyLeagueMatchupsResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyLeagueMatchupsResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyLeagueMatchupsResponse_EResult_Name(CMsgDOTAFantasyLeagueMatchupsResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyLeagueMatchupsResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyLeagueMatchupsResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyLeagueMatchupsResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyLeagueMatchupsResponse_EResult>(
    CMsgDOTAFantasyLeagueMatchupsResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAEditFantasyTeamResponse_EResult {
  CMsgDOTAEditFantasyTeamResponse_EResult_SUCCESS = 0,
  CMsgDOTAEditFantasyTeamResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAEditFantasyTeamResponse_EResult_ERROR_INVALID_TEAM_INFO = 2,
  CMsgDOTAEditFantasyTeamResponse_EResult_ERROR_NAME_ALREADY_TAKEN = 3,
  CMsgDOTAEditFantasyTeamResponse_EResult_ERROR_NO_PERMISSION = 4
};
bool CMsgDOTAEditFantasyTeamResponse_EResult_IsValid(int value);
const CMsgDOTAEditFantasyTeamResponse_EResult CMsgDOTAEditFantasyTeamResponse_EResult_EResult_MIN = CMsgDOTAEditFantasyTeamResponse_EResult_SUCCESS;
const CMsgDOTAEditFantasyTeamResponse_EResult CMsgDOTAEditFantasyTeamResponse_EResult_EResult_MAX = CMsgDOTAEditFantasyTeamResponse_EResult_ERROR_NO_PERMISSION;
const int CMsgDOTAEditFantasyTeamResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAEditFantasyTeamResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAEditFantasyTeamResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAEditFantasyTeamResponse_EResult_Name(CMsgDOTAEditFantasyTeamResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAEditFantasyTeamResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAEditFantasyTeamResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAEditFantasyTeamResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAEditFantasyTeamResponse_EResult>(
    CMsgDOTAEditFantasyTeamResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyTeamScoreResponse_EResult {
  CMsgDOTAFantasyTeamScoreResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyTeamScoreResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyTeamScoreResponse_EResult_ERROR_NO_PERMISSION = 2,
  CMsgDOTAFantasyTeamScoreResponse_EResult_ERROR_OWNER_NOT_IN_LEAGUE = 3
};
bool CMsgDOTAFantasyTeamScoreResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyTeamScoreResponse_EResult CMsgDOTAFantasyTeamScoreResponse_EResult_EResult_MIN = CMsgDOTAFantasyTeamScoreResponse_EResult_SUCCESS;
const CMsgDOTAFantasyTeamScoreResponse_EResult CMsgDOTAFantasyTeamScoreResponse_EResult_EResult_MAX = CMsgDOTAFantasyTeamScoreResponse_EResult_ERROR_OWNER_NOT_IN_LEAGUE;
const int CMsgDOTAFantasyTeamScoreResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyTeamScoreResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyTeamScoreResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyTeamScoreResponse_EResult_Name(CMsgDOTAFantasyTeamScoreResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyTeamScoreResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyTeamScoreResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyTeamScoreResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyTeamScoreResponse_EResult>(
    CMsgDOTAFantasyTeamScoreResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyTeamStandingsResponse_EResult {
  CMsgDOTAFantasyTeamStandingsResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyTeamStandingsResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyTeamStandingsResponse_EResult_ERROR_NO_PERMISSION = 2
};
bool CMsgDOTAFantasyTeamStandingsResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyTeamStandingsResponse_EResult CMsgDOTAFantasyTeamStandingsResponse_EResult_EResult_MIN = CMsgDOTAFantasyTeamStandingsResponse_EResult_SUCCESS;
const CMsgDOTAFantasyTeamStandingsResponse_EResult CMsgDOTAFantasyTeamStandingsResponse_EResult_EResult_MAX = CMsgDOTAFantasyTeamStandingsResponse_EResult_ERROR_NO_PERMISSION;
const int CMsgDOTAFantasyTeamStandingsResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyTeamStandingsResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyTeamStandingsResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyTeamStandingsResponse_EResult_Name(CMsgDOTAFantasyTeamStandingsResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyTeamStandingsResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyTeamStandingsResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyTeamStandingsResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyTeamStandingsResponse_EResult>(
    CMsgDOTAFantasyTeamStandingsResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyPlayerScoreResponse_EResult {
  CMsgDOTAFantasyPlayerScoreResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyPlayerScoreResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyPlayerScoreResponse_EResult_ERROR_NO_PERMISSION = 2
};
bool CMsgDOTAFantasyPlayerScoreResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyPlayerScoreResponse_EResult CMsgDOTAFantasyPlayerScoreResponse_EResult_EResult_MIN = CMsgDOTAFantasyPlayerScoreResponse_EResult_SUCCESS;
const CMsgDOTAFantasyPlayerScoreResponse_EResult CMsgDOTAFantasyPlayerScoreResponse_EResult_EResult_MAX = CMsgDOTAFantasyPlayerScoreResponse_EResult_ERROR_NO_PERMISSION;
const int CMsgDOTAFantasyPlayerScoreResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyPlayerScoreResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyPlayerScoreResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyPlayerScoreResponse_EResult_Name(CMsgDOTAFantasyPlayerScoreResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyPlayerScoreResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyPlayerScoreResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyPlayerScoreResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyPlayerScoreResponse_EResult>(
    CMsgDOTAFantasyPlayerScoreResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyPlayerStandingsResponse_EResult {
  CMsgDOTAFantasyPlayerStandingsResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyPlayerStandingsResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyPlayerStandingsResponse_EResult_ERROR_NO_PERMISSION = 2
};
bool CMsgDOTAFantasyPlayerStandingsResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyPlayerStandingsResponse_EResult CMsgDOTAFantasyPlayerStandingsResponse_EResult_EResult_MIN = CMsgDOTAFantasyPlayerStandingsResponse_EResult_SUCCESS;
const CMsgDOTAFantasyPlayerStandingsResponse_EResult CMsgDOTAFantasyPlayerStandingsResponse_EResult_EResult_MAX = CMsgDOTAFantasyPlayerStandingsResponse_EResult_ERROR_NO_PERMISSION;
const int CMsgDOTAFantasyPlayerStandingsResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyPlayerStandingsResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyPlayerStandingsResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyPlayerStandingsResponse_EResult_Name(CMsgDOTAFantasyPlayerStandingsResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyPlayerStandingsResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyPlayerStandingsResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyPlayerStandingsResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyPlayerStandingsResponse_EResult>(
    CMsgDOTAFantasyPlayerStandingsResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyLeagueCreateResponse_EResult {
  CMsgDOTAFantasyLeagueCreateResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_NO_PERMISSION = 1,
  CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_BAD_SEASON_ID = 2,
  CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_BAD_LEAGUE_NAME = 3,
  CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_BAD_TEAM_NAME = 4,
  CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_UNSPECIFIED = 5,
  CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_FAILED_LOGO_UPLOAD = 6,
  CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_NO_TICKET = 7
};
bool CMsgDOTAFantasyLeagueCreateResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyLeagueCreateResponse_EResult CMsgDOTAFantasyLeagueCreateResponse_EResult_EResult_MIN = CMsgDOTAFantasyLeagueCreateResponse_EResult_SUCCESS;
const CMsgDOTAFantasyLeagueCreateResponse_EResult CMsgDOTAFantasyLeagueCreateResponse_EResult_EResult_MAX = CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_NO_TICKET;
const int CMsgDOTAFantasyLeagueCreateResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyLeagueCreateResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyLeagueCreateResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyLeagueCreateResponse_EResult_Name(CMsgDOTAFantasyLeagueCreateResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyLeagueCreateResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyLeagueCreateResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyLeagueCreateResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyLeagueCreateResponse_EResult>(
    CMsgDOTAFantasyLeagueCreateResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyTeamCreateResponse_EResult {
  CMsgDOTAFantasyTeamCreateResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_NO_PERMISSION = 1,
  CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_FAILED_LOGO_UPLOAD = 2,
  CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_BAD_FANTASY_LEAGUE_ID = 3,
  CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_BAD_NAME = 4,
  CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_FULL = 5,
  CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_ALREADY_MEMBER = 6,
  CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_BAD_PASSWORD = 7,
  CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_UNSPECIFIED = 8,
  CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_NO_TICKET = 9,
  CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_LEAGUE_LOCKED = 10
};
bool CMsgDOTAFantasyTeamCreateResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyTeamCreateResponse_EResult CMsgDOTAFantasyTeamCreateResponse_EResult_EResult_MIN = CMsgDOTAFantasyTeamCreateResponse_EResult_SUCCESS;
const CMsgDOTAFantasyTeamCreateResponse_EResult CMsgDOTAFantasyTeamCreateResponse_EResult_EResult_MAX = CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_LEAGUE_LOCKED;
const int CMsgDOTAFantasyTeamCreateResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyTeamCreateResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyTeamCreateResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyTeamCreateResponse_EResult_Name(CMsgDOTAFantasyTeamCreateResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyTeamCreateResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyTeamCreateResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyTeamCreateResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyTeamCreateResponse_EResult>(
    CMsgDOTAFantasyTeamCreateResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyLeagueEditInvitesResponse_EResult {
  CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_ERROR_UNSPECIFIED = 1
};
bool CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyLeagueEditInvitesResponse_EResult CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_EResult_MIN = CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_SUCCESS;
const CMsgDOTAFantasyLeagueEditInvitesResponse_EResult CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_EResult_MAX = CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_ERROR_UNSPECIFIED;
const int CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_Name(CMsgDOTAFantasyLeagueEditInvitesResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyLeagueEditInvitesResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyLeagueEditInvitesResponse_EResult>(
    CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult {
  CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_INVALID_FANTASY_LEAGUE = 2,
  CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_FANTASY_LEAGUE_NOT_DRAFTING = 3,
  CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_OWNER_NOT_IN_LEAGUE = 4,
  CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_NOT_OWNERS_TURN = 5,
  CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_PLAYER_INVALID = 6,
  CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_PLAYER_UNAVAILABLE = 7,
  CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_PLAYER_NO_VALID_SLOTS = 8
};
bool CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_EResult_MIN = CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_SUCCESS;
const CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_EResult_MAX = CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_PLAYER_NO_VALID_SLOTS;
const int CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_Name(CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult>(
    CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyTeamRosterSwapResponse_EResult {
  CMsgDOTAFantasyTeamRosterSwapResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyTeamRosterSwapResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyTeamRosterSwapResponse_EResult_ERROR_OWNER_NOT_IN_LEAGUE = 2,
  CMsgDOTAFantasyTeamRosterSwapResponse_EResult_ERROR_SLOTS_INVALID = 3,
  CMsgDOTAFantasyTeamRosterSwapResponse_EResult_ERROR_SLOT_LOCKED = 4
};
bool CMsgDOTAFantasyTeamRosterSwapResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyTeamRosterSwapResponse_EResult CMsgDOTAFantasyTeamRosterSwapResponse_EResult_EResult_MIN = CMsgDOTAFantasyTeamRosterSwapResponse_EResult_SUCCESS;
const CMsgDOTAFantasyTeamRosterSwapResponse_EResult CMsgDOTAFantasyTeamRosterSwapResponse_EResult_EResult_MAX = CMsgDOTAFantasyTeamRosterSwapResponse_EResult_ERROR_SLOT_LOCKED;
const int CMsgDOTAFantasyTeamRosterSwapResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyTeamRosterSwapResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyTeamRosterSwapResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyTeamRosterSwapResponse_EResult_Name(CMsgDOTAFantasyTeamRosterSwapResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyTeamRosterSwapResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyTeamRosterSwapResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyTeamRosterSwapResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyTeamRosterSwapResponse_EResult>(
    CMsgDOTAFantasyTeamRosterSwapResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyTeamRosterAddDropResponse_EResult {
  CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_ERROR_OWNER_NOT_IN_LEAGUE = 2,
  CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_ERROR_PLAYER_NOT_AVAILABLE = 3,
  CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_ERROR_PLAYER_NOT_ON_TEAM = 4,
  CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_ERROR_TRADE_ALREADY_PENDING = 5
};
bool CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyTeamRosterAddDropResponse_EResult CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_EResult_MIN = CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_SUCCESS;
const CMsgDOTAFantasyTeamRosterAddDropResponse_EResult CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_EResult_MAX = CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_ERROR_TRADE_ALREADY_PENDING;
const int CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_Name(CMsgDOTAFantasyTeamRosterAddDropResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyTeamRosterAddDropResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyTeamRosterAddDropResponse_EResult>(
    CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyTeamTradesResponse_EResult {
  CMsgDOTAFantasyTeamTradesResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyTeamTradesResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyTeamTradesResponse_EResult_ERROR_NO_PERMISSION = 2
};
bool CMsgDOTAFantasyTeamTradesResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyTeamTradesResponse_EResult CMsgDOTAFantasyTeamTradesResponse_EResult_EResult_MIN = CMsgDOTAFantasyTeamTradesResponse_EResult_SUCCESS;
const CMsgDOTAFantasyTeamTradesResponse_EResult CMsgDOTAFantasyTeamTradesResponse_EResult_EResult_MAX = CMsgDOTAFantasyTeamTradesResponse_EResult_ERROR_NO_PERMISSION;
const int CMsgDOTAFantasyTeamTradesResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyTeamTradesResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyTeamTradesResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyTeamTradesResponse_EResult_Name(CMsgDOTAFantasyTeamTradesResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyTeamTradesResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyTeamTradesResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyTeamTradesResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyTeamTradesResponse_EResult>(
    CMsgDOTAFantasyTeamTradesResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyTeamTradeCancelResponse_EResult {
  CMsgDOTAFantasyTeamTradeCancelResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyTeamTradeCancelResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyTeamTradeCancelResponse_EResult_ERROR_NO_PERMISSION = 2,
  CMsgDOTAFantasyTeamTradeCancelResponse_EResult_ERROR_NO_TRADE = 3
};
bool CMsgDOTAFantasyTeamTradeCancelResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyTeamTradeCancelResponse_EResult CMsgDOTAFantasyTeamTradeCancelResponse_EResult_EResult_MIN = CMsgDOTAFantasyTeamTradeCancelResponse_EResult_SUCCESS;
const CMsgDOTAFantasyTeamTradeCancelResponse_EResult CMsgDOTAFantasyTeamTradeCancelResponse_EResult_EResult_MAX = CMsgDOTAFantasyTeamTradeCancelResponse_EResult_ERROR_NO_TRADE;
const int CMsgDOTAFantasyTeamTradeCancelResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyTeamTradeCancelResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyTeamTradeCancelResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyTeamTradeCancelResponse_EResult_Name(CMsgDOTAFantasyTeamTradeCancelResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyTeamTradeCancelResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyTeamTradeCancelResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyTeamTradeCancelResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyTeamTradeCancelResponse_EResult>(
    CMsgDOTAFantasyTeamTradeCancelResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyTeamRosterResponse_EResult {
  CMsgDOTAFantasyTeamRosterResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyTeamRosterResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyTeamRosterResponse_EResult_ERROR_NO_PERMISSION = 2,
  CMsgDOTAFantasyTeamRosterResponse_EResult_ERROR_OWNER_NOT_IN_LEAGUE = 3
};
bool CMsgDOTAFantasyTeamRosterResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyTeamRosterResponse_EResult CMsgDOTAFantasyTeamRosterResponse_EResult_EResult_MIN = CMsgDOTAFantasyTeamRosterResponse_EResult_SUCCESS;
const CMsgDOTAFantasyTeamRosterResponse_EResult CMsgDOTAFantasyTeamRosterResponse_EResult_EResult_MAX = CMsgDOTAFantasyTeamRosterResponse_EResult_ERROR_OWNER_NOT_IN_LEAGUE;
const int CMsgDOTAFantasyTeamRosterResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyTeamRosterResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyTeamRosterResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyTeamRosterResponse_EResult_Name(CMsgDOTAFantasyTeamRosterResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyTeamRosterResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyTeamRosterResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyTeamRosterResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyTeamRosterResponse_EResult>(
    CMsgDOTAFantasyTeamRosterResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult {
  CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_ERROR_NO_PERMISSION = 2
};
bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_EResult_MIN = CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_SUCCESS;
const CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_EResult_MAX = CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_ERROR_NO_PERMISSION;
const int CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_Name(CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult>(
    CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyMessagesResponse_EResult {
  CMsgDOTAFantasyMessagesResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyMessagesResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyMessagesResponse_EResult_ERROR_NO_PERMISSION = 2
};
bool CMsgDOTAFantasyMessagesResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyMessagesResponse_EResult CMsgDOTAFantasyMessagesResponse_EResult_EResult_MIN = CMsgDOTAFantasyMessagesResponse_EResult_SUCCESS;
const CMsgDOTAFantasyMessagesResponse_EResult CMsgDOTAFantasyMessagesResponse_EResult_EResult_MAX = CMsgDOTAFantasyMessagesResponse_EResult_ERROR_NO_PERMISSION;
const int CMsgDOTAFantasyMessagesResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyMessagesResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyMessagesResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyMessagesResponse_EResult_Name(CMsgDOTAFantasyMessagesResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyMessagesResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyMessagesResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyMessagesResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyMessagesResponse_EResult>(
    CMsgDOTAFantasyMessagesResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyRemoveOwnerResponse_EResult {
  CMsgDOTAFantasyRemoveOwnerResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyRemoveOwnerResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyRemoveOwnerResponse_EResult_ERROR_NO_PERMISSION = 2,
  CMsgDOTAFantasyRemoveOwnerResponse_EResult_ERROR_LEAGUE_LOCKED = 3,
  CMsgDOTAFantasyRemoveOwnerResponse_EResult_ERROR_NOT_A_MEMBER = 4
};
bool CMsgDOTAFantasyRemoveOwnerResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyRemoveOwnerResponse_EResult CMsgDOTAFantasyRemoveOwnerResponse_EResult_EResult_MIN = CMsgDOTAFantasyRemoveOwnerResponse_EResult_SUCCESS;
const CMsgDOTAFantasyRemoveOwnerResponse_EResult CMsgDOTAFantasyRemoveOwnerResponse_EResult_EResult_MAX = CMsgDOTAFantasyRemoveOwnerResponse_EResult_ERROR_NOT_A_MEMBER;
const int CMsgDOTAFantasyRemoveOwnerResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyRemoveOwnerResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyRemoveOwnerResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyRemoveOwnerResponse_EResult_Name(CMsgDOTAFantasyRemoveOwnerResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyRemoveOwnerResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyRemoveOwnerResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyRemoveOwnerResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyRemoveOwnerResponse_EResult>(
    CMsgDOTAFantasyRemoveOwnerResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyScheduledMatchesResponse_EResult {
  CMsgDOTAFantasyScheduledMatchesResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyScheduledMatchesResponse_EResult_ERROR_UNSPECIFIED = 1
};
bool CMsgDOTAFantasyScheduledMatchesResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyScheduledMatchesResponse_EResult CMsgDOTAFantasyScheduledMatchesResponse_EResult_EResult_MIN = CMsgDOTAFantasyScheduledMatchesResponse_EResult_SUCCESS;
const CMsgDOTAFantasyScheduledMatchesResponse_EResult CMsgDOTAFantasyScheduledMatchesResponse_EResult_EResult_MAX = CMsgDOTAFantasyScheduledMatchesResponse_EResult_ERROR_UNSPECIFIED;
const int CMsgDOTAFantasyScheduledMatchesResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyScheduledMatchesResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyScheduledMatchesResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyScheduledMatchesResponse_EResult_Name(CMsgDOTAFantasyScheduledMatchesResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyScheduledMatchesResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyScheduledMatchesResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyScheduledMatchesResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyScheduledMatchesResponse_EResult>(
    CMsgDOTAFantasyScheduledMatchesResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyLeaveLeagueResponse_EResult {
  CMsgDOTAFantasyLeaveLeagueResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyLeaveLeagueResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyLeaveLeagueResponse_EResult_ERROR_NOT_MEMBER = 2,
  CMsgDOTAFantasyLeaveLeagueResponse_EResult_ERROR_LEAGUE_NOT_FOUND = 3,
  CMsgDOTAFantasyLeaveLeagueResponse_EResult_ERROR_DRAFT_ACTIVE = 4
};
bool CMsgDOTAFantasyLeaveLeagueResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyLeaveLeagueResponse_EResult CMsgDOTAFantasyLeaveLeagueResponse_EResult_EResult_MIN = CMsgDOTAFantasyLeaveLeagueResponse_EResult_SUCCESS;
const CMsgDOTAFantasyLeaveLeagueResponse_EResult CMsgDOTAFantasyLeaveLeagueResponse_EResult_EResult_MAX = CMsgDOTAFantasyLeaveLeagueResponse_EResult_ERROR_DRAFT_ACTIVE;
const int CMsgDOTAFantasyLeaveLeagueResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyLeaveLeagueResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyLeaveLeagueResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyLeaveLeagueResponse_EResult_Name(CMsgDOTAFantasyLeaveLeagueResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyLeaveLeagueResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyLeaveLeagueResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyLeaveLeagueResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyLeaveLeagueResponse_EResult>(
    CMsgDOTAFantasyLeaveLeagueResponse_EResult_descriptor(), name, value);
}
enum CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult {
  CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_SUCCESS = 0,
  CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_ERROR_UNSPECIFIED = 1,
  CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_ERROR_NOT_MEMBER = 2
};
bool CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_IsValid(int value);
const CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_EResult_MIN = CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_SUCCESS;
const CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_EResult_MAX = CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_ERROR_NOT_MEMBER;
const int CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_EResult_ARRAYSIZE = CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_EResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_descriptor();
inline const ::std::string& CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_Name(CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_descriptor(), value);
}
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_Parse(
    const ::std::string& name, CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult>(
    CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_descriptor(), name, value);
}
enum CMsgClientToGCGetPlayerCardRosterResponse_Result {
  CMsgClientToGCGetPlayerCardRosterResponse_Result_SUCCESS = 0,
  CMsgClientToGCGetPlayerCardRosterResponse_Result_ERROR_UNSPECIFIED = 1,
  CMsgClientToGCGetPlayerCardRosterResponse_Result_ERROR_INVALID_LEAGUE_ID = 2,
  CMsgClientToGCGetPlayerCardRosterResponse_Result_ERROR_INVALID_TIMESTAMP = 3
};
bool CMsgClientToGCGetPlayerCardRosterResponse_Result_IsValid(int value);
const CMsgClientToGCGetPlayerCardRosterResponse_Result CMsgClientToGCGetPlayerCardRosterResponse_Result_Result_MIN = CMsgClientToGCGetPlayerCardRosterResponse_Result_SUCCESS;
const CMsgClientToGCGetPlayerCardRosterResponse_Result CMsgClientToGCGetPlayerCardRosterResponse_Result_Result_MAX = CMsgClientToGCGetPlayerCardRosterResponse_Result_ERROR_INVALID_TIMESTAMP;
const int CMsgClientToGCGetPlayerCardRosterResponse_Result_Result_ARRAYSIZE = CMsgClientToGCGetPlayerCardRosterResponse_Result_Result_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgClientToGCGetPlayerCardRosterResponse_Result_descriptor();
inline const ::std::string& CMsgClientToGCGetPlayerCardRosterResponse_Result_Name(CMsgClientToGCGetPlayerCardRosterResponse_Result value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgClientToGCGetPlayerCardRosterResponse_Result_descriptor(), value);
}
inline bool CMsgClientToGCGetPlayerCardRosterResponse_Result_Parse(
    const ::std::string& name, CMsgClientToGCGetPlayerCardRosterResponse_Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgClientToGCGetPlayerCardRosterResponse_Result>(
    CMsgClientToGCGetPlayerCardRosterResponse_Result_descriptor(), name, value);
}
enum CMsgClientToGCSetPlayerCardRosterResponse_Result {
  CMsgClientToGCSetPlayerCardRosterResponse_Result_SUCCESS = 0,
  CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_UNSPECIFIED = 1,
  CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_INVALID_LEAGUE_ID = 2,
  CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_INVALID_TIMESTAMP = 3,
  CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_PLAYER_CARD_NOT_OWNED = 4,
  CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_INVALID_SLOT = 5,
  CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_FAILED_CARD_INFO = 6,
  CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_ACCOUNT_DUPLICATE = 7,
  CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_LOCKED_TIMESTAMP = 8
};
bool CMsgClientToGCSetPlayerCardRosterResponse_Result_IsValid(int value);
const CMsgClientToGCSetPlayerCardRosterResponse_Result CMsgClientToGCSetPlayerCardRosterResponse_Result_Result_MIN = CMsgClientToGCSetPlayerCardRosterResponse_Result_SUCCESS;
const CMsgClientToGCSetPlayerCardRosterResponse_Result CMsgClientToGCSetPlayerCardRosterResponse_Result_Result_MAX = CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_LOCKED_TIMESTAMP;
const int CMsgClientToGCSetPlayerCardRosterResponse_Result_Result_ARRAYSIZE = CMsgClientToGCSetPlayerCardRosterResponse_Result_Result_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgClientToGCSetPlayerCardRosterResponse_Result_descriptor();
inline const ::std::string& CMsgClientToGCSetPlayerCardRosterResponse_Result_Name(CMsgClientToGCSetPlayerCardRosterResponse_Result value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgClientToGCSetPlayerCardRosterResponse_Result_descriptor(), value);
}
inline bool CMsgClientToGCSetPlayerCardRosterResponse_Result_Parse(
    const ::std::string& name, CMsgClientToGCSetPlayerCardRosterResponse_Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgClientToGCSetPlayerCardRosterResponse_Result>(
    CMsgClientToGCSetPlayerCardRosterResponse_Result_descriptor(), name, value);
}
enum CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus {
  CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_UNSET = 0,
  CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_PARTIAL = 1,
  CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_FULL = 2,
  CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_CONCLUDED = 3
};
bool CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_IsValid(int value);
const CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_ERosterStatus_MIN = CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_UNSET;
const CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_ERosterStatus_MAX = CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_CONCLUDED;
const int CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_ERosterStatus_ARRAYSIZE = CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_ERosterStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_descriptor();
inline const ::std::string& CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_Name(CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_descriptor(), value);
}
inline bool CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_Parse(
    const ::std::string& name, CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus>(
    CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_descriptor(), name, value);
}
enum DOTA_2013PassportSelectionIndices {
  PP13_SEL_ALLSTAR_PLAYER_0 = 0,
  PP13_SEL_ALLSTAR_PLAYER_1 = 1,
  PP13_SEL_ALLSTAR_PLAYER_2 = 2,
  PP13_SEL_ALLSTAR_PLAYER_3 = 3,
  PP13_SEL_ALLSTAR_PLAYER_4 = 4,
  PP13_SEL_ALLSTAR_PLAYER_5 = 5,
  PP13_SEL_ALLSTAR_PLAYER_6 = 6,
  PP13_SEL_ALLSTAR_PLAYER_7 = 7,
  PP13_SEL_ALLSTAR_PLAYER_8 = 8,
  PP13_SEL_ALLSTAR_PLAYER_9 = 9,
  PP13_SEL_QUALPRED_WEST_0 = 10,
  PP13_SEL_QUALPRED_WEST_1 = 11,
  PP13_SEL_QUALPRED_WEST_2 = 12,
  PP13_SEL_QUALPRED_WEST_3 = 13,
  PP13_SEL_QUALPRED_WEST_4 = 14,
  PP13_SEL_QUALPRED_WEST_5 = 15,
  PP13_SEL_QUALPRED_WEST_6 = 16,
  PP13_SEL_QUALPRED_WEST_7 = 17,
  PP13_SEL_QUALPRED_WEST_8 = 18,
  PP13_SEL_QUALPRED_WEST_9 = 19,
  PP13_SEL_QUALPRED_WEST_10 = 20,
  PP13_SEL_QUALPRED_WEST_11 = 21,
  PP13_SEL_QUALPRED_WEST_12 = 22,
  PP13_SEL_QUALPRED_WEST_13 = 23,
  PP13_SEL_QUALPRED_WEST_14 = 24,
  PP13_SEL_QUALPRED_EAST_0 = 25,
  PP13_SEL_QUALPRED_EAST_1 = 26,
  PP13_SEL_QUALPRED_EAST_2 = 27,
  PP13_SEL_QUALPRED_EAST_3 = 28,
  PP13_SEL_QUALPRED_EAST_4 = 29,
  PP13_SEL_QUALPRED_EAST_5 = 30,
  PP13_SEL_QUALPRED_EAST_6 = 31,
  PP13_SEL_QUALPRED_EAST_7 = 32,
  PP13_SEL_QUALPRED_EAST_8 = 33,
  PP13_SEL_QUALPRED_EAST_9 = 34,
  PP13_SEL_QUALPRED_EAST_10 = 35,
  PP13_SEL_QUALPRED_EAST_11 = 36,
  PP13_SEL_QUALPRED_EAST_12 = 37,
  PP13_SEL_QUALPRED_EAST_13 = 38,
  PP13_SEL_QUALPRED_EAST_14 = 39,
  PP13_SEL_TEAMCUP_TEAM = 40,
  PP13_SEL_TEAMCUP_PLAYER = 41,
  PP13_SEL_TEAMCUP_TEAM_LOCK = 42,
  PP13_SEL_TEAMCUP_PLAYER_LOCK = 43,
  PP13_SEL_EVENTPRED_0 = 44,
  PP13_SEL_EVENTPRED_1 = 45,
  PP13_SEL_EVENTPRED_2 = 46,
  PP13_SEL_EVENTPRED_3 = 47,
  PP13_SEL_EVENTPRED_4 = 48,
  PP13_SEL_EVENTPRED_5 = 49,
  PP13_SEL_EVENTPRED_6 = 50,
  PP13_SEL_EVENTPRED_7 = 51,
  PP13_SEL_EVENTPRED_8 = 52,
  PP13_SEL_EVENTPRED_9 = 53,
  PP13_SEL_EVENTPRED_10 = 54,
  PP13_SEL_EVENTPRED_11 = 55,
  PP13_SEL_EVENTPRED_12 = 56,
  PP13_SEL_EVENTPRED_13 = 57,
  PP13_SEL_EVENTPRED_14 = 58,
  PP13_SEL_EVENTPRED_15 = 59,
  PP13_SEL_EVENTPRED_16 = 60,
  PP13_SEL_EVENTPRED_17 = 61,
  PP13_SEL_EVENTPRED_18 = 62,
  PP13_SEL_EVENTPRED_19 = 63,
  PP13_SEL_EVENTPRED_20 = 64,
  PP13_SEL_EVENTPRED_21 = 65,
  PP13_SEL_EVENTPRED_22 = 66,
  PP13_SEL_EVENTPRED_23 = 67,
  PP13_SEL_EVENTPRED_24 = 68,
  PP13_SEL_EVENTPRED_25 = 69,
  PP13_SEL_EVENTPRED_26 = 70,
  PP13_SEL_EVENTPRED_27 = 71,
  PP13_SEL_EVENTPRED_28 = 72,
  PP13_SEL_EVENTPRED_29 = 73,
  PP13_SEL_EVENTPRED_30 = 74,
  PP13_SEL_EVENTPRED_31 = 75,
  PP13_SEL_EVENTPRED_32 = 76,
  PP13_SEL_EVENTPRED_33 = 77,
  PP13_SEL_EVENTPRED_34 = 78,
  PP13_SEL_EVENTPRED_35 = 79,
  PP13_SEL_EVENTPRED_36 = 80,
  PP13_SEL_EVENTPRED_37 = 81,
  PP13_SEL_EVENTPRED_38 = 82,
  PP13_SEL_EVENTPRED_39 = 83,
  PP13_SEL_EVENTPRED_40 = 84,
  PP13_SEL_EVENTPRED_41 = 85,
  PP13_SEL_EVENTPRED_42 = 86,
  PP13_SEL_EVENTPRED_43 = 87,
  PP13_SEL_SOLO_0 = 88,
  PP13_SEL_SOLO_1 = 89,
  PP13_SEL_SOLO_2 = 90,
  PP13_SEL_SOLO_3 = 91,
  PP13_SEL_SOLO_4 = 92,
  PP13_SEL_SOLO_5 = 93,
  PP13_SEL_SOLO_6 = 94,
  PP13_SEL_SOLO_7 = 95
};
bool DOTA_2013PassportSelectionIndices_IsValid(int value);
const DOTA_2013PassportSelectionIndices DOTA_2013PassportSelectionIndices_MIN = PP13_SEL_ALLSTAR_PLAYER_0;
const DOTA_2013PassportSelectionIndices DOTA_2013PassportSelectionIndices_MAX = PP13_SEL_SOLO_7;
const int DOTA_2013PassportSelectionIndices_ARRAYSIZE = DOTA_2013PassportSelectionIndices_MAX + 1;

const ::google::protobuf::EnumDescriptor* DOTA_2013PassportSelectionIndices_descriptor();
inline const ::std::string& DOTA_2013PassportSelectionIndices_Name(DOTA_2013PassportSelectionIndices value) {
  return ::google::protobuf::internal::NameOfEnum(
    DOTA_2013PassportSelectionIndices_descriptor(), value);
}
inline bool DOTA_2013PassportSelectionIndices_Parse(
    const ::std::string& name, DOTA_2013PassportSelectionIndices* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DOTA_2013PassportSelectionIndices>(
    DOTA_2013PassportSelectionIndices_descriptor(), name, value);
}
// ===================================================================

class CMsgDOTAPlayerInfo_Results final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAPlayerInfo.Results) */ {
 public:
  CMsgDOTAPlayerInfo_Results();
  virtual ~CMsgDOTAPlayerInfo_Results();

  CMsgDOTAPlayerInfo_Results(const CMsgDOTAPlayerInfo_Results& from);

  inline CMsgDOTAPlayerInfo_Results& operator=(const CMsgDOTAPlayerInfo_Results& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAPlayerInfo_Results(CMsgDOTAPlayerInfo_Results&& from) noexcept
    : CMsgDOTAPlayerInfo_Results() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAPlayerInfo_Results& operator=(CMsgDOTAPlayerInfo_Results&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAPlayerInfo_Results& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAPlayerInfo_Results* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAPlayerInfo_Results*>(
               &_CMsgDOTAPlayerInfo_Results_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CMsgDOTAPlayerInfo_Results* other);
  friend void swap(CMsgDOTAPlayerInfo_Results& a, CMsgDOTAPlayerInfo_Results& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAPlayerInfo_Results* New() const final {
    return CreateMaybeMessage<CMsgDOTAPlayerInfo_Results>(nullptr);
  }

  CMsgDOTAPlayerInfo_Results* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAPlayerInfo_Results>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAPlayerInfo_Results& from);
  void MergeFrom(const CMsgDOTAPlayerInfo_Results& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAPlayerInfo_Results* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 league_id = 1;
  bool has_league_id() const;
  void clear_league_id();
  static const int kLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 league_id() const;
  void set_league_id(::google::protobuf::uint32 value);

  // optional uint32 placement = 2;
  bool has_placement() const;
  void clear_placement();
  static const int kPlacementFieldNumber = 2;
  ::google::protobuf::uint32 placement() const;
  void set_placement(::google::protobuf::uint32 value);

  // optional uint32 earnings = 3;
  bool has_earnings() const;
  void clear_earnings();
  static const int kEarningsFieldNumber = 3;
  ::google::protobuf::uint32 earnings() const;
  void set_earnings(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAPlayerInfo.Results)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 league_id_;
  ::google::protobuf::uint32 placement_;
  ::google::protobuf::uint32 earnings_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAPlayerInfo_AuditEntry final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAPlayerInfo.AuditEntry) */ {
 public:
  CMsgDOTAPlayerInfo_AuditEntry();
  virtual ~CMsgDOTAPlayerInfo_AuditEntry();

  CMsgDOTAPlayerInfo_AuditEntry(const CMsgDOTAPlayerInfo_AuditEntry& from);

  inline CMsgDOTAPlayerInfo_AuditEntry& operator=(const CMsgDOTAPlayerInfo_AuditEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAPlayerInfo_AuditEntry(CMsgDOTAPlayerInfo_AuditEntry&& from) noexcept
    : CMsgDOTAPlayerInfo_AuditEntry() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAPlayerInfo_AuditEntry& operator=(CMsgDOTAPlayerInfo_AuditEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAPlayerInfo_AuditEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAPlayerInfo_AuditEntry* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAPlayerInfo_AuditEntry*>(
               &_CMsgDOTAPlayerInfo_AuditEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(CMsgDOTAPlayerInfo_AuditEntry* other);
  friend void swap(CMsgDOTAPlayerInfo_AuditEntry& a, CMsgDOTAPlayerInfo_AuditEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAPlayerInfo_AuditEntry* New() const final {
    return CreateMaybeMessage<CMsgDOTAPlayerInfo_AuditEntry>(nullptr);
  }

  CMsgDOTAPlayerInfo_AuditEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAPlayerInfo_AuditEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAPlayerInfo_AuditEntry& from);
  void MergeFrom(const CMsgDOTAPlayerInfo_AuditEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAPlayerInfo_AuditEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string team_name = 4;
  bool has_team_name() const;
  void clear_team_name();
  static const int kTeamNameFieldNumber = 4;
  const ::std::string& team_name() const;
  void set_team_name(const ::std::string& value);
  #if LANG_CXX11
  void set_team_name(::std::string&& value);
  #endif
  void set_team_name(const char* value);
  void set_team_name(const char* value, size_t size);
  ::std::string* mutable_team_name();
  ::std::string* release_team_name();
  void set_allocated_team_name(::std::string* team_name);

  // optional string team_tag = 5;
  bool has_team_tag() const;
  void clear_team_tag();
  static const int kTeamTagFieldNumber = 5;
  const ::std::string& team_tag() const;
  void set_team_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_team_tag(::std::string&& value);
  #endif
  void set_team_tag(const char* value);
  void set_team_tag(const char* value, size_t size);
  ::std::string* mutable_team_tag();
  ::std::string* release_team_tag();
  void set_allocated_team_tag(::std::string* team_tag);

  // optional string team_url_logo = 6;
  bool has_team_url_logo() const;
  void clear_team_url_logo();
  static const int kTeamUrlLogoFieldNumber = 6;
  const ::std::string& team_url_logo() const;
  void set_team_url_logo(const ::std::string& value);
  #if LANG_CXX11
  void set_team_url_logo(::std::string&& value);
  #endif
  void set_team_url_logo(const char* value);
  void set_team_url_logo(const char* value, size_t size);
  ::std::string* mutable_team_url_logo();
  ::std::string* release_team_url_logo();
  void set_allocated_team_url_logo(::std::string* team_url_logo);

  // optional uint32 start_timestamp = 1;
  bool has_start_timestamp() const;
  void clear_start_timestamp();
  static const int kStartTimestampFieldNumber = 1;
  ::google::protobuf::uint32 start_timestamp() const;
  void set_start_timestamp(::google::protobuf::uint32 value);

  // optional uint32 end_timestamp = 2;
  bool has_end_timestamp() const;
  void clear_end_timestamp();
  static const int kEndTimestampFieldNumber = 2;
  ::google::protobuf::uint32 end_timestamp() const;
  void set_end_timestamp(::google::protobuf::uint32 value);

  // optional uint32 team_id = 3;
  bool has_team_id() const;
  void clear_team_id();
  static const int kTeamIdFieldNumber = 3;
  ::google::protobuf::uint32 team_id() const;
  void set_team_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAPlayerInfo.AuditEntry)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr team_name_;
  ::google::protobuf::internal::ArenaStringPtr team_tag_;
  ::google::protobuf::internal::ArenaStringPtr team_url_logo_;
  ::google::protobuf::uint32 start_timestamp_;
  ::google::protobuf::uint32 end_timestamp_;
  ::google::protobuf::uint32 team_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAPlayerInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAPlayerInfo) */ {
 public:
  CMsgDOTAPlayerInfo();
  virtual ~CMsgDOTAPlayerInfo();

  CMsgDOTAPlayerInfo(const CMsgDOTAPlayerInfo& from);

  inline CMsgDOTAPlayerInfo& operator=(const CMsgDOTAPlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAPlayerInfo(CMsgDOTAPlayerInfo&& from) noexcept
    : CMsgDOTAPlayerInfo() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAPlayerInfo& operator=(CMsgDOTAPlayerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAPlayerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAPlayerInfo* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAPlayerInfo*>(
               &_CMsgDOTAPlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(CMsgDOTAPlayerInfo* other);
  friend void swap(CMsgDOTAPlayerInfo& a, CMsgDOTAPlayerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAPlayerInfo* New() const final {
    return CreateMaybeMessage<CMsgDOTAPlayerInfo>(nullptr);
  }

  CMsgDOTAPlayerInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAPlayerInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAPlayerInfo& from);
  void MergeFrom(const CMsgDOTAPlayerInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAPlayerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAPlayerInfo_Results Results;
  typedef CMsgDOTAPlayerInfo_AuditEntry AuditEntry;

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTAPlayerInfo.Results results = 14;
  int results_size() const;
  void clear_results();
  static const int kResultsFieldNumber = 14;
  ::proto::dota::CMsgDOTAPlayerInfo_Results* mutable_results(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPlayerInfo_Results >*
      mutable_results();
  const ::proto::dota::CMsgDOTAPlayerInfo_Results& results(int index) const;
  ::proto::dota::CMsgDOTAPlayerInfo_Results* add_results();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPlayerInfo_Results >&
      results() const;

  // repeated .proto.dota.CMsgDOTAPlayerInfo.AuditEntry audit_entries = 16;
  int audit_entries_size() const;
  void clear_audit_entries();
  static const int kAuditEntriesFieldNumber = 16;
  ::proto::dota::CMsgDOTAPlayerInfo_AuditEntry* mutable_audit_entries(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPlayerInfo_AuditEntry >*
      mutable_audit_entries();
  const ::proto::dota::CMsgDOTAPlayerInfo_AuditEntry& audit_entries(int index) const;
  ::proto::dota::CMsgDOTAPlayerInfo_AuditEntry* add_audit_entries();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPlayerInfo_AuditEntry >&
      audit_entries() const;

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string country_code = 3;
  bool has_country_code() const;
  void clear_country_code();
  static const int kCountryCodeFieldNumber = 3;
  const ::std::string& country_code() const;
  void set_country_code(const ::std::string& value);
  #if LANG_CXX11
  void set_country_code(::std::string&& value);
  #endif
  void set_country_code(const char* value);
  void set_country_code(const char* value, size_t size);
  ::std::string* mutable_country_code();
  ::std::string* release_country_code();
  void set_allocated_country_code(::std::string* country_code);

  // optional string team_name = 6;
  bool has_team_name() const;
  void clear_team_name();
  static const int kTeamNameFieldNumber = 6;
  const ::std::string& team_name() const;
  void set_team_name(const ::std::string& value);
  #if LANG_CXX11
  void set_team_name(::std::string&& value);
  #endif
  void set_team_name(const char* value);
  void set_team_name(const char* value, size_t size);
  ::std::string* mutable_team_name();
  ::std::string* release_team_name();
  void set_allocated_team_name(::std::string* team_name);

  // optional string team_tag = 7;
  bool has_team_tag() const;
  void clear_team_tag();
  static const int kTeamTagFieldNumber = 7;
  const ::std::string& team_tag() const;
  void set_team_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_team_tag(::std::string&& value);
  #endif
  void set_team_tag(const char* value);
  void set_team_tag(const char* value, size_t size);
  ::std::string* mutable_team_tag();
  ::std::string* release_team_tag();
  void set_allocated_team_tag(::std::string* team_tag);

  // optional string sponsor = 8;
  bool has_sponsor() const;
  void clear_sponsor();
  static const int kSponsorFieldNumber = 8;
  const ::std::string& sponsor() const;
  void set_sponsor(const ::std::string& value);
  #if LANG_CXX11
  void set_sponsor(::std::string&& value);
  #endif
  void set_sponsor(const char* value);
  void set_sponsor(const char* value, size_t size);
  ::std::string* mutable_sponsor();
  ::std::string* release_sponsor();
  void set_allocated_sponsor(::std::string* sponsor);

  // optional string real_name = 11;
  bool has_real_name() const;
  void clear_real_name();
  static const int kRealNameFieldNumber = 11;
  const ::std::string& real_name() const;
  void set_real_name(const ::std::string& value);
  #if LANG_CXX11
  void set_real_name(::std::string&& value);
  #endif
  void set_real_name(const char* value);
  void set_real_name(const char* value, size_t size);
  ::std::string* mutable_real_name();
  ::std::string* release_real_name();
  void set_allocated_real_name(::std::string* real_name);

  // optional string team_url_logo = 15;
  bool has_team_url_logo() const;
  void clear_team_url_logo();
  static const int kTeamUrlLogoFieldNumber = 15;
  const ::std::string& team_url_logo() const;
  void set_team_url_logo(const ::std::string& value);
  #if LANG_CXX11
  void set_team_url_logo(::std::string&& value);
  #endif
  void set_team_url_logo(const char* value);
  void set_team_url_logo(const char* value, size_t size);
  ::std::string* mutable_team_url_logo();
  ::std::string* release_team_url_logo();
  void set_allocated_team_url_logo(::std::string* team_url_logo);

  // optional uint32 account_id = 1;
  bool has_account_id() const;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  ::google::protobuf::uint32 account_id() const;
  void set_account_id(::google::protobuf::uint32 value);

  // optional .proto.dota.Fantasy_Roles fantasy_role = 4 [default = FANTASY_ROLE_UNDEFINED];
  bool has_fantasy_role() const;
  void clear_fantasy_role();
  static const int kFantasyRoleFieldNumber = 4;
  ::proto::dota::Fantasy_Roles fantasy_role() const;
  void set_fantasy_role(::proto::dota::Fantasy_Roles value);

  // optional uint32 team_id = 5;
  bool has_team_id() const;
  void clear_team_id();
  static const int kTeamIdFieldNumber = 5;
  ::google::protobuf::uint32 team_id() const;
  void set_team_id(::google::protobuf::uint32 value);

  // optional bool is_locked = 9;
  bool has_is_locked() const;
  void clear_is_locked();
  static const int kIsLockedFieldNumber = 9;
  bool is_locked() const;
  void set_is_locked(bool value);

  // optional bool is_pro = 10;
  bool has_is_pro() const;
  void clear_is_pro();
  static const int kIsProFieldNumber = 10;
  bool is_pro() const;
  void set_is_pro(bool value);

  // optional uint32 birthdate = 12;
  bool has_birthdate() const;
  void clear_birthdate();
  static const int kBirthdateFieldNumber = 12;
  ::google::protobuf::uint32 birthdate() const;
  void set_birthdate(::google::protobuf::uint32 value);

  // optional uint32 total_earnings = 13;
  bool has_total_earnings() const;
  void clear_total_earnings();
  static const int kTotalEarningsFieldNumber = 13;
  ::google::protobuf::uint32 total_earnings() const;
  void set_total_earnings(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAPlayerInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPlayerInfo_Results > results_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPlayerInfo_AuditEntry > audit_entries_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr country_code_;
  ::google::protobuf::internal::ArenaStringPtr team_name_;
  ::google::protobuf::internal::ArenaStringPtr team_tag_;
  ::google::protobuf::internal::ArenaStringPtr sponsor_;
  ::google::protobuf::internal::ArenaStringPtr real_name_;
  ::google::protobuf::internal::ArenaStringPtr team_url_logo_;
  ::google::protobuf::uint32 account_id_;
  int fantasy_role_;
  ::google::protobuf::uint32 team_id_;
  bool is_locked_;
  bool is_pro_;
  ::google::protobuf::uint32 birthdate_;
  ::google::protobuf::uint32 total_earnings_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAPlayerInfoList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAPlayerInfoList) */ {
 public:
  CMsgDOTAPlayerInfoList();
  virtual ~CMsgDOTAPlayerInfoList();

  CMsgDOTAPlayerInfoList(const CMsgDOTAPlayerInfoList& from);

  inline CMsgDOTAPlayerInfoList& operator=(const CMsgDOTAPlayerInfoList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAPlayerInfoList(CMsgDOTAPlayerInfoList&& from) noexcept
    : CMsgDOTAPlayerInfoList() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAPlayerInfoList& operator=(CMsgDOTAPlayerInfoList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAPlayerInfoList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAPlayerInfoList* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAPlayerInfoList*>(
               &_CMsgDOTAPlayerInfoList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(CMsgDOTAPlayerInfoList* other);
  friend void swap(CMsgDOTAPlayerInfoList& a, CMsgDOTAPlayerInfoList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAPlayerInfoList* New() const final {
    return CreateMaybeMessage<CMsgDOTAPlayerInfoList>(nullptr);
  }

  CMsgDOTAPlayerInfoList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAPlayerInfoList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAPlayerInfoList& from);
  void MergeFrom(const CMsgDOTAPlayerInfoList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAPlayerInfoList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTAPlayerInfo player_infos = 1;
  int player_infos_size() const;
  void clear_player_infos();
  static const int kPlayerInfosFieldNumber = 1;
  ::proto::dota::CMsgDOTAPlayerInfo* mutable_player_infos(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPlayerInfo >*
      mutable_player_infos();
  const ::proto::dota::CMsgDOTAPlayerInfo& player_infos(int index) const;
  ::proto::dota::CMsgDOTAPlayerInfo* add_player_infos();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPlayerInfo >&
      player_infos() const;

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAPlayerInfoList)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPlayerInfo > player_infos_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTADPCProfileInfo_PredictionInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTADPCProfileInfo.PredictionInfo) */ {
 public:
  CMsgDOTADPCProfileInfo_PredictionInfo();
  virtual ~CMsgDOTADPCProfileInfo_PredictionInfo();

  CMsgDOTADPCProfileInfo_PredictionInfo(const CMsgDOTADPCProfileInfo_PredictionInfo& from);

  inline CMsgDOTADPCProfileInfo_PredictionInfo& operator=(const CMsgDOTADPCProfileInfo_PredictionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTADPCProfileInfo_PredictionInfo(CMsgDOTADPCProfileInfo_PredictionInfo&& from) noexcept
    : CMsgDOTADPCProfileInfo_PredictionInfo() {
    *this = ::std::move(from);
  }

  inline CMsgDOTADPCProfileInfo_PredictionInfo& operator=(CMsgDOTADPCProfileInfo_PredictionInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTADPCProfileInfo_PredictionInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTADPCProfileInfo_PredictionInfo* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTADPCProfileInfo_PredictionInfo*>(
               &_CMsgDOTADPCProfileInfo_PredictionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(CMsgDOTADPCProfileInfo_PredictionInfo* other);
  friend void swap(CMsgDOTADPCProfileInfo_PredictionInfo& a, CMsgDOTADPCProfileInfo_PredictionInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTADPCProfileInfo_PredictionInfo* New() const final {
    return CreateMaybeMessage<CMsgDOTADPCProfileInfo_PredictionInfo>(nullptr);
  }

  CMsgDOTADPCProfileInfo_PredictionInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTADPCProfileInfo_PredictionInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTADPCProfileInfo_PredictionInfo& from);
  void MergeFrom(const CMsgDOTADPCProfileInfo_PredictionInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTADPCProfileInfo_PredictionInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 percent = 1;
  bool has_percent() const;
  void clear_percent();
  static const int kPercentFieldNumber = 1;
  ::google::protobuf::uint32 percent() const;
  void set_percent(::google::protobuf::uint32 value);

  // optional uint32 shard_winnings = 2;
  bool has_shard_winnings() const;
  void clear_shard_winnings();
  static const int kShardWinningsFieldNumber = 2;
  ::google::protobuf::uint32 shard_winnings() const;
  void set_shard_winnings(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTADPCProfileInfo.PredictionInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 percent_;
  ::google::protobuf::uint32 shard_winnings_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTADPCProfileInfo_FantasyInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTADPCProfileInfo.FantasyInfo) */ {
 public:
  CMsgDOTADPCProfileInfo_FantasyInfo();
  virtual ~CMsgDOTADPCProfileInfo_FantasyInfo();

  CMsgDOTADPCProfileInfo_FantasyInfo(const CMsgDOTADPCProfileInfo_FantasyInfo& from);

  inline CMsgDOTADPCProfileInfo_FantasyInfo& operator=(const CMsgDOTADPCProfileInfo_FantasyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTADPCProfileInfo_FantasyInfo(CMsgDOTADPCProfileInfo_FantasyInfo&& from) noexcept
    : CMsgDOTADPCProfileInfo_FantasyInfo() {
    *this = ::std::move(from);
  }

  inline CMsgDOTADPCProfileInfo_FantasyInfo& operator=(CMsgDOTADPCProfileInfo_FantasyInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTADPCProfileInfo_FantasyInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTADPCProfileInfo_FantasyInfo* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTADPCProfileInfo_FantasyInfo*>(
               &_CMsgDOTADPCProfileInfo_FantasyInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(CMsgDOTADPCProfileInfo_FantasyInfo* other);
  friend void swap(CMsgDOTADPCProfileInfo_FantasyInfo& a, CMsgDOTADPCProfileInfo_FantasyInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTADPCProfileInfo_FantasyInfo* New() const final {
    return CreateMaybeMessage<CMsgDOTADPCProfileInfo_FantasyInfo>(nullptr);
  }

  CMsgDOTADPCProfileInfo_FantasyInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTADPCProfileInfo_FantasyInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTADPCProfileInfo_FantasyInfo& from);
  void MergeFrom(const CMsgDOTADPCProfileInfo_FantasyInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTADPCProfileInfo_FantasyInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 top_90_finishes = 1;
  bool has_top_90_finishes() const;
  void clear_top_90_finishes();
  static const int kTop90FinishesFieldNumber = 1;
  ::google::protobuf::uint32 top_90_finishes() const;
  void set_top_90_finishes(::google::protobuf::uint32 value);

  // optional uint32 top_75_finishes = 2;
  bool has_top_75_finishes() const;
  void clear_top_75_finishes();
  static const int kTop75FinishesFieldNumber = 2;
  ::google::protobuf::uint32 top_75_finishes() const;
  void set_top_75_finishes(::google::protobuf::uint32 value);

  // optional uint32 top_50_finishes = 3;
  bool has_top_50_finishes() const;
  void clear_top_50_finishes();
  static const int kTop50FinishesFieldNumber = 3;
  ::google::protobuf::uint32 top_50_finishes() const;
  void set_top_50_finishes(::google::protobuf::uint32 value);

  // optional uint32 shard_winnings = 4;
  bool has_shard_winnings() const;
  void clear_shard_winnings();
  static const int kShardWinningsFieldNumber = 4;
  ::google::protobuf::uint32 shard_winnings() const;
  void set_shard_winnings(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTADPCProfileInfo.FantasyInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 top_90_finishes_;
  ::google::protobuf::uint32 top_75_finishes_;
  ::google::protobuf::uint32 top_50_finishes_;
  ::google::protobuf::uint32 shard_winnings_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTADPCProfileInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTADPCProfileInfo) */ {
 public:
  CMsgDOTADPCProfileInfo();
  virtual ~CMsgDOTADPCProfileInfo();

  CMsgDOTADPCProfileInfo(const CMsgDOTADPCProfileInfo& from);

  inline CMsgDOTADPCProfileInfo& operator=(const CMsgDOTADPCProfileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTADPCProfileInfo(CMsgDOTADPCProfileInfo&& from) noexcept
    : CMsgDOTADPCProfileInfo() {
    *this = ::std::move(from);
  }

  inline CMsgDOTADPCProfileInfo& operator=(CMsgDOTADPCProfileInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTADPCProfileInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTADPCProfileInfo* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTADPCProfileInfo*>(
               &_CMsgDOTADPCProfileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(CMsgDOTADPCProfileInfo* other);
  friend void swap(CMsgDOTADPCProfileInfo& a, CMsgDOTADPCProfileInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTADPCProfileInfo* New() const final {
    return CreateMaybeMessage<CMsgDOTADPCProfileInfo>(nullptr);
  }

  CMsgDOTADPCProfileInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTADPCProfileInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTADPCProfileInfo& from);
  void MergeFrom(const CMsgDOTADPCProfileInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTADPCProfileInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTADPCProfileInfo_PredictionInfo PredictionInfo;
  typedef CMsgDOTADPCProfileInfo_FantasyInfo FantasyInfo;

  // accessors -------------------------------------------------------

  // repeated uint32 disabled_notifications = 4;
  int disabled_notifications_size() const;
  void clear_disabled_notifications();
  static const int kDisabledNotificationsFieldNumber = 4;
  ::google::protobuf::uint32 disabled_notifications(int index) const;
  void set_disabled_notifications(int index, ::google::protobuf::uint32 value);
  void add_disabled_notifications(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      disabled_notifications() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_disabled_notifications();

  // optional .proto.dota.CMsgDOTAPlayerInfo player_info = 1;
  bool has_player_info() const;
  void clear_player_info();
  static const int kPlayerInfoFieldNumber = 1;
  const ::proto::dota::CMsgDOTAPlayerInfo& player_info() const;
  ::proto::dota::CMsgDOTAPlayerInfo* release_player_info();
  ::proto::dota::CMsgDOTAPlayerInfo* mutable_player_info();
  void set_allocated_player_info(::proto::dota::CMsgDOTAPlayerInfo* player_info);

  // optional .proto.dota.CMsgDOTADPCProfileInfo.PredictionInfo prediction_info = 2;
  bool has_prediction_info() const;
  void clear_prediction_info();
  static const int kPredictionInfoFieldNumber = 2;
  const ::proto::dota::CMsgDOTADPCProfileInfo_PredictionInfo& prediction_info() const;
  ::proto::dota::CMsgDOTADPCProfileInfo_PredictionInfo* release_prediction_info();
  ::proto::dota::CMsgDOTADPCProfileInfo_PredictionInfo* mutable_prediction_info();
  void set_allocated_prediction_info(::proto::dota::CMsgDOTADPCProfileInfo_PredictionInfo* prediction_info);

  // optional .proto.dota.CMsgDOTADPCProfileInfo.FantasyInfo fantasy_info = 3;
  bool has_fantasy_info() const;
  void clear_fantasy_info();
  static const int kFantasyInfoFieldNumber = 3;
  const ::proto::dota::CMsgDOTADPCProfileInfo_FantasyInfo& fantasy_info() const;
  ::proto::dota::CMsgDOTADPCProfileInfo_FantasyInfo* release_fantasy_info();
  ::proto::dota::CMsgDOTADPCProfileInfo_FantasyInfo* mutable_fantasy_info();
  void set_allocated_fantasy_info(::proto::dota::CMsgDOTADPCProfileInfo_FantasyInfo* fantasy_info);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTADPCProfileInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > disabled_notifications_;
  ::proto::dota::CMsgDOTAPlayerInfo* player_info_;
  ::proto::dota::CMsgDOTADPCProfileInfo_PredictionInfo* prediction_info_;
  ::proto::dota::CMsgDOTADPCProfileInfo_FantasyInfo* fantasy_info_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeaderboards_RegionLeaderboard final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeaderboards.RegionLeaderboard) */ {
 public:
  CMsgDOTALeaderboards_RegionLeaderboard();
  virtual ~CMsgDOTALeaderboards_RegionLeaderboard();

  CMsgDOTALeaderboards_RegionLeaderboard(const CMsgDOTALeaderboards_RegionLeaderboard& from);

  inline CMsgDOTALeaderboards_RegionLeaderboard& operator=(const CMsgDOTALeaderboards_RegionLeaderboard& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeaderboards_RegionLeaderboard(CMsgDOTALeaderboards_RegionLeaderboard&& from) noexcept
    : CMsgDOTALeaderboards_RegionLeaderboard() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeaderboards_RegionLeaderboard& operator=(CMsgDOTALeaderboards_RegionLeaderboard&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeaderboards_RegionLeaderboard& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeaderboards_RegionLeaderboard* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeaderboards_RegionLeaderboard*>(
               &_CMsgDOTALeaderboards_RegionLeaderboard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(CMsgDOTALeaderboards_RegionLeaderboard* other);
  friend void swap(CMsgDOTALeaderboards_RegionLeaderboard& a, CMsgDOTALeaderboards_RegionLeaderboard& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeaderboards_RegionLeaderboard* New() const final {
    return CreateMaybeMessage<CMsgDOTALeaderboards_RegionLeaderboard>(nullptr);
  }

  CMsgDOTALeaderboards_RegionLeaderboard* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeaderboards_RegionLeaderboard>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeaderboards_RegionLeaderboard& from);
  void MergeFrom(const CMsgDOTALeaderboards_RegionLeaderboard& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeaderboards_RegionLeaderboard* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 account_ids = 2;
  int account_ids_size() const;
  void clear_account_ids();
  static const int kAccountIdsFieldNumber = 2;
  ::google::protobuf::uint32 account_ids(int index) const;
  void set_account_ids(int index, ::google::protobuf::uint32 value);
  void add_account_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      account_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_account_ids();

  // optional uint32 division = 1;
  bool has_division() const;
  void clear_division();
  static const int kDivisionFieldNumber = 1;
  ::google::protobuf::uint32 division() const;
  void set_division(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeaderboards.RegionLeaderboard)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > account_ids_;
  ::google::protobuf::uint32 division_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTALeaderboards final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTALeaderboards) */ {
 public:
  CMsgDOTALeaderboards();
  virtual ~CMsgDOTALeaderboards();

  CMsgDOTALeaderboards(const CMsgDOTALeaderboards& from);

  inline CMsgDOTALeaderboards& operator=(const CMsgDOTALeaderboards& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTALeaderboards(CMsgDOTALeaderboards&& from) noexcept
    : CMsgDOTALeaderboards() {
    *this = ::std::move(from);
  }

  inline CMsgDOTALeaderboards& operator=(CMsgDOTALeaderboards&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTALeaderboards& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTALeaderboards* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTALeaderboards*>(
               &_CMsgDOTALeaderboards_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(CMsgDOTALeaderboards* other);
  friend void swap(CMsgDOTALeaderboards& a, CMsgDOTALeaderboards& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTALeaderboards* New() const final {
    return CreateMaybeMessage<CMsgDOTALeaderboards>(nullptr);
  }

  CMsgDOTALeaderboards* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTALeaderboards>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTALeaderboards& from);
  void MergeFrom(const CMsgDOTALeaderboards& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTALeaderboards* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTALeaderboards_RegionLeaderboard RegionLeaderboard;

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTALeaderboards.RegionLeaderboard leaderboards = 2;
  int leaderboards_size() const;
  void clear_leaderboards();
  static const int kLeaderboardsFieldNumber = 2;
  ::proto::dota::CMsgDOTALeaderboards_RegionLeaderboard* mutable_leaderboards(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeaderboards_RegionLeaderboard >*
      mutable_leaderboards();
  const ::proto::dota::CMsgDOTALeaderboards_RegionLeaderboard& leaderboards(int index) const;
  ::proto::dota::CMsgDOTALeaderboards_RegionLeaderboard* add_leaderboards();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeaderboards_RegionLeaderboard >&
      leaderboards() const;

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTALeaderboards)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeaderboards_RegionLeaderboard > leaderboards_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTACreateFantasyLeagueRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTACreateFantasyLeagueRequest) */ {
 public:
  CMsgDOTACreateFantasyLeagueRequest();
  virtual ~CMsgDOTACreateFantasyLeagueRequest();

  CMsgDOTACreateFantasyLeagueRequest(const CMsgDOTACreateFantasyLeagueRequest& from);

  inline CMsgDOTACreateFantasyLeagueRequest& operator=(const CMsgDOTACreateFantasyLeagueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTACreateFantasyLeagueRequest(CMsgDOTACreateFantasyLeagueRequest&& from) noexcept
    : CMsgDOTACreateFantasyLeagueRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTACreateFantasyLeagueRequest& operator=(CMsgDOTACreateFantasyLeagueRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTACreateFantasyLeagueRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTACreateFantasyLeagueRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTACreateFantasyLeagueRequest*>(
               &_CMsgDOTACreateFantasyLeagueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(CMsgDOTACreateFantasyLeagueRequest* other);
  friend void swap(CMsgDOTACreateFantasyLeagueRequest& a, CMsgDOTACreateFantasyLeagueRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTACreateFantasyLeagueRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTACreateFantasyLeagueRequest>(nullptr);
  }

  CMsgDOTACreateFantasyLeagueRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTACreateFantasyLeagueRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTACreateFantasyLeagueRequest& from);
  void MergeFrom(const CMsgDOTACreateFantasyLeagueRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTACreateFantasyLeagueRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string league_name = 1;
  bool has_league_name() const;
  void clear_league_name();
  static const int kLeagueNameFieldNumber = 1;
  const ::std::string& league_name() const;
  void set_league_name(const ::std::string& value);
  #if LANG_CXX11
  void set_league_name(::std::string&& value);
  #endif
  void set_league_name(const char* value);
  void set_league_name(const char* value, size_t size);
  ::std::string* mutable_league_name();
  ::std::string* release_league_name();
  void set_allocated_league_name(::std::string* league_name);

  // optional uint64 league_logo = 2;
  bool has_league_logo() const;
  void clear_league_logo();
  static const int kLeagueLogoFieldNumber = 2;
  ::google::protobuf::uint64 league_logo() const;
  void set_league_logo(::google::protobuf::uint64 value);

  // optional .proto.dota.Fantasy_Selection_Mode selection_mode = 3 [default = FANTASY_SELECTION_INVALID];
  bool has_selection_mode() const;
  void clear_selection_mode();
  static const int kSelectionModeFieldNumber = 3;
  ::proto::dota::Fantasy_Selection_Mode selection_mode() const;
  void set_selection_mode(::proto::dota::Fantasy_Selection_Mode value);

  // optional uint32 team_count = 4;
  bool has_team_count() const;
  void clear_team_count();
  static const int kTeamCountFieldNumber = 4;
  ::google::protobuf::uint32 team_count() const;
  void set_team_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTACreateFantasyLeagueRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr league_name_;
  ::google::protobuf::uint64 league_logo_;
  int selection_mode_;
  ::google::protobuf::uint32 team_count_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTACreateFantasyLeagueResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTACreateFantasyLeagueResponse) */ {
 public:
  CMsgDOTACreateFantasyLeagueResponse();
  virtual ~CMsgDOTACreateFantasyLeagueResponse();

  CMsgDOTACreateFantasyLeagueResponse(const CMsgDOTACreateFantasyLeagueResponse& from);

  inline CMsgDOTACreateFantasyLeagueResponse& operator=(const CMsgDOTACreateFantasyLeagueResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTACreateFantasyLeagueResponse(CMsgDOTACreateFantasyLeagueResponse&& from) noexcept
    : CMsgDOTACreateFantasyLeagueResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTACreateFantasyLeagueResponse& operator=(CMsgDOTACreateFantasyLeagueResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTACreateFantasyLeagueResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTACreateFantasyLeagueResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTACreateFantasyLeagueResponse*>(
               &_CMsgDOTACreateFantasyLeagueResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(CMsgDOTACreateFantasyLeagueResponse* other);
  friend void swap(CMsgDOTACreateFantasyLeagueResponse& a, CMsgDOTACreateFantasyLeagueResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTACreateFantasyLeagueResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTACreateFantasyLeagueResponse>(nullptr);
  }

  CMsgDOTACreateFantasyLeagueResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTACreateFantasyLeagueResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTACreateFantasyLeagueResponse& from);
  void MergeFrom(const CMsgDOTACreateFantasyLeagueResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTACreateFantasyLeagueResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTACreateFantasyLeagueResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTACreateFantasyLeagueResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTACreateFantasyLeagueResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_TOO_MANY_LEAGUES =
    CMsgDOTACreateFantasyLeagueResponse_EResult_ERROR_TOO_MANY_LEAGUES;
  static const EResult ERROR_INVALID_TEAM_COUNT =
    CMsgDOTACreateFantasyLeagueResponse_EResult_ERROR_INVALID_TEAM_COUNT;
  static const EResult ERROR_CREATION_DISABLED =
    CMsgDOTACreateFantasyLeagueResponse_EResult_ERROR_CREATION_DISABLED;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTACreateFantasyLeagueResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTACreateFantasyLeagueResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTACreateFantasyLeagueResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTACreateFantasyLeagueResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTACreateFantasyLeagueResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTACreateFantasyLeagueResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTACreateFantasyLeagueResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgDOTACreateFantasyLeagueResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTACreateFantasyLeagueResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTACreateFantasyLeagueResponse_EResult value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTACreateFantasyLeagueResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int result_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgFantasyLeagueScoring final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgFantasyLeagueScoring) */ {
 public:
  CMsgFantasyLeagueScoring();
  virtual ~CMsgFantasyLeagueScoring();

  CMsgFantasyLeagueScoring(const CMsgFantasyLeagueScoring& from);

  inline CMsgFantasyLeagueScoring& operator=(const CMsgFantasyLeagueScoring& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgFantasyLeagueScoring(CMsgFantasyLeagueScoring&& from) noexcept
    : CMsgFantasyLeagueScoring() {
    *this = ::std::move(from);
  }

  inline CMsgFantasyLeagueScoring& operator=(CMsgFantasyLeagueScoring&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgFantasyLeagueScoring& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgFantasyLeagueScoring* internal_default_instance() {
    return reinterpret_cast<const CMsgFantasyLeagueScoring*>(
               &_CMsgFantasyLeagueScoring_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(CMsgFantasyLeagueScoring* other);
  friend void swap(CMsgFantasyLeagueScoring& a, CMsgFantasyLeagueScoring& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgFantasyLeagueScoring* New() const final {
    return CreateMaybeMessage<CMsgFantasyLeagueScoring>(nullptr);
  }

  CMsgFantasyLeagueScoring* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgFantasyLeagueScoring>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgFantasyLeagueScoring& from);
  void MergeFrom(const CMsgFantasyLeagueScoring& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgFantasyLeagueScoring* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float level = 1;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 1;
  float level() const;
  void set_level(float value);

  // optional float kills = 2;
  bool has_kills() const;
  void clear_kills();
  static const int kKillsFieldNumber = 2;
  float kills() const;
  void set_kills(float value);

  // optional float deaths = 3;
  bool has_deaths() const;
  void clear_deaths();
  static const int kDeathsFieldNumber = 3;
  float deaths() const;
  void set_deaths(float value);

  // optional float assists = 4;
  bool has_assists() const;
  void clear_assists();
  static const int kAssistsFieldNumber = 4;
  float assists() const;
  void set_assists(float value);

  // optional float last_hits = 5;
  bool has_last_hits() const;
  void clear_last_hits();
  static const int kLastHitsFieldNumber = 5;
  float last_hits() const;
  void set_last_hits(float value);

  // optional float denies = 6;
  bool has_denies() const;
  void clear_denies();
  static const int kDeniesFieldNumber = 6;
  float denies() const;
  void set_denies(float value);

  // optional float gpm = 7;
  bool has_gpm() const;
  void clear_gpm();
  static const int kGpmFieldNumber = 7;
  float gpm() const;
  void set_gpm(float value);

  // optional float xppm = 8;
  bool has_xppm() const;
  void clear_xppm();
  static const int kXppmFieldNumber = 8;
  float xppm() const;
  void set_xppm(float value);

  // optional float stuns = 9;
  bool has_stuns() const;
  void clear_stuns();
  static const int kStunsFieldNumber = 9;
  float stuns() const;
  void set_stuns(float value);

  // optional float healing = 10;
  bool has_healing() const;
  void clear_healing();
  static const int kHealingFieldNumber = 10;
  float healing() const;
  void set_healing(float value);

  // optional float tower_kills = 11;
  bool has_tower_kills() const;
  void clear_tower_kills();
  static const int kTowerKillsFieldNumber = 11;
  float tower_kills() const;
  void set_tower_kills(float value);

  // optional float roshan_kills = 12;
  bool has_roshan_kills() const;
  void clear_roshan_kills();
  static const int kRoshanKillsFieldNumber = 12;
  float roshan_kills() const;
  void set_roshan_kills(float value);

  // optional float multiplier_premium = 13;
  bool has_multiplier_premium() const;
  void clear_multiplier_premium();
  static const int kMultiplierPremiumFieldNumber = 13;
  float multiplier_premium() const;
  void set_multiplier_premium(float value);

  // optional float multiplier_professional = 14;
  bool has_multiplier_professional() const;
  void clear_multiplier_professional();
  static const int kMultiplierProfessionalFieldNumber = 14;
  float multiplier_professional() const;
  void set_multiplier_professional(float value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgFantasyLeagueScoring)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float level_;
  float kills_;
  float deaths_;
  float assists_;
  float last_hits_;
  float denies_;
  float gpm_;
  float xppm_;
  float stuns_;
  float healing_;
  float tower_kills_;
  float roshan_kills_;
  float multiplier_premium_;
  float multiplier_professional_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueInfo_OwnerInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyLeagueInfo.OwnerInfo) */ {
 public:
  CMsgDOTAFantasyLeagueInfo_OwnerInfo();
  virtual ~CMsgDOTAFantasyLeagueInfo_OwnerInfo();

  CMsgDOTAFantasyLeagueInfo_OwnerInfo(const CMsgDOTAFantasyLeagueInfo_OwnerInfo& from);

  inline CMsgDOTAFantasyLeagueInfo_OwnerInfo& operator=(const CMsgDOTAFantasyLeagueInfo_OwnerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyLeagueInfo_OwnerInfo(CMsgDOTAFantasyLeagueInfo_OwnerInfo&& from) noexcept
    : CMsgDOTAFantasyLeagueInfo_OwnerInfo() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyLeagueInfo_OwnerInfo& operator=(CMsgDOTAFantasyLeagueInfo_OwnerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyLeagueInfo_OwnerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyLeagueInfo_OwnerInfo* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyLeagueInfo_OwnerInfo*>(
               &_CMsgDOTAFantasyLeagueInfo_OwnerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(CMsgDOTAFantasyLeagueInfo_OwnerInfo* other);
  friend void swap(CMsgDOTAFantasyLeagueInfo_OwnerInfo& a, CMsgDOTAFantasyLeagueInfo_OwnerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyLeagueInfo_OwnerInfo* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueInfo_OwnerInfo>(nullptr);
  }

  CMsgDOTAFantasyLeagueInfo_OwnerInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueInfo_OwnerInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyLeagueInfo_OwnerInfo& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueInfo_OwnerInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyLeagueInfo_OwnerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 player_account_id = 3;
  int player_account_id_size() const;
  void clear_player_account_id();
  static const int kPlayerAccountIdFieldNumber = 3;
  ::google::protobuf::uint32 player_account_id(int index) const;
  void set_player_account_id(int index, ::google::protobuf::uint32 value);
  void add_player_account_id(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      player_account_id() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_player_account_id();

  // optional uint32 owner_account_id = 1;
  bool has_owner_account_id() const;
  void clear_owner_account_id();
  static const int kOwnerAccountIdFieldNumber = 1;
  ::google::protobuf::uint32 owner_account_id() const;
  void set_owner_account_id(::google::protobuf::uint32 value);

  // optional bool left_league = 2;
  bool has_left_league() const;
  void clear_left_league();
  static const int kLeftLeagueFieldNumber = 2;
  bool left_league() const;
  void set_left_league(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyLeagueInfo.OwnerInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > player_account_id_;
  ::google::protobuf::uint32 owner_account_id_;
  bool left_league_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyLeagueInfo) */ {
 public:
  CMsgDOTAFantasyLeagueInfo();
  virtual ~CMsgDOTAFantasyLeagueInfo();

  CMsgDOTAFantasyLeagueInfo(const CMsgDOTAFantasyLeagueInfo& from);

  inline CMsgDOTAFantasyLeagueInfo& operator=(const CMsgDOTAFantasyLeagueInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyLeagueInfo(CMsgDOTAFantasyLeagueInfo&& from) noexcept
    : CMsgDOTAFantasyLeagueInfo() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyLeagueInfo& operator=(CMsgDOTAFantasyLeagueInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyLeagueInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyLeagueInfo* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyLeagueInfo*>(
               &_CMsgDOTAFantasyLeagueInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(CMsgDOTAFantasyLeagueInfo* other);
  friend void swap(CMsgDOTAFantasyLeagueInfo& a, CMsgDOTAFantasyLeagueInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyLeagueInfo* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueInfo>(nullptr);
  }

  CMsgDOTAFantasyLeagueInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyLeagueInfo& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyLeagueInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyLeagueInfo_OwnerInfo OwnerInfo;

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTAFantasyLeagueInfo.OwnerInfo owner_info = 25;
  int owner_info_size() const;
  void clear_owner_info();
  static const int kOwnerInfoFieldNumber = 25;
  ::proto::dota::CMsgDOTAFantasyLeagueInfo_OwnerInfo* mutable_owner_info(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyLeagueInfo_OwnerInfo >*
      mutable_owner_info();
  const ::proto::dota::CMsgDOTAFantasyLeagueInfo_OwnerInfo& owner_info(int index) const;
  ::proto::dota::CMsgDOTAFantasyLeagueInfo_OwnerInfo* add_owner_info();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyLeagueInfo_OwnerInfo >&
      owner_info() const;

  // repeated uint32 players = 26;
  int players_size() const;
  void clear_players();
  static const int kPlayersFieldNumber = 26;
  ::google::protobuf::uint32 players(int index) const;
  void set_players(int index, ::google::protobuf::uint32 value);
  void add_players(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      players() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_players();

  // optional string fantasy_league_name = 3;
  bool has_fantasy_league_name() const;
  void clear_fantasy_league_name();
  static const int kFantasyLeagueNameFieldNumber = 3;
  const ::std::string& fantasy_league_name() const;
  void set_fantasy_league_name(const ::std::string& value);
  #if LANG_CXX11
  void set_fantasy_league_name(::std::string&& value);
  #endif
  void set_fantasy_league_name(const char* value);
  void set_fantasy_league_name(const char* value, size_t size);
  ::std::string* mutable_fantasy_league_name();
  ::std::string* release_fantasy_league_name();
  void set_allocated_fantasy_league_name(::std::string* fantasy_league_name);

  // optional string password = 29;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 29;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // optional .proto.dota.CMsgFantasyLeagueScoring scoring = 7;
  bool has_scoring() const;
  void clear_scoring();
  static const int kScoringFieldNumber = 7;
  const ::proto::dota::CMsgFantasyLeagueScoring& scoring() const;
  ::proto::dota::CMsgFantasyLeagueScoring* release_scoring();
  ::proto::dota::CMsgFantasyLeagueScoring* mutable_scoring();
  void set_allocated_scoring(::proto::dota::CMsgFantasyLeagueScoring* scoring);

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 commissioner_account_id = 2;
  bool has_commissioner_account_id() const;
  void clear_commissioner_account_id();
  static const int kCommissionerAccountIdFieldNumber = 2;
  ::google::protobuf::uint32 commissioner_account_id() const;
  void set_commissioner_account_id(::google::protobuf::uint32 value);

  // optional .proto.dota.Fantasy_Selection_Mode selection_mode = 4 [default = FANTASY_SELECTION_INVALID];
  bool has_selection_mode() const;
  void clear_selection_mode();
  static const int kSelectionModeFieldNumber = 4;
  ::proto::dota::Fantasy_Selection_Mode selection_mode() const;
  void set_selection_mode(::proto::dota::Fantasy_Selection_Mode value);

  // optional uint32 team_count = 5;
  bool has_team_count() const;
  void clear_team_count();
  static const int kTeamCountFieldNumber = 5;
  ::google::protobuf::uint32 team_count() const;
  void set_team_count(::google::protobuf::uint32 value);

  // optional uint64 logo = 6;
  bool has_logo() const;
  void clear_logo();
  static const int kLogoFieldNumber = 6;
  ::google::protobuf::uint64 logo() const;
  void set_logo(::google::protobuf::uint64 value);

  // optional uint32 draft_time = 12;
  bool has_draft_time() const;
  void clear_draft_time();
  static const int kDraftTimeFieldNumber = 12;
  ::google::protobuf::uint32 draft_time() const;
  void set_draft_time(::google::protobuf::uint32 value);

  // optional uint32 draft_pick_time = 13;
  bool has_draft_pick_time() const;
  void clear_draft_pick_time();
  static const int kDraftPickTimeFieldNumber = 13;
  ::google::protobuf::uint32 draft_pick_time() const;
  void set_draft_pick_time(::google::protobuf::uint32 value);

  // optional uint32 season_start = 15;
  bool has_season_start() const;
  void clear_season_start();
  static const int kSeasonStartFieldNumber = 15;
  ::google::protobuf::uint32 season_start() const;
  void set_season_start(::google::protobuf::uint32 value);

  // optional uint32 season_length = 16;
  bool has_season_length() const;
  void clear_season_length();
  static const int kSeasonLengthFieldNumber = 16;
  ::google::protobuf::uint32 season_length() const;
  void set_season_length(::google::protobuf::uint32 value);

  // optional uint32 veto_votes = 17;
  bool has_veto_votes() const;
  void clear_veto_votes();
  static const int kVetoVotesFieldNumber = 17;
  ::google::protobuf::uint32 veto_votes() const;
  void set_veto_votes(::google::protobuf::uint32 value);

  // optional uint32 acquisitions = 18;
  bool has_acquisitions() const;
  void clear_acquisitions();
  static const int kAcquisitionsFieldNumber = 18;
  ::google::protobuf::uint32 acquisitions() const;
  void set_acquisitions(::google::protobuf::uint32 value);

  // optional uint32 slot_1 = 19;
  bool has_slot_1() const;
  void clear_slot_1();
  static const int kSlot1FieldNumber = 19;
  ::google::protobuf::uint32 slot_1() const;
  void set_slot_1(::google::protobuf::uint32 value);

  // optional uint32 slot_2 = 20;
  bool has_slot_2() const;
  void clear_slot_2();
  static const int kSlot2FieldNumber = 20;
  ::google::protobuf::uint32 slot_2() const;
  void set_slot_2(::google::protobuf::uint32 value);

  // optional uint32 slot_3 = 21;
  bool has_slot_3() const;
  void clear_slot_3();
  static const int kSlot3FieldNumber = 21;
  ::google::protobuf::uint32 slot_3() const;
  void set_slot_3(::google::protobuf::uint32 value);

  // optional uint32 slot_4 = 22;
  bool has_slot_4() const;
  void clear_slot_4();
  static const int kSlot4FieldNumber = 22;
  ::google::protobuf::uint32 slot_4() const;
  void set_slot_4(::google::protobuf::uint32 value);

  // optional uint32 slot_5 = 23;
  bool has_slot_5() const;
  void clear_slot_5();
  static const int kSlot5FieldNumber = 23;
  ::google::protobuf::uint32 slot_5() const;
  void set_slot_5(::google::protobuf::uint32 value);

  // optional uint32 bench_slots = 24;
  bool has_bench_slots() const;
  void clear_bench_slots();
  static const int kBenchSlotsFieldNumber = 24;
  ::google::protobuf::uint32 bench_slots() const;
  void set_bench_slots(::google::protobuf::uint32 value);

  // optional uint32 time_zone = 27;
  bool has_time_zone() const;
  void clear_time_zone();
  static const int kTimeZoneFieldNumber = 27;
  ::google::protobuf::uint32 time_zone() const;
  void set_time_zone(::google::protobuf::uint32 value);

  // optional uint32 season = 28;
  bool has_season() const;
  void clear_season();
  static const int kSeasonFieldNumber = 28;
  ::google::protobuf::uint32 season() const;
  void set_season(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyLeagueInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyLeagueInfo_OwnerInfo > owner_info_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > players_;
  ::google::protobuf::internal::ArenaStringPtr fantasy_league_name_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::proto::dota::CMsgFantasyLeagueScoring* scoring_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 commissioner_account_id_;
  int selection_mode_;
  ::google::protobuf::uint32 team_count_;
  ::google::protobuf::uint64 logo_;
  ::google::protobuf::uint32 draft_time_;
  ::google::protobuf::uint32 draft_pick_time_;
  ::google::protobuf::uint32 season_start_;
  ::google::protobuf::uint32 season_length_;
  ::google::protobuf::uint32 veto_votes_;
  ::google::protobuf::uint32 acquisitions_;
  ::google::protobuf::uint32 slot_1_;
  ::google::protobuf::uint32 slot_2_;
  ::google::protobuf::uint32 slot_3_;
  ::google::protobuf::uint32 slot_4_;
  ::google::protobuf::uint32 slot_5_;
  ::google::protobuf::uint32 bench_slots_;
  ::google::protobuf::uint32 time_zone_;
  ::google::protobuf::uint32 season_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueEditInfoRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyLeagueEditInfoRequest) */ {
 public:
  CMsgDOTAFantasyLeagueEditInfoRequest();
  virtual ~CMsgDOTAFantasyLeagueEditInfoRequest();

  CMsgDOTAFantasyLeagueEditInfoRequest(const CMsgDOTAFantasyLeagueEditInfoRequest& from);

  inline CMsgDOTAFantasyLeagueEditInfoRequest& operator=(const CMsgDOTAFantasyLeagueEditInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyLeagueEditInfoRequest(CMsgDOTAFantasyLeagueEditInfoRequest&& from) noexcept
    : CMsgDOTAFantasyLeagueEditInfoRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyLeagueEditInfoRequest& operator=(CMsgDOTAFantasyLeagueEditInfoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyLeagueEditInfoRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyLeagueEditInfoRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyLeagueEditInfoRequest*>(
               &_CMsgDOTAFantasyLeagueEditInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(CMsgDOTAFantasyLeagueEditInfoRequest* other);
  friend void swap(CMsgDOTAFantasyLeagueEditInfoRequest& a, CMsgDOTAFantasyLeagueEditInfoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyLeagueEditInfoRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueEditInfoRequest>(nullptr);
  }

  CMsgDOTAFantasyLeagueEditInfoRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueEditInfoRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyLeagueEditInfoRequest& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueEditInfoRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyLeagueEditInfoRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgDOTAFantasyLeagueInfo edit_info = 2;
  bool has_edit_info() const;
  void clear_edit_info();
  static const int kEditInfoFieldNumber = 2;
  const ::proto::dota::CMsgDOTAFantasyLeagueInfo& edit_info() const;
  ::proto::dota::CMsgDOTAFantasyLeagueInfo* release_edit_info();
  ::proto::dota::CMsgDOTAFantasyLeagueInfo* mutable_edit_info();
  void set_allocated_edit_info(::proto::dota::CMsgDOTAFantasyLeagueInfo* edit_info);

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyLeagueEditInfoRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::proto::dota::CMsgDOTAFantasyLeagueInfo* edit_info_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueEditInfoResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyLeagueEditInfoResponse) */ {
 public:
  CMsgDOTAFantasyLeagueEditInfoResponse();
  virtual ~CMsgDOTAFantasyLeagueEditInfoResponse();

  CMsgDOTAFantasyLeagueEditInfoResponse(const CMsgDOTAFantasyLeagueEditInfoResponse& from);

  inline CMsgDOTAFantasyLeagueEditInfoResponse& operator=(const CMsgDOTAFantasyLeagueEditInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyLeagueEditInfoResponse(CMsgDOTAFantasyLeagueEditInfoResponse&& from) noexcept
    : CMsgDOTAFantasyLeagueEditInfoResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyLeagueEditInfoResponse& operator=(CMsgDOTAFantasyLeagueEditInfoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyLeagueEditInfoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyLeagueEditInfoResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyLeagueEditInfoResponse*>(
               &_CMsgDOTAFantasyLeagueEditInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(CMsgDOTAFantasyLeagueEditInfoResponse* other);
  friend void swap(CMsgDOTAFantasyLeagueEditInfoResponse& a, CMsgDOTAFantasyLeagueEditInfoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyLeagueEditInfoResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueEditInfoResponse>(nullptr);
  }

  CMsgDOTAFantasyLeagueEditInfoResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueEditInfoResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyLeagueEditInfoResponse& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueEditInfoResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyLeagueEditInfoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyLeagueEditInfoResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTAFantasyLeagueEditInfoResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTAFantasyLeagueEditInfoResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NO_PERMISSION =
    CMsgDOTAFantasyLeagueEditInfoResponse_EResult_ERROR_NO_PERMISSION;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyLeagueEditInfoResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyLeagueEditInfoResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyLeagueEditInfoResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyLeagueEditInfoResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyLeagueEditInfoResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyLeagueEditInfoResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyLeagueEditInfoResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgDOTAFantasyLeagueEditInfoResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyLeagueEditInfoResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTAFantasyLeagueEditInfoResponse_EResult value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyLeagueEditInfoResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int result_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueFindRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyLeagueFindRequest) */ {
 public:
  CMsgDOTAFantasyLeagueFindRequest();
  virtual ~CMsgDOTAFantasyLeagueFindRequest();

  CMsgDOTAFantasyLeagueFindRequest(const CMsgDOTAFantasyLeagueFindRequest& from);

  inline CMsgDOTAFantasyLeagueFindRequest& operator=(const CMsgDOTAFantasyLeagueFindRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyLeagueFindRequest(CMsgDOTAFantasyLeagueFindRequest&& from) noexcept
    : CMsgDOTAFantasyLeagueFindRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyLeagueFindRequest& operator=(CMsgDOTAFantasyLeagueFindRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyLeagueFindRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyLeagueFindRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyLeagueFindRequest*>(
               &_CMsgDOTAFantasyLeagueFindRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(CMsgDOTAFantasyLeagueFindRequest* other);
  friend void swap(CMsgDOTAFantasyLeagueFindRequest& a, CMsgDOTAFantasyLeagueFindRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyLeagueFindRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueFindRequest>(nullptr);
  }

  CMsgDOTAFantasyLeagueFindRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueFindRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyLeagueFindRequest& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueFindRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyLeagueFindRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string password = 2;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyLeagueFindRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueFindResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyLeagueFindResponse) */ {
 public:
  CMsgDOTAFantasyLeagueFindResponse();
  virtual ~CMsgDOTAFantasyLeagueFindResponse();

  CMsgDOTAFantasyLeagueFindResponse(const CMsgDOTAFantasyLeagueFindResponse& from);

  inline CMsgDOTAFantasyLeagueFindResponse& operator=(const CMsgDOTAFantasyLeagueFindResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyLeagueFindResponse(CMsgDOTAFantasyLeagueFindResponse&& from) noexcept
    : CMsgDOTAFantasyLeagueFindResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyLeagueFindResponse& operator=(CMsgDOTAFantasyLeagueFindResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyLeagueFindResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyLeagueFindResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyLeagueFindResponse*>(
               &_CMsgDOTAFantasyLeagueFindResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(CMsgDOTAFantasyLeagueFindResponse* other);
  friend void swap(CMsgDOTAFantasyLeagueFindResponse& a, CMsgDOTAFantasyLeagueFindResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyLeagueFindResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueFindResponse>(nullptr);
  }

  CMsgDOTAFantasyLeagueFindResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueFindResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyLeagueFindResponse& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueFindResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyLeagueFindResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyLeagueFindResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTAFantasyLeagueFindResponse_EResult_SUCCESS;
  static const EResult ERROR_LEAGUE_NOT_FOUND =
    CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_LEAGUE_NOT_FOUND;
  static const EResult ERROR_BAD_PASSWORD =
    CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_BAD_PASSWORD;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_FULL =
    CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_FULL;
  static const EResult ERROR_ALREADY_MEMBER =
    CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_ALREADY_MEMBER;
  static const EResult ERROR_LEAGUE_LOCKED =
    CMsgDOTAFantasyLeagueFindResponse_EResult_ERROR_LEAGUE_LOCKED;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyLeagueFindResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyLeagueFindResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyLeagueFindResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyLeagueFindResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyLeagueFindResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyLeagueFindResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyLeagueFindResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string fantasy_league_name = 2;
  bool has_fantasy_league_name() const;
  void clear_fantasy_league_name();
  static const int kFantasyLeagueNameFieldNumber = 2;
  const ::std::string& fantasy_league_name() const;
  void set_fantasy_league_name(const ::std::string& value);
  #if LANG_CXX11
  void set_fantasy_league_name(::std::string&& value);
  #endif
  void set_fantasy_league_name(const char* value);
  void set_fantasy_league_name(const char* value, size_t size);
  ::std::string* mutable_fantasy_league_name();
  ::std::string* release_fantasy_league_name();
  void set_allocated_fantasy_league_name(::std::string* fantasy_league_name);

  // optional string commissioner_name = 3;
  bool has_commissioner_name() const;
  void clear_commissioner_name();
  static const int kCommissionerNameFieldNumber = 3;
  const ::std::string& commissioner_name() const;
  void set_commissioner_name(const ::std::string& value);
  #if LANG_CXX11
  void set_commissioner_name(::std::string&& value);
  #endif
  void set_commissioner_name(const char* value);
  void set_commissioner_name(const char* value, size_t size);
  ::std::string* mutable_commissioner_name();
  ::std::string* release_commissioner_name();
  void set_allocated_commissioner_name(::std::string* commissioner_name);

  // optional .proto.dota.CMsgDOTAFantasyLeagueFindResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyLeagueFindResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTAFantasyLeagueFindResponse_EResult value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyLeagueFindResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr fantasy_league_name_;
  ::google::protobuf::internal::ArenaStringPtr commissioner_name_;
  int result_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueInfoRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyLeagueInfoRequest) */ {
 public:
  CMsgDOTAFantasyLeagueInfoRequest();
  virtual ~CMsgDOTAFantasyLeagueInfoRequest();

  CMsgDOTAFantasyLeagueInfoRequest(const CMsgDOTAFantasyLeagueInfoRequest& from);

  inline CMsgDOTAFantasyLeagueInfoRequest& operator=(const CMsgDOTAFantasyLeagueInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyLeagueInfoRequest(CMsgDOTAFantasyLeagueInfoRequest&& from) noexcept
    : CMsgDOTAFantasyLeagueInfoRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyLeagueInfoRequest& operator=(CMsgDOTAFantasyLeagueInfoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyLeagueInfoRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyLeagueInfoRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyLeagueInfoRequest*>(
               &_CMsgDOTAFantasyLeagueInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(CMsgDOTAFantasyLeagueInfoRequest* other);
  friend void swap(CMsgDOTAFantasyLeagueInfoRequest& a, CMsgDOTAFantasyLeagueInfoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyLeagueInfoRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueInfoRequest>(nullptr);
  }

  CMsgDOTAFantasyLeagueInfoRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueInfoRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyLeagueInfoRequest& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueInfoRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyLeagueInfoRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyLeagueInfoRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueInfoResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyLeagueInfoResponse) */ {
 public:
  CMsgDOTAFantasyLeagueInfoResponse();
  virtual ~CMsgDOTAFantasyLeagueInfoResponse();

  CMsgDOTAFantasyLeagueInfoResponse(const CMsgDOTAFantasyLeagueInfoResponse& from);

  inline CMsgDOTAFantasyLeagueInfoResponse& operator=(const CMsgDOTAFantasyLeagueInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyLeagueInfoResponse(CMsgDOTAFantasyLeagueInfoResponse&& from) noexcept
    : CMsgDOTAFantasyLeagueInfoResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyLeagueInfoResponse& operator=(CMsgDOTAFantasyLeagueInfoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyLeagueInfoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyLeagueInfoResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyLeagueInfoResponse*>(
               &_CMsgDOTAFantasyLeagueInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(CMsgDOTAFantasyLeagueInfoResponse* other);
  friend void swap(CMsgDOTAFantasyLeagueInfoResponse& a, CMsgDOTAFantasyLeagueInfoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyLeagueInfoResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueInfoResponse>(nullptr);
  }

  CMsgDOTAFantasyLeagueInfoResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueInfoResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyLeagueInfoResponse& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueInfoResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyLeagueInfoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyLeagueInfoResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTAFantasyLeagueInfoResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTAFantasyLeagueInfoResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_BAD_LEAGUE_ID =
    CMsgDOTAFantasyLeagueInfoResponse_EResult_ERROR_BAD_LEAGUE_ID;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyLeagueInfoResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyLeagueInfoResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyLeagueInfoResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyLeagueInfoResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyLeagueInfoResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyLeagueInfoResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyLeagueInfoResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgDOTAFantasyLeagueInfoResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyLeagueInfoResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTAFantasyLeagueInfoResponse_EResult value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyLeagueInfoResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int result_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueMatchupsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyLeagueMatchupsRequest) */ {
 public:
  CMsgDOTAFantasyLeagueMatchupsRequest();
  virtual ~CMsgDOTAFantasyLeagueMatchupsRequest();

  CMsgDOTAFantasyLeagueMatchupsRequest(const CMsgDOTAFantasyLeagueMatchupsRequest& from);

  inline CMsgDOTAFantasyLeagueMatchupsRequest& operator=(const CMsgDOTAFantasyLeagueMatchupsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyLeagueMatchupsRequest(CMsgDOTAFantasyLeagueMatchupsRequest&& from) noexcept
    : CMsgDOTAFantasyLeagueMatchupsRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyLeagueMatchupsRequest& operator=(CMsgDOTAFantasyLeagueMatchupsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyLeagueMatchupsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyLeagueMatchupsRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyLeagueMatchupsRequest*>(
               &_CMsgDOTAFantasyLeagueMatchupsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(CMsgDOTAFantasyLeagueMatchupsRequest* other);
  friend void swap(CMsgDOTAFantasyLeagueMatchupsRequest& a, CMsgDOTAFantasyLeagueMatchupsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyLeagueMatchupsRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueMatchupsRequest>(nullptr);
  }

  CMsgDOTAFantasyLeagueMatchupsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueMatchupsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyLeagueMatchupsRequest& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueMatchupsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyLeagueMatchupsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyLeagueMatchupsRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueMatchupsResponse_Matchup final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.Matchup) */ {
 public:
  CMsgDOTAFantasyLeagueMatchupsResponse_Matchup();
  virtual ~CMsgDOTAFantasyLeagueMatchupsResponse_Matchup();

  CMsgDOTAFantasyLeagueMatchupsResponse_Matchup(const CMsgDOTAFantasyLeagueMatchupsResponse_Matchup& from);

  inline CMsgDOTAFantasyLeagueMatchupsResponse_Matchup& operator=(const CMsgDOTAFantasyLeagueMatchupsResponse_Matchup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyLeagueMatchupsResponse_Matchup(CMsgDOTAFantasyLeagueMatchupsResponse_Matchup&& from) noexcept
    : CMsgDOTAFantasyLeagueMatchupsResponse_Matchup() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyLeagueMatchupsResponse_Matchup& operator=(CMsgDOTAFantasyLeagueMatchupsResponse_Matchup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyLeagueMatchupsResponse_Matchup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyLeagueMatchupsResponse_Matchup* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyLeagueMatchupsResponse_Matchup*>(
               &_CMsgDOTAFantasyLeagueMatchupsResponse_Matchup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(CMsgDOTAFantasyLeagueMatchupsResponse_Matchup* other);
  friend void swap(CMsgDOTAFantasyLeagueMatchupsResponse_Matchup& a, CMsgDOTAFantasyLeagueMatchupsResponse_Matchup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyLeagueMatchupsResponse_Matchup* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueMatchupsResponse_Matchup>(nullptr);
  }

  CMsgDOTAFantasyLeagueMatchupsResponse_Matchup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueMatchupsResponse_Matchup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyLeagueMatchupsResponse_Matchup& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueMatchupsResponse_Matchup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyLeagueMatchupsResponse_Matchup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 owner_account_id_1 = 1;
  bool has_owner_account_id_1() const;
  void clear_owner_account_id_1();
  static const int kOwnerAccountId1FieldNumber = 1;
  ::google::protobuf::uint32 owner_account_id_1() const;
  void set_owner_account_id_1(::google::protobuf::uint32 value);

  // optional uint32 owner_account_id_2 = 2;
  bool has_owner_account_id_2() const;
  void clear_owner_account_id_2();
  static const int kOwnerAccountId2FieldNumber = 2;
  ::google::protobuf::uint32 owner_account_id_2() const;
  void set_owner_account_id_2(::google::protobuf::uint32 value);

  // optional float score_1 = 3;
  bool has_score_1() const;
  void clear_score_1();
  static const int kScore1FieldNumber = 3;
  float score_1() const;
  void set_score_1(float value);

  // optional float score_2 = 4;
  bool has_score_2() const;
  void clear_score_2();
  static const int kScore2FieldNumber = 4;
  float score_2() const;
  void set_score_2(float value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.Matchup)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 owner_account_id_1_;
  ::google::protobuf::uint32 owner_account_id_2_;
  float score_1_;
  float score_2_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups) */ {
 public:
  CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups();
  virtual ~CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups();

  CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups(const CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups& from);

  inline CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups& operator=(const CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups(CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups&& from) noexcept
    : CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups& operator=(CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups*>(
               &_CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups* other);
  friend void swap(CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups& a, CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups>(nullptr);
  }

  CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.Matchup matchup = 1;
  int matchup_size() const;
  void clear_matchup();
  static const int kMatchupFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_Matchup* mutable_matchup(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_Matchup >*
      mutable_matchup();
  const ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_Matchup& matchup(int index) const;
  ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_Matchup* add_matchup();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_Matchup >&
      matchup() const;

  // optional uint32 start_time = 2;
  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 2;
  ::google::protobuf::uint32 start_time() const;
  void set_start_time(::google::protobuf::uint32 value);

  // optional uint32 end_time = 3;
  bool has_end_time() const;
  void clear_end_time();
  static const int kEndTimeFieldNumber = 3;
  ::google::protobuf::uint32 end_time() const;
  void set_end_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_Matchup > matchup_;
  ::google::protobuf::uint32 start_time_;
  ::google::protobuf::uint32 end_time_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueMatchupsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse) */ {
 public:
  CMsgDOTAFantasyLeagueMatchupsResponse();
  virtual ~CMsgDOTAFantasyLeagueMatchupsResponse();

  CMsgDOTAFantasyLeagueMatchupsResponse(const CMsgDOTAFantasyLeagueMatchupsResponse& from);

  inline CMsgDOTAFantasyLeagueMatchupsResponse& operator=(const CMsgDOTAFantasyLeagueMatchupsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyLeagueMatchupsResponse(CMsgDOTAFantasyLeagueMatchupsResponse&& from) noexcept
    : CMsgDOTAFantasyLeagueMatchupsResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyLeagueMatchupsResponse& operator=(CMsgDOTAFantasyLeagueMatchupsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyLeagueMatchupsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyLeagueMatchupsResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyLeagueMatchupsResponse*>(
               &_CMsgDOTAFantasyLeagueMatchupsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(CMsgDOTAFantasyLeagueMatchupsResponse* other);
  friend void swap(CMsgDOTAFantasyLeagueMatchupsResponse& a, CMsgDOTAFantasyLeagueMatchupsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyLeagueMatchupsResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueMatchupsResponse>(nullptr);
  }

  CMsgDOTAFantasyLeagueMatchupsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueMatchupsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyLeagueMatchupsResponse& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueMatchupsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyLeagueMatchupsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyLeagueMatchupsResponse_Matchup Matchup;
  typedef CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups WeeklyMatchups;

  typedef CMsgDOTAFantasyLeagueMatchupsResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTAFantasyLeagueMatchupsResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTAFantasyLeagueMatchupsResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_BAD_LEAGUE_ID =
    CMsgDOTAFantasyLeagueMatchupsResponse_EResult_ERROR_BAD_LEAGUE_ID;
  static const EResult ERROR_NO_PERMISSION =
    CMsgDOTAFantasyLeagueMatchupsResponse_EResult_ERROR_NO_PERMISSION;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyLeagueMatchupsResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyLeagueMatchupsResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyLeagueMatchupsResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyLeagueMatchupsResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyLeagueMatchupsResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyLeagueMatchupsResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyLeagueMatchupsResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups weekly_matchups = 3;
  int weekly_matchups_size() const;
  void clear_weekly_matchups();
  static const int kWeeklyMatchupsFieldNumber = 3;
  ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups* mutable_weekly_matchups(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups >*
      mutable_weekly_matchups();
  const ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups& weekly_matchups(int index) const;
  ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups* add_weekly_matchups();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups >&
      weekly_matchups() const;

  // optional .proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_EResult value);

  // optional uint32 fantasy_league_id = 2;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 2;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups > weekly_matchups_;
  int result_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAEditFantasyTeamRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAEditFantasyTeamRequest) */ {
 public:
  CMsgDOTAEditFantasyTeamRequest();
  virtual ~CMsgDOTAEditFantasyTeamRequest();

  CMsgDOTAEditFantasyTeamRequest(const CMsgDOTAEditFantasyTeamRequest& from);

  inline CMsgDOTAEditFantasyTeamRequest& operator=(const CMsgDOTAEditFantasyTeamRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAEditFantasyTeamRequest(CMsgDOTAEditFantasyTeamRequest&& from) noexcept
    : CMsgDOTAEditFantasyTeamRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAEditFantasyTeamRequest& operator=(CMsgDOTAEditFantasyTeamRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAEditFantasyTeamRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAEditFantasyTeamRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAEditFantasyTeamRequest*>(
               &_CMsgDOTAEditFantasyTeamRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(CMsgDOTAEditFantasyTeamRequest* other);
  friend void swap(CMsgDOTAEditFantasyTeamRequest& a, CMsgDOTAEditFantasyTeamRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAEditFantasyTeamRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAEditFantasyTeamRequest>(nullptr);
  }

  CMsgDOTAEditFantasyTeamRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAEditFantasyTeamRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAEditFantasyTeamRequest& from);
  void MergeFrom(const CMsgDOTAEditFantasyTeamRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAEditFantasyTeamRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string team_name = 3;
  bool has_team_name() const;
  void clear_team_name();
  static const int kTeamNameFieldNumber = 3;
  const ::std::string& team_name() const;
  void set_team_name(const ::std::string& value);
  #if LANG_CXX11
  void set_team_name(::std::string&& value);
  #endif
  void set_team_name(const char* value);
  void set_team_name(const char* value, size_t size);
  ::std::string* mutable_team_name();
  ::std::string* release_team_name();
  void set_allocated_team_name(::std::string* team_name);

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 team_index = 2;
  bool has_team_index() const;
  void clear_team_index();
  static const int kTeamIndexFieldNumber = 2;
  ::google::protobuf::uint32 team_index() const;
  void set_team_index(::google::protobuf::uint32 value);

  // optional uint64 team_logo = 4;
  bool has_team_logo() const;
  void clear_team_logo();
  static const int kTeamLogoFieldNumber = 4;
  ::google::protobuf::uint64 team_logo() const;
  void set_team_logo(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAEditFantasyTeamRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr team_name_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 team_index_;
  ::google::protobuf::uint64 team_logo_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAEditFantasyTeamResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAEditFantasyTeamResponse) */ {
 public:
  CMsgDOTAEditFantasyTeamResponse();
  virtual ~CMsgDOTAEditFantasyTeamResponse();

  CMsgDOTAEditFantasyTeamResponse(const CMsgDOTAEditFantasyTeamResponse& from);

  inline CMsgDOTAEditFantasyTeamResponse& operator=(const CMsgDOTAEditFantasyTeamResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAEditFantasyTeamResponse(CMsgDOTAEditFantasyTeamResponse&& from) noexcept
    : CMsgDOTAEditFantasyTeamResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAEditFantasyTeamResponse& operator=(CMsgDOTAEditFantasyTeamResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAEditFantasyTeamResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAEditFantasyTeamResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAEditFantasyTeamResponse*>(
               &_CMsgDOTAEditFantasyTeamResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(CMsgDOTAEditFantasyTeamResponse* other);
  friend void swap(CMsgDOTAEditFantasyTeamResponse& a, CMsgDOTAEditFantasyTeamResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAEditFantasyTeamResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAEditFantasyTeamResponse>(nullptr);
  }

  CMsgDOTAEditFantasyTeamResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAEditFantasyTeamResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAEditFantasyTeamResponse& from);
  void MergeFrom(const CMsgDOTAEditFantasyTeamResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAEditFantasyTeamResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAEditFantasyTeamResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTAEditFantasyTeamResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTAEditFantasyTeamResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_INVALID_TEAM_INFO =
    CMsgDOTAEditFantasyTeamResponse_EResult_ERROR_INVALID_TEAM_INFO;
  static const EResult ERROR_NAME_ALREADY_TAKEN =
    CMsgDOTAEditFantasyTeamResponse_EResult_ERROR_NAME_ALREADY_TAKEN;
  static const EResult ERROR_NO_PERMISSION =
    CMsgDOTAEditFantasyTeamResponse_EResult_ERROR_NO_PERMISSION;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAEditFantasyTeamResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAEditFantasyTeamResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAEditFantasyTeamResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAEditFantasyTeamResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAEditFantasyTeamResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAEditFantasyTeamResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAEditFantasyTeamResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgDOTAEditFantasyTeamResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTAEditFantasyTeamResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTAEditFantasyTeamResponse_EResult value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAEditFantasyTeamResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int result_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID) */ {
 public:
  CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID();
  virtual ~CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID();

  CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID(const CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID& from);

  inline CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID& operator=(const CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID(CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID&& from) noexcept
    : CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID& operator=(CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID*>(
               &_CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID* other);
  friend void swap(CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID& a, CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID>(nullptr);
  }

  CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID& from);
  void MergeFrom(const CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID) */ {
 public:
  CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID();
  virtual ~CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID();

  CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID(const CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID& from);

  inline CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID& operator=(const CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID(CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID&& from) noexcept
    : CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID& operator=(CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID*>(
               &_CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID* other);
  friend void swap(CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID& a, CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID>(nullptr);
  }

  CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID& from);
  void MergeFrom(const CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 owner_account_id = 1;
  bool has_owner_account_id() const;
  void clear_owner_account_id();
  static const int kOwnerAccountIdFieldNumber = 1;
  ::google::protobuf::uint32 owner_account_id() const;
  void set_owner_account_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 owner_account_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamInfoResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyTeamInfoResponse) */ {
 public:
  CMsgDOTAFantasyTeamInfoResponse();
  virtual ~CMsgDOTAFantasyTeamInfoResponse();

  CMsgDOTAFantasyTeamInfoResponse(const CMsgDOTAFantasyTeamInfoResponse& from);

  inline CMsgDOTAFantasyTeamInfoResponse& operator=(const CMsgDOTAFantasyTeamInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyTeamInfoResponse(CMsgDOTAFantasyTeamInfoResponse&& from) noexcept
    : CMsgDOTAFantasyTeamInfoResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyTeamInfoResponse& operator=(CMsgDOTAFantasyTeamInfoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyTeamInfoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyTeamInfoResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyTeamInfoResponse*>(
               &_CMsgDOTAFantasyTeamInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(CMsgDOTAFantasyTeamInfoResponse* other);
  friend void swap(CMsgDOTAFantasyTeamInfoResponse& a, CMsgDOTAFantasyTeamInfoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyTeamInfoResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamInfoResponse>(nullptr);
  }

  CMsgDOTAFantasyTeamInfoResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamInfoResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyTeamInfoResponse& from);
  void MergeFrom(const CMsgDOTAFantasyTeamInfoResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyTeamInfoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTAFantasyTeamInfo results = 1;
  int results_size() const;
  void clear_results();
  static const int kResultsFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyTeamInfo* mutable_results(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyTeamInfo >*
      mutable_results();
  const ::proto::dota::CMsgDOTAFantasyTeamInfo& results(int index) const;
  ::proto::dota::CMsgDOTAFantasyTeamInfo* add_results();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyTeamInfo >&
      results() const;

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyTeamInfoResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyTeamInfo > results_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyTeamInfo) */ {
 public:
  CMsgDOTAFantasyTeamInfo();
  virtual ~CMsgDOTAFantasyTeamInfo();

  CMsgDOTAFantasyTeamInfo(const CMsgDOTAFantasyTeamInfo& from);

  inline CMsgDOTAFantasyTeamInfo& operator=(const CMsgDOTAFantasyTeamInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyTeamInfo(CMsgDOTAFantasyTeamInfo&& from) noexcept
    : CMsgDOTAFantasyTeamInfo() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyTeamInfo& operator=(CMsgDOTAFantasyTeamInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyTeamInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyTeamInfo* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyTeamInfo*>(
               &_CMsgDOTAFantasyTeamInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(CMsgDOTAFantasyTeamInfo* other);
  friend void swap(CMsgDOTAFantasyTeamInfo& a, CMsgDOTAFantasyTeamInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyTeamInfo* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamInfo>(nullptr);
  }

  CMsgDOTAFantasyTeamInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyTeamInfo& from);
  void MergeFrom(const CMsgDOTAFantasyTeamInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyTeamInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 current_roster = 8;
  int current_roster_size() const;
  void clear_current_roster();
  static const int kCurrentRosterFieldNumber = 8;
  ::google::protobuf::uint32 current_roster(int index) const;
  void set_current_roster(int index, ::google::protobuf::uint32 value);
  void add_current_roster(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      current_roster() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_current_roster();

  // optional string team_name = 4;
  bool has_team_name() const;
  void clear_team_name();
  static const int kTeamNameFieldNumber = 4;
  const ::std::string& team_name() const;
  void set_team_name(const ::std::string& value);
  #if LANG_CXX11
  void set_team_name(::std::string&& value);
  #endif
  void set_team_name(const char* value);
  void set_team_name(const char* value, size_t size);
  ::std::string* mutable_team_name();
  ::std::string* release_team_name();
  void set_allocated_team_name(::std::string* team_name);

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 owner_account_id = 2;
  bool has_owner_account_id() const;
  void clear_owner_account_id();
  static const int kOwnerAccountIdFieldNumber = 2;
  ::google::protobuf::uint32 owner_account_id() const;
  void set_owner_account_id(::google::protobuf::uint32 value);

  // optional uint32 fantasy_team_index = 3;
  bool has_fantasy_team_index() const;
  void clear_fantasy_team_index();
  static const int kFantasyTeamIndexFieldNumber = 3;
  ::google::protobuf::uint32 fantasy_team_index() const;
  void set_fantasy_team_index(::google::protobuf::uint32 value);

  // optional uint32 wins = 6;
  bool has_wins() const;
  void clear_wins();
  static const int kWinsFieldNumber = 6;
  ::google::protobuf::uint32 wins() const;
  void set_wins(::google::protobuf::uint32 value);

  // optional uint64 team_logo = 5;
  bool has_team_logo() const;
  void clear_team_logo();
  static const int kTeamLogoFieldNumber = 5;
  ::google::protobuf::uint64 team_logo() const;
  void set_team_logo(::google::protobuf::uint64 value);

  // optional uint32 losses = 7;
  bool has_losses() const;
  void clear_losses();
  static const int kLossesFieldNumber = 7;
  ::google::protobuf::uint32 losses() const;
  void set_losses(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyTeamInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > current_roster_;
  ::google::protobuf::internal::ArenaStringPtr team_name_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 owner_account_id_;
  ::google::protobuf::uint32 fantasy_team_index_;
  ::google::protobuf::uint32 wins_;
  ::google::protobuf::uint64 team_logo_;
  ::google::protobuf::uint32 losses_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamScoreRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyTeamScoreRequest) */ {
 public:
  CMsgDOTAFantasyTeamScoreRequest();
  virtual ~CMsgDOTAFantasyTeamScoreRequest();

  CMsgDOTAFantasyTeamScoreRequest(const CMsgDOTAFantasyTeamScoreRequest& from);

  inline CMsgDOTAFantasyTeamScoreRequest& operator=(const CMsgDOTAFantasyTeamScoreRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyTeamScoreRequest(CMsgDOTAFantasyTeamScoreRequest&& from) noexcept
    : CMsgDOTAFantasyTeamScoreRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyTeamScoreRequest& operator=(CMsgDOTAFantasyTeamScoreRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyTeamScoreRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyTeamScoreRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyTeamScoreRequest*>(
               &_CMsgDOTAFantasyTeamScoreRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(CMsgDOTAFantasyTeamScoreRequest* other);
  friend void swap(CMsgDOTAFantasyTeamScoreRequest& a, CMsgDOTAFantasyTeamScoreRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyTeamScoreRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamScoreRequest>(nullptr);
  }

  CMsgDOTAFantasyTeamScoreRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamScoreRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyTeamScoreRequest& from);
  void MergeFrom(const CMsgDOTAFantasyTeamScoreRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyTeamScoreRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 owner_account_id = 2;
  bool has_owner_account_id() const;
  void clear_owner_account_id();
  static const int kOwnerAccountIdFieldNumber = 2;
  ::google::protobuf::uint32 owner_account_id() const;
  void set_owner_account_id(::google::protobuf::uint32 value);

  // optional uint64 filter_match_id = 4;
  bool has_filter_match_id() const;
  void clear_filter_match_id();
  static const int kFilterMatchIdFieldNumber = 4;
  ::google::protobuf::uint64 filter_match_id() const;
  void set_filter_match_id(::google::protobuf::uint64 value);

  // optional uint32 fantasy_team_index = 3;
  bool has_fantasy_team_index() const;
  void clear_fantasy_team_index();
  static const int kFantasyTeamIndexFieldNumber = 3;
  ::google::protobuf::uint32 fantasy_team_index() const;
  void set_fantasy_team_index(::google::protobuf::uint32 value);

  // optional uint32 filter_start_time = 5;
  bool has_filter_start_time() const;
  void clear_filter_start_time();
  static const int kFilterStartTimeFieldNumber = 5;
  ::google::protobuf::uint32 filter_start_time() const;
  void set_filter_start_time(::google::protobuf::uint32 value);

  // optional uint32 filter_end_time = 6;
  bool has_filter_end_time() const;
  void clear_filter_end_time();
  static const int kFilterEndTimeFieldNumber = 6;
  ::google::protobuf::uint32 filter_end_time() const;
  void set_filter_end_time(::google::protobuf::uint32 value);

  // optional bool include_bench = 7;
  bool has_include_bench() const;
  void clear_include_bench();
  static const int kIncludeBenchFieldNumber = 7;
  bool include_bench() const;
  void set_include_bench(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyTeamScoreRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 owner_account_id_;
  ::google::protobuf::uint64 filter_match_id_;
  ::google::protobuf::uint32 fantasy_team_index_;
  ::google::protobuf::uint32 filter_start_time_;
  ::google::protobuf::uint32 filter_end_time_;
  bool include_bench_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore) */ {
 public:
  CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore();
  virtual ~CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore();

  CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore(const CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore& from);

  inline CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore& operator=(const CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore(CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore&& from) noexcept
    : CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore& operator=(CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore*>(
               &_CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore* other);
  friend void swap(CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore& a, CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore>(nullptr);
  }

  CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore& from);
  void MergeFrom(const CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 account_id = 1;
  bool has_account_id() const;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  ::google::protobuf::uint32 account_id() const;
  void set_account_id(::google::protobuf::uint32 value);

  // optional float score = 2;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 2;
  float score() const;
  void set_score(float value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 account_id_;
  float score_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamScoreResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyTeamScoreResponse) */ {
 public:
  CMsgDOTAFantasyTeamScoreResponse();
  virtual ~CMsgDOTAFantasyTeamScoreResponse();

  CMsgDOTAFantasyTeamScoreResponse(const CMsgDOTAFantasyTeamScoreResponse& from);

  inline CMsgDOTAFantasyTeamScoreResponse& operator=(const CMsgDOTAFantasyTeamScoreResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyTeamScoreResponse(CMsgDOTAFantasyTeamScoreResponse&& from) noexcept
    : CMsgDOTAFantasyTeamScoreResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyTeamScoreResponse& operator=(CMsgDOTAFantasyTeamScoreResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyTeamScoreResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyTeamScoreResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyTeamScoreResponse*>(
               &_CMsgDOTAFantasyTeamScoreResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(CMsgDOTAFantasyTeamScoreResponse* other);
  friend void swap(CMsgDOTAFantasyTeamScoreResponse& a, CMsgDOTAFantasyTeamScoreResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyTeamScoreResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamScoreResponse>(nullptr);
  }

  CMsgDOTAFantasyTeamScoreResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamScoreResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyTeamScoreResponse& from);
  void MergeFrom(const CMsgDOTAFantasyTeamScoreResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyTeamScoreResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore CMsgPlayerScore;

  typedef CMsgDOTAFantasyTeamScoreResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTAFantasyTeamScoreResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTAFantasyTeamScoreResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NO_PERMISSION =
    CMsgDOTAFantasyTeamScoreResponse_EResult_ERROR_NO_PERMISSION;
  static const EResult ERROR_OWNER_NOT_IN_LEAGUE =
    CMsgDOTAFantasyTeamScoreResponse_EResult_ERROR_OWNER_NOT_IN_LEAGUE;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyTeamScoreResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyTeamScoreResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyTeamScoreResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyTeamScoreResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyTeamScoreResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyTeamScoreResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyTeamScoreResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore fantasy_player_score = 3;
  int fantasy_player_score_size() const;
  void clear_fantasy_player_score();
  static const int kFantasyPlayerScoreFieldNumber = 3;
  ::proto::dota::CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore* mutable_fantasy_player_score(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore >*
      mutable_fantasy_player_score();
  const ::proto::dota::CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore& fantasy_player_score(int index) const;
  ::proto::dota::CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore* add_fantasy_player_score();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore >&
      fantasy_player_score() const;

  // optional .proto.dota.CMsgDOTAFantasyTeamScoreResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyTeamScoreResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTAFantasyTeamScoreResponse_EResult value);

  // optional float fantasy_team_score = 2;
  bool has_fantasy_team_score() const;
  void clear_fantasy_team_score();
  static const int kFantasyTeamScoreFieldNumber = 2;
  float fantasy_team_score() const;
  void set_fantasy_team_score(float value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyTeamScoreResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore > fantasy_player_score_;
  int result_;
  float fantasy_team_score_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamStandingsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyTeamStandingsRequest) */ {
 public:
  CMsgDOTAFantasyTeamStandingsRequest();
  virtual ~CMsgDOTAFantasyTeamStandingsRequest();

  CMsgDOTAFantasyTeamStandingsRequest(const CMsgDOTAFantasyTeamStandingsRequest& from);

  inline CMsgDOTAFantasyTeamStandingsRequest& operator=(const CMsgDOTAFantasyTeamStandingsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyTeamStandingsRequest(CMsgDOTAFantasyTeamStandingsRequest&& from) noexcept
    : CMsgDOTAFantasyTeamStandingsRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyTeamStandingsRequest& operator=(CMsgDOTAFantasyTeamStandingsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyTeamStandingsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyTeamStandingsRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyTeamStandingsRequest*>(
               &_CMsgDOTAFantasyTeamStandingsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(CMsgDOTAFantasyTeamStandingsRequest* other);
  friend void swap(CMsgDOTAFantasyTeamStandingsRequest& a, CMsgDOTAFantasyTeamStandingsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyTeamStandingsRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamStandingsRequest>(nullptr);
  }

  CMsgDOTAFantasyTeamStandingsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamStandingsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyTeamStandingsRequest& from);
  void MergeFrom(const CMsgDOTAFantasyTeamStandingsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyTeamStandingsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 count = 2;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // optional uint32 filter_start_time = 3;
  bool has_filter_start_time() const;
  void clear_filter_start_time();
  static const int kFilterStartTimeFieldNumber = 3;
  ::google::protobuf::uint32 filter_start_time() const;
  void set_filter_start_time(::google::protobuf::uint32 value);

  // optional uint32 filter_end_time = 4;
  bool has_filter_end_time() const;
  void clear_filter_end_time();
  static const int kFilterEndTimeFieldNumber = 4;
  ::google::protobuf::uint32 filter_end_time() const;
  void set_filter_end_time(::google::protobuf::uint32 value);

  // optional uint64 filter_match_id = 5;
  bool has_filter_match_id() const;
  void clear_filter_match_id();
  static const int kFilterMatchIdFieldNumber = 5;
  ::google::protobuf::uint64 filter_match_id() const;
  void set_filter_match_id(::google::protobuf::uint64 value);

  // optional bool filter_last_match = 6;
  bool has_filter_last_match() const;
  void clear_filter_last_match();
  static const int kFilterLastMatchFieldNumber = 6;
  bool filter_last_match() const;
  void set_filter_last_match(bool value);

  // optional bool filter_in_hall = 7;
  bool has_filter_in_hall() const;
  void clear_filter_in_hall();
  static const int kFilterInHallFieldNumber = 7;
  bool filter_in_hall() const;
  void set_filter_in_hall(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyTeamStandingsRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 filter_start_time_;
  ::google::protobuf::uint32 filter_end_time_;
  ::google::protobuf::uint64 filter_match_id_;
  bool filter_last_match_;
  bool filter_in_hall_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore) */ {
 public:
  CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore();
  virtual ~CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore();

  CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore(const CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore& from);

  inline CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore& operator=(const CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore(CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore&& from) noexcept
    : CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore& operator=(CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore*>(
               &_CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore* other);
  friend void swap(CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore& a, CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore>(nullptr);
  }

  CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore& from);
  void MergeFrom(const CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string owner_name = 5;
  bool has_owner_name() const;
  void clear_owner_name();
  static const int kOwnerNameFieldNumber = 5;
  const ::std::string& owner_name() const;
  void set_owner_name(const ::std::string& value);
  #if LANG_CXX11
  void set_owner_name(::std::string&& value);
  #endif
  void set_owner_name(const char* value);
  void set_owner_name(const char* value, size_t size);
  ::std::string* mutable_owner_name();
  ::std::string* release_owner_name();
  void set_allocated_owner_name(::std::string* owner_name);

  // optional string fantasy_team_name = 6;
  bool has_fantasy_team_name() const;
  void clear_fantasy_team_name();
  static const int kFantasyTeamNameFieldNumber = 6;
  const ::std::string& fantasy_team_name() const;
  void set_fantasy_team_name(const ::std::string& value);
  #if LANG_CXX11
  void set_fantasy_team_name(::std::string&& value);
  #endif
  void set_fantasy_team_name(const char* value);
  void set_fantasy_team_name(const char* value, size_t size);
  ::std::string* mutable_fantasy_team_name();
  ::std::string* release_fantasy_team_name();
  void set_allocated_fantasy_team_name(::std::string* fantasy_team_name);

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 owner_account_id = 2;
  bool has_owner_account_id() const;
  void clear_owner_account_id();
  static const int kOwnerAccountIdFieldNumber = 2;
  ::google::protobuf::uint32 owner_account_id() const;
  void set_owner_account_id(::google::protobuf::uint32 value);

  // optional uint64 fantasy_team_logo = 4;
  bool has_fantasy_team_logo() const;
  void clear_fantasy_team_logo();
  static const int kFantasyTeamLogoFieldNumber = 4;
  ::google::protobuf::uint64 fantasy_team_logo() const;
  void set_fantasy_team_logo(::google::protobuf::uint64 value);

  // optional uint32 fantasy_team_index = 3;
  bool has_fantasy_team_index() const;
  void clear_fantasy_team_index();
  static const int kFantasyTeamIndexFieldNumber = 3;
  ::google::protobuf::uint32 fantasy_team_index() const;
  void set_fantasy_team_index(::google::protobuf::uint32 value);

  // optional float score = 7;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 7;
  float score() const;
  void set_score(float value);

  // optional float score_against = 8;
  bool has_score_against() const;
  void clear_score_against();
  static const int kScoreAgainstFieldNumber = 8;
  float score_against() const;
  void set_score_against(float value);

  // optional uint32 wins = 9;
  bool has_wins() const;
  void clear_wins();
  static const int kWinsFieldNumber = 9;
  ::google::protobuf::uint32 wins() const;
  void set_wins(::google::protobuf::uint32 value);

  // optional uint32 losses = 10;
  bool has_losses() const;
  void clear_losses();
  static const int kLossesFieldNumber = 10;
  ::google::protobuf::uint32 losses() const;
  void set_losses(::google::protobuf::uint32 value);

  // optional int32 streak = 11;
  bool has_streak() const;
  void clear_streak();
  static const int kStreakFieldNumber = 11;
  ::google::protobuf::int32 streak() const;
  void set_streak(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr owner_name_;
  ::google::protobuf::internal::ArenaStringPtr fantasy_team_name_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 owner_account_id_;
  ::google::protobuf::uint64 fantasy_team_logo_;
  ::google::protobuf::uint32 fantasy_team_index_;
  float score_;
  float score_against_;
  ::google::protobuf::uint32 wins_;
  ::google::protobuf::uint32 losses_;
  ::google::protobuf::int32 streak_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamStandingsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyTeamStandingsResponse) */ {
 public:
  CMsgDOTAFantasyTeamStandingsResponse();
  virtual ~CMsgDOTAFantasyTeamStandingsResponse();

  CMsgDOTAFantasyTeamStandingsResponse(const CMsgDOTAFantasyTeamStandingsResponse& from);

  inline CMsgDOTAFantasyTeamStandingsResponse& operator=(const CMsgDOTAFantasyTeamStandingsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyTeamStandingsResponse(CMsgDOTAFantasyTeamStandingsResponse&& from) noexcept
    : CMsgDOTAFantasyTeamStandingsResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyTeamStandingsResponse& operator=(CMsgDOTAFantasyTeamStandingsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyTeamStandingsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyTeamStandingsResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyTeamStandingsResponse*>(
               &_CMsgDOTAFantasyTeamStandingsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(CMsgDOTAFantasyTeamStandingsResponse* other);
  friend void swap(CMsgDOTAFantasyTeamStandingsResponse& a, CMsgDOTAFantasyTeamStandingsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyTeamStandingsResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamStandingsResponse>(nullptr);
  }

  CMsgDOTAFantasyTeamStandingsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamStandingsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyTeamStandingsResponse& from);
  void MergeFrom(const CMsgDOTAFantasyTeamStandingsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyTeamStandingsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore CMsgTeamScore;

  typedef CMsgDOTAFantasyTeamStandingsResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTAFantasyTeamStandingsResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTAFantasyTeamStandingsResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NO_PERMISSION =
    CMsgDOTAFantasyTeamStandingsResponse_EResult_ERROR_NO_PERMISSION;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyTeamStandingsResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyTeamStandingsResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyTeamStandingsResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyTeamStandingsResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyTeamStandingsResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyTeamStandingsResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyTeamStandingsResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore team_scores = 3;
  int team_scores_size() const;
  void clear_team_scores();
  static const int kTeamScoresFieldNumber = 3;
  ::proto::dota::CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore* mutable_team_scores(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore >*
      mutable_team_scores();
  const ::proto::dota::CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore& team_scores(int index) const;
  ::proto::dota::CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore* add_team_scores();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore >&
      team_scores() const;

  // optional .proto.dota.CMsgDOTAFantasyTeamStandingsResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyTeamStandingsResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTAFantasyTeamStandingsResponse_EResult value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyTeamStandingsResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore > team_scores_;
  int result_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerScoreRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyPlayerScoreRequest) */ {
 public:
  CMsgDOTAFantasyPlayerScoreRequest();
  virtual ~CMsgDOTAFantasyPlayerScoreRequest();

  CMsgDOTAFantasyPlayerScoreRequest(const CMsgDOTAFantasyPlayerScoreRequest& from);

  inline CMsgDOTAFantasyPlayerScoreRequest& operator=(const CMsgDOTAFantasyPlayerScoreRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyPlayerScoreRequest(CMsgDOTAFantasyPlayerScoreRequest&& from) noexcept
    : CMsgDOTAFantasyPlayerScoreRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyPlayerScoreRequest& operator=(CMsgDOTAFantasyPlayerScoreRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyPlayerScoreRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyPlayerScoreRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyPlayerScoreRequest*>(
               &_CMsgDOTAFantasyPlayerScoreRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(CMsgDOTAFantasyPlayerScoreRequest* other);
  friend void swap(CMsgDOTAFantasyPlayerScoreRequest& a, CMsgDOTAFantasyPlayerScoreRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyPlayerScoreRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyPlayerScoreRequest>(nullptr);
  }

  CMsgDOTAFantasyPlayerScoreRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyPlayerScoreRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyPlayerScoreRequest& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerScoreRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyPlayerScoreRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 player_account_id = 2;
  bool has_player_account_id() const;
  void clear_player_account_id();
  static const int kPlayerAccountIdFieldNumber = 2;
  ::google::protobuf::uint32 player_account_id() const;
  void set_player_account_id(::google::protobuf::uint32 value);

  // optional uint32 filter_start_time = 3;
  bool has_filter_start_time() const;
  void clear_filter_start_time();
  static const int kFilterStartTimeFieldNumber = 3;
  ::google::protobuf::uint32 filter_start_time() const;
  void set_filter_start_time(::google::protobuf::uint32 value);

  // optional uint32 filter_end_time = 4;
  bool has_filter_end_time() const;
  void clear_filter_end_time();
  static const int kFilterEndTimeFieldNumber = 4;
  ::google::protobuf::uint32 filter_end_time() const;
  void set_filter_end_time(::google::protobuf::uint32 value);

  // optional uint64 filter_match_id = 5;
  bool has_filter_match_id() const;
  void clear_filter_match_id();
  static const int kFilterMatchIdFieldNumber = 5;
  ::google::protobuf::uint64 filter_match_id() const;
  void set_filter_match_id(::google::protobuf::uint64 value);

  // optional bool filter_last_match = 6;
  bool has_filter_last_match() const;
  void clear_filter_last_match();
  static const int kFilterLastMatchFieldNumber = 6;
  bool filter_last_match() const;
  void set_filter_last_match(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyPlayerScoreRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 player_account_id_;
  ::google::protobuf::uint32 filter_start_time_;
  ::google::protobuf::uint32 filter_end_time_;
  ::google::protobuf::uint64 filter_match_id_;
  bool filter_last_match_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerScoreResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyPlayerScoreResponse) */ {
 public:
  CMsgDOTAFantasyPlayerScoreResponse();
  virtual ~CMsgDOTAFantasyPlayerScoreResponse();

  CMsgDOTAFantasyPlayerScoreResponse(const CMsgDOTAFantasyPlayerScoreResponse& from);

  inline CMsgDOTAFantasyPlayerScoreResponse& operator=(const CMsgDOTAFantasyPlayerScoreResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyPlayerScoreResponse(CMsgDOTAFantasyPlayerScoreResponse&& from) noexcept
    : CMsgDOTAFantasyPlayerScoreResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyPlayerScoreResponse& operator=(CMsgDOTAFantasyPlayerScoreResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyPlayerScoreResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyPlayerScoreResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyPlayerScoreResponse*>(
               &_CMsgDOTAFantasyPlayerScoreResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(CMsgDOTAFantasyPlayerScoreResponse* other);
  friend void swap(CMsgDOTAFantasyPlayerScoreResponse& a, CMsgDOTAFantasyPlayerScoreResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyPlayerScoreResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyPlayerScoreResponse>(nullptr);
  }

  CMsgDOTAFantasyPlayerScoreResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyPlayerScoreResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyPlayerScoreResponse& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerScoreResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyPlayerScoreResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyPlayerScoreResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTAFantasyPlayerScoreResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTAFantasyPlayerScoreResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NO_PERMISSION =
    CMsgDOTAFantasyPlayerScoreResponse_EResult_ERROR_NO_PERMISSION;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyPlayerScoreResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyPlayerScoreResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyPlayerScoreResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyPlayerScoreResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyPlayerScoreResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyPlayerScoreResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyPlayerScoreResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string player_name = 4;
  bool has_player_name() const;
  void clear_player_name();
  static const int kPlayerNameFieldNumber = 4;
  const ::std::string& player_name() const;
  void set_player_name(const ::std::string& value);
  #if LANG_CXX11
  void set_player_name(::std::string&& value);
  #endif
  void set_player_name(const char* value);
  void set_player_name(const char* value, size_t size);
  ::std::string* mutable_player_name();
  ::std::string* release_player_name();
  void set_allocated_player_name(::std::string* player_name);

  // optional .proto.dota.CMsgDOTAFantasyPlayerScoreResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyPlayerScoreResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTAFantasyPlayerScoreResponse_EResult value);

  // optional uint32 fantasy_league_id = 2;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 2;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 player_account_id = 3;
  bool has_player_account_id() const;
  void clear_player_account_id();
  static const int kPlayerAccountIdFieldNumber = 3;
  ::google::protobuf::uint32 player_account_id() const;
  void set_player_account_id(::google::protobuf::uint32 value);

  // optional float score = 5;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 5;
  float score() const;
  void set_score(float value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyPlayerScoreResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr player_name_;
  int result_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 player_account_id_;
  float score_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerStandingsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyPlayerStandingsRequest) */ {
 public:
  CMsgDOTAFantasyPlayerStandingsRequest();
  virtual ~CMsgDOTAFantasyPlayerStandingsRequest();

  CMsgDOTAFantasyPlayerStandingsRequest(const CMsgDOTAFantasyPlayerStandingsRequest& from);

  inline CMsgDOTAFantasyPlayerStandingsRequest& operator=(const CMsgDOTAFantasyPlayerStandingsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyPlayerStandingsRequest(CMsgDOTAFantasyPlayerStandingsRequest&& from) noexcept
    : CMsgDOTAFantasyPlayerStandingsRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyPlayerStandingsRequest& operator=(CMsgDOTAFantasyPlayerStandingsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyPlayerStandingsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyPlayerStandingsRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyPlayerStandingsRequest*>(
               &_CMsgDOTAFantasyPlayerStandingsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(CMsgDOTAFantasyPlayerStandingsRequest* other);
  friend void swap(CMsgDOTAFantasyPlayerStandingsRequest& a, CMsgDOTAFantasyPlayerStandingsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyPlayerStandingsRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyPlayerStandingsRequest>(nullptr);
  }

  CMsgDOTAFantasyPlayerStandingsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyPlayerStandingsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyPlayerStandingsRequest& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerStandingsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyPlayerStandingsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 count = 2;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // optional uint32 role = 3;
  bool has_role() const;
  void clear_role();
  static const int kRoleFieldNumber = 3;
  ::google::protobuf::uint32 role() const;
  void set_role(::google::protobuf::uint32 value);

  // optional uint32 filter_start_time = 4;
  bool has_filter_start_time() const;
  void clear_filter_start_time();
  static const int kFilterStartTimeFieldNumber = 4;
  ::google::protobuf::uint32 filter_start_time() const;
  void set_filter_start_time(::google::protobuf::uint32 value);

  // optional uint64 filter_match_id = 6;
  bool has_filter_match_id() const;
  void clear_filter_match_id();
  static const int kFilterMatchIdFieldNumber = 6;
  ::google::protobuf::uint64 filter_match_id() const;
  void set_filter_match_id(::google::protobuf::uint64 value);

  // optional uint32 filter_end_time = 5;
  bool has_filter_end_time() const;
  void clear_filter_end_time();
  static const int kFilterEndTimeFieldNumber = 5;
  ::google::protobuf::uint32 filter_end_time() const;
  void set_filter_end_time(::google::protobuf::uint32 value);

  // optional bool filter_last_match = 7;
  bool has_filter_last_match() const;
  void clear_filter_last_match();
  static const int kFilterLastMatchFieldNumber = 7;
  bool filter_last_match() const;
  void set_filter_last_match(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyPlayerStandingsRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 role_;
  ::google::protobuf::uint32 filter_start_time_;
  ::google::protobuf::uint64 filter_match_id_;
  ::google::protobuf::uint32 filter_end_time_;
  bool filter_last_match_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore) */ {
 public:
  CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore();
  virtual ~CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore();

  CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore(const CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore& from);

  inline CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore& operator=(const CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore(CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore&& from) noexcept
    : CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore& operator=(CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore*>(
               &_CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore* other);
  friend void swap(CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore& a, CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore>(nullptr);
  }

  CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string player_name = 2;
  bool has_player_name() const;
  void clear_player_name();
  static const int kPlayerNameFieldNumber = 2;
  const ::std::string& player_name() const;
  void set_player_name(const ::std::string& value);
  #if LANG_CXX11
  void set_player_name(::std::string&& value);
  #endif
  void set_player_name(const char* value);
  void set_player_name(const char* value, size_t size);
  ::std::string* mutable_player_name();
  ::std::string* release_player_name();
  void set_allocated_player_name(::std::string* player_name);

  // optional uint32 player_account_id = 1;
  bool has_player_account_id() const;
  void clear_player_account_id();
  static const int kPlayerAccountIdFieldNumber = 1;
  ::google::protobuf::uint32 player_account_id() const;
  void set_player_account_id(::google::protobuf::uint32 value);

  // optional float score = 3;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 3;
  float score() const;
  void set_score(float value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr player_name_;
  ::google::protobuf::uint32 player_account_id_;
  float score_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerStandingsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse) */ {
 public:
  CMsgDOTAFantasyPlayerStandingsResponse();
  virtual ~CMsgDOTAFantasyPlayerStandingsResponse();

  CMsgDOTAFantasyPlayerStandingsResponse(const CMsgDOTAFantasyPlayerStandingsResponse& from);

  inline CMsgDOTAFantasyPlayerStandingsResponse& operator=(const CMsgDOTAFantasyPlayerStandingsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyPlayerStandingsResponse(CMsgDOTAFantasyPlayerStandingsResponse&& from) noexcept
    : CMsgDOTAFantasyPlayerStandingsResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyPlayerStandingsResponse& operator=(CMsgDOTAFantasyPlayerStandingsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyPlayerStandingsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyPlayerStandingsResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyPlayerStandingsResponse*>(
               &_CMsgDOTAFantasyPlayerStandingsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(CMsgDOTAFantasyPlayerStandingsResponse* other);
  friend void swap(CMsgDOTAFantasyPlayerStandingsResponse& a, CMsgDOTAFantasyPlayerStandingsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyPlayerStandingsResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyPlayerStandingsResponse>(nullptr);
  }

  CMsgDOTAFantasyPlayerStandingsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyPlayerStandingsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyPlayerStandingsResponse& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerStandingsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyPlayerStandingsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore CMsgPlayerScore;

  typedef CMsgDOTAFantasyPlayerStandingsResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTAFantasyPlayerStandingsResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTAFantasyPlayerStandingsResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NO_PERMISSION =
    CMsgDOTAFantasyPlayerStandingsResponse_EResult_ERROR_NO_PERMISSION;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyPlayerStandingsResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyPlayerStandingsResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyPlayerStandingsResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyPlayerStandingsResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyPlayerStandingsResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyPlayerStandingsResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyPlayerStandingsResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore player_scores = 4;
  int player_scores_size() const;
  void clear_player_scores();
  static const int kPlayerScoresFieldNumber = 4;
  ::proto::dota::CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore* mutable_player_scores(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore >*
      mutable_player_scores();
  const ::proto::dota::CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore& player_scores(int index) const;
  ::proto::dota::CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore* add_player_scores();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore >&
      player_scores() const;

  // optional .proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyPlayerStandingsResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTAFantasyPlayerStandingsResponse_EResult value);

  // optional uint32 fantasy_league_id = 2;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 2;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 role = 3;
  bool has_role() const;
  void clear_role();
  static const int kRoleFieldNumber = 3;
  ::google::protobuf::uint32 role() const;
  void set_role(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore > player_scores_;
  int result_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 role_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueCreateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyLeagueCreateRequest) */ {
 public:
  CMsgDOTAFantasyLeagueCreateRequest();
  virtual ~CMsgDOTAFantasyLeagueCreateRequest();

  CMsgDOTAFantasyLeagueCreateRequest(const CMsgDOTAFantasyLeagueCreateRequest& from);

  inline CMsgDOTAFantasyLeagueCreateRequest& operator=(const CMsgDOTAFantasyLeagueCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyLeagueCreateRequest(CMsgDOTAFantasyLeagueCreateRequest&& from) noexcept
    : CMsgDOTAFantasyLeagueCreateRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyLeagueCreateRequest& operator=(CMsgDOTAFantasyLeagueCreateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyLeagueCreateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyLeagueCreateRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyLeagueCreateRequest*>(
               &_CMsgDOTAFantasyLeagueCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(CMsgDOTAFantasyLeagueCreateRequest* other);
  friend void swap(CMsgDOTAFantasyLeagueCreateRequest& a, CMsgDOTAFantasyLeagueCreateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyLeagueCreateRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueCreateRequest>(nullptr);
  }

  CMsgDOTAFantasyLeagueCreateRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueCreateRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyLeagueCreateRequest& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueCreateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyLeagueCreateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fantasy_league_name = 2;
  bool has_fantasy_league_name() const;
  void clear_fantasy_league_name();
  static const int kFantasyLeagueNameFieldNumber = 2;
  const ::std::string& fantasy_league_name() const;
  void set_fantasy_league_name(const ::std::string& value);
  #if LANG_CXX11
  void set_fantasy_league_name(::std::string&& value);
  #endif
  void set_fantasy_league_name(const char* value);
  void set_fantasy_league_name(const char* value, size_t size);
  ::std::string* mutable_fantasy_league_name();
  ::std::string* release_fantasy_league_name();
  void set_allocated_fantasy_league_name(::std::string* fantasy_league_name);

  // optional string password = 3;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 3;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // optional string team_name = 4;
  bool has_team_name() const;
  void clear_team_name();
  static const int kTeamNameFieldNumber = 4;
  const ::std::string& team_name() const;
  void set_team_name(const ::std::string& value);
  #if LANG_CXX11
  void set_team_name(::std::string&& value);
  #endif
  void set_team_name(const char* value);
  void set_team_name(const char* value, size_t size);
  ::std::string* mutable_team_name();
  ::std::string* release_team_name();
  void set_allocated_team_name(::std::string* team_name);

  // optional uint64 logo = 5;
  bool has_logo() const;
  void clear_logo();
  static const int kLogoFieldNumber = 5;
  ::google::protobuf::uint64 logo() const;
  void set_logo(::google::protobuf::uint64 value);

  // optional uint64 ticket_item_id = 6;
  bool has_ticket_item_id() const;
  void clear_ticket_item_id();
  static const int kTicketItemIdFieldNumber = 6;
  ::google::protobuf::uint64 ticket_item_id() const;
  void set_ticket_item_id(::google::protobuf::uint64 value);

  // optional uint32 season_id = 1;
  bool has_season_id() const;
  void clear_season_id();
  static const int kSeasonIdFieldNumber = 1;
  ::google::protobuf::uint32 season_id() const;
  void set_season_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyLeagueCreateRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr fantasy_league_name_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr team_name_;
  ::google::protobuf::uint64 logo_;
  ::google::protobuf::uint64 ticket_item_id_;
  ::google::protobuf::uint32 season_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueCreateResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyLeagueCreateResponse) */ {
 public:
  CMsgDOTAFantasyLeagueCreateResponse();
  virtual ~CMsgDOTAFantasyLeagueCreateResponse();

  CMsgDOTAFantasyLeagueCreateResponse(const CMsgDOTAFantasyLeagueCreateResponse& from);

  inline CMsgDOTAFantasyLeagueCreateResponse& operator=(const CMsgDOTAFantasyLeagueCreateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyLeagueCreateResponse(CMsgDOTAFantasyLeagueCreateResponse&& from) noexcept
    : CMsgDOTAFantasyLeagueCreateResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyLeagueCreateResponse& operator=(CMsgDOTAFantasyLeagueCreateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyLeagueCreateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyLeagueCreateResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyLeagueCreateResponse*>(
               &_CMsgDOTAFantasyLeagueCreateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(CMsgDOTAFantasyLeagueCreateResponse* other);
  friend void swap(CMsgDOTAFantasyLeagueCreateResponse& a, CMsgDOTAFantasyLeagueCreateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyLeagueCreateResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueCreateResponse>(nullptr);
  }

  CMsgDOTAFantasyLeagueCreateResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueCreateResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyLeagueCreateResponse& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueCreateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyLeagueCreateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyLeagueCreateResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTAFantasyLeagueCreateResponse_EResult_SUCCESS;
  static const EResult ERROR_NO_PERMISSION =
    CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_NO_PERMISSION;
  static const EResult ERROR_BAD_SEASON_ID =
    CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_BAD_SEASON_ID;
  static const EResult ERROR_BAD_LEAGUE_NAME =
    CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_BAD_LEAGUE_NAME;
  static const EResult ERROR_BAD_TEAM_NAME =
    CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_BAD_TEAM_NAME;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_FAILED_LOGO_UPLOAD =
    CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_FAILED_LOGO_UPLOAD;
  static const EResult ERROR_NO_TICKET =
    CMsgDOTAFantasyLeagueCreateResponse_EResult_ERROR_NO_TICKET;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyLeagueCreateResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyLeagueCreateResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyLeagueCreateResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyLeagueCreateResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyLeagueCreateResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyLeagueCreateResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyLeagueCreateResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgDOTAFantasyLeagueCreateResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyLeagueCreateResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTAFantasyLeagueCreateResponse_EResult value);

  // optional uint32 fantasy_league_id = 2;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 2;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyLeagueCreateResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int result_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamCreateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyTeamCreateRequest) */ {
 public:
  CMsgDOTAFantasyTeamCreateRequest();
  virtual ~CMsgDOTAFantasyTeamCreateRequest();

  CMsgDOTAFantasyTeamCreateRequest(const CMsgDOTAFantasyTeamCreateRequest& from);

  inline CMsgDOTAFantasyTeamCreateRequest& operator=(const CMsgDOTAFantasyTeamCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyTeamCreateRequest(CMsgDOTAFantasyTeamCreateRequest&& from) noexcept
    : CMsgDOTAFantasyTeamCreateRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyTeamCreateRequest& operator=(CMsgDOTAFantasyTeamCreateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyTeamCreateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyTeamCreateRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyTeamCreateRequest*>(
               &_CMsgDOTAFantasyTeamCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(CMsgDOTAFantasyTeamCreateRequest* other);
  friend void swap(CMsgDOTAFantasyTeamCreateRequest& a, CMsgDOTAFantasyTeamCreateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyTeamCreateRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamCreateRequest>(nullptr);
  }

  CMsgDOTAFantasyTeamCreateRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamCreateRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyTeamCreateRequest& from);
  void MergeFrom(const CMsgDOTAFantasyTeamCreateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyTeamCreateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string password = 2;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // optional string team_name = 3;
  bool has_team_name() const;
  void clear_team_name();
  static const int kTeamNameFieldNumber = 3;
  const ::std::string& team_name() const;
  void set_team_name(const ::std::string& value);
  #if LANG_CXX11
  void set_team_name(::std::string&& value);
  #endif
  void set_team_name(const char* value);
  void set_team_name(const char* value, size_t size);
  ::std::string* mutable_team_name();
  ::std::string* release_team_name();
  void set_allocated_team_name(::std::string* team_name);

  // optional uint64 logo = 4;
  bool has_logo() const;
  void clear_logo();
  static const int kLogoFieldNumber = 4;
  ::google::protobuf::uint64 logo() const;
  void set_logo(::google::protobuf::uint64 value);

  // optional uint64 ticket_item_id = 5;
  bool has_ticket_item_id() const;
  void clear_ticket_item_id();
  static const int kTicketItemIdFieldNumber = 5;
  ::google::protobuf::uint64 ticket_item_id() const;
  void set_ticket_item_id(::google::protobuf::uint64 value);

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyTeamCreateRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr team_name_;
  ::google::protobuf::uint64 logo_;
  ::google::protobuf::uint64 ticket_item_id_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamCreateResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyTeamCreateResponse) */ {
 public:
  CMsgDOTAFantasyTeamCreateResponse();
  virtual ~CMsgDOTAFantasyTeamCreateResponse();

  CMsgDOTAFantasyTeamCreateResponse(const CMsgDOTAFantasyTeamCreateResponse& from);

  inline CMsgDOTAFantasyTeamCreateResponse& operator=(const CMsgDOTAFantasyTeamCreateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyTeamCreateResponse(CMsgDOTAFantasyTeamCreateResponse&& from) noexcept
    : CMsgDOTAFantasyTeamCreateResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyTeamCreateResponse& operator=(CMsgDOTAFantasyTeamCreateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyTeamCreateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyTeamCreateResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyTeamCreateResponse*>(
               &_CMsgDOTAFantasyTeamCreateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(CMsgDOTAFantasyTeamCreateResponse* other);
  friend void swap(CMsgDOTAFantasyTeamCreateResponse& a, CMsgDOTAFantasyTeamCreateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyTeamCreateResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamCreateResponse>(nullptr);
  }

  CMsgDOTAFantasyTeamCreateResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamCreateResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyTeamCreateResponse& from);
  void MergeFrom(const CMsgDOTAFantasyTeamCreateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyTeamCreateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyTeamCreateResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTAFantasyTeamCreateResponse_EResult_SUCCESS;
  static const EResult ERROR_NO_PERMISSION =
    CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_NO_PERMISSION;
  static const EResult ERROR_FAILED_LOGO_UPLOAD =
    CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_FAILED_LOGO_UPLOAD;
  static const EResult ERROR_BAD_FANTASY_LEAGUE_ID =
    CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_BAD_FANTASY_LEAGUE_ID;
  static const EResult ERROR_BAD_NAME =
    CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_BAD_NAME;
  static const EResult ERROR_FULL =
    CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_FULL;
  static const EResult ERROR_ALREADY_MEMBER =
    CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_ALREADY_MEMBER;
  static const EResult ERROR_BAD_PASSWORD =
    CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_BAD_PASSWORD;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NO_TICKET =
    CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_NO_TICKET;
  static const EResult ERROR_LEAGUE_LOCKED =
    CMsgDOTAFantasyTeamCreateResponse_EResult_ERROR_LEAGUE_LOCKED;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyTeamCreateResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyTeamCreateResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyTeamCreateResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyTeamCreateResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyTeamCreateResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyTeamCreateResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyTeamCreateResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgDOTAFantasyTeamCreateResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyTeamCreateResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTAFantasyTeamCreateResponse_EResult value);

  // optional uint32 fantasy_team_index = 2;
  bool has_fantasy_team_index() const;
  void clear_fantasy_team_index();
  static const int kFantasyTeamIndexFieldNumber = 2;
  ::google::protobuf::uint32 fantasy_team_index() const;
  void set_fantasy_team_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyTeamCreateResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int result_;
  ::google::protobuf::uint32 fantasy_team_index_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange) */ {
 public:
  CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange();
  virtual ~CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange();

  CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange(const CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange& from);

  inline CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange& operator=(const CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange(CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange&& from) noexcept
    : CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange& operator=(CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange*>(
               &_CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange* other);
  friend void swap(CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange& a, CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange>(nullptr);
  }

  CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 account_id = 1;
  bool has_account_id() const;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  ::google::protobuf::uint32 account_id() const;
  void set_account_id(::google::protobuf::uint32 value);

  // optional bool invited = 2;
  bool has_invited() const;
  void clear_invited();
  static const int kInvitedFieldNumber = 2;
  bool invited() const;
  void set_invited(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 account_id_;
  bool invited_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueEditInvitesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest) */ {
 public:
  CMsgDOTAFantasyLeagueEditInvitesRequest();
  virtual ~CMsgDOTAFantasyLeagueEditInvitesRequest();

  CMsgDOTAFantasyLeagueEditInvitesRequest(const CMsgDOTAFantasyLeagueEditInvitesRequest& from);

  inline CMsgDOTAFantasyLeagueEditInvitesRequest& operator=(const CMsgDOTAFantasyLeagueEditInvitesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyLeagueEditInvitesRequest(CMsgDOTAFantasyLeagueEditInvitesRequest&& from) noexcept
    : CMsgDOTAFantasyLeagueEditInvitesRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyLeagueEditInvitesRequest& operator=(CMsgDOTAFantasyLeagueEditInvitesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyLeagueEditInvitesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyLeagueEditInvitesRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyLeagueEditInvitesRequest*>(
               &_CMsgDOTAFantasyLeagueEditInvitesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(CMsgDOTAFantasyLeagueEditInvitesRequest* other);
  friend void swap(CMsgDOTAFantasyLeagueEditInvitesRequest& a, CMsgDOTAFantasyLeagueEditInvitesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyLeagueEditInvitesRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueEditInvitesRequest>(nullptr);
  }

  CMsgDOTAFantasyLeagueEditInvitesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueEditInvitesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyLeagueEditInvitesRequest& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueEditInvitesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyLeagueEditInvitesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange InviteChange;

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange invite_change = 3;
  int invite_change_size() const;
  void clear_invite_change();
  static const int kInviteChangeFieldNumber = 3;
  ::proto::dota::CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange* mutable_invite_change(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange >*
      mutable_invite_change();
  const ::proto::dota::CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange& invite_change(int index) const;
  ::proto::dota::CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange* add_invite_change();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange >&
      invite_change() const;

  // optional string password = 2;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange > invite_change_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueEditInvitesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyLeagueEditInvitesResponse) */ {
 public:
  CMsgDOTAFantasyLeagueEditInvitesResponse();
  virtual ~CMsgDOTAFantasyLeagueEditInvitesResponse();

  CMsgDOTAFantasyLeagueEditInvitesResponse(const CMsgDOTAFantasyLeagueEditInvitesResponse& from);

  inline CMsgDOTAFantasyLeagueEditInvitesResponse& operator=(const CMsgDOTAFantasyLeagueEditInvitesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyLeagueEditInvitesResponse(CMsgDOTAFantasyLeagueEditInvitesResponse&& from) noexcept
    : CMsgDOTAFantasyLeagueEditInvitesResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyLeagueEditInvitesResponse& operator=(CMsgDOTAFantasyLeagueEditInvitesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyLeagueEditInvitesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyLeagueEditInvitesResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyLeagueEditInvitesResponse*>(
               &_CMsgDOTAFantasyLeagueEditInvitesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  void Swap(CMsgDOTAFantasyLeagueEditInvitesResponse* other);
  friend void swap(CMsgDOTAFantasyLeagueEditInvitesResponse& a, CMsgDOTAFantasyLeagueEditInvitesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyLeagueEditInvitesResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueEditInvitesResponse>(nullptr);
  }

  CMsgDOTAFantasyLeagueEditInvitesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueEditInvitesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyLeagueEditInvitesResponse& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueEditInvitesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyLeagueEditInvitesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyLeagueEditInvitesResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_ERROR_UNSPECIFIED;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgDOTAFantasyLeagueEditInvitesResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyLeagueEditInvitesResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTAFantasyLeagueEditInvitesResponse_EResult value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyLeagueEditInvitesResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int result_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueDraftStatusRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyLeagueDraftStatusRequest) */ {
 public:
  CMsgDOTAFantasyLeagueDraftStatusRequest();
  virtual ~CMsgDOTAFantasyLeagueDraftStatusRequest();

  CMsgDOTAFantasyLeagueDraftStatusRequest(const CMsgDOTAFantasyLeagueDraftStatusRequest& from);

  inline CMsgDOTAFantasyLeagueDraftStatusRequest& operator=(const CMsgDOTAFantasyLeagueDraftStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyLeagueDraftStatusRequest(CMsgDOTAFantasyLeagueDraftStatusRequest&& from) noexcept
    : CMsgDOTAFantasyLeagueDraftStatusRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyLeagueDraftStatusRequest& operator=(CMsgDOTAFantasyLeagueDraftStatusRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyLeagueDraftStatusRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyLeagueDraftStatusRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyLeagueDraftStatusRequest*>(
               &_CMsgDOTAFantasyLeagueDraftStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  void Swap(CMsgDOTAFantasyLeagueDraftStatusRequest* other);
  friend void swap(CMsgDOTAFantasyLeagueDraftStatusRequest& a, CMsgDOTAFantasyLeagueDraftStatusRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyLeagueDraftStatusRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueDraftStatusRequest>(nullptr);
  }

  CMsgDOTAFantasyLeagueDraftStatusRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueDraftStatusRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyLeagueDraftStatusRequest& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueDraftStatusRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyLeagueDraftStatusRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyLeagueDraftStatusRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueDraftStatus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyLeagueDraftStatus) */ {
 public:
  CMsgDOTAFantasyLeagueDraftStatus();
  virtual ~CMsgDOTAFantasyLeagueDraftStatus();

  CMsgDOTAFantasyLeagueDraftStatus(const CMsgDOTAFantasyLeagueDraftStatus& from);

  inline CMsgDOTAFantasyLeagueDraftStatus& operator=(const CMsgDOTAFantasyLeagueDraftStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyLeagueDraftStatus(CMsgDOTAFantasyLeagueDraftStatus&& from) noexcept
    : CMsgDOTAFantasyLeagueDraftStatus() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyLeagueDraftStatus& operator=(CMsgDOTAFantasyLeagueDraftStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyLeagueDraftStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyLeagueDraftStatus* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyLeagueDraftStatus*>(
               &_CMsgDOTAFantasyLeagueDraftStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  void Swap(CMsgDOTAFantasyLeagueDraftStatus* other);
  friend void swap(CMsgDOTAFantasyLeagueDraftStatus& a, CMsgDOTAFantasyLeagueDraftStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyLeagueDraftStatus* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueDraftStatus>(nullptr);
  }

  CMsgDOTAFantasyLeagueDraftStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueDraftStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyLeagueDraftStatus& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueDraftStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyLeagueDraftStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 draft_order = 2;
  int draft_order_size() const;
  void clear_draft_order();
  static const int kDraftOrderFieldNumber = 2;
  ::google::protobuf::uint32 draft_order(int index) const;
  void set_draft_order(int index, ::google::protobuf::uint32 value);
  void add_draft_order(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      draft_order() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_draft_order();

  // repeated uint32 available_players = 7;
  int available_players_size() const;
  void clear_available_players();
  static const int kAvailablePlayersFieldNumber = 7;
  ::google::protobuf::uint32 available_players(int index) const;
  void set_available_players(int index, ::google::protobuf::uint32 value);
  void add_available_players(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      available_players() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_available_players();

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 current_pick = 3;
  bool has_current_pick() const;
  void clear_current_pick();
  static const int kCurrentPickFieldNumber = 3;
  ::google::protobuf::uint32 current_pick() const;
  void set_current_pick(::google::protobuf::uint32 value);

  // optional uint32 time_remaining = 4;
  bool has_time_remaining() const;
  void clear_time_remaining();
  static const int kTimeRemainingFieldNumber = 4;
  ::google::protobuf::uint32 time_remaining() const;
  void set_time_remaining(::google::protobuf::uint32 value);

  // optional bool pending_resume = 5;
  bool has_pending_resume() const;
  void clear_pending_resume();
  static const int kPendingResumeFieldNumber = 5;
  bool pending_resume() const;
  void set_pending_resume(bool value);

  // optional bool completed = 6;
  bool has_completed() const;
  void clear_completed();
  static const int kCompletedFieldNumber = 6;
  bool completed() const;
  void set_completed(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyLeagueDraftStatus)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > draft_order_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > available_players_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 current_pick_;
  ::google::protobuf::uint32 time_remaining_;
  bool pending_resume_;
  bool completed_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueDraftPlayerRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyLeagueDraftPlayerRequest) */ {
 public:
  CMsgDOTAFantasyLeagueDraftPlayerRequest();
  virtual ~CMsgDOTAFantasyLeagueDraftPlayerRequest();

  CMsgDOTAFantasyLeagueDraftPlayerRequest(const CMsgDOTAFantasyLeagueDraftPlayerRequest& from);

  inline CMsgDOTAFantasyLeagueDraftPlayerRequest& operator=(const CMsgDOTAFantasyLeagueDraftPlayerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyLeagueDraftPlayerRequest(CMsgDOTAFantasyLeagueDraftPlayerRequest&& from) noexcept
    : CMsgDOTAFantasyLeagueDraftPlayerRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyLeagueDraftPlayerRequest& operator=(CMsgDOTAFantasyLeagueDraftPlayerRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyLeagueDraftPlayerRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyLeagueDraftPlayerRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyLeagueDraftPlayerRequest*>(
               &_CMsgDOTAFantasyLeagueDraftPlayerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  void Swap(CMsgDOTAFantasyLeagueDraftPlayerRequest* other);
  friend void swap(CMsgDOTAFantasyLeagueDraftPlayerRequest& a, CMsgDOTAFantasyLeagueDraftPlayerRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyLeagueDraftPlayerRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueDraftPlayerRequest>(nullptr);
  }

  CMsgDOTAFantasyLeagueDraftPlayerRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueDraftPlayerRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyLeagueDraftPlayerRequest& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueDraftPlayerRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyLeagueDraftPlayerRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 team_index = 2;
  bool has_team_index() const;
  void clear_team_index();
  static const int kTeamIndexFieldNumber = 2;
  ::google::protobuf::uint32 team_index() const;
  void set_team_index(::google::protobuf::uint32 value);

  // optional uint32 player_account_id = 3;
  bool has_player_account_id() const;
  void clear_player_account_id();
  static const int kPlayerAccountIdFieldNumber = 3;
  ::google::protobuf::uint32 player_account_id() const;
  void set_player_account_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyLeagueDraftPlayerRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 team_index_;
  ::google::protobuf::uint32 player_account_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeagueDraftPlayerResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyLeagueDraftPlayerResponse) */ {
 public:
  CMsgDOTAFantasyLeagueDraftPlayerResponse();
  virtual ~CMsgDOTAFantasyLeagueDraftPlayerResponse();

  CMsgDOTAFantasyLeagueDraftPlayerResponse(const CMsgDOTAFantasyLeagueDraftPlayerResponse& from);

  inline CMsgDOTAFantasyLeagueDraftPlayerResponse& operator=(const CMsgDOTAFantasyLeagueDraftPlayerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyLeagueDraftPlayerResponse(CMsgDOTAFantasyLeagueDraftPlayerResponse&& from) noexcept
    : CMsgDOTAFantasyLeagueDraftPlayerResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyLeagueDraftPlayerResponse& operator=(CMsgDOTAFantasyLeagueDraftPlayerResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyLeagueDraftPlayerResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyLeagueDraftPlayerResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyLeagueDraftPlayerResponse*>(
               &_CMsgDOTAFantasyLeagueDraftPlayerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  void Swap(CMsgDOTAFantasyLeagueDraftPlayerResponse* other);
  friend void swap(CMsgDOTAFantasyLeagueDraftPlayerResponse& a, CMsgDOTAFantasyLeagueDraftPlayerResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyLeagueDraftPlayerResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueDraftPlayerResponse>(nullptr);
  }

  CMsgDOTAFantasyLeagueDraftPlayerResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeagueDraftPlayerResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyLeagueDraftPlayerResponse& from);
  void MergeFrom(const CMsgDOTAFantasyLeagueDraftPlayerResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyLeagueDraftPlayerResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_INVALID_FANTASY_LEAGUE =
    CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_INVALID_FANTASY_LEAGUE;
  static const EResult ERROR_FANTASY_LEAGUE_NOT_DRAFTING =
    CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_FANTASY_LEAGUE_NOT_DRAFTING;
  static const EResult ERROR_OWNER_NOT_IN_LEAGUE =
    CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_OWNER_NOT_IN_LEAGUE;
  static const EResult ERROR_NOT_OWNERS_TURN =
    CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_NOT_OWNERS_TURN;
  static const EResult ERROR_PLAYER_INVALID =
    CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_PLAYER_INVALID;
  static const EResult ERROR_PLAYER_UNAVAILABLE =
    CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_PLAYER_UNAVAILABLE;
  static const EResult ERROR_PLAYER_NO_VALID_SLOTS =
    CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_ERROR_PLAYER_NO_VALID_SLOTS;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgDOTAFantasyLeagueDraftPlayerResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyLeagueDraftPlayerResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int result_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamRosterSwapRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyTeamRosterSwapRequest) */ {
 public:
  CMsgDOTAFantasyTeamRosterSwapRequest();
  virtual ~CMsgDOTAFantasyTeamRosterSwapRequest();

  CMsgDOTAFantasyTeamRosterSwapRequest(const CMsgDOTAFantasyTeamRosterSwapRequest& from);

  inline CMsgDOTAFantasyTeamRosterSwapRequest& operator=(const CMsgDOTAFantasyTeamRosterSwapRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyTeamRosterSwapRequest(CMsgDOTAFantasyTeamRosterSwapRequest&& from) noexcept
    : CMsgDOTAFantasyTeamRosterSwapRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyTeamRosterSwapRequest& operator=(CMsgDOTAFantasyTeamRosterSwapRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyTeamRosterSwapRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyTeamRosterSwapRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyTeamRosterSwapRequest*>(
               &_CMsgDOTAFantasyTeamRosterSwapRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  void Swap(CMsgDOTAFantasyTeamRosterSwapRequest* other);
  friend void swap(CMsgDOTAFantasyTeamRosterSwapRequest& a, CMsgDOTAFantasyTeamRosterSwapRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyTeamRosterSwapRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamRosterSwapRequest>(nullptr);
  }

  CMsgDOTAFantasyTeamRosterSwapRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamRosterSwapRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyTeamRosterSwapRequest& from);
  void MergeFrom(const CMsgDOTAFantasyTeamRosterSwapRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyTeamRosterSwapRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 team_index = 2;
  bool has_team_index() const;
  void clear_team_index();
  static const int kTeamIndexFieldNumber = 2;
  ::google::protobuf::uint32 team_index() const;
  void set_team_index(::google::protobuf::uint32 value);

  // optional uint32 timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // optional uint32 slot_1 = 4;
  bool has_slot_1() const;
  void clear_slot_1();
  static const int kSlot1FieldNumber = 4;
  ::google::protobuf::uint32 slot_1() const;
  void set_slot_1(::google::protobuf::uint32 value);

  // optional uint32 slot_2 = 5;
  bool has_slot_2() const;
  void clear_slot_2();
  static const int kSlot2FieldNumber = 5;
  ::google::protobuf::uint32 slot_2() const;
  void set_slot_2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyTeamRosterSwapRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 team_index_;
  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::uint32 slot_1_;
  ::google::protobuf::uint32 slot_2_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamRosterSwapResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyTeamRosterSwapResponse) */ {
 public:
  CMsgDOTAFantasyTeamRosterSwapResponse();
  virtual ~CMsgDOTAFantasyTeamRosterSwapResponse();

  CMsgDOTAFantasyTeamRosterSwapResponse(const CMsgDOTAFantasyTeamRosterSwapResponse& from);

  inline CMsgDOTAFantasyTeamRosterSwapResponse& operator=(const CMsgDOTAFantasyTeamRosterSwapResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyTeamRosterSwapResponse(CMsgDOTAFantasyTeamRosterSwapResponse&& from) noexcept
    : CMsgDOTAFantasyTeamRosterSwapResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyTeamRosterSwapResponse& operator=(CMsgDOTAFantasyTeamRosterSwapResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyTeamRosterSwapResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyTeamRosterSwapResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyTeamRosterSwapResponse*>(
               &_CMsgDOTAFantasyTeamRosterSwapResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  void Swap(CMsgDOTAFantasyTeamRosterSwapResponse* other);
  friend void swap(CMsgDOTAFantasyTeamRosterSwapResponse& a, CMsgDOTAFantasyTeamRosterSwapResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyTeamRosterSwapResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamRosterSwapResponse>(nullptr);
  }

  CMsgDOTAFantasyTeamRosterSwapResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamRosterSwapResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyTeamRosterSwapResponse& from);
  void MergeFrom(const CMsgDOTAFantasyTeamRosterSwapResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyTeamRosterSwapResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyTeamRosterSwapResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTAFantasyTeamRosterSwapResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTAFantasyTeamRosterSwapResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_OWNER_NOT_IN_LEAGUE =
    CMsgDOTAFantasyTeamRosterSwapResponse_EResult_ERROR_OWNER_NOT_IN_LEAGUE;
  static const EResult ERROR_SLOTS_INVALID =
    CMsgDOTAFantasyTeamRosterSwapResponse_EResult_ERROR_SLOTS_INVALID;
  static const EResult ERROR_SLOT_LOCKED =
    CMsgDOTAFantasyTeamRosterSwapResponse_EResult_ERROR_SLOT_LOCKED;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyTeamRosterSwapResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyTeamRosterSwapResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyTeamRosterSwapResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyTeamRosterSwapResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyTeamRosterSwapResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyTeamRosterSwapResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyTeamRosterSwapResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgDOTAFantasyTeamRosterSwapResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyTeamRosterSwapResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTAFantasyTeamRosterSwapResponse_EResult value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyTeamRosterSwapResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int result_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamRosterAddDropRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyTeamRosterAddDropRequest) */ {
 public:
  CMsgDOTAFantasyTeamRosterAddDropRequest();
  virtual ~CMsgDOTAFantasyTeamRosterAddDropRequest();

  CMsgDOTAFantasyTeamRosterAddDropRequest(const CMsgDOTAFantasyTeamRosterAddDropRequest& from);

  inline CMsgDOTAFantasyTeamRosterAddDropRequest& operator=(const CMsgDOTAFantasyTeamRosterAddDropRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyTeamRosterAddDropRequest(CMsgDOTAFantasyTeamRosterAddDropRequest&& from) noexcept
    : CMsgDOTAFantasyTeamRosterAddDropRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyTeamRosterAddDropRequest& operator=(CMsgDOTAFantasyTeamRosterAddDropRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyTeamRosterAddDropRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyTeamRosterAddDropRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyTeamRosterAddDropRequest*>(
               &_CMsgDOTAFantasyTeamRosterAddDropRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  void Swap(CMsgDOTAFantasyTeamRosterAddDropRequest* other);
  friend void swap(CMsgDOTAFantasyTeamRosterAddDropRequest& a, CMsgDOTAFantasyTeamRosterAddDropRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyTeamRosterAddDropRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamRosterAddDropRequest>(nullptr);
  }

  CMsgDOTAFantasyTeamRosterAddDropRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamRosterAddDropRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyTeamRosterAddDropRequest& from);
  void MergeFrom(const CMsgDOTAFantasyTeamRosterAddDropRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyTeamRosterAddDropRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 team_index = 2;
  bool has_team_index() const;
  void clear_team_index();
  static const int kTeamIndexFieldNumber = 2;
  ::google::protobuf::uint32 team_index() const;
  void set_team_index(::google::protobuf::uint32 value);

  // optional uint32 add_account_id = 5;
  bool has_add_account_id() const;
  void clear_add_account_id();
  static const int kAddAccountIdFieldNumber = 5;
  ::google::protobuf::uint32 add_account_id() const;
  void set_add_account_id(::google::protobuf::uint32 value);

  // optional uint32 drop_account_id = 6;
  bool has_drop_account_id() const;
  void clear_drop_account_id();
  static const int kDropAccountIdFieldNumber = 6;
  ::google::protobuf::uint32 drop_account_id() const;
  void set_drop_account_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyTeamRosterAddDropRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 team_index_;
  ::google::protobuf::uint32 add_account_id_;
  ::google::protobuf::uint32 drop_account_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamRosterAddDropResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyTeamRosterAddDropResponse) */ {
 public:
  CMsgDOTAFantasyTeamRosterAddDropResponse();
  virtual ~CMsgDOTAFantasyTeamRosterAddDropResponse();

  CMsgDOTAFantasyTeamRosterAddDropResponse(const CMsgDOTAFantasyTeamRosterAddDropResponse& from);

  inline CMsgDOTAFantasyTeamRosterAddDropResponse& operator=(const CMsgDOTAFantasyTeamRosterAddDropResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyTeamRosterAddDropResponse(CMsgDOTAFantasyTeamRosterAddDropResponse&& from) noexcept
    : CMsgDOTAFantasyTeamRosterAddDropResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyTeamRosterAddDropResponse& operator=(CMsgDOTAFantasyTeamRosterAddDropResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyTeamRosterAddDropResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyTeamRosterAddDropResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyTeamRosterAddDropResponse*>(
               &_CMsgDOTAFantasyTeamRosterAddDropResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  void Swap(CMsgDOTAFantasyTeamRosterAddDropResponse* other);
  friend void swap(CMsgDOTAFantasyTeamRosterAddDropResponse& a, CMsgDOTAFantasyTeamRosterAddDropResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyTeamRosterAddDropResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamRosterAddDropResponse>(nullptr);
  }

  CMsgDOTAFantasyTeamRosterAddDropResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamRosterAddDropResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyTeamRosterAddDropResponse& from);
  void MergeFrom(const CMsgDOTAFantasyTeamRosterAddDropResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyTeamRosterAddDropResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyTeamRosterAddDropResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_OWNER_NOT_IN_LEAGUE =
    CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_ERROR_OWNER_NOT_IN_LEAGUE;
  static const EResult ERROR_PLAYER_NOT_AVAILABLE =
    CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_ERROR_PLAYER_NOT_AVAILABLE;
  static const EResult ERROR_PLAYER_NOT_ON_TEAM =
    CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_ERROR_PLAYER_NOT_ON_TEAM;
  static const EResult ERROR_TRADE_ALREADY_PENDING =
    CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_ERROR_TRADE_ALREADY_PENDING;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgDOTAFantasyTeamRosterAddDropResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyTeamRosterAddDropResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTAFantasyTeamRosterAddDropResponse_EResult value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyTeamRosterAddDropResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int result_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamTradesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyTeamTradesRequest) */ {
 public:
  CMsgDOTAFantasyTeamTradesRequest();
  virtual ~CMsgDOTAFantasyTeamTradesRequest();

  CMsgDOTAFantasyTeamTradesRequest(const CMsgDOTAFantasyTeamTradesRequest& from);

  inline CMsgDOTAFantasyTeamTradesRequest& operator=(const CMsgDOTAFantasyTeamTradesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyTeamTradesRequest(CMsgDOTAFantasyTeamTradesRequest&& from) noexcept
    : CMsgDOTAFantasyTeamTradesRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyTeamTradesRequest& operator=(CMsgDOTAFantasyTeamTradesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyTeamTradesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyTeamTradesRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyTeamTradesRequest*>(
               &_CMsgDOTAFantasyTeamTradesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  void Swap(CMsgDOTAFantasyTeamTradesRequest* other);
  friend void swap(CMsgDOTAFantasyTeamTradesRequest& a, CMsgDOTAFantasyTeamTradesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyTeamTradesRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamTradesRequest>(nullptr);
  }

  CMsgDOTAFantasyTeamTradesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamTradesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyTeamTradesRequest& from);
  void MergeFrom(const CMsgDOTAFantasyTeamTradesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyTeamTradesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyTeamTradesRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamTradesResponse_Trade final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyTeamTradesResponse.Trade) */ {
 public:
  CMsgDOTAFantasyTeamTradesResponse_Trade();
  virtual ~CMsgDOTAFantasyTeamTradesResponse_Trade();

  CMsgDOTAFantasyTeamTradesResponse_Trade(const CMsgDOTAFantasyTeamTradesResponse_Trade& from);

  inline CMsgDOTAFantasyTeamTradesResponse_Trade& operator=(const CMsgDOTAFantasyTeamTradesResponse_Trade& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyTeamTradesResponse_Trade(CMsgDOTAFantasyTeamTradesResponse_Trade&& from) noexcept
    : CMsgDOTAFantasyTeamTradesResponse_Trade() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyTeamTradesResponse_Trade& operator=(CMsgDOTAFantasyTeamTradesResponse_Trade&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyTeamTradesResponse_Trade& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyTeamTradesResponse_Trade* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyTeamTradesResponse_Trade*>(
               &_CMsgDOTAFantasyTeamTradesResponse_Trade_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  void Swap(CMsgDOTAFantasyTeamTradesResponse_Trade* other);
  friend void swap(CMsgDOTAFantasyTeamTradesResponse_Trade& a, CMsgDOTAFantasyTeamTradesResponse_Trade& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyTeamTradesResponse_Trade* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamTradesResponse_Trade>(nullptr);
  }

  CMsgDOTAFantasyTeamTradesResponse_Trade* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamTradesResponse_Trade>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyTeamTradesResponse_Trade& from);
  void MergeFrom(const CMsgDOTAFantasyTeamTradesResponse_Trade& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyTeamTradesResponse_Trade* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // optional uint32 owner_account_id_1 = 2;
  bool has_owner_account_id_1() const;
  void clear_owner_account_id_1();
  static const int kOwnerAccountId1FieldNumber = 2;
  ::google::protobuf::uint32 owner_account_id_1() const;
  void set_owner_account_id_1(::google::protobuf::uint32 value);

  // optional uint32 owner_account_id_2 = 3;
  bool has_owner_account_id_2() const;
  void clear_owner_account_id_2();
  static const int kOwnerAccountId2FieldNumber = 3;
  ::google::protobuf::uint32 owner_account_id_2() const;
  void set_owner_account_id_2(::google::protobuf::uint32 value);

  // optional uint32 player_account_id_1 = 4;
  bool has_player_account_id_1() const;
  void clear_player_account_id_1();
  static const int kPlayerAccountId1FieldNumber = 4;
  ::google::protobuf::uint32 player_account_id_1() const;
  void set_player_account_id_1(::google::protobuf::uint32 value);

  // optional uint32 player_account_id_2 = 5;
  bool has_player_account_id_2() const;
  void clear_player_account_id_2();
  static const int kPlayerAccountId2FieldNumber = 5;
  ::google::protobuf::uint32 player_account_id_2() const;
  void set_player_account_id_2(::google::protobuf::uint32 value);

  // optional uint32 status = 6;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 6;
  ::google::protobuf::uint32 status() const;
  void set_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyTeamTradesResponse.Trade)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::uint32 owner_account_id_1_;
  ::google::protobuf::uint32 owner_account_id_2_;
  ::google::protobuf::uint32 player_account_id_1_;
  ::google::protobuf::uint32 player_account_id_2_;
  ::google::protobuf::uint32 status_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamTradesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyTeamTradesResponse) */ {
 public:
  CMsgDOTAFantasyTeamTradesResponse();
  virtual ~CMsgDOTAFantasyTeamTradesResponse();

  CMsgDOTAFantasyTeamTradesResponse(const CMsgDOTAFantasyTeamTradesResponse& from);

  inline CMsgDOTAFantasyTeamTradesResponse& operator=(const CMsgDOTAFantasyTeamTradesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyTeamTradesResponse(CMsgDOTAFantasyTeamTradesResponse&& from) noexcept
    : CMsgDOTAFantasyTeamTradesResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyTeamTradesResponse& operator=(CMsgDOTAFantasyTeamTradesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyTeamTradesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyTeamTradesResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyTeamTradesResponse*>(
               &_CMsgDOTAFantasyTeamTradesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  void Swap(CMsgDOTAFantasyTeamTradesResponse* other);
  friend void swap(CMsgDOTAFantasyTeamTradesResponse& a, CMsgDOTAFantasyTeamTradesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyTeamTradesResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamTradesResponse>(nullptr);
  }

  CMsgDOTAFantasyTeamTradesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamTradesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyTeamTradesResponse& from);
  void MergeFrom(const CMsgDOTAFantasyTeamTradesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyTeamTradesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyTeamTradesResponse_Trade Trade;

  typedef CMsgDOTAFantasyTeamTradesResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTAFantasyTeamTradesResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTAFantasyTeamTradesResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NO_PERMISSION =
    CMsgDOTAFantasyTeamTradesResponse_EResult_ERROR_NO_PERMISSION;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyTeamTradesResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyTeamTradesResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyTeamTradesResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyTeamTradesResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyTeamTradesResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyTeamTradesResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyTeamTradesResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTAFantasyTeamTradesResponse.Trade trades = 2;
  int trades_size() const;
  void clear_trades();
  static const int kTradesFieldNumber = 2;
  ::proto::dota::CMsgDOTAFantasyTeamTradesResponse_Trade* mutable_trades(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyTeamTradesResponse_Trade >*
      mutable_trades();
  const ::proto::dota::CMsgDOTAFantasyTeamTradesResponse_Trade& trades(int index) const;
  ::proto::dota::CMsgDOTAFantasyTeamTradesResponse_Trade* add_trades();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyTeamTradesResponse_Trade >&
      trades() const;

  // optional .proto.dota.CMsgDOTAFantasyTeamTradesResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyTeamTradesResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTAFantasyTeamTradesResponse_EResult value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyTeamTradesResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyTeamTradesResponse_Trade > trades_;
  int result_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamTradeCancelRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyTeamTradeCancelRequest) */ {
 public:
  CMsgDOTAFantasyTeamTradeCancelRequest();
  virtual ~CMsgDOTAFantasyTeamTradeCancelRequest();

  CMsgDOTAFantasyTeamTradeCancelRequest(const CMsgDOTAFantasyTeamTradeCancelRequest& from);

  inline CMsgDOTAFantasyTeamTradeCancelRequest& operator=(const CMsgDOTAFantasyTeamTradeCancelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyTeamTradeCancelRequest(CMsgDOTAFantasyTeamTradeCancelRequest&& from) noexcept
    : CMsgDOTAFantasyTeamTradeCancelRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyTeamTradeCancelRequest& operator=(CMsgDOTAFantasyTeamTradeCancelRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyTeamTradeCancelRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyTeamTradeCancelRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyTeamTradeCancelRequest*>(
               &_CMsgDOTAFantasyTeamTradeCancelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  void Swap(CMsgDOTAFantasyTeamTradeCancelRequest* other);
  friend void swap(CMsgDOTAFantasyTeamTradeCancelRequest& a, CMsgDOTAFantasyTeamTradeCancelRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyTeamTradeCancelRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamTradeCancelRequest>(nullptr);
  }

  CMsgDOTAFantasyTeamTradeCancelRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamTradeCancelRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyTeamTradeCancelRequest& from);
  void MergeFrom(const CMsgDOTAFantasyTeamTradeCancelRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyTeamTradeCancelRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 team_index_1 = 3;
  bool has_team_index_1() const;
  void clear_team_index_1();
  static const int kTeamIndex1FieldNumber = 3;
  ::google::protobuf::uint32 team_index_1() const;
  void set_team_index_1(::google::protobuf::uint32 value);

  // optional uint32 owner_account_id_2 = 4;
  bool has_owner_account_id_2() const;
  void clear_owner_account_id_2();
  static const int kOwnerAccountId2FieldNumber = 4;
  ::google::protobuf::uint32 owner_account_id_2() const;
  void set_owner_account_id_2(::google::protobuf::uint32 value);

  // optional uint32 team_index_2 = 5;
  bool has_team_index_2() const;
  void clear_team_index_2();
  static const int kTeamIndex2FieldNumber = 5;
  ::google::protobuf::uint32 team_index_2() const;
  void set_team_index_2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyTeamTradeCancelRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 team_index_1_;
  ::google::protobuf::uint32 owner_account_id_2_;
  ::google::protobuf::uint32 team_index_2_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamTradeCancelResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyTeamTradeCancelResponse) */ {
 public:
  CMsgDOTAFantasyTeamTradeCancelResponse();
  virtual ~CMsgDOTAFantasyTeamTradeCancelResponse();

  CMsgDOTAFantasyTeamTradeCancelResponse(const CMsgDOTAFantasyTeamTradeCancelResponse& from);

  inline CMsgDOTAFantasyTeamTradeCancelResponse& operator=(const CMsgDOTAFantasyTeamTradeCancelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyTeamTradeCancelResponse(CMsgDOTAFantasyTeamTradeCancelResponse&& from) noexcept
    : CMsgDOTAFantasyTeamTradeCancelResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyTeamTradeCancelResponse& operator=(CMsgDOTAFantasyTeamTradeCancelResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyTeamTradeCancelResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyTeamTradeCancelResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyTeamTradeCancelResponse*>(
               &_CMsgDOTAFantasyTeamTradeCancelResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  void Swap(CMsgDOTAFantasyTeamTradeCancelResponse* other);
  friend void swap(CMsgDOTAFantasyTeamTradeCancelResponse& a, CMsgDOTAFantasyTeamTradeCancelResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyTeamTradeCancelResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamTradeCancelResponse>(nullptr);
  }

  CMsgDOTAFantasyTeamTradeCancelResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamTradeCancelResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyTeamTradeCancelResponse& from);
  void MergeFrom(const CMsgDOTAFantasyTeamTradeCancelResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyTeamTradeCancelResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyTeamTradeCancelResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTAFantasyTeamTradeCancelResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTAFantasyTeamTradeCancelResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NO_PERMISSION =
    CMsgDOTAFantasyTeamTradeCancelResponse_EResult_ERROR_NO_PERMISSION;
  static const EResult ERROR_NO_TRADE =
    CMsgDOTAFantasyTeamTradeCancelResponse_EResult_ERROR_NO_TRADE;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyTeamTradeCancelResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyTeamTradeCancelResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyTeamTradeCancelResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyTeamTradeCancelResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyTeamTradeCancelResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyTeamTradeCancelResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyTeamTradeCancelResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgDOTAFantasyTeamTradeCancelResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyTeamTradeCancelResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTAFantasyTeamTradeCancelResponse_EResult value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyTeamTradeCancelResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int result_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamRosterRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyTeamRosterRequest) */ {
 public:
  CMsgDOTAFantasyTeamRosterRequest();
  virtual ~CMsgDOTAFantasyTeamRosterRequest();

  CMsgDOTAFantasyTeamRosterRequest(const CMsgDOTAFantasyTeamRosterRequest& from);

  inline CMsgDOTAFantasyTeamRosterRequest& operator=(const CMsgDOTAFantasyTeamRosterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyTeamRosterRequest(CMsgDOTAFantasyTeamRosterRequest&& from) noexcept
    : CMsgDOTAFantasyTeamRosterRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyTeamRosterRequest& operator=(CMsgDOTAFantasyTeamRosterRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyTeamRosterRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyTeamRosterRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyTeamRosterRequest*>(
               &_CMsgDOTAFantasyTeamRosterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  void Swap(CMsgDOTAFantasyTeamRosterRequest* other);
  friend void swap(CMsgDOTAFantasyTeamRosterRequest& a, CMsgDOTAFantasyTeamRosterRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyTeamRosterRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamRosterRequest>(nullptr);
  }

  CMsgDOTAFantasyTeamRosterRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamRosterRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyTeamRosterRequest& from);
  void MergeFrom(const CMsgDOTAFantasyTeamRosterRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyTeamRosterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 team_index = 2;
  bool has_team_index() const;
  void clear_team_index();
  static const int kTeamIndexFieldNumber = 2;
  ::google::protobuf::uint32 team_index() const;
  void set_team_index(::google::protobuf::uint32 value);

  // optional uint32 owner_account_id = 3;
  bool has_owner_account_id() const;
  void clear_owner_account_id();
  static const int kOwnerAccountIdFieldNumber = 3;
  ::google::protobuf::uint32 owner_account_id() const;
  void set_owner_account_id(::google::protobuf::uint32 value);

  // optional uint32 timestamp = 4;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyTeamRosterRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 team_index_;
  ::google::protobuf::uint32 owner_account_id_;
  ::google::protobuf::uint32 timestamp_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyTeamRosterResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyTeamRosterResponse) */ {
 public:
  CMsgDOTAFantasyTeamRosterResponse();
  virtual ~CMsgDOTAFantasyTeamRosterResponse();

  CMsgDOTAFantasyTeamRosterResponse(const CMsgDOTAFantasyTeamRosterResponse& from);

  inline CMsgDOTAFantasyTeamRosterResponse& operator=(const CMsgDOTAFantasyTeamRosterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyTeamRosterResponse(CMsgDOTAFantasyTeamRosterResponse&& from) noexcept
    : CMsgDOTAFantasyTeamRosterResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyTeamRosterResponse& operator=(CMsgDOTAFantasyTeamRosterResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyTeamRosterResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyTeamRosterResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyTeamRosterResponse*>(
               &_CMsgDOTAFantasyTeamRosterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  void Swap(CMsgDOTAFantasyTeamRosterResponse* other);
  friend void swap(CMsgDOTAFantasyTeamRosterResponse& a, CMsgDOTAFantasyTeamRosterResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyTeamRosterResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamRosterResponse>(nullptr);
  }

  CMsgDOTAFantasyTeamRosterResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyTeamRosterResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyTeamRosterResponse& from);
  void MergeFrom(const CMsgDOTAFantasyTeamRosterResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyTeamRosterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyTeamRosterResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTAFantasyTeamRosterResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTAFantasyTeamRosterResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NO_PERMISSION =
    CMsgDOTAFantasyTeamRosterResponse_EResult_ERROR_NO_PERMISSION;
  static const EResult ERROR_OWNER_NOT_IN_LEAGUE =
    CMsgDOTAFantasyTeamRosterResponse_EResult_ERROR_OWNER_NOT_IN_LEAGUE;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyTeamRosterResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyTeamRosterResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyTeamRosterResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyTeamRosterResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyTeamRosterResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyTeamRosterResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyTeamRosterResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated uint32 player_account_ids = 2;
  int player_account_ids_size() const;
  void clear_player_account_ids();
  static const int kPlayerAccountIdsFieldNumber = 2;
  ::google::protobuf::uint32 player_account_ids(int index) const;
  void set_player_account_ids(int index, ::google::protobuf::uint32 value);
  void add_player_account_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      player_account_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_player_account_ids();

  // repeated bool player_locked = 3;
  int player_locked_size() const;
  void clear_player_locked();
  static const int kPlayerLockedFieldNumber = 3;
  bool player_locked(int index) const;
  void set_player_locked(int index, bool value);
  void add_player_locked(bool value);
  const ::google::protobuf::RepeatedField< bool >&
      player_locked() const;
  ::google::protobuf::RepeatedField< bool >*
      mutable_player_locked();

  // optional .proto.dota.CMsgDOTAFantasyTeamRosterResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyTeamRosterResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTAFantasyTeamRosterResponse_EResult value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyTeamRosterResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > player_account_ids_;
  ::google::protobuf::RepeatedField< bool > player_locked_;
  int result_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerHisoricalStatsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsRequest) */ {
 public:
  CMsgDOTAFantasyPlayerHisoricalStatsRequest();
  virtual ~CMsgDOTAFantasyPlayerHisoricalStatsRequest();

  CMsgDOTAFantasyPlayerHisoricalStatsRequest(const CMsgDOTAFantasyPlayerHisoricalStatsRequest& from);

  inline CMsgDOTAFantasyPlayerHisoricalStatsRequest& operator=(const CMsgDOTAFantasyPlayerHisoricalStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyPlayerHisoricalStatsRequest(CMsgDOTAFantasyPlayerHisoricalStatsRequest&& from) noexcept
    : CMsgDOTAFantasyPlayerHisoricalStatsRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyPlayerHisoricalStatsRequest& operator=(CMsgDOTAFantasyPlayerHisoricalStatsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyPlayerHisoricalStatsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyPlayerHisoricalStatsRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyPlayerHisoricalStatsRequest*>(
               &_CMsgDOTAFantasyPlayerHisoricalStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  void Swap(CMsgDOTAFantasyPlayerHisoricalStatsRequest* other);
  friend void swap(CMsgDOTAFantasyPlayerHisoricalStatsRequest& a, CMsgDOTAFantasyPlayerHisoricalStatsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyPlayerHisoricalStatsRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyPlayerHisoricalStatsRequest>(nullptr);
  }

  CMsgDOTAFantasyPlayerHisoricalStatsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyPlayerHisoricalStatsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyPlayerHisoricalStatsRequest& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerHisoricalStatsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyPlayerHisoricalStatsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator) */ {
 public:
  CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator();
  virtual ~CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator();

  CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator(const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator& from);

  inline CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator& operator=(const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator(CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator&& from) noexcept
    : CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator& operator=(CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator*>(
               &_CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  void Swap(CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* other);
  friend void swap(CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator& a, CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator>(nullptr);
  }

  CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 matches = 1;
  bool has_matches() const;
  void clear_matches();
  static const int kMatchesFieldNumber = 1;
  ::google::protobuf::uint32 matches() const;
  void set_matches(::google::protobuf::uint32 value);

  // optional float levels = 2;
  bool has_levels() const;
  void clear_levels();
  static const int kLevelsFieldNumber = 2;
  float levels() const;
  void set_levels(float value);

  // optional float kills = 3;
  bool has_kills() const;
  void clear_kills();
  static const int kKillsFieldNumber = 3;
  float kills() const;
  void set_kills(float value);

  // optional float deaths = 4;
  bool has_deaths() const;
  void clear_deaths();
  static const int kDeathsFieldNumber = 4;
  float deaths() const;
  void set_deaths(float value);

  // optional float assists = 5;
  bool has_assists() const;
  void clear_assists();
  static const int kAssistsFieldNumber = 5;
  float assists() const;
  void set_assists(float value);

  // optional float last_hits = 6;
  bool has_last_hits() const;
  void clear_last_hits();
  static const int kLastHitsFieldNumber = 6;
  float last_hits() const;
  void set_last_hits(float value);

  // optional float denies = 7;
  bool has_denies() const;
  void clear_denies();
  static const int kDeniesFieldNumber = 7;
  float denies() const;
  void set_denies(float value);

  // optional float gpm = 8;
  bool has_gpm() const;
  void clear_gpm();
  static const int kGpmFieldNumber = 8;
  float gpm() const;
  void set_gpm(float value);

  // optional float xppm = 9;
  bool has_xppm() const;
  void clear_xppm();
  static const int kXppmFieldNumber = 9;
  float xppm() const;
  void set_xppm(float value);

  // optional float stuns = 10;
  bool has_stuns() const;
  void clear_stuns();
  static const int kStunsFieldNumber = 10;
  float stuns() const;
  void set_stuns(float value);

  // optional float healing = 11;
  bool has_healing() const;
  void clear_healing();
  static const int kHealingFieldNumber = 11;
  float healing() const;
  void set_healing(float value);

  // optional float tower_kills = 12;
  bool has_tower_kills() const;
  void clear_tower_kills();
  static const int kTowerKillsFieldNumber = 12;
  float tower_kills() const;
  void set_tower_kills(float value);

  // optional float roshan_kills = 13;
  bool has_roshan_kills() const;
  void clear_roshan_kills();
  static const int kRoshanKillsFieldNumber = 13;
  float roshan_kills() const;
  void set_roshan_kills(float value);

  // optional float score = 14;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 14;
  float score() const;
  void set_score(float value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 matches_;
  float levels_;
  float kills_;
  float deaths_;
  float assists_;
  float last_hits_;
  float denies_;
  float gpm_;
  float xppm_;
  float stuns_;
  float healing_;
  float tower_kills_;
  float roshan_kills_;
  float score_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats) */ {
 public:
  CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats();
  virtual ~CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats();

  CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats(const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats& from);

  inline CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats& operator=(const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats(CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats&& from) noexcept
    : CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats& operator=(CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats*>(
               &_CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  void Swap(CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats* other);
  friend void swap(CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats& a, CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats>(nullptr);
  }

  CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator stats_premium = 4;
  bool has_stats_premium() const;
  void clear_stats_premium();
  static const int kStatsPremiumFieldNumber = 4;
  const ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator& stats_premium() const;
  ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* release_stats_premium();
  ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* mutable_stats_premium();
  void set_allocated_stats_premium(::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* stats_premium);

  // optional .proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator stats_professional = 5;
  bool has_stats_professional() const;
  void clear_stats_professional();
  static const int kStatsProfessionalFieldNumber = 5;
  const ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator& stats_professional() const;
  ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* release_stats_professional();
  ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* mutable_stats_professional();
  void set_allocated_stats_professional(::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* stats_professional);

  // optional uint32 account_id = 1;
  bool has_account_id() const;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  ::google::protobuf::uint32 account_id() const;
  void set_account_id(::google::protobuf::uint32 value);

  // optional uint32 weeks = 2;
  bool has_weeks() const;
  void clear_weeks();
  static const int kWeeksFieldNumber = 2;
  ::google::protobuf::uint32 weeks() const;
  void set_weeks(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* stats_premium_;
  ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* stats_professional_;
  ::google::protobuf::uint32 account_id_;
  ::google::protobuf::uint32 weeks_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerHisoricalStatsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse) */ {
 public:
  CMsgDOTAFantasyPlayerHisoricalStatsResponse();
  virtual ~CMsgDOTAFantasyPlayerHisoricalStatsResponse();

  CMsgDOTAFantasyPlayerHisoricalStatsResponse(const CMsgDOTAFantasyPlayerHisoricalStatsResponse& from);

  inline CMsgDOTAFantasyPlayerHisoricalStatsResponse& operator=(const CMsgDOTAFantasyPlayerHisoricalStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyPlayerHisoricalStatsResponse(CMsgDOTAFantasyPlayerHisoricalStatsResponse&& from) noexcept
    : CMsgDOTAFantasyPlayerHisoricalStatsResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyPlayerHisoricalStatsResponse& operator=(CMsgDOTAFantasyPlayerHisoricalStatsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyPlayerHisoricalStatsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyPlayerHisoricalStatsResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyPlayerHisoricalStatsResponse*>(
               &_CMsgDOTAFantasyPlayerHisoricalStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  void Swap(CMsgDOTAFantasyPlayerHisoricalStatsResponse* other);
  friend void swap(CMsgDOTAFantasyPlayerHisoricalStatsResponse& a, CMsgDOTAFantasyPlayerHisoricalStatsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyPlayerHisoricalStatsResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyPlayerHisoricalStatsResponse>(nullptr);
  }

  CMsgDOTAFantasyPlayerHisoricalStatsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyPlayerHisoricalStatsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyPlayerHisoricalStatsResponse& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerHisoricalStatsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyPlayerHisoricalStatsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator PlayerScoreAccumulator;
  typedef CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats PlayerStats;

  typedef CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NO_PERMISSION =
    CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_ERROR_NO_PERMISSION;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats stats = 2;
  int stats_size() const;
  void clear_stats();
  static const int kStatsFieldNumber = 2;
  ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats* mutable_stats(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats >*
      mutable_stats();
  const ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats& stats(int index) const;
  ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats* add_stats();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats >&
      stats() const;

  // optional .proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats > stats_;
  int result_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyMessageAdd final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyMessageAdd) */ {
 public:
  CMsgDOTAFantasyMessageAdd();
  virtual ~CMsgDOTAFantasyMessageAdd();

  CMsgDOTAFantasyMessageAdd(const CMsgDOTAFantasyMessageAdd& from);

  inline CMsgDOTAFantasyMessageAdd& operator=(const CMsgDOTAFantasyMessageAdd& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyMessageAdd(CMsgDOTAFantasyMessageAdd&& from) noexcept
    : CMsgDOTAFantasyMessageAdd() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyMessageAdd& operator=(CMsgDOTAFantasyMessageAdd&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyMessageAdd& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyMessageAdd* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyMessageAdd*>(
               &_CMsgDOTAFantasyMessageAdd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  void Swap(CMsgDOTAFantasyMessageAdd* other);
  friend void swap(CMsgDOTAFantasyMessageAdd& a, CMsgDOTAFantasyMessageAdd& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyMessageAdd* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyMessageAdd>(nullptr);
  }

  CMsgDOTAFantasyMessageAdd* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyMessageAdd>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyMessageAdd& from);
  void MergeFrom(const CMsgDOTAFantasyMessageAdd& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyMessageAdd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyMessageAdd)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyMessagesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyMessagesRequest) */ {
 public:
  CMsgDOTAFantasyMessagesRequest();
  virtual ~CMsgDOTAFantasyMessagesRequest();

  CMsgDOTAFantasyMessagesRequest(const CMsgDOTAFantasyMessagesRequest& from);

  inline CMsgDOTAFantasyMessagesRequest& operator=(const CMsgDOTAFantasyMessagesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyMessagesRequest(CMsgDOTAFantasyMessagesRequest&& from) noexcept
    : CMsgDOTAFantasyMessagesRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyMessagesRequest& operator=(CMsgDOTAFantasyMessagesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyMessagesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyMessagesRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyMessagesRequest*>(
               &_CMsgDOTAFantasyMessagesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  void Swap(CMsgDOTAFantasyMessagesRequest* other);
  friend void swap(CMsgDOTAFantasyMessagesRequest& a, CMsgDOTAFantasyMessagesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyMessagesRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyMessagesRequest>(nullptr);
  }

  CMsgDOTAFantasyMessagesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyMessagesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyMessagesRequest& from);
  void MergeFrom(const CMsgDOTAFantasyMessagesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyMessagesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 start_message = 2;
  bool has_start_message() const;
  void clear_start_message();
  static const int kStartMessageFieldNumber = 2;
  ::google::protobuf::uint32 start_message() const;
  void set_start_message(::google::protobuf::uint32 value);

  // optional uint32 end_message = 3;
  bool has_end_message() const;
  void clear_end_message();
  static const int kEndMessageFieldNumber = 3;
  ::google::protobuf::uint32 end_message() const;
  void set_end_message(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyMessagesRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 start_message_;
  ::google::protobuf::uint32 end_message_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyMessagesResponse_Message final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyMessagesResponse.Message) */ {
 public:
  CMsgDOTAFantasyMessagesResponse_Message();
  virtual ~CMsgDOTAFantasyMessagesResponse_Message();

  CMsgDOTAFantasyMessagesResponse_Message(const CMsgDOTAFantasyMessagesResponse_Message& from);

  inline CMsgDOTAFantasyMessagesResponse_Message& operator=(const CMsgDOTAFantasyMessagesResponse_Message& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyMessagesResponse_Message(CMsgDOTAFantasyMessagesResponse_Message&& from) noexcept
    : CMsgDOTAFantasyMessagesResponse_Message() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyMessagesResponse_Message& operator=(CMsgDOTAFantasyMessagesResponse_Message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyMessagesResponse_Message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyMessagesResponse_Message* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyMessagesResponse_Message*>(
               &_CMsgDOTAFantasyMessagesResponse_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  void Swap(CMsgDOTAFantasyMessagesResponse_Message* other);
  friend void swap(CMsgDOTAFantasyMessagesResponse_Message& a, CMsgDOTAFantasyMessagesResponse_Message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyMessagesResponse_Message* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyMessagesResponse_Message>(nullptr);
  }

  CMsgDOTAFantasyMessagesResponse_Message* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyMessagesResponse_Message>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyMessagesResponse_Message& from);
  void MergeFrom(const CMsgDOTAFantasyMessagesResponse_Message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyMessagesResponse_Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional uint32 message_id = 1;
  bool has_message_id() const;
  void clear_message_id();
  static const int kMessageIdFieldNumber = 1;
  ::google::protobuf::uint32 message_id() const;
  void set_message_id(::google::protobuf::uint32 value);

  // optional uint32 author_account_id = 3;
  bool has_author_account_id() const;
  void clear_author_account_id();
  static const int kAuthorAccountIdFieldNumber = 3;
  ::google::protobuf::uint32 author_account_id() const;
  void set_author_account_id(::google::protobuf::uint32 value);

  // optional uint32 time = 4;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 4;
  ::google::protobuf::uint32 time() const;
  void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyMessagesResponse.Message)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::uint32 message_id_;
  ::google::protobuf::uint32 author_account_id_;
  ::google::protobuf::uint32 time_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyMessagesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyMessagesResponse) */ {
 public:
  CMsgDOTAFantasyMessagesResponse();
  virtual ~CMsgDOTAFantasyMessagesResponse();

  CMsgDOTAFantasyMessagesResponse(const CMsgDOTAFantasyMessagesResponse& from);

  inline CMsgDOTAFantasyMessagesResponse& operator=(const CMsgDOTAFantasyMessagesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyMessagesResponse(CMsgDOTAFantasyMessagesResponse&& from) noexcept
    : CMsgDOTAFantasyMessagesResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyMessagesResponse& operator=(CMsgDOTAFantasyMessagesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyMessagesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyMessagesResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyMessagesResponse*>(
               &_CMsgDOTAFantasyMessagesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  void Swap(CMsgDOTAFantasyMessagesResponse* other);
  friend void swap(CMsgDOTAFantasyMessagesResponse& a, CMsgDOTAFantasyMessagesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyMessagesResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyMessagesResponse>(nullptr);
  }

  CMsgDOTAFantasyMessagesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyMessagesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyMessagesResponse& from);
  void MergeFrom(const CMsgDOTAFantasyMessagesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyMessagesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyMessagesResponse_Message Message;

  typedef CMsgDOTAFantasyMessagesResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTAFantasyMessagesResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTAFantasyMessagesResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NO_PERMISSION =
    CMsgDOTAFantasyMessagesResponse_EResult_ERROR_NO_PERMISSION;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyMessagesResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyMessagesResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyMessagesResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyMessagesResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyMessagesResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyMessagesResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyMessagesResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTAFantasyMessagesResponse.Message messages = 2;
  int messages_size() const;
  void clear_messages();
  static const int kMessagesFieldNumber = 2;
  ::proto::dota::CMsgDOTAFantasyMessagesResponse_Message* mutable_messages(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyMessagesResponse_Message >*
      mutable_messages();
  const ::proto::dota::CMsgDOTAFantasyMessagesResponse_Message& messages(int index) const;
  ::proto::dota::CMsgDOTAFantasyMessagesResponse_Message* add_messages();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyMessagesResponse_Message >&
      messages() const;

  // optional .proto.dota.CMsgDOTAFantasyMessagesResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyMessagesResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTAFantasyMessagesResponse_EResult value);

  // optional uint32 num_total_messages = 3;
  bool has_num_total_messages() const;
  void clear_num_total_messages();
  static const int kNumTotalMessagesFieldNumber = 3;
  ::google::protobuf::uint32 num_total_messages() const;
  void set_num_total_messages(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyMessagesResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyMessagesResponse_Message > messages_;
  int result_;
  ::google::protobuf::uint32 num_total_messages_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyRemoveOwner final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyRemoveOwner) */ {
 public:
  CMsgDOTAFantasyRemoveOwner();
  virtual ~CMsgDOTAFantasyRemoveOwner();

  CMsgDOTAFantasyRemoveOwner(const CMsgDOTAFantasyRemoveOwner& from);

  inline CMsgDOTAFantasyRemoveOwner& operator=(const CMsgDOTAFantasyRemoveOwner& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyRemoveOwner(CMsgDOTAFantasyRemoveOwner&& from) noexcept
    : CMsgDOTAFantasyRemoveOwner() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyRemoveOwner& operator=(CMsgDOTAFantasyRemoveOwner&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyRemoveOwner& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyRemoveOwner* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyRemoveOwner*>(
               &_CMsgDOTAFantasyRemoveOwner_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  void Swap(CMsgDOTAFantasyRemoveOwner* other);
  friend void swap(CMsgDOTAFantasyRemoveOwner& a, CMsgDOTAFantasyRemoveOwner& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyRemoveOwner* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyRemoveOwner>(nullptr);
  }

  CMsgDOTAFantasyRemoveOwner* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyRemoveOwner>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyRemoveOwner& from);
  void MergeFrom(const CMsgDOTAFantasyRemoveOwner& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyRemoveOwner* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 owner_account_id = 2;
  bool has_owner_account_id() const;
  void clear_owner_account_id();
  static const int kOwnerAccountIdFieldNumber = 2;
  ::google::protobuf::uint32 owner_account_id() const;
  void set_owner_account_id(::google::protobuf::uint32 value);

  // optional uint32 team_index = 3;
  bool has_team_index() const;
  void clear_team_index();
  static const int kTeamIndexFieldNumber = 3;
  ::google::protobuf::uint32 team_index() const;
  void set_team_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyRemoveOwner)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 owner_account_id_;
  ::google::protobuf::uint32 team_index_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyRemoveOwnerResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyRemoveOwnerResponse) */ {
 public:
  CMsgDOTAFantasyRemoveOwnerResponse();
  virtual ~CMsgDOTAFantasyRemoveOwnerResponse();

  CMsgDOTAFantasyRemoveOwnerResponse(const CMsgDOTAFantasyRemoveOwnerResponse& from);

  inline CMsgDOTAFantasyRemoveOwnerResponse& operator=(const CMsgDOTAFantasyRemoveOwnerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyRemoveOwnerResponse(CMsgDOTAFantasyRemoveOwnerResponse&& from) noexcept
    : CMsgDOTAFantasyRemoveOwnerResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyRemoveOwnerResponse& operator=(CMsgDOTAFantasyRemoveOwnerResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyRemoveOwnerResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyRemoveOwnerResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyRemoveOwnerResponse*>(
               &_CMsgDOTAFantasyRemoveOwnerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  void Swap(CMsgDOTAFantasyRemoveOwnerResponse* other);
  friend void swap(CMsgDOTAFantasyRemoveOwnerResponse& a, CMsgDOTAFantasyRemoveOwnerResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyRemoveOwnerResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyRemoveOwnerResponse>(nullptr);
  }

  CMsgDOTAFantasyRemoveOwnerResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyRemoveOwnerResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyRemoveOwnerResponse& from);
  void MergeFrom(const CMsgDOTAFantasyRemoveOwnerResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyRemoveOwnerResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyRemoveOwnerResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTAFantasyRemoveOwnerResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTAFantasyRemoveOwnerResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NO_PERMISSION =
    CMsgDOTAFantasyRemoveOwnerResponse_EResult_ERROR_NO_PERMISSION;
  static const EResult ERROR_LEAGUE_LOCKED =
    CMsgDOTAFantasyRemoveOwnerResponse_EResult_ERROR_LEAGUE_LOCKED;
  static const EResult ERROR_NOT_A_MEMBER =
    CMsgDOTAFantasyRemoveOwnerResponse_EResult_ERROR_NOT_A_MEMBER;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyRemoveOwnerResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyRemoveOwnerResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyRemoveOwnerResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyRemoveOwnerResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyRemoveOwnerResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyRemoveOwnerResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyRemoveOwnerResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgDOTAFantasyRemoveOwnerResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyRemoveOwnerResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTAFantasyRemoveOwnerResponse_EResult value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyRemoveOwnerResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int result_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyScheduledMatchesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyScheduledMatchesRequest) */ {
 public:
  CMsgDOTAFantasyScheduledMatchesRequest();
  virtual ~CMsgDOTAFantasyScheduledMatchesRequest();

  CMsgDOTAFantasyScheduledMatchesRequest(const CMsgDOTAFantasyScheduledMatchesRequest& from);

  inline CMsgDOTAFantasyScheduledMatchesRequest& operator=(const CMsgDOTAFantasyScheduledMatchesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyScheduledMatchesRequest(CMsgDOTAFantasyScheduledMatchesRequest&& from) noexcept
    : CMsgDOTAFantasyScheduledMatchesRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyScheduledMatchesRequest& operator=(CMsgDOTAFantasyScheduledMatchesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyScheduledMatchesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyScheduledMatchesRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyScheduledMatchesRequest*>(
               &_CMsgDOTAFantasyScheduledMatchesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  void Swap(CMsgDOTAFantasyScheduledMatchesRequest* other);
  friend void swap(CMsgDOTAFantasyScheduledMatchesRequest& a, CMsgDOTAFantasyScheduledMatchesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyScheduledMatchesRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyScheduledMatchesRequest>(nullptr);
  }

  CMsgDOTAFantasyScheduledMatchesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyScheduledMatchesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyScheduledMatchesRequest& from);
  void MergeFrom(const CMsgDOTAFantasyScheduledMatchesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyScheduledMatchesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyScheduledMatchesRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays) */ {
 public:
  CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays();
  virtual ~CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays();

  CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays(const CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays& from);

  inline CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays& operator=(const CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays(CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays&& from) noexcept
    : CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays& operator=(CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays*>(
               &_CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  void Swap(CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays* other);
  friend void swap(CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays& a, CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays>(nullptr);
  }

  CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays& from);
  void MergeFrom(const CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 team_ids = 2;
  int team_ids_size() const;
  void clear_team_ids();
  static const int kTeamIdsFieldNumber = 2;
  ::google::protobuf::uint32 team_ids(int index) const;
  void set_team_ids(int index, ::google::protobuf::uint32 value);
  void add_team_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      team_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_team_ids();

  // repeated uint32 league_ids = 3;
  int league_ids_size() const;
  void clear_league_ids();
  static const int kLeagueIdsFieldNumber = 3;
  ::google::protobuf::uint32 league_ids(int index) const;
  void set_league_ids(int index, ::google::protobuf::uint32 value);
  void add_league_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      league_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_league_ids();

  // optional uint32 timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > team_ids_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > league_ids_;
  ::google::protobuf::uint32 timestamp_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyScheduledMatchesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyScheduledMatchesResponse) */ {
 public:
  CMsgDOTAFantasyScheduledMatchesResponse();
  virtual ~CMsgDOTAFantasyScheduledMatchesResponse();

  CMsgDOTAFantasyScheduledMatchesResponse(const CMsgDOTAFantasyScheduledMatchesResponse& from);

  inline CMsgDOTAFantasyScheduledMatchesResponse& operator=(const CMsgDOTAFantasyScheduledMatchesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyScheduledMatchesResponse(CMsgDOTAFantasyScheduledMatchesResponse&& from) noexcept
    : CMsgDOTAFantasyScheduledMatchesResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyScheduledMatchesResponse& operator=(CMsgDOTAFantasyScheduledMatchesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyScheduledMatchesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyScheduledMatchesResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyScheduledMatchesResponse*>(
               &_CMsgDOTAFantasyScheduledMatchesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  void Swap(CMsgDOTAFantasyScheduledMatchesResponse* other);
  friend void swap(CMsgDOTAFantasyScheduledMatchesResponse& a, CMsgDOTAFantasyScheduledMatchesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyScheduledMatchesResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyScheduledMatchesResponse>(nullptr);
  }

  CMsgDOTAFantasyScheduledMatchesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyScheduledMatchesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyScheduledMatchesResponse& from);
  void MergeFrom(const CMsgDOTAFantasyScheduledMatchesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyScheduledMatchesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays ScheduledMatchDays;

  typedef CMsgDOTAFantasyScheduledMatchesResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTAFantasyScheduledMatchesResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTAFantasyScheduledMatchesResponse_EResult_ERROR_UNSPECIFIED;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyScheduledMatchesResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyScheduledMatchesResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyScheduledMatchesResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyScheduledMatchesResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyScheduledMatchesResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyScheduledMatchesResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyScheduledMatchesResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays scheduled_match_days = 2;
  int scheduled_match_days_size() const;
  void clear_scheduled_match_days();
  static const int kScheduledMatchDaysFieldNumber = 2;
  ::proto::dota::CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays* mutable_scheduled_match_days(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays >*
      mutable_scheduled_match_days();
  const ::proto::dota::CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays& scheduled_match_days(int index) const;
  ::proto::dota::CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays* add_scheduled_match_days();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays >&
      scheduled_match_days() const;

  // optional .proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyScheduledMatchesResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTAFantasyScheduledMatchesResponse_EResult value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyScheduledMatchesResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays > scheduled_match_days_;
  int result_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeaveLeagueRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyLeaveLeagueRequest) */ {
 public:
  CMsgDOTAFantasyLeaveLeagueRequest();
  virtual ~CMsgDOTAFantasyLeaveLeagueRequest();

  CMsgDOTAFantasyLeaveLeagueRequest(const CMsgDOTAFantasyLeaveLeagueRequest& from);

  inline CMsgDOTAFantasyLeaveLeagueRequest& operator=(const CMsgDOTAFantasyLeaveLeagueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyLeaveLeagueRequest(CMsgDOTAFantasyLeaveLeagueRequest&& from) noexcept
    : CMsgDOTAFantasyLeaveLeagueRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyLeaveLeagueRequest& operator=(CMsgDOTAFantasyLeaveLeagueRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyLeaveLeagueRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyLeaveLeagueRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyLeaveLeagueRequest*>(
               &_CMsgDOTAFantasyLeaveLeagueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  void Swap(CMsgDOTAFantasyLeaveLeagueRequest* other);
  friend void swap(CMsgDOTAFantasyLeaveLeagueRequest& a, CMsgDOTAFantasyLeaveLeagueRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyLeaveLeagueRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeaveLeagueRequest>(nullptr);
  }

  CMsgDOTAFantasyLeaveLeagueRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeaveLeagueRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyLeaveLeagueRequest& from);
  void MergeFrom(const CMsgDOTAFantasyLeaveLeagueRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyLeaveLeagueRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 fantasy_team_index = 2;
  bool has_fantasy_team_index() const;
  void clear_fantasy_team_index();
  static const int kFantasyTeamIndexFieldNumber = 2;
  ::google::protobuf::uint32 fantasy_team_index() const;
  void set_fantasy_team_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyLeaveLeagueRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 fantasy_team_index_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyLeaveLeagueResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyLeaveLeagueResponse) */ {
 public:
  CMsgDOTAFantasyLeaveLeagueResponse();
  virtual ~CMsgDOTAFantasyLeaveLeagueResponse();

  CMsgDOTAFantasyLeaveLeagueResponse(const CMsgDOTAFantasyLeaveLeagueResponse& from);

  inline CMsgDOTAFantasyLeaveLeagueResponse& operator=(const CMsgDOTAFantasyLeaveLeagueResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyLeaveLeagueResponse(CMsgDOTAFantasyLeaveLeagueResponse&& from) noexcept
    : CMsgDOTAFantasyLeaveLeagueResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyLeaveLeagueResponse& operator=(CMsgDOTAFantasyLeaveLeagueResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyLeaveLeagueResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyLeaveLeagueResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyLeaveLeagueResponse*>(
               &_CMsgDOTAFantasyLeaveLeagueResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  void Swap(CMsgDOTAFantasyLeaveLeagueResponse* other);
  friend void swap(CMsgDOTAFantasyLeaveLeagueResponse& a, CMsgDOTAFantasyLeaveLeagueResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyLeaveLeagueResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeaveLeagueResponse>(nullptr);
  }

  CMsgDOTAFantasyLeaveLeagueResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyLeaveLeagueResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyLeaveLeagueResponse& from);
  void MergeFrom(const CMsgDOTAFantasyLeaveLeagueResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyLeaveLeagueResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyLeaveLeagueResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTAFantasyLeaveLeagueResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTAFantasyLeaveLeagueResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NOT_MEMBER =
    CMsgDOTAFantasyLeaveLeagueResponse_EResult_ERROR_NOT_MEMBER;
  static const EResult ERROR_LEAGUE_NOT_FOUND =
    CMsgDOTAFantasyLeaveLeagueResponse_EResult_ERROR_LEAGUE_NOT_FOUND;
  static const EResult ERROR_DRAFT_ACTIVE =
    CMsgDOTAFantasyLeaveLeagueResponse_EResult_ERROR_DRAFT_ACTIVE;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyLeaveLeagueResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyLeaveLeagueResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyLeaveLeagueResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyLeaveLeagueResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyLeaveLeagueResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyLeaveLeagueResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyLeaveLeagueResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgDOTAFantasyLeaveLeagueResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyLeaveLeagueResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTAFantasyLeaveLeagueResponse_EResult value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyLeaveLeagueResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int result_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerScoreDetailsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsRequest) */ {
 public:
  CMsgDOTAFantasyPlayerScoreDetailsRequest();
  virtual ~CMsgDOTAFantasyPlayerScoreDetailsRequest();

  CMsgDOTAFantasyPlayerScoreDetailsRequest(const CMsgDOTAFantasyPlayerScoreDetailsRequest& from);

  inline CMsgDOTAFantasyPlayerScoreDetailsRequest& operator=(const CMsgDOTAFantasyPlayerScoreDetailsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyPlayerScoreDetailsRequest(CMsgDOTAFantasyPlayerScoreDetailsRequest&& from) noexcept
    : CMsgDOTAFantasyPlayerScoreDetailsRequest() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyPlayerScoreDetailsRequest& operator=(CMsgDOTAFantasyPlayerScoreDetailsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyPlayerScoreDetailsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyPlayerScoreDetailsRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyPlayerScoreDetailsRequest*>(
               &_CMsgDOTAFantasyPlayerScoreDetailsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  void Swap(CMsgDOTAFantasyPlayerScoreDetailsRequest* other);
  friend void swap(CMsgDOTAFantasyPlayerScoreDetailsRequest& a, CMsgDOTAFantasyPlayerScoreDetailsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyPlayerScoreDetailsRequest* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyPlayerScoreDetailsRequest>(nullptr);
  }

  CMsgDOTAFantasyPlayerScoreDetailsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyPlayerScoreDetailsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyPlayerScoreDetailsRequest& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerScoreDetailsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyPlayerScoreDetailsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fantasy_league_id = 1;
  bool has_fantasy_league_id() const;
  void clear_fantasy_league_id();
  static const int kFantasyLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 fantasy_league_id() const;
  void set_fantasy_league_id(::google::protobuf::uint32 value);

  // optional uint32 player_account_id = 2;
  bool has_player_account_id() const;
  void clear_player_account_id();
  static const int kPlayerAccountIdFieldNumber = 2;
  ::google::protobuf::uint32 player_account_id() const;
  void set_player_account_id(::google::protobuf::uint32 value);

  // optional uint32 start_time = 3;
  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  ::google::protobuf::uint32 start_time() const;
  void set_start_time(::google::protobuf::uint32 value);

  // optional uint32 end_time = 4;
  bool has_end_time() const;
  void clear_end_time();
  static const int kEndTimeFieldNumber = 4;
  ::google::protobuf::uint32 end_time() const;
  void set_end_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 fantasy_league_id_;
  ::google::protobuf::uint32 player_account_id_;
  ::google::protobuf::uint32 start_time_;
  ::google::protobuf::uint32 end_time_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData) */ {
 public:
  CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData();
  virtual ~CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData();

  CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData(const CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData& from);

  inline CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData& operator=(const CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData(CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData&& from) noexcept
    : CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData& operator=(CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData*>(
               &_CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  void Swap(CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData* other);
  friend void swap(CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData& a, CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData>(nullptr);
  }

  CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string opposing_team_name = 9;
  bool has_opposing_team_name() const;
  void clear_opposing_team_name();
  static const int kOpposingTeamNameFieldNumber = 9;
  const ::std::string& opposing_team_name() const;
  void set_opposing_team_name(const ::std::string& value);
  #if LANG_CXX11
  void set_opposing_team_name(::std::string&& value);
  #endif
  void set_opposing_team_name(const char* value);
  void set_opposing_team_name(const char* value, size_t size);
  ::std::string* mutable_opposing_team_name();
  ::std::string* release_opposing_team_name();
  void set_allocated_opposing_team_name(::std::string* opposing_team_name);

  // optional uint64 match_id = 1;
  bool has_match_id() const;
  void clear_match_id();
  static const int kMatchIdFieldNumber = 1;
  ::google::protobuf::uint64 match_id() const;
  void set_match_id(::google::protobuf::uint64 value);

  // optional uint32 series_id = 2;
  bool has_series_id() const;
  void clear_series_id();
  static const int kSeriesIdFieldNumber = 2;
  ::google::protobuf::uint32 series_id() const;
  void set_series_id(::google::protobuf::uint32 value);

  // optional uint32 series_num = 3;
  bool has_series_num() const;
  void clear_series_num();
  static const int kSeriesNumFieldNumber = 3;
  ::google::protobuf::uint32 series_num() const;
  void set_series_num(::google::protobuf::uint32 value);

  // optional uint32 series_type = 4;
  bool has_series_type() const;
  void clear_series_type();
  static const int kSeriesTypeFieldNumber = 4;
  ::google::protobuf::uint32 series_type() const;
  void set_series_type(::google::protobuf::uint32 value);

  // optional uint32 league_tier = 5;
  bool has_league_tier() const;
  void clear_league_tier();
  static const int kLeagueTierFieldNumber = 5;
  ::google::protobuf::uint32 league_tier() const;
  void set_league_tier(::google::protobuf::uint32 value);

  // optional uint32 league_id = 6;
  bool has_league_id() const;
  void clear_league_id();
  static const int kLeagueIdFieldNumber = 6;
  ::google::protobuf::uint32 league_id() const;
  void set_league_id(::google::protobuf::uint32 value);

  // optional uint32 opposing_team_id = 7;
  bool has_opposing_team_id() const;
  void clear_opposing_team_id();
  static const int kOpposingTeamIdFieldNumber = 7;
  ::google::protobuf::uint32 opposing_team_id() const;
  void set_opposing_team_id(::google::protobuf::uint32 value);

  // optional uint64 opposing_team_logo = 8;
  bool has_opposing_team_logo() const;
  void clear_opposing_team_logo();
  static const int kOpposingTeamLogoFieldNumber = 8;
  ::google::protobuf::uint64 opposing_team_logo() const;
  void set_opposing_team_logo(::google::protobuf::uint64 value);

  // optional uint32 owned_by = 11;
  bool has_owned_by() const;
  void clear_owned_by();
  static const int kOwnedByFieldNumber = 11;
  ::google::protobuf::uint32 owned_by() const;
  void set_owned_by(::google::protobuf::uint32 value);

  // optional bool benched = 12;
  bool has_benched() const;
  void clear_benched();
  static const int kBenchedFieldNumber = 12;
  bool benched() const;
  void set_benched(bool value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr opposing_team_name_;
  ::google::protobuf::uint64 match_id_;
  ::google::protobuf::uint32 series_id_;
  ::google::protobuf::uint32 series_num_;
  ::google::protobuf::uint32 series_type_;
  ::google::protobuf::uint32 league_tier_;
  ::google::protobuf::uint32 league_id_;
  ::google::protobuf::uint32 opposing_team_id_;
  ::google::protobuf::uint64 opposing_team_logo_;
  ::google::protobuf::uint32 owned_by_;
  bool benched_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyPlayerScoreDetailsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse) */ {
 public:
  CMsgDOTAFantasyPlayerScoreDetailsResponse();
  virtual ~CMsgDOTAFantasyPlayerScoreDetailsResponse();

  CMsgDOTAFantasyPlayerScoreDetailsResponse(const CMsgDOTAFantasyPlayerScoreDetailsResponse& from);

  inline CMsgDOTAFantasyPlayerScoreDetailsResponse& operator=(const CMsgDOTAFantasyPlayerScoreDetailsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyPlayerScoreDetailsResponse(CMsgDOTAFantasyPlayerScoreDetailsResponse&& from) noexcept
    : CMsgDOTAFantasyPlayerScoreDetailsResponse() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyPlayerScoreDetailsResponse& operator=(CMsgDOTAFantasyPlayerScoreDetailsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyPlayerScoreDetailsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyPlayerScoreDetailsResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyPlayerScoreDetailsResponse*>(
               &_CMsgDOTAFantasyPlayerScoreDetailsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  void Swap(CMsgDOTAFantasyPlayerScoreDetailsResponse* other);
  friend void swap(CMsgDOTAFantasyPlayerScoreDetailsResponse& a, CMsgDOTAFantasyPlayerScoreDetailsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyPlayerScoreDetailsResponse* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyPlayerScoreDetailsResponse>(nullptr);
  }

  CMsgDOTAFantasyPlayerScoreDetailsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyPlayerScoreDetailsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyPlayerScoreDetailsResponse& from);
  void MergeFrom(const CMsgDOTAFantasyPlayerScoreDetailsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyPlayerScoreDetailsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData PlayerMatchData;

  typedef CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult EResult;
  static const EResult SUCCESS =
    CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_SUCCESS;
  static const EResult ERROR_UNSPECIFIED =
    CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_ERROR_UNSPECIFIED;
  static const EResult ERROR_NOT_MEMBER =
    CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_ERROR_NOT_MEMBER;
  static inline bool EResult_IsValid(int value) {
    return CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_IsValid(value);
  }
  static const EResult EResult_MIN =
    CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_EResult_MIN;
  static const EResult EResult_MAX =
    CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_EResult_MAX;
  static const int EResult_ARRAYSIZE =
    CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_EResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EResult_descriptor() {
    return CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_descriptor();
  }
  static inline const ::std::string& EResult_Name(EResult value) {
    return CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_Name(value);
  }
  static inline bool EResult_Parse(const ::std::string& name,
      EResult* value) {
    return CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  ::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData* mutable_data(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData >*
      mutable_data();
  const ::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData& data(int index) const;
  ::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData* add_data();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData >&
      data() const;

  // optional .proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.EResult result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult result() const;
  void set_result(::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData > data_;
  int result_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAPassportVoteTeamGuess final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAPassportVoteTeamGuess) */ {
 public:
  CMsgDOTAPassportVoteTeamGuess();
  virtual ~CMsgDOTAPassportVoteTeamGuess();

  CMsgDOTAPassportVoteTeamGuess(const CMsgDOTAPassportVoteTeamGuess& from);

  inline CMsgDOTAPassportVoteTeamGuess& operator=(const CMsgDOTAPassportVoteTeamGuess& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAPassportVoteTeamGuess(CMsgDOTAPassportVoteTeamGuess&& from) noexcept
    : CMsgDOTAPassportVoteTeamGuess() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAPassportVoteTeamGuess& operator=(CMsgDOTAPassportVoteTeamGuess&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAPassportVoteTeamGuess& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAPassportVoteTeamGuess* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAPassportVoteTeamGuess*>(
               &_CMsgDOTAPassportVoteTeamGuess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  void Swap(CMsgDOTAPassportVoteTeamGuess* other);
  friend void swap(CMsgDOTAPassportVoteTeamGuess& a, CMsgDOTAPassportVoteTeamGuess& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAPassportVoteTeamGuess* New() const final {
    return CreateMaybeMessage<CMsgDOTAPassportVoteTeamGuess>(nullptr);
  }

  CMsgDOTAPassportVoteTeamGuess* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAPassportVoteTeamGuess>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAPassportVoteTeamGuess& from);
  void MergeFrom(const CMsgDOTAPassportVoteTeamGuess& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAPassportVoteTeamGuess* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 league_id = 1;
  bool has_league_id() const;
  void clear_league_id();
  static const int kLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 league_id() const;
  void set_league_id(::google::protobuf::uint32 value);

  // optional uint32 winner_id = 2;
  bool has_winner_id() const;
  void clear_winner_id();
  static const int kWinnerIdFieldNumber = 2;
  ::google::protobuf::uint32 winner_id() const;
  void set_winner_id(::google::protobuf::uint32 value);

  // optional uint32 runnerup_id = 3;
  bool has_runnerup_id() const;
  void clear_runnerup_id();
  static const int kRunnerupIdFieldNumber = 3;
  ::google::protobuf::uint32 runnerup_id() const;
  void set_runnerup_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAPassportVoteTeamGuess)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 league_id_;
  ::google::protobuf::uint32 winner_id_;
  ::google::protobuf::uint32 runnerup_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAPassportVoteGenericSelection final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAPassportVoteGenericSelection) */ {
 public:
  CMsgDOTAPassportVoteGenericSelection();
  virtual ~CMsgDOTAPassportVoteGenericSelection();

  CMsgDOTAPassportVoteGenericSelection(const CMsgDOTAPassportVoteGenericSelection& from);

  inline CMsgDOTAPassportVoteGenericSelection& operator=(const CMsgDOTAPassportVoteGenericSelection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAPassportVoteGenericSelection(CMsgDOTAPassportVoteGenericSelection&& from) noexcept
    : CMsgDOTAPassportVoteGenericSelection() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAPassportVoteGenericSelection& operator=(CMsgDOTAPassportVoteGenericSelection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAPassportVoteGenericSelection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAPassportVoteGenericSelection* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAPassportVoteGenericSelection*>(
               &_CMsgDOTAPassportVoteGenericSelection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  void Swap(CMsgDOTAPassportVoteGenericSelection* other);
  friend void swap(CMsgDOTAPassportVoteGenericSelection& a, CMsgDOTAPassportVoteGenericSelection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAPassportVoteGenericSelection* New() const final {
    return CreateMaybeMessage<CMsgDOTAPassportVoteGenericSelection>(nullptr);
  }

  CMsgDOTAPassportVoteGenericSelection* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAPassportVoteGenericSelection>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAPassportVoteGenericSelection& from);
  void MergeFrom(const CMsgDOTAPassportVoteGenericSelection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAPassportVoteGenericSelection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.dota.DOTA_2013PassportSelectionIndices selection_index = 1 [default = PP13_SEL_ALLSTAR_PLAYER_0];
  bool has_selection_index() const;
  void clear_selection_index();
  static const int kSelectionIndexFieldNumber = 1;
  ::proto::dota::DOTA_2013PassportSelectionIndices selection_index() const;
  void set_selection_index(::proto::dota::DOTA_2013PassportSelectionIndices value);

  // optional uint32 selection = 2;
  bool has_selection() const;
  void clear_selection();
  static const int kSelectionFieldNumber = 2;
  ::google::protobuf::uint32 selection() const;
  void set_selection(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAPassportVoteGenericSelection)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int selection_index_;
  ::google::protobuf::uint32 selection_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAPassportStampedPlayer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAPassportStampedPlayer) */ {
 public:
  CMsgDOTAPassportStampedPlayer();
  virtual ~CMsgDOTAPassportStampedPlayer();

  CMsgDOTAPassportStampedPlayer(const CMsgDOTAPassportStampedPlayer& from);

  inline CMsgDOTAPassportStampedPlayer& operator=(const CMsgDOTAPassportStampedPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAPassportStampedPlayer(CMsgDOTAPassportStampedPlayer&& from) noexcept
    : CMsgDOTAPassportStampedPlayer() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAPassportStampedPlayer& operator=(CMsgDOTAPassportStampedPlayer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAPassportStampedPlayer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAPassportStampedPlayer* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAPassportStampedPlayer*>(
               &_CMsgDOTAPassportStampedPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  void Swap(CMsgDOTAPassportStampedPlayer* other);
  friend void swap(CMsgDOTAPassportStampedPlayer& a, CMsgDOTAPassportStampedPlayer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAPassportStampedPlayer* New() const final {
    return CreateMaybeMessage<CMsgDOTAPassportStampedPlayer>(nullptr);
  }

  CMsgDOTAPassportStampedPlayer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAPassportStampedPlayer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAPassportStampedPlayer& from);
  void MergeFrom(const CMsgDOTAPassportStampedPlayer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAPassportStampedPlayer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 steam_id = 1;
  bool has_steam_id() const;
  void clear_steam_id();
  static const int kSteamIdFieldNumber = 1;
  ::google::protobuf::uint64 steam_id() const;
  void set_steam_id(::google::protobuf::uint64 value);

  // optional uint32 stamp_level = 2;
  bool has_stamp_level() const;
  void clear_stamp_level();
  static const int kStampLevelFieldNumber = 2;
  ::google::protobuf::uint32 stamp_level() const;
  void set_stamp_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAPassportStampedPlayer)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 steam_id_;
  ::google::protobuf::uint32 stamp_level_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAPassportPlayerCardChallenge final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAPassportPlayerCardChallenge) */ {
 public:
  CMsgDOTAPassportPlayerCardChallenge();
  virtual ~CMsgDOTAPassportPlayerCardChallenge();

  CMsgDOTAPassportPlayerCardChallenge(const CMsgDOTAPassportPlayerCardChallenge& from);

  inline CMsgDOTAPassportPlayerCardChallenge& operator=(const CMsgDOTAPassportPlayerCardChallenge& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAPassportPlayerCardChallenge(CMsgDOTAPassportPlayerCardChallenge&& from) noexcept
    : CMsgDOTAPassportPlayerCardChallenge() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAPassportPlayerCardChallenge& operator=(CMsgDOTAPassportPlayerCardChallenge&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAPassportPlayerCardChallenge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAPassportPlayerCardChallenge* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAPassportPlayerCardChallenge*>(
               &_CMsgDOTAPassportPlayerCardChallenge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  void Swap(CMsgDOTAPassportPlayerCardChallenge* other);
  friend void swap(CMsgDOTAPassportPlayerCardChallenge& a, CMsgDOTAPassportPlayerCardChallenge& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAPassportPlayerCardChallenge* New() const final {
    return CreateMaybeMessage<CMsgDOTAPassportPlayerCardChallenge>(nullptr);
  }

  CMsgDOTAPassportPlayerCardChallenge* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAPassportPlayerCardChallenge>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAPassportPlayerCardChallenge& from);
  void MergeFrom(const CMsgDOTAPassportPlayerCardChallenge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAPassportPlayerCardChallenge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 challenge_id = 1;
  bool has_challenge_id() const;
  void clear_challenge_id();
  static const int kChallengeIdFieldNumber = 1;
  ::google::protobuf::uint32 challenge_id() const;
  void set_challenge_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAPassportPlayerCardChallenge)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 challenge_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAPassportVote final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAPassportVote) */ {
 public:
  CMsgDOTAPassportVote();
  virtual ~CMsgDOTAPassportVote();

  CMsgDOTAPassportVote(const CMsgDOTAPassportVote& from);

  inline CMsgDOTAPassportVote& operator=(const CMsgDOTAPassportVote& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAPassportVote(CMsgDOTAPassportVote&& from) noexcept
    : CMsgDOTAPassportVote() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAPassportVote& operator=(CMsgDOTAPassportVote&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAPassportVote& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAPassportVote* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAPassportVote*>(
               &_CMsgDOTAPassportVote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  void Swap(CMsgDOTAPassportVote* other);
  friend void swap(CMsgDOTAPassportVote& a, CMsgDOTAPassportVote& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAPassportVote* New() const final {
    return CreateMaybeMessage<CMsgDOTAPassportVote>(nullptr);
  }

  CMsgDOTAPassportVote* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAPassportVote>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAPassportVote& from);
  void MergeFrom(const CMsgDOTAPassportVote& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAPassportVote* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTAPassportVoteTeamGuess team_votes = 1;
  int team_votes_size() const;
  void clear_team_votes();
  static const int kTeamVotesFieldNumber = 1;
  ::proto::dota::CMsgDOTAPassportVoteTeamGuess* mutable_team_votes(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPassportVoteTeamGuess >*
      mutable_team_votes();
  const ::proto::dota::CMsgDOTAPassportVoteTeamGuess& team_votes(int index) const;
  ::proto::dota::CMsgDOTAPassportVoteTeamGuess* add_team_votes();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPassportVoteTeamGuess >&
      team_votes() const;

  // repeated .proto.dota.CMsgDOTAPassportVoteGenericSelection generic_selections = 2;
  int generic_selections_size() const;
  void clear_generic_selections();
  static const int kGenericSelectionsFieldNumber = 2;
  ::proto::dota::CMsgDOTAPassportVoteGenericSelection* mutable_generic_selections(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPassportVoteGenericSelection >*
      mutable_generic_selections();
  const ::proto::dota::CMsgDOTAPassportVoteGenericSelection& generic_selections(int index) const;
  ::proto::dota::CMsgDOTAPassportVoteGenericSelection* add_generic_selections();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPassportVoteGenericSelection >&
      generic_selections() const;

  // repeated .proto.dota.CMsgDOTAPassportStampedPlayer stamped_players = 3;
  int stamped_players_size() const;
  void clear_stamped_players();
  static const int kStampedPlayersFieldNumber = 3;
  ::proto::dota::CMsgDOTAPassportStampedPlayer* mutable_stamped_players(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPassportStampedPlayer >*
      mutable_stamped_players();
  const ::proto::dota::CMsgDOTAPassportStampedPlayer& stamped_players(int index) const;
  ::proto::dota::CMsgDOTAPassportStampedPlayer* add_stamped_players();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPassportStampedPlayer >&
      stamped_players() const;

  // repeated .proto.dota.CMsgDOTAPassportPlayerCardChallenge player_card_challenges = 4;
  int player_card_challenges_size() const;
  void clear_player_card_challenges();
  static const int kPlayerCardChallengesFieldNumber = 4;
  ::proto::dota::CMsgDOTAPassportPlayerCardChallenge* mutable_player_card_challenges(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPassportPlayerCardChallenge >*
      mutable_player_card_challenges();
  const ::proto::dota::CMsgDOTAPassportPlayerCardChallenge& player_card_challenges(int index) const;
  ::proto::dota::CMsgDOTAPassportPlayerCardChallenge* add_player_card_challenges();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPassportPlayerCardChallenge >&
      player_card_challenges() const;

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAPassportVote)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPassportVoteTeamGuess > team_votes_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPassportVoteGenericSelection > generic_selections_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPassportStampedPlayer > stamped_players_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPassportPlayerCardChallenge > player_card_challenges_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCGetPlayerCardRosterRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgClientToGCGetPlayerCardRosterRequest) */ {
 public:
  CMsgClientToGCGetPlayerCardRosterRequest();
  virtual ~CMsgClientToGCGetPlayerCardRosterRequest();

  CMsgClientToGCGetPlayerCardRosterRequest(const CMsgClientToGCGetPlayerCardRosterRequest& from);

  inline CMsgClientToGCGetPlayerCardRosterRequest& operator=(const CMsgClientToGCGetPlayerCardRosterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgClientToGCGetPlayerCardRosterRequest(CMsgClientToGCGetPlayerCardRosterRequest&& from) noexcept
    : CMsgClientToGCGetPlayerCardRosterRequest() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCGetPlayerCardRosterRequest& operator=(CMsgClientToGCGetPlayerCardRosterRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgClientToGCGetPlayerCardRosterRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgClientToGCGetPlayerCardRosterRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCGetPlayerCardRosterRequest*>(
               &_CMsgClientToGCGetPlayerCardRosterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  void Swap(CMsgClientToGCGetPlayerCardRosterRequest* other);
  friend void swap(CMsgClientToGCGetPlayerCardRosterRequest& a, CMsgClientToGCGetPlayerCardRosterRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgClientToGCGetPlayerCardRosterRequest* New() const final {
    return CreateMaybeMessage<CMsgClientToGCGetPlayerCardRosterRequest>(nullptr);
  }

  CMsgClientToGCGetPlayerCardRosterRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgClientToGCGetPlayerCardRosterRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgClientToGCGetPlayerCardRosterRequest& from);
  void MergeFrom(const CMsgClientToGCGetPlayerCardRosterRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCGetPlayerCardRosterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 league_id = 1;
  bool has_league_id() const;
  void clear_league_id();
  static const int kLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 league_id() const;
  void set_league_id(::google::protobuf::uint32 value);

  // optional uint32 timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgClientToGCGetPlayerCardRosterRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 league_id_;
  ::google::protobuf::uint32 timestamp_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCGetPlayerCardRosterResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgClientToGCGetPlayerCardRosterResponse) */ {
 public:
  CMsgClientToGCGetPlayerCardRosterResponse();
  virtual ~CMsgClientToGCGetPlayerCardRosterResponse();

  CMsgClientToGCGetPlayerCardRosterResponse(const CMsgClientToGCGetPlayerCardRosterResponse& from);

  inline CMsgClientToGCGetPlayerCardRosterResponse& operator=(const CMsgClientToGCGetPlayerCardRosterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgClientToGCGetPlayerCardRosterResponse(CMsgClientToGCGetPlayerCardRosterResponse&& from) noexcept
    : CMsgClientToGCGetPlayerCardRosterResponse() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCGetPlayerCardRosterResponse& operator=(CMsgClientToGCGetPlayerCardRosterResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgClientToGCGetPlayerCardRosterResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgClientToGCGetPlayerCardRosterResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCGetPlayerCardRosterResponse*>(
               &_CMsgClientToGCGetPlayerCardRosterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  void Swap(CMsgClientToGCGetPlayerCardRosterResponse* other);
  friend void swap(CMsgClientToGCGetPlayerCardRosterResponse& a, CMsgClientToGCGetPlayerCardRosterResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgClientToGCGetPlayerCardRosterResponse* New() const final {
    return CreateMaybeMessage<CMsgClientToGCGetPlayerCardRosterResponse>(nullptr);
  }

  CMsgClientToGCGetPlayerCardRosterResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgClientToGCGetPlayerCardRosterResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgClientToGCGetPlayerCardRosterResponse& from);
  void MergeFrom(const CMsgClientToGCGetPlayerCardRosterResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCGetPlayerCardRosterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgClientToGCGetPlayerCardRosterResponse_Result Result;
  static const Result SUCCESS =
    CMsgClientToGCGetPlayerCardRosterResponse_Result_SUCCESS;
  static const Result ERROR_UNSPECIFIED =
    CMsgClientToGCGetPlayerCardRosterResponse_Result_ERROR_UNSPECIFIED;
  static const Result ERROR_INVALID_LEAGUE_ID =
    CMsgClientToGCGetPlayerCardRosterResponse_Result_ERROR_INVALID_LEAGUE_ID;
  static const Result ERROR_INVALID_TIMESTAMP =
    CMsgClientToGCGetPlayerCardRosterResponse_Result_ERROR_INVALID_TIMESTAMP;
  static inline bool Result_IsValid(int value) {
    return CMsgClientToGCGetPlayerCardRosterResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    CMsgClientToGCGetPlayerCardRosterResponse_Result_Result_MIN;
  static const Result Result_MAX =
    CMsgClientToGCGetPlayerCardRosterResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    CMsgClientToGCGetPlayerCardRosterResponse_Result_Result_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Result_descriptor() {
    return CMsgClientToGCGetPlayerCardRosterResponse_Result_descriptor();
  }
  static inline const ::std::string& Result_Name(Result value) {
    return CMsgClientToGCGetPlayerCardRosterResponse_Result_Name(value);
  }
  static inline bool Result_Parse(const ::std::string& name,
      Result* value) {
    return CMsgClientToGCGetPlayerCardRosterResponse_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated uint64 player_card_item_id = 2;
  int player_card_item_id_size() const;
  void clear_player_card_item_id();
  static const int kPlayerCardItemIdFieldNumber = 2;
  ::google::protobuf::uint64 player_card_item_id(int index) const;
  void set_player_card_item_id(int index, ::google::protobuf::uint64 value);
  void add_player_card_item_id(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      player_card_item_id() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_player_card_item_id();

  // optional .proto.dota.CMsgClientToGCGetPlayerCardRosterResponse.Result result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgClientToGCGetPlayerCardRosterResponse_Result result() const;
  void set_result(::proto::dota::CMsgClientToGCGetPlayerCardRosterResponse_Result value);

  // optional float score = 3;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 3;
  float score() const;
  void set_score(float value);

  // optional bool finalized = 4;
  bool has_finalized() const;
  void clear_finalized();
  static const int kFinalizedFieldNumber = 4;
  bool finalized() const;
  void set_finalized(bool value);

  // optional float percentile = 5;
  bool has_percentile() const;
  void clear_percentile();
  static const int kPercentileFieldNumber = 5;
  float percentile() const;
  void set_percentile(float value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgClientToGCGetPlayerCardRosterResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > player_card_item_id_;
  int result_;
  float score_;
  bool finalized_;
  float percentile_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCSetPlayerCardRosterRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgClientToGCSetPlayerCardRosterRequest) */ {
 public:
  CMsgClientToGCSetPlayerCardRosterRequest();
  virtual ~CMsgClientToGCSetPlayerCardRosterRequest();

  CMsgClientToGCSetPlayerCardRosterRequest(const CMsgClientToGCSetPlayerCardRosterRequest& from);

  inline CMsgClientToGCSetPlayerCardRosterRequest& operator=(const CMsgClientToGCSetPlayerCardRosterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgClientToGCSetPlayerCardRosterRequest(CMsgClientToGCSetPlayerCardRosterRequest&& from) noexcept
    : CMsgClientToGCSetPlayerCardRosterRequest() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCSetPlayerCardRosterRequest& operator=(CMsgClientToGCSetPlayerCardRosterRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgClientToGCSetPlayerCardRosterRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgClientToGCSetPlayerCardRosterRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCSetPlayerCardRosterRequest*>(
               &_CMsgClientToGCSetPlayerCardRosterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  void Swap(CMsgClientToGCSetPlayerCardRosterRequest* other);
  friend void swap(CMsgClientToGCSetPlayerCardRosterRequest& a, CMsgClientToGCSetPlayerCardRosterRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgClientToGCSetPlayerCardRosterRequest* New() const final {
    return CreateMaybeMessage<CMsgClientToGCSetPlayerCardRosterRequest>(nullptr);
  }

  CMsgClientToGCSetPlayerCardRosterRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgClientToGCSetPlayerCardRosterRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgClientToGCSetPlayerCardRosterRequest& from);
  void MergeFrom(const CMsgClientToGCSetPlayerCardRosterRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCSetPlayerCardRosterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 league_id = 1;
  bool has_league_id() const;
  void clear_league_id();
  static const int kLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 league_id() const;
  void set_league_id(::google::protobuf::uint32 value);

  // optional uint32 timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // optional uint64 player_card_item_id = 4;
  bool has_player_card_item_id() const;
  void clear_player_card_item_id();
  static const int kPlayerCardItemIdFieldNumber = 4;
  ::google::protobuf::uint64 player_card_item_id() const;
  void set_player_card_item_id(::google::protobuf::uint64 value);

  // optional uint32 slot = 3;
  bool has_slot() const;
  void clear_slot();
  static const int kSlotFieldNumber = 3;
  ::google::protobuf::uint32 slot() const;
  void set_slot(::google::protobuf::uint32 value);

  // optional uint32 event_id = 5;
  bool has_event_id() const;
  void clear_event_id();
  static const int kEventIdFieldNumber = 5;
  ::google::protobuf::uint32 event_id() const;
  void set_event_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgClientToGCSetPlayerCardRosterRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 league_id_;
  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::uint64 player_card_item_id_;
  ::google::protobuf::uint32 slot_;
  ::google::protobuf::uint32 event_id_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCSetPlayerCardRosterResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgClientToGCSetPlayerCardRosterResponse) */ {
 public:
  CMsgClientToGCSetPlayerCardRosterResponse();
  virtual ~CMsgClientToGCSetPlayerCardRosterResponse();

  CMsgClientToGCSetPlayerCardRosterResponse(const CMsgClientToGCSetPlayerCardRosterResponse& from);

  inline CMsgClientToGCSetPlayerCardRosterResponse& operator=(const CMsgClientToGCSetPlayerCardRosterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgClientToGCSetPlayerCardRosterResponse(CMsgClientToGCSetPlayerCardRosterResponse&& from) noexcept
    : CMsgClientToGCSetPlayerCardRosterResponse() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCSetPlayerCardRosterResponse& operator=(CMsgClientToGCSetPlayerCardRosterResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgClientToGCSetPlayerCardRosterResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgClientToGCSetPlayerCardRosterResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCSetPlayerCardRosterResponse*>(
               &_CMsgClientToGCSetPlayerCardRosterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  void Swap(CMsgClientToGCSetPlayerCardRosterResponse* other);
  friend void swap(CMsgClientToGCSetPlayerCardRosterResponse& a, CMsgClientToGCSetPlayerCardRosterResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgClientToGCSetPlayerCardRosterResponse* New() const final {
    return CreateMaybeMessage<CMsgClientToGCSetPlayerCardRosterResponse>(nullptr);
  }

  CMsgClientToGCSetPlayerCardRosterResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgClientToGCSetPlayerCardRosterResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgClientToGCSetPlayerCardRosterResponse& from);
  void MergeFrom(const CMsgClientToGCSetPlayerCardRosterResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCSetPlayerCardRosterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgClientToGCSetPlayerCardRosterResponse_Result Result;
  static const Result SUCCESS =
    CMsgClientToGCSetPlayerCardRosterResponse_Result_SUCCESS;
  static const Result ERROR_UNSPECIFIED =
    CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_UNSPECIFIED;
  static const Result ERROR_INVALID_LEAGUE_ID =
    CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_INVALID_LEAGUE_ID;
  static const Result ERROR_INVALID_TIMESTAMP =
    CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_INVALID_TIMESTAMP;
  static const Result ERROR_PLAYER_CARD_NOT_OWNED =
    CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_PLAYER_CARD_NOT_OWNED;
  static const Result ERROR_INVALID_SLOT =
    CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_INVALID_SLOT;
  static const Result ERROR_FAILED_CARD_INFO =
    CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_FAILED_CARD_INFO;
  static const Result ERROR_ACCOUNT_DUPLICATE =
    CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_ACCOUNT_DUPLICATE;
  static const Result ERROR_LOCKED_TIMESTAMP =
    CMsgClientToGCSetPlayerCardRosterResponse_Result_ERROR_LOCKED_TIMESTAMP;
  static inline bool Result_IsValid(int value) {
    return CMsgClientToGCSetPlayerCardRosterResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    CMsgClientToGCSetPlayerCardRosterResponse_Result_Result_MIN;
  static const Result Result_MAX =
    CMsgClientToGCSetPlayerCardRosterResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    CMsgClientToGCSetPlayerCardRosterResponse_Result_Result_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Result_descriptor() {
    return CMsgClientToGCSetPlayerCardRosterResponse_Result_descriptor();
  }
  static inline const ::std::string& Result_Name(Result value) {
    return CMsgClientToGCSetPlayerCardRosterResponse_Result_Name(value);
  }
  static inline bool Result_Parse(const ::std::string& name,
      Result* value) {
    return CMsgClientToGCSetPlayerCardRosterResponse_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .proto.dota.CMsgClientToGCSetPlayerCardRosterResponse.Result result = 1 [default = SUCCESS];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::proto::dota::CMsgClientToGCSetPlayerCardRosterResponse_Result result() const;
  void set_result(::proto::dota::CMsgClientToGCSetPlayerCardRosterResponse_Result value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgClientToGCSetPlayerCardRosterResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int result_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo) */ {
 public:
  CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo();
  virtual ~CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo();

  CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo(const CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo& from);

  inline CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo& operator=(const CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo(CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo&& from) noexcept
    : CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo& operator=(CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo*>(
               &_CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  void Swap(CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo* other);
  friend void swap(CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo& a, CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo>(nullptr);
  }

  CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo& from);
  void MergeFrom(const CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 day_timestamps = 5;
  int day_timestamps_size() const;
  void clear_day_timestamps();
  static const int kDayTimestampsFieldNumber = 5;
  ::google::protobuf::uint32 day_timestamps(int index) const;
  void set_day_timestamps(int index, ::google::protobuf::uint32 value);
  void add_day_timestamps(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      day_timestamps() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_day_timestamps();

  // optional string league_name = 2;
  bool has_league_name() const;
  void clear_league_name();
  static const int kLeagueNameFieldNumber = 2;
  const ::std::string& league_name() const;
  void set_league_name(const ::std::string& value);
  #if LANG_CXX11
  void set_league_name(::std::string&& value);
  #endif
  void set_league_name(const char* value);
  void set_league_name(const char* value, size_t size);
  ::std::string* mutable_league_name();
  ::std::string* release_league_name();
  void set_allocated_league_name(::std::string* league_name);

  // optional uint32 league_id = 1;
  bool has_league_id() const;
  void clear_league_id();
  static const int kLeagueIdFieldNumber = 1;
  ::google::protobuf::uint32 league_id() const;
  void set_league_id(::google::protobuf::uint32 value);

  // optional uint32 start_timestamp = 3;
  bool has_start_timestamp() const;
  void clear_start_timestamp();
  static const int kStartTimestampFieldNumber = 3;
  ::google::protobuf::uint32 start_timestamp() const;
  void set_start_timestamp(::google::protobuf::uint32 value);

  // optional uint32 end_timestamp = 4;
  bool has_end_timestamp() const;
  void clear_end_timestamp();
  static const int kEndTimestampFieldNumber = 4;
  ::google::protobuf::uint32 end_timestamp() const;
  void set_end_timestamp(::google::protobuf::uint32 value);

  // optional bool is_qualifier = 6;
  bool has_is_qualifier() const;
  void clear_is_qualifier();
  static const int kIsQualifierFieldNumber = 6;
  bool is_qualifier() const;
  void set_is_qualifier(bool value);

  // optional .proto.dota.ELeagueFantasyPhase phase = 7 [default = LEAGUE_FANTASY_PHASE_UNSET];
  bool has_phase() const;
  void clear_phase();
  static const int kPhaseFieldNumber = 7;
  ::proto::dota::ELeagueFantasyPhase phase() const;
  void set_phase(::proto::dota::ELeagueFantasyPhase value);

  // optional .proto.dota.CMsgDOTAFantasyDPCLeagueStatus.ERosterStatus status = 8 [default = UNSET];
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 8;
  ::proto::dota::CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus status() const;
  void set_status(::proto::dota::CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus value);

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > day_timestamps_;
  ::google::protobuf::internal::ArenaStringPtr league_name_;
  ::google::protobuf::uint32 league_id_;
  ::google::protobuf::uint32 start_timestamp_;
  ::google::protobuf::uint32 end_timestamp_;
  bool is_qualifier_;
  int phase_;
  int status_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// -------------------------------------------------------------------

class CMsgDOTAFantasyDPCLeagueStatus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:proto.dota.CMsgDOTAFantasyDPCLeagueStatus) */ {
 public:
  CMsgDOTAFantasyDPCLeagueStatus();
  virtual ~CMsgDOTAFantasyDPCLeagueStatus();

  CMsgDOTAFantasyDPCLeagueStatus(const CMsgDOTAFantasyDPCLeagueStatus& from);

  inline CMsgDOTAFantasyDPCLeagueStatus& operator=(const CMsgDOTAFantasyDPCLeagueStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMsgDOTAFantasyDPCLeagueStatus(CMsgDOTAFantasyDPCLeagueStatus&& from) noexcept
    : CMsgDOTAFantasyDPCLeagueStatus() {
    *this = ::std::move(from);
  }

  inline CMsgDOTAFantasyDPCLeagueStatus& operator=(CMsgDOTAFantasyDPCLeagueStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CMsgDOTAFantasyDPCLeagueStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMsgDOTAFantasyDPCLeagueStatus* internal_default_instance() {
    return reinterpret_cast<const CMsgDOTAFantasyDPCLeagueStatus*>(
               &_CMsgDOTAFantasyDPCLeagueStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  void Swap(CMsgDOTAFantasyDPCLeagueStatus* other);
  friend void swap(CMsgDOTAFantasyDPCLeagueStatus& a, CMsgDOTAFantasyDPCLeagueStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMsgDOTAFantasyDPCLeagueStatus* New() const final {
    return CreateMaybeMessage<CMsgDOTAFantasyDPCLeagueStatus>(nullptr);
  }

  CMsgDOTAFantasyDPCLeagueStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CMsgDOTAFantasyDPCLeagueStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CMsgDOTAFantasyDPCLeagueStatus& from);
  void MergeFrom(const CMsgDOTAFantasyDPCLeagueStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgDOTAFantasyDPCLeagueStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo LeagueInfo;

  typedef CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus ERosterStatus;
  static const ERosterStatus UNSET =
    CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_UNSET;
  static const ERosterStatus PARTIAL =
    CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_PARTIAL;
  static const ERosterStatus FULL =
    CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_FULL;
  static const ERosterStatus CONCLUDED =
    CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_CONCLUDED;
  static inline bool ERosterStatus_IsValid(int value) {
    return CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_IsValid(value);
  }
  static const ERosterStatus ERosterStatus_MIN =
    CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_ERosterStatus_MIN;
  static const ERosterStatus ERosterStatus_MAX =
    CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_ERosterStatus_MAX;
  static const int ERosterStatus_ARRAYSIZE =
    CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_ERosterStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ERosterStatus_descriptor() {
    return CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_descriptor();
  }
  static inline const ::std::string& ERosterStatus_Name(ERosterStatus value) {
    return CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_Name(value);
  }
  static inline bool ERosterStatus_Parse(const ::std::string& name,
      ERosterStatus* value) {
    return CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo league_infos = 1;
  int league_infos_size() const;
  void clear_league_infos();
  static const int kLeagueInfosFieldNumber = 1;
  ::proto::dota::CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo* mutable_league_infos(int index);
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo >*
      mutable_league_infos();
  const ::proto::dota::CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo& league_infos(int index) const;
  ::proto::dota::CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo* add_league_infos();
  const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo >&
      league_infos() const;

  // @@protoc_insertion_point(class_scope:proto.dota.CMsgDOTAFantasyDPCLeagueStatus)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo > league_infos_;
  friend struct ::TableStruct_dota_5fgcmessages_5fclient_5ffantasy_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CMsgDOTAPlayerInfo_Results

// optional uint32 league_id = 1;
inline bool CMsgDOTAPlayerInfo_Results::has_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAPlayerInfo_Results::clear_league_id() {
  league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAPlayerInfo_Results::league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.Results.league_id)
  return league_id_;
}
inline void CMsgDOTAPlayerInfo_Results::set_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPlayerInfo.Results.league_id)
}

// optional uint32 placement = 2;
inline bool CMsgDOTAPlayerInfo_Results::has_placement() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAPlayerInfo_Results::clear_placement() {
  placement_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAPlayerInfo_Results::placement() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.Results.placement)
  return placement_;
}
inline void CMsgDOTAPlayerInfo_Results::set_placement(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  placement_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPlayerInfo.Results.placement)
}

// optional uint32 earnings = 3;
inline bool CMsgDOTAPlayerInfo_Results::has_earnings() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAPlayerInfo_Results::clear_earnings() {
  earnings_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAPlayerInfo_Results::earnings() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.Results.earnings)
  return earnings_;
}
inline void CMsgDOTAPlayerInfo_Results::set_earnings(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  earnings_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPlayerInfo.Results.earnings)
}

// -------------------------------------------------------------------

// CMsgDOTAPlayerInfo_AuditEntry

// optional uint32 start_timestamp = 1;
inline bool CMsgDOTAPlayerInfo_AuditEntry::has_start_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAPlayerInfo_AuditEntry::clear_start_timestamp() {
  start_timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTAPlayerInfo_AuditEntry::start_timestamp() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.start_timestamp)
  return start_timestamp_;
}
inline void CMsgDOTAPlayerInfo_AuditEntry::set_start_timestamp(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  start_timestamp_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.start_timestamp)
}

// optional uint32 end_timestamp = 2;
inline bool CMsgDOTAPlayerInfo_AuditEntry::has_end_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAPlayerInfo_AuditEntry::clear_end_timestamp() {
  end_timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgDOTAPlayerInfo_AuditEntry::end_timestamp() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.end_timestamp)
  return end_timestamp_;
}
inline void CMsgDOTAPlayerInfo_AuditEntry::set_end_timestamp(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  end_timestamp_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.end_timestamp)
}

// optional uint32 team_id = 3;
inline bool CMsgDOTAPlayerInfo_AuditEntry::has_team_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAPlayerInfo_AuditEntry::clear_team_id() {
  team_id_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 CMsgDOTAPlayerInfo_AuditEntry::team_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_id)
  return team_id_;
}
inline void CMsgDOTAPlayerInfo_AuditEntry::set_team_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  team_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_id)
}

// optional string team_name = 4;
inline bool CMsgDOTAPlayerInfo_AuditEntry::has_team_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAPlayerInfo_AuditEntry::clear_team_name() {
  team_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTAPlayerInfo_AuditEntry::team_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_name)
  return team_name_.GetNoArena();
}
inline void CMsgDOTAPlayerInfo_AuditEntry::set_team_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_name)
}
#if LANG_CXX11
inline void CMsgDOTAPlayerInfo_AuditEntry::set_team_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_name)
}
#endif
inline void CMsgDOTAPlayerInfo_AuditEntry::set_team_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_name)
}
inline void CMsgDOTAPlayerInfo_AuditEntry::set_team_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_name)
}
inline ::std::string* CMsgDOTAPlayerInfo_AuditEntry::mutable_team_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_name)
  return team_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAPlayerInfo_AuditEntry::release_team_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_name)
  if (!has_team_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return team_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAPlayerInfo_AuditEntry::set_allocated_team_name(::std::string* team_name) {
  if (team_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  team_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_name)
}

// optional string team_tag = 5;
inline bool CMsgDOTAPlayerInfo_AuditEntry::has_team_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAPlayerInfo_AuditEntry::clear_team_tag() {
  team_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgDOTAPlayerInfo_AuditEntry::team_tag() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_tag)
  return team_tag_.GetNoArena();
}
inline void CMsgDOTAPlayerInfo_AuditEntry::set_team_tag(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  team_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_tag)
}
#if LANG_CXX11
inline void CMsgDOTAPlayerInfo_AuditEntry::set_team_tag(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  team_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_tag)
}
#endif
inline void CMsgDOTAPlayerInfo_AuditEntry::set_team_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  team_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_tag)
}
inline void CMsgDOTAPlayerInfo_AuditEntry::set_team_tag(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  team_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_tag)
}
inline ::std::string* CMsgDOTAPlayerInfo_AuditEntry::mutable_team_tag() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_tag)
  return team_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAPlayerInfo_AuditEntry::release_team_tag() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_tag)
  if (!has_team_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return team_tag_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAPlayerInfo_AuditEntry::set_allocated_team_tag(::std::string* team_tag) {
  if (team_tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  team_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team_tag);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_tag)
}

// optional string team_url_logo = 6;
inline bool CMsgDOTAPlayerInfo_AuditEntry::has_team_url_logo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAPlayerInfo_AuditEntry::clear_team_url_logo() {
  team_url_logo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& CMsgDOTAPlayerInfo_AuditEntry::team_url_logo() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_url_logo)
  return team_url_logo_.GetNoArena();
}
inline void CMsgDOTAPlayerInfo_AuditEntry::set_team_url_logo(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  team_url_logo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_url_logo)
}
#if LANG_CXX11
inline void CMsgDOTAPlayerInfo_AuditEntry::set_team_url_logo(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  team_url_logo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_url_logo)
}
#endif
inline void CMsgDOTAPlayerInfo_AuditEntry::set_team_url_logo(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  team_url_logo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_url_logo)
}
inline void CMsgDOTAPlayerInfo_AuditEntry::set_team_url_logo(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  team_url_logo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_url_logo)
}
inline ::std::string* CMsgDOTAPlayerInfo_AuditEntry::mutable_team_url_logo() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_url_logo)
  return team_url_logo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAPlayerInfo_AuditEntry::release_team_url_logo() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_url_logo)
  if (!has_team_url_logo()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return team_url_logo_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAPlayerInfo_AuditEntry::set_allocated_team_url_logo(::std::string* team_url_logo) {
  if (team_url_logo != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  team_url_logo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team_url_logo);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAPlayerInfo.AuditEntry.team_url_logo)
}

// -------------------------------------------------------------------

// CMsgDOTAPlayerInfo

// optional uint32 account_id = 1;
inline bool CMsgDOTAPlayerInfo::has_account_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgDOTAPlayerInfo::clear_account_id() {
  account_id_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 CMsgDOTAPlayerInfo::account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.account_id)
  return account_id_;
}
inline void CMsgDOTAPlayerInfo::set_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPlayerInfo.account_id)
}

// optional string name = 2;
inline bool CMsgDOTAPlayerInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAPlayerInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTAPlayerInfo::name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.name)
  return name_.GetNoArena();
}
inline void CMsgDOTAPlayerInfo::set_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPlayerInfo.name)
}
#if LANG_CXX11
inline void CMsgDOTAPlayerInfo::set_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAPlayerInfo.name)
}
#endif
inline void CMsgDOTAPlayerInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAPlayerInfo.name)
}
inline void CMsgDOTAPlayerInfo::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAPlayerInfo.name)
}
inline ::std::string* CMsgDOTAPlayerInfo::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAPlayerInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAPlayerInfo::release_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAPlayerInfo.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAPlayerInfo::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAPlayerInfo.name)
}

// optional string country_code = 3;
inline bool CMsgDOTAPlayerInfo::has_country_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAPlayerInfo::clear_country_code() {
  country_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgDOTAPlayerInfo::country_code() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.country_code)
  return country_code_.GetNoArena();
}
inline void CMsgDOTAPlayerInfo::set_country_code(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  country_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPlayerInfo.country_code)
}
#if LANG_CXX11
inline void CMsgDOTAPlayerInfo::set_country_code(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  country_code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAPlayerInfo.country_code)
}
#endif
inline void CMsgDOTAPlayerInfo::set_country_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  country_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAPlayerInfo.country_code)
}
inline void CMsgDOTAPlayerInfo::set_country_code(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  country_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAPlayerInfo.country_code)
}
inline ::std::string* CMsgDOTAPlayerInfo::mutable_country_code() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAPlayerInfo.country_code)
  return country_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAPlayerInfo::release_country_code() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAPlayerInfo.country_code)
  if (!has_country_code()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return country_code_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAPlayerInfo::set_allocated_country_code(::std::string* country_code) {
  if (country_code != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  country_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), country_code);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAPlayerInfo.country_code)
}

// optional .proto.dota.Fantasy_Roles fantasy_role = 4 [default = FANTASY_ROLE_UNDEFINED];
inline bool CMsgDOTAPlayerInfo::has_fantasy_role() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgDOTAPlayerInfo::clear_fantasy_role() {
  fantasy_role_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::proto::dota::Fantasy_Roles CMsgDOTAPlayerInfo::fantasy_role() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.fantasy_role)
  return static_cast< ::proto::dota::Fantasy_Roles >(fantasy_role_);
}
inline void CMsgDOTAPlayerInfo::set_fantasy_role(::proto::dota::Fantasy_Roles value) {
  assert(::proto::dota::Fantasy_Roles_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  fantasy_role_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPlayerInfo.fantasy_role)
}

// optional uint32 team_id = 5;
inline bool CMsgDOTAPlayerInfo::has_team_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgDOTAPlayerInfo::clear_team_id() {
  team_id_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::google::protobuf::uint32 CMsgDOTAPlayerInfo::team_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.team_id)
  return team_id_;
}
inline void CMsgDOTAPlayerInfo::set_team_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  team_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPlayerInfo.team_id)
}

// optional string team_name = 6;
inline bool CMsgDOTAPlayerInfo::has_team_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAPlayerInfo::clear_team_name() {
  team_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& CMsgDOTAPlayerInfo::team_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.team_name)
  return team_name_.GetNoArena();
}
inline void CMsgDOTAPlayerInfo::set_team_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPlayerInfo.team_name)
}
#if LANG_CXX11
inline void CMsgDOTAPlayerInfo::set_team_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  team_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAPlayerInfo.team_name)
}
#endif
inline void CMsgDOTAPlayerInfo::set_team_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAPlayerInfo.team_name)
}
inline void CMsgDOTAPlayerInfo::set_team_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAPlayerInfo.team_name)
}
inline ::std::string* CMsgDOTAPlayerInfo::mutable_team_name() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAPlayerInfo.team_name)
  return team_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAPlayerInfo::release_team_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAPlayerInfo.team_name)
  if (!has_team_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return team_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAPlayerInfo::set_allocated_team_name(::std::string* team_name) {
  if (team_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  team_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAPlayerInfo.team_name)
}

// optional string team_tag = 7;
inline bool CMsgDOTAPlayerInfo::has_team_tag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAPlayerInfo::clear_team_tag() {
  team_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& CMsgDOTAPlayerInfo::team_tag() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.team_tag)
  return team_tag_.GetNoArena();
}
inline void CMsgDOTAPlayerInfo::set_team_tag(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  team_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPlayerInfo.team_tag)
}
#if LANG_CXX11
inline void CMsgDOTAPlayerInfo::set_team_tag(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  team_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAPlayerInfo.team_tag)
}
#endif
inline void CMsgDOTAPlayerInfo::set_team_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  team_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAPlayerInfo.team_tag)
}
inline void CMsgDOTAPlayerInfo::set_team_tag(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  team_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAPlayerInfo.team_tag)
}
inline ::std::string* CMsgDOTAPlayerInfo::mutable_team_tag() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAPlayerInfo.team_tag)
  return team_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAPlayerInfo::release_team_tag() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAPlayerInfo.team_tag)
  if (!has_team_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return team_tag_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAPlayerInfo::set_allocated_team_tag(::std::string* team_tag) {
  if (team_tag != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  team_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team_tag);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAPlayerInfo.team_tag)
}

// optional string sponsor = 8;
inline bool CMsgDOTAPlayerInfo::has_sponsor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAPlayerInfo::clear_sponsor() {
  sponsor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& CMsgDOTAPlayerInfo::sponsor() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.sponsor)
  return sponsor_.GetNoArena();
}
inline void CMsgDOTAPlayerInfo::set_sponsor(const ::std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  sponsor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPlayerInfo.sponsor)
}
#if LANG_CXX11
inline void CMsgDOTAPlayerInfo::set_sponsor(::std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  sponsor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAPlayerInfo.sponsor)
}
#endif
inline void CMsgDOTAPlayerInfo::set_sponsor(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  sponsor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAPlayerInfo.sponsor)
}
inline void CMsgDOTAPlayerInfo::set_sponsor(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  sponsor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAPlayerInfo.sponsor)
}
inline ::std::string* CMsgDOTAPlayerInfo::mutable_sponsor() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAPlayerInfo.sponsor)
  return sponsor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAPlayerInfo::release_sponsor() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAPlayerInfo.sponsor)
  if (!has_sponsor()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return sponsor_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAPlayerInfo::set_allocated_sponsor(::std::string* sponsor) {
  if (sponsor != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  sponsor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sponsor);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAPlayerInfo.sponsor)
}

// optional bool is_locked = 9;
inline bool CMsgDOTAPlayerInfo::has_is_locked() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgDOTAPlayerInfo::clear_is_locked() {
  is_locked_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool CMsgDOTAPlayerInfo::is_locked() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.is_locked)
  return is_locked_;
}
inline void CMsgDOTAPlayerInfo::set_is_locked(bool value) {
  _has_bits_[0] |= 0x00000400u;
  is_locked_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPlayerInfo.is_locked)
}

// optional bool is_pro = 10;
inline bool CMsgDOTAPlayerInfo::has_is_pro() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgDOTAPlayerInfo::clear_is_pro() {
  is_pro_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool CMsgDOTAPlayerInfo::is_pro() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.is_pro)
  return is_pro_;
}
inline void CMsgDOTAPlayerInfo::set_is_pro(bool value) {
  _has_bits_[0] |= 0x00000800u;
  is_pro_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPlayerInfo.is_pro)
}

// optional string real_name = 11;
inline bool CMsgDOTAPlayerInfo::has_real_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAPlayerInfo::clear_real_name() {
  real_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::std::string& CMsgDOTAPlayerInfo::real_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.real_name)
  return real_name_.GetNoArena();
}
inline void CMsgDOTAPlayerInfo::set_real_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  real_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPlayerInfo.real_name)
}
#if LANG_CXX11
inline void CMsgDOTAPlayerInfo::set_real_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  real_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAPlayerInfo.real_name)
}
#endif
inline void CMsgDOTAPlayerInfo::set_real_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  real_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAPlayerInfo.real_name)
}
inline void CMsgDOTAPlayerInfo::set_real_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000020u;
  real_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAPlayerInfo.real_name)
}
inline ::std::string* CMsgDOTAPlayerInfo::mutable_real_name() {
  _has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAPlayerInfo.real_name)
  return real_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAPlayerInfo::release_real_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAPlayerInfo.real_name)
  if (!has_real_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return real_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAPlayerInfo::set_allocated_real_name(::std::string* real_name) {
  if (real_name != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  real_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), real_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAPlayerInfo.real_name)
}

// optional uint32 birthdate = 12;
inline bool CMsgDOTAPlayerInfo::has_birthdate() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgDOTAPlayerInfo::clear_birthdate() {
  birthdate_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::google::protobuf::uint32 CMsgDOTAPlayerInfo::birthdate() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.birthdate)
  return birthdate_;
}
inline void CMsgDOTAPlayerInfo::set_birthdate(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00001000u;
  birthdate_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPlayerInfo.birthdate)
}

// optional uint32 total_earnings = 13;
inline bool CMsgDOTAPlayerInfo::has_total_earnings() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgDOTAPlayerInfo::clear_total_earnings() {
  total_earnings_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::google::protobuf::uint32 CMsgDOTAPlayerInfo::total_earnings() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.total_earnings)
  return total_earnings_;
}
inline void CMsgDOTAPlayerInfo::set_total_earnings(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00002000u;
  total_earnings_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPlayerInfo.total_earnings)
}

// repeated .proto.dota.CMsgDOTAPlayerInfo.Results results = 14;
inline int CMsgDOTAPlayerInfo::results_size() const {
  return results_.size();
}
inline void CMsgDOTAPlayerInfo::clear_results() {
  results_.Clear();
}
inline ::proto::dota::CMsgDOTAPlayerInfo_Results* CMsgDOTAPlayerInfo::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAPlayerInfo.results)
  return results_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPlayerInfo_Results >*
CMsgDOTAPlayerInfo::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAPlayerInfo.results)
  return &results_;
}
inline const ::proto::dota::CMsgDOTAPlayerInfo_Results& CMsgDOTAPlayerInfo::results(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.results)
  return results_.Get(index);
}
inline ::proto::dota::CMsgDOTAPlayerInfo_Results* CMsgDOTAPlayerInfo::add_results() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAPlayerInfo.results)
  return results_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPlayerInfo_Results >&
CMsgDOTAPlayerInfo::results() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAPlayerInfo.results)
  return results_;
}

// optional string team_url_logo = 15;
inline bool CMsgDOTAPlayerInfo::has_team_url_logo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTAPlayerInfo::clear_team_url_logo() {
  team_url_logo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::std::string& CMsgDOTAPlayerInfo::team_url_logo() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.team_url_logo)
  return team_url_logo_.GetNoArena();
}
inline void CMsgDOTAPlayerInfo::set_team_url_logo(const ::std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  team_url_logo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPlayerInfo.team_url_logo)
}
#if LANG_CXX11
inline void CMsgDOTAPlayerInfo::set_team_url_logo(::std::string&& value) {
  _has_bits_[0] |= 0x00000040u;
  team_url_logo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAPlayerInfo.team_url_logo)
}
#endif
inline void CMsgDOTAPlayerInfo::set_team_url_logo(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000040u;
  team_url_logo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAPlayerInfo.team_url_logo)
}
inline void CMsgDOTAPlayerInfo::set_team_url_logo(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000040u;
  team_url_logo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAPlayerInfo.team_url_logo)
}
inline ::std::string* CMsgDOTAPlayerInfo::mutable_team_url_logo() {
  _has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAPlayerInfo.team_url_logo)
  return team_url_logo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAPlayerInfo::release_team_url_logo() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAPlayerInfo.team_url_logo)
  if (!has_team_url_logo()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return team_url_logo_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAPlayerInfo::set_allocated_team_url_logo(::std::string* team_url_logo) {
  if (team_url_logo != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  team_url_logo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team_url_logo);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAPlayerInfo.team_url_logo)
}

// repeated .proto.dota.CMsgDOTAPlayerInfo.AuditEntry audit_entries = 16;
inline int CMsgDOTAPlayerInfo::audit_entries_size() const {
  return audit_entries_.size();
}
inline void CMsgDOTAPlayerInfo::clear_audit_entries() {
  audit_entries_.Clear();
}
inline ::proto::dota::CMsgDOTAPlayerInfo_AuditEntry* CMsgDOTAPlayerInfo::mutable_audit_entries(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAPlayerInfo.audit_entries)
  return audit_entries_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPlayerInfo_AuditEntry >*
CMsgDOTAPlayerInfo::mutable_audit_entries() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAPlayerInfo.audit_entries)
  return &audit_entries_;
}
inline const ::proto::dota::CMsgDOTAPlayerInfo_AuditEntry& CMsgDOTAPlayerInfo::audit_entries(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfo.audit_entries)
  return audit_entries_.Get(index);
}
inline ::proto::dota::CMsgDOTAPlayerInfo_AuditEntry* CMsgDOTAPlayerInfo::add_audit_entries() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAPlayerInfo.audit_entries)
  return audit_entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPlayerInfo_AuditEntry >&
CMsgDOTAPlayerInfo::audit_entries() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAPlayerInfo.audit_entries)
  return audit_entries_;
}

// -------------------------------------------------------------------

// CMsgDOTAPlayerInfoList

// repeated .proto.dota.CMsgDOTAPlayerInfo player_infos = 1;
inline int CMsgDOTAPlayerInfoList::player_infos_size() const {
  return player_infos_.size();
}
inline void CMsgDOTAPlayerInfoList::clear_player_infos() {
  player_infos_.Clear();
}
inline ::proto::dota::CMsgDOTAPlayerInfo* CMsgDOTAPlayerInfoList::mutable_player_infos(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAPlayerInfoList.player_infos)
  return player_infos_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPlayerInfo >*
CMsgDOTAPlayerInfoList::mutable_player_infos() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAPlayerInfoList.player_infos)
  return &player_infos_;
}
inline const ::proto::dota::CMsgDOTAPlayerInfo& CMsgDOTAPlayerInfoList::player_infos(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPlayerInfoList.player_infos)
  return player_infos_.Get(index);
}
inline ::proto::dota::CMsgDOTAPlayerInfo* CMsgDOTAPlayerInfoList::add_player_infos() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAPlayerInfoList.player_infos)
  return player_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPlayerInfo >&
CMsgDOTAPlayerInfoList::player_infos() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAPlayerInfoList.player_infos)
  return player_infos_;
}

// -------------------------------------------------------------------

// CMsgDOTADPCProfileInfo_PredictionInfo

// optional uint32 percent = 1;
inline bool CMsgDOTADPCProfileInfo_PredictionInfo::has_percent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTADPCProfileInfo_PredictionInfo::clear_percent() {
  percent_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTADPCProfileInfo_PredictionInfo::percent() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTADPCProfileInfo.PredictionInfo.percent)
  return percent_;
}
inline void CMsgDOTADPCProfileInfo_PredictionInfo::set_percent(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  percent_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTADPCProfileInfo.PredictionInfo.percent)
}

// optional uint32 shard_winnings = 2;
inline bool CMsgDOTADPCProfileInfo_PredictionInfo::has_shard_winnings() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTADPCProfileInfo_PredictionInfo::clear_shard_winnings() {
  shard_winnings_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTADPCProfileInfo_PredictionInfo::shard_winnings() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTADPCProfileInfo.PredictionInfo.shard_winnings)
  return shard_winnings_;
}
inline void CMsgDOTADPCProfileInfo_PredictionInfo::set_shard_winnings(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  shard_winnings_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTADPCProfileInfo.PredictionInfo.shard_winnings)
}

// -------------------------------------------------------------------

// CMsgDOTADPCProfileInfo_FantasyInfo

// optional uint32 top_90_finishes = 1;
inline bool CMsgDOTADPCProfileInfo_FantasyInfo::has_top_90_finishes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTADPCProfileInfo_FantasyInfo::clear_top_90_finishes() {
  top_90_finishes_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTADPCProfileInfo_FantasyInfo::top_90_finishes() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTADPCProfileInfo.FantasyInfo.top_90_finishes)
  return top_90_finishes_;
}
inline void CMsgDOTADPCProfileInfo_FantasyInfo::set_top_90_finishes(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  top_90_finishes_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTADPCProfileInfo.FantasyInfo.top_90_finishes)
}

// optional uint32 top_75_finishes = 2;
inline bool CMsgDOTADPCProfileInfo_FantasyInfo::has_top_75_finishes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTADPCProfileInfo_FantasyInfo::clear_top_75_finishes() {
  top_75_finishes_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTADPCProfileInfo_FantasyInfo::top_75_finishes() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTADPCProfileInfo.FantasyInfo.top_75_finishes)
  return top_75_finishes_;
}
inline void CMsgDOTADPCProfileInfo_FantasyInfo::set_top_75_finishes(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  top_75_finishes_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTADPCProfileInfo.FantasyInfo.top_75_finishes)
}

// optional uint32 top_50_finishes = 3;
inline bool CMsgDOTADPCProfileInfo_FantasyInfo::has_top_50_finishes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTADPCProfileInfo_FantasyInfo::clear_top_50_finishes() {
  top_50_finishes_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTADPCProfileInfo_FantasyInfo::top_50_finishes() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTADPCProfileInfo.FantasyInfo.top_50_finishes)
  return top_50_finishes_;
}
inline void CMsgDOTADPCProfileInfo_FantasyInfo::set_top_50_finishes(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  top_50_finishes_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTADPCProfileInfo.FantasyInfo.top_50_finishes)
}

// optional uint32 shard_winnings = 4;
inline bool CMsgDOTADPCProfileInfo_FantasyInfo::has_shard_winnings() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTADPCProfileInfo_FantasyInfo::clear_shard_winnings() {
  shard_winnings_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTADPCProfileInfo_FantasyInfo::shard_winnings() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTADPCProfileInfo.FantasyInfo.shard_winnings)
  return shard_winnings_;
}
inline void CMsgDOTADPCProfileInfo_FantasyInfo::set_shard_winnings(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  shard_winnings_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTADPCProfileInfo.FantasyInfo.shard_winnings)
}

// -------------------------------------------------------------------

// CMsgDOTADPCProfileInfo

// optional .proto.dota.CMsgDOTAPlayerInfo player_info = 1;
inline bool CMsgDOTADPCProfileInfo::has_player_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTADPCProfileInfo::clear_player_info() {
  if (player_info_ != nullptr) player_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::dota::CMsgDOTAPlayerInfo& CMsgDOTADPCProfileInfo::player_info() const {
  const ::proto::dota::CMsgDOTAPlayerInfo* p = player_info_;
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTADPCProfileInfo.player_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::dota::CMsgDOTAPlayerInfo*>(
      &::proto::dota::_CMsgDOTAPlayerInfo_default_instance_);
}
inline ::proto::dota::CMsgDOTAPlayerInfo* CMsgDOTADPCProfileInfo::release_player_info() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTADPCProfileInfo.player_info)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::dota::CMsgDOTAPlayerInfo* temp = player_info_;
  player_info_ = nullptr;
  return temp;
}
inline ::proto::dota::CMsgDOTAPlayerInfo* CMsgDOTADPCProfileInfo::mutable_player_info() {
  _has_bits_[0] |= 0x00000001u;
  if (player_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::dota::CMsgDOTAPlayerInfo>(GetArenaNoVirtual());
    player_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTADPCProfileInfo.player_info)
  return player_info_;
}
inline void CMsgDOTADPCProfileInfo::set_allocated_player_info(::proto::dota::CMsgDOTAPlayerInfo* player_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete player_info_;
  }
  if (player_info) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      player_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  player_info_ = player_info;
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTADPCProfileInfo.player_info)
}

// optional .proto.dota.CMsgDOTADPCProfileInfo.PredictionInfo prediction_info = 2;
inline bool CMsgDOTADPCProfileInfo::has_prediction_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTADPCProfileInfo::clear_prediction_info() {
  if (prediction_info_ != nullptr) prediction_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::dota::CMsgDOTADPCProfileInfo_PredictionInfo& CMsgDOTADPCProfileInfo::prediction_info() const {
  const ::proto::dota::CMsgDOTADPCProfileInfo_PredictionInfo* p = prediction_info_;
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTADPCProfileInfo.prediction_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::dota::CMsgDOTADPCProfileInfo_PredictionInfo*>(
      &::proto::dota::_CMsgDOTADPCProfileInfo_PredictionInfo_default_instance_);
}
inline ::proto::dota::CMsgDOTADPCProfileInfo_PredictionInfo* CMsgDOTADPCProfileInfo::release_prediction_info() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTADPCProfileInfo.prediction_info)
  _has_bits_[0] &= ~0x00000002u;
  ::proto::dota::CMsgDOTADPCProfileInfo_PredictionInfo* temp = prediction_info_;
  prediction_info_ = nullptr;
  return temp;
}
inline ::proto::dota::CMsgDOTADPCProfileInfo_PredictionInfo* CMsgDOTADPCProfileInfo::mutable_prediction_info() {
  _has_bits_[0] |= 0x00000002u;
  if (prediction_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::dota::CMsgDOTADPCProfileInfo_PredictionInfo>(GetArenaNoVirtual());
    prediction_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTADPCProfileInfo.prediction_info)
  return prediction_info_;
}
inline void CMsgDOTADPCProfileInfo::set_allocated_prediction_info(::proto::dota::CMsgDOTADPCProfileInfo_PredictionInfo* prediction_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete prediction_info_;
  }
  if (prediction_info) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      prediction_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, prediction_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  prediction_info_ = prediction_info;
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTADPCProfileInfo.prediction_info)
}

// optional .proto.dota.CMsgDOTADPCProfileInfo.FantasyInfo fantasy_info = 3;
inline bool CMsgDOTADPCProfileInfo::has_fantasy_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTADPCProfileInfo::clear_fantasy_info() {
  if (fantasy_info_ != nullptr) fantasy_info_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::proto::dota::CMsgDOTADPCProfileInfo_FantasyInfo& CMsgDOTADPCProfileInfo::fantasy_info() const {
  const ::proto::dota::CMsgDOTADPCProfileInfo_FantasyInfo* p = fantasy_info_;
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTADPCProfileInfo.fantasy_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::dota::CMsgDOTADPCProfileInfo_FantasyInfo*>(
      &::proto::dota::_CMsgDOTADPCProfileInfo_FantasyInfo_default_instance_);
}
inline ::proto::dota::CMsgDOTADPCProfileInfo_FantasyInfo* CMsgDOTADPCProfileInfo::release_fantasy_info() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTADPCProfileInfo.fantasy_info)
  _has_bits_[0] &= ~0x00000004u;
  ::proto::dota::CMsgDOTADPCProfileInfo_FantasyInfo* temp = fantasy_info_;
  fantasy_info_ = nullptr;
  return temp;
}
inline ::proto::dota::CMsgDOTADPCProfileInfo_FantasyInfo* CMsgDOTADPCProfileInfo::mutable_fantasy_info() {
  _has_bits_[0] |= 0x00000004u;
  if (fantasy_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::dota::CMsgDOTADPCProfileInfo_FantasyInfo>(GetArenaNoVirtual());
    fantasy_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTADPCProfileInfo.fantasy_info)
  return fantasy_info_;
}
inline void CMsgDOTADPCProfileInfo::set_allocated_fantasy_info(::proto::dota::CMsgDOTADPCProfileInfo_FantasyInfo* fantasy_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete fantasy_info_;
  }
  if (fantasy_info) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fantasy_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fantasy_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  fantasy_info_ = fantasy_info;
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTADPCProfileInfo.fantasy_info)
}

// repeated uint32 disabled_notifications = 4;
inline int CMsgDOTADPCProfileInfo::disabled_notifications_size() const {
  return disabled_notifications_.size();
}
inline void CMsgDOTADPCProfileInfo::clear_disabled_notifications() {
  disabled_notifications_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTADPCProfileInfo::disabled_notifications(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTADPCProfileInfo.disabled_notifications)
  return disabled_notifications_.Get(index);
}
inline void CMsgDOTADPCProfileInfo::set_disabled_notifications(int index, ::google::protobuf::uint32 value) {
  disabled_notifications_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTADPCProfileInfo.disabled_notifications)
}
inline void CMsgDOTADPCProfileInfo::add_disabled_notifications(::google::protobuf::uint32 value) {
  disabled_notifications_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTADPCProfileInfo.disabled_notifications)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTADPCProfileInfo::disabled_notifications() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTADPCProfileInfo.disabled_notifications)
  return disabled_notifications_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTADPCProfileInfo::mutable_disabled_notifications() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTADPCProfileInfo.disabled_notifications)
  return &disabled_notifications_;
}

// -------------------------------------------------------------------

// CMsgDOTALeaderboards_RegionLeaderboard

// optional uint32 division = 1;
inline bool CMsgDOTALeaderboards_RegionLeaderboard::has_division() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTALeaderboards_RegionLeaderboard::clear_division() {
  division_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTALeaderboards_RegionLeaderboard::division() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeaderboards.RegionLeaderboard.division)
  return division_;
}
inline void CMsgDOTALeaderboards_RegionLeaderboard::set_division(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  division_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeaderboards.RegionLeaderboard.division)
}

// repeated uint32 account_ids = 2;
inline int CMsgDOTALeaderboards_RegionLeaderboard::account_ids_size() const {
  return account_ids_.size();
}
inline void CMsgDOTALeaderboards_RegionLeaderboard::clear_account_ids() {
  account_ids_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTALeaderboards_RegionLeaderboard::account_ids(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeaderboards.RegionLeaderboard.account_ids)
  return account_ids_.Get(index);
}
inline void CMsgDOTALeaderboards_RegionLeaderboard::set_account_ids(int index, ::google::protobuf::uint32 value) {
  account_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTALeaderboards.RegionLeaderboard.account_ids)
}
inline void CMsgDOTALeaderboards_RegionLeaderboard::add_account_ids(::google::protobuf::uint32 value) {
  account_ids_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTALeaderboards.RegionLeaderboard.account_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTALeaderboards_RegionLeaderboard::account_ids() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTALeaderboards.RegionLeaderboard.account_ids)
  return account_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTALeaderboards_RegionLeaderboard::mutable_account_ids() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTALeaderboards.RegionLeaderboard.account_ids)
  return &account_ids_;
}

// -------------------------------------------------------------------

// CMsgDOTALeaderboards

// repeated .proto.dota.CMsgDOTALeaderboards.RegionLeaderboard leaderboards = 2;
inline int CMsgDOTALeaderboards::leaderboards_size() const {
  return leaderboards_.size();
}
inline void CMsgDOTALeaderboards::clear_leaderboards() {
  leaderboards_.Clear();
}
inline ::proto::dota::CMsgDOTALeaderboards_RegionLeaderboard* CMsgDOTALeaderboards::mutable_leaderboards(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTALeaderboards.leaderboards)
  return leaderboards_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeaderboards_RegionLeaderboard >*
CMsgDOTALeaderboards::mutable_leaderboards() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTALeaderboards.leaderboards)
  return &leaderboards_;
}
inline const ::proto::dota::CMsgDOTALeaderboards_RegionLeaderboard& CMsgDOTALeaderboards::leaderboards(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTALeaderboards.leaderboards)
  return leaderboards_.Get(index);
}
inline ::proto::dota::CMsgDOTALeaderboards_RegionLeaderboard* CMsgDOTALeaderboards::add_leaderboards() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTALeaderboards.leaderboards)
  return leaderboards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTALeaderboards_RegionLeaderboard >&
CMsgDOTALeaderboards::leaderboards() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTALeaderboards.leaderboards)
  return leaderboards_;
}

// -------------------------------------------------------------------

// CMsgDOTACreateFantasyLeagueRequest

// optional string league_name = 1;
inline bool CMsgDOTACreateFantasyLeagueRequest::has_league_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTACreateFantasyLeagueRequest::clear_league_name() {
  league_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTACreateFantasyLeagueRequest::league_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTACreateFantasyLeagueRequest.league_name)
  return league_name_.GetNoArena();
}
inline void CMsgDOTACreateFantasyLeagueRequest::set_league_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  league_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTACreateFantasyLeagueRequest.league_name)
}
#if LANG_CXX11
inline void CMsgDOTACreateFantasyLeagueRequest::set_league_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  league_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTACreateFantasyLeagueRequest.league_name)
}
#endif
inline void CMsgDOTACreateFantasyLeagueRequest::set_league_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  league_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTACreateFantasyLeagueRequest.league_name)
}
inline void CMsgDOTACreateFantasyLeagueRequest::set_league_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  league_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTACreateFantasyLeagueRequest.league_name)
}
inline ::std::string* CMsgDOTACreateFantasyLeagueRequest::mutable_league_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTACreateFantasyLeagueRequest.league_name)
  return league_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTACreateFantasyLeagueRequest::release_league_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTACreateFantasyLeagueRequest.league_name)
  if (!has_league_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return league_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTACreateFantasyLeagueRequest::set_allocated_league_name(::std::string* league_name) {
  if (league_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  league_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), league_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTACreateFantasyLeagueRequest.league_name)
}

// optional uint64 league_logo = 2;
inline bool CMsgDOTACreateFantasyLeagueRequest::has_league_logo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTACreateFantasyLeagueRequest::clear_league_logo() {
  league_logo_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 CMsgDOTACreateFantasyLeagueRequest::league_logo() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTACreateFantasyLeagueRequest.league_logo)
  return league_logo_;
}
inline void CMsgDOTACreateFantasyLeagueRequest::set_league_logo(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  league_logo_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTACreateFantasyLeagueRequest.league_logo)
}

// optional .proto.dota.Fantasy_Selection_Mode selection_mode = 3 [default = FANTASY_SELECTION_INVALID];
inline bool CMsgDOTACreateFantasyLeagueRequest::has_selection_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTACreateFantasyLeagueRequest::clear_selection_mode() {
  selection_mode_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::proto::dota::Fantasy_Selection_Mode CMsgDOTACreateFantasyLeagueRequest::selection_mode() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTACreateFantasyLeagueRequest.selection_mode)
  return static_cast< ::proto::dota::Fantasy_Selection_Mode >(selection_mode_);
}
inline void CMsgDOTACreateFantasyLeagueRequest::set_selection_mode(::proto::dota::Fantasy_Selection_Mode value) {
  assert(::proto::dota::Fantasy_Selection_Mode_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  selection_mode_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTACreateFantasyLeagueRequest.selection_mode)
}

// optional uint32 team_count = 4;
inline bool CMsgDOTACreateFantasyLeagueRequest::has_team_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTACreateFantasyLeagueRequest::clear_team_count() {
  team_count_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTACreateFantasyLeagueRequest::team_count() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTACreateFantasyLeagueRequest.team_count)
  return team_count_;
}
inline void CMsgDOTACreateFantasyLeagueRequest::set_team_count(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  team_count_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTACreateFantasyLeagueRequest.team_count)
}

// -------------------------------------------------------------------

// CMsgDOTACreateFantasyLeagueResponse

// optional .proto.dota.CMsgDOTACreateFantasyLeagueResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTACreateFantasyLeagueResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTACreateFantasyLeagueResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgDOTACreateFantasyLeagueResponse_EResult CMsgDOTACreateFantasyLeagueResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTACreateFantasyLeagueResponse.result)
  return static_cast< ::proto::dota::CMsgDOTACreateFantasyLeagueResponse_EResult >(result_);
}
inline void CMsgDOTACreateFantasyLeagueResponse::set_result(::proto::dota::CMsgDOTACreateFantasyLeagueResponse_EResult value) {
  assert(::proto::dota::CMsgDOTACreateFantasyLeagueResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTACreateFantasyLeagueResponse.result)
}

// -------------------------------------------------------------------

// CMsgFantasyLeagueScoring

// optional float level = 1;
inline bool CMsgFantasyLeagueScoring::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgFantasyLeagueScoring::clear_level() {
  level_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float CMsgFantasyLeagueScoring::level() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgFantasyLeagueScoring.level)
  return level_;
}
inline void CMsgFantasyLeagueScoring::set_level(float value) {
  _has_bits_[0] |= 0x00000001u;
  level_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgFantasyLeagueScoring.level)
}

// optional float kills = 2;
inline bool CMsgFantasyLeagueScoring::has_kills() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgFantasyLeagueScoring::clear_kills() {
  kills_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float CMsgFantasyLeagueScoring::kills() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgFantasyLeagueScoring.kills)
  return kills_;
}
inline void CMsgFantasyLeagueScoring::set_kills(float value) {
  _has_bits_[0] |= 0x00000002u;
  kills_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgFantasyLeagueScoring.kills)
}

// optional float deaths = 3;
inline bool CMsgFantasyLeagueScoring::has_deaths() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgFantasyLeagueScoring::clear_deaths() {
  deaths_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float CMsgFantasyLeagueScoring::deaths() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgFantasyLeagueScoring.deaths)
  return deaths_;
}
inline void CMsgFantasyLeagueScoring::set_deaths(float value) {
  _has_bits_[0] |= 0x00000004u;
  deaths_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgFantasyLeagueScoring.deaths)
}

// optional float assists = 4;
inline bool CMsgFantasyLeagueScoring::has_assists() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgFantasyLeagueScoring::clear_assists() {
  assists_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float CMsgFantasyLeagueScoring::assists() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgFantasyLeagueScoring.assists)
  return assists_;
}
inline void CMsgFantasyLeagueScoring::set_assists(float value) {
  _has_bits_[0] |= 0x00000008u;
  assists_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgFantasyLeagueScoring.assists)
}

// optional float last_hits = 5;
inline bool CMsgFantasyLeagueScoring::has_last_hits() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgFantasyLeagueScoring::clear_last_hits() {
  last_hits_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float CMsgFantasyLeagueScoring::last_hits() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgFantasyLeagueScoring.last_hits)
  return last_hits_;
}
inline void CMsgFantasyLeagueScoring::set_last_hits(float value) {
  _has_bits_[0] |= 0x00000010u;
  last_hits_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgFantasyLeagueScoring.last_hits)
}

// optional float denies = 6;
inline bool CMsgFantasyLeagueScoring::has_denies() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgFantasyLeagueScoring::clear_denies() {
  denies_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float CMsgFantasyLeagueScoring::denies() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgFantasyLeagueScoring.denies)
  return denies_;
}
inline void CMsgFantasyLeagueScoring::set_denies(float value) {
  _has_bits_[0] |= 0x00000020u;
  denies_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgFantasyLeagueScoring.denies)
}

// optional float gpm = 7;
inline bool CMsgFantasyLeagueScoring::has_gpm() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgFantasyLeagueScoring::clear_gpm() {
  gpm_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float CMsgFantasyLeagueScoring::gpm() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgFantasyLeagueScoring.gpm)
  return gpm_;
}
inline void CMsgFantasyLeagueScoring::set_gpm(float value) {
  _has_bits_[0] |= 0x00000040u;
  gpm_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgFantasyLeagueScoring.gpm)
}

// optional float xppm = 8;
inline bool CMsgFantasyLeagueScoring::has_xppm() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgFantasyLeagueScoring::clear_xppm() {
  xppm_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float CMsgFantasyLeagueScoring::xppm() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgFantasyLeagueScoring.xppm)
  return xppm_;
}
inline void CMsgFantasyLeagueScoring::set_xppm(float value) {
  _has_bits_[0] |= 0x00000080u;
  xppm_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgFantasyLeagueScoring.xppm)
}

// optional float stuns = 9;
inline bool CMsgFantasyLeagueScoring::has_stuns() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgFantasyLeagueScoring::clear_stuns() {
  stuns_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float CMsgFantasyLeagueScoring::stuns() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgFantasyLeagueScoring.stuns)
  return stuns_;
}
inline void CMsgFantasyLeagueScoring::set_stuns(float value) {
  _has_bits_[0] |= 0x00000100u;
  stuns_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgFantasyLeagueScoring.stuns)
}

// optional float healing = 10;
inline bool CMsgFantasyLeagueScoring::has_healing() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgFantasyLeagueScoring::clear_healing() {
  healing_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float CMsgFantasyLeagueScoring::healing() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgFantasyLeagueScoring.healing)
  return healing_;
}
inline void CMsgFantasyLeagueScoring::set_healing(float value) {
  _has_bits_[0] |= 0x00000200u;
  healing_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgFantasyLeagueScoring.healing)
}

// optional float tower_kills = 11;
inline bool CMsgFantasyLeagueScoring::has_tower_kills() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgFantasyLeagueScoring::clear_tower_kills() {
  tower_kills_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline float CMsgFantasyLeagueScoring::tower_kills() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgFantasyLeagueScoring.tower_kills)
  return tower_kills_;
}
inline void CMsgFantasyLeagueScoring::set_tower_kills(float value) {
  _has_bits_[0] |= 0x00000400u;
  tower_kills_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgFantasyLeagueScoring.tower_kills)
}

// optional float roshan_kills = 12;
inline bool CMsgFantasyLeagueScoring::has_roshan_kills() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgFantasyLeagueScoring::clear_roshan_kills() {
  roshan_kills_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline float CMsgFantasyLeagueScoring::roshan_kills() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgFantasyLeagueScoring.roshan_kills)
  return roshan_kills_;
}
inline void CMsgFantasyLeagueScoring::set_roshan_kills(float value) {
  _has_bits_[0] |= 0x00000800u;
  roshan_kills_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgFantasyLeagueScoring.roshan_kills)
}

// optional float multiplier_premium = 13;
inline bool CMsgFantasyLeagueScoring::has_multiplier_premium() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgFantasyLeagueScoring::clear_multiplier_premium() {
  multiplier_premium_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline float CMsgFantasyLeagueScoring::multiplier_premium() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgFantasyLeagueScoring.multiplier_premium)
  return multiplier_premium_;
}
inline void CMsgFantasyLeagueScoring::set_multiplier_premium(float value) {
  _has_bits_[0] |= 0x00001000u;
  multiplier_premium_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgFantasyLeagueScoring.multiplier_premium)
}

// optional float multiplier_professional = 14;
inline bool CMsgFantasyLeagueScoring::has_multiplier_professional() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgFantasyLeagueScoring::clear_multiplier_professional() {
  multiplier_professional_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline float CMsgFantasyLeagueScoring::multiplier_professional() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgFantasyLeagueScoring.multiplier_professional)
  return multiplier_professional_;
}
inline void CMsgFantasyLeagueScoring::set_multiplier_professional(float value) {
  _has_bits_[0] |= 0x00002000u;
  multiplier_professional_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgFantasyLeagueScoring.multiplier_professional)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueInfo_OwnerInfo

// optional uint32 owner_account_id = 1;
inline bool CMsgDOTAFantasyLeagueInfo_OwnerInfo::has_owner_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo_OwnerInfo::clear_owner_account_id() {
  owner_account_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo_OwnerInfo::owner_account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.OwnerInfo.owner_account_id)
  return owner_account_id_;
}
inline void CMsgDOTAFantasyLeagueInfo_OwnerInfo::set_owner_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  owner_account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.OwnerInfo.owner_account_id)
}

// optional bool left_league = 2;
inline bool CMsgDOTAFantasyLeagueInfo_OwnerInfo::has_left_league() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo_OwnerInfo::clear_left_league() {
  left_league_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CMsgDOTAFantasyLeagueInfo_OwnerInfo::left_league() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.OwnerInfo.left_league)
  return left_league_;
}
inline void CMsgDOTAFantasyLeagueInfo_OwnerInfo::set_left_league(bool value) {
  _has_bits_[0] |= 0x00000002u;
  left_league_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.OwnerInfo.left_league)
}

// repeated uint32 player_account_id = 3;
inline int CMsgDOTAFantasyLeagueInfo_OwnerInfo::player_account_id_size() const {
  return player_account_id_.size();
}
inline void CMsgDOTAFantasyLeagueInfo_OwnerInfo::clear_player_account_id() {
  player_account_id_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo_OwnerInfo::player_account_id(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.OwnerInfo.player_account_id)
  return player_account_id_.Get(index);
}
inline void CMsgDOTAFantasyLeagueInfo_OwnerInfo::set_player_account_id(int index, ::google::protobuf::uint32 value) {
  player_account_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.OwnerInfo.player_account_id)
}
inline void CMsgDOTAFantasyLeagueInfo_OwnerInfo::add_player_account_id(::google::protobuf::uint32 value) {
  player_account_id_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAFantasyLeagueInfo.OwnerInfo.player_account_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTAFantasyLeagueInfo_OwnerInfo::player_account_id() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAFantasyLeagueInfo.OwnerInfo.player_account_id)
  return player_account_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTAFantasyLeagueInfo_OwnerInfo::mutable_player_account_id() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAFantasyLeagueInfo.OwnerInfo.player_account_id)
  return &player_account_id_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueInfo

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyLeagueInfo::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.fantasy_league_id)
}

// optional uint32 commissioner_account_id = 2;
inline bool CMsgDOTAFantasyLeagueInfo::has_commissioner_account_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_commissioner_account_id() {
  commissioner_account_id_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::commissioner_account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.commissioner_account_id)
  return commissioner_account_id_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_commissioner_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  commissioner_account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.commissioner_account_id)
}

// optional string fantasy_league_name = 3;
inline bool CMsgDOTAFantasyLeagueInfo::has_fantasy_league_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_fantasy_league_name() {
  fantasy_league_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTAFantasyLeagueInfo::fantasy_league_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.fantasy_league_name)
  return fantasy_league_name_.GetNoArena();
}
inline void CMsgDOTAFantasyLeagueInfo::set_fantasy_league_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.fantasy_league_name)
}
#if LANG_CXX11
inline void CMsgDOTAFantasyLeagueInfo::set_fantasy_league_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAFantasyLeagueInfo.fantasy_league_name)
}
#endif
inline void CMsgDOTAFantasyLeagueInfo::set_fantasy_league_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAFantasyLeagueInfo.fantasy_league_name)
}
inline void CMsgDOTAFantasyLeagueInfo::set_fantasy_league_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAFantasyLeagueInfo.fantasy_league_name)
}
inline ::std::string* CMsgDOTAFantasyLeagueInfo::mutable_fantasy_league_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyLeagueInfo.fantasy_league_name)
  return fantasy_league_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAFantasyLeagueInfo::release_fantasy_league_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAFantasyLeagueInfo.fantasy_league_name)
  if (!has_fantasy_league_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return fantasy_league_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAFantasyLeagueInfo::set_allocated_fantasy_league_name(::std::string* fantasy_league_name) {
  if (fantasy_league_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  fantasy_league_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fantasy_league_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAFantasyLeagueInfo.fantasy_league_name)
}

// optional .proto.dota.Fantasy_Selection_Mode selection_mode = 4 [default = FANTASY_SELECTION_INVALID];
inline bool CMsgDOTAFantasyLeagueInfo::has_selection_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_selection_mode() {
  selection_mode_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::proto::dota::Fantasy_Selection_Mode CMsgDOTAFantasyLeagueInfo::selection_mode() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.selection_mode)
  return static_cast< ::proto::dota::Fantasy_Selection_Mode >(selection_mode_);
}
inline void CMsgDOTAFantasyLeagueInfo::set_selection_mode(::proto::dota::Fantasy_Selection_Mode value) {
  assert(::proto::dota::Fantasy_Selection_Mode_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  selection_mode_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.selection_mode)
}

// optional uint32 team_count = 5;
inline bool CMsgDOTAFantasyLeagueInfo::has_team_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_team_count() {
  team_count_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::team_count() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.team_count)
  return team_count_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_team_count(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  team_count_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.team_count)
}

// optional uint64 logo = 6;
inline bool CMsgDOTAFantasyLeagueInfo::has_logo() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_logo() {
  logo_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyLeagueInfo::logo() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.logo)
  return logo_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_logo(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000080u;
  logo_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.logo)
}

// optional .proto.dota.CMsgFantasyLeagueScoring scoring = 7;
inline bool CMsgDOTAFantasyLeagueInfo::has_scoring() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_scoring() {
  if (scoring_ != nullptr) scoring_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::proto::dota::CMsgFantasyLeagueScoring& CMsgDOTAFantasyLeagueInfo::scoring() const {
  const ::proto::dota::CMsgFantasyLeagueScoring* p = scoring_;
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.scoring)
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::dota::CMsgFantasyLeagueScoring*>(
      &::proto::dota::_CMsgFantasyLeagueScoring_default_instance_);
}
inline ::proto::dota::CMsgFantasyLeagueScoring* CMsgDOTAFantasyLeagueInfo::release_scoring() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAFantasyLeagueInfo.scoring)
  _has_bits_[0] &= ~0x00000004u;
  ::proto::dota::CMsgFantasyLeagueScoring* temp = scoring_;
  scoring_ = nullptr;
  return temp;
}
inline ::proto::dota::CMsgFantasyLeagueScoring* CMsgDOTAFantasyLeagueInfo::mutable_scoring() {
  _has_bits_[0] |= 0x00000004u;
  if (scoring_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::dota::CMsgFantasyLeagueScoring>(GetArenaNoVirtual());
    scoring_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyLeagueInfo.scoring)
  return scoring_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_allocated_scoring(::proto::dota::CMsgFantasyLeagueScoring* scoring) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete scoring_;
  }
  if (scoring) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      scoring = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, scoring, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  scoring_ = scoring;
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAFantasyLeagueInfo.scoring)
}

// optional uint32 draft_time = 12;
inline bool CMsgDOTAFantasyLeagueInfo::has_draft_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_draft_time() {
  draft_time_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::draft_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.draft_time)
  return draft_time_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_draft_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  draft_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.draft_time)
}

// optional uint32 draft_pick_time = 13;
inline bool CMsgDOTAFantasyLeagueInfo::has_draft_pick_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_draft_pick_time() {
  draft_pick_time_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::draft_pick_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.draft_pick_time)
  return draft_pick_time_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_draft_pick_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  draft_pick_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.draft_pick_time)
}

// optional uint32 season_start = 15;
inline bool CMsgDOTAFantasyLeagueInfo::has_season_start() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_season_start() {
  season_start_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::season_start() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.season_start)
  return season_start_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_season_start(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000400u;
  season_start_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.season_start)
}

// optional uint32 season_length = 16;
inline bool CMsgDOTAFantasyLeagueInfo::has_season_length() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_season_length() {
  season_length_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::season_length() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.season_length)
  return season_length_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_season_length(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000800u;
  season_length_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.season_length)
}

// optional uint32 veto_votes = 17;
inline bool CMsgDOTAFantasyLeagueInfo::has_veto_votes() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_veto_votes() {
  veto_votes_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::veto_votes() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.veto_votes)
  return veto_votes_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_veto_votes(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00001000u;
  veto_votes_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.veto_votes)
}

// optional uint32 acquisitions = 18;
inline bool CMsgDOTAFantasyLeagueInfo::has_acquisitions() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_acquisitions() {
  acquisitions_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::acquisitions() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.acquisitions)
  return acquisitions_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_acquisitions(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00002000u;
  acquisitions_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.acquisitions)
}

// optional uint32 slot_1 = 19;
inline bool CMsgDOTAFantasyLeagueInfo::has_slot_1() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_slot_1() {
  slot_1_ = 0u;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::slot_1() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.slot_1)
  return slot_1_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_slot_1(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00004000u;
  slot_1_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.slot_1)
}

// optional uint32 slot_2 = 20;
inline bool CMsgDOTAFantasyLeagueInfo::has_slot_2() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_slot_2() {
  slot_2_ = 0u;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::slot_2() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.slot_2)
  return slot_2_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_slot_2(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00008000u;
  slot_2_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.slot_2)
}

// optional uint32 slot_3 = 21;
inline bool CMsgDOTAFantasyLeagueInfo::has_slot_3() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_slot_3() {
  slot_3_ = 0u;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::slot_3() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.slot_3)
  return slot_3_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_slot_3(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00010000u;
  slot_3_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.slot_3)
}

// optional uint32 slot_4 = 22;
inline bool CMsgDOTAFantasyLeagueInfo::has_slot_4() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_slot_4() {
  slot_4_ = 0u;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::slot_4() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.slot_4)
  return slot_4_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_slot_4(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00020000u;
  slot_4_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.slot_4)
}

// optional uint32 slot_5 = 23;
inline bool CMsgDOTAFantasyLeagueInfo::has_slot_5() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_slot_5() {
  slot_5_ = 0u;
  _has_bits_[0] &= ~0x00040000u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::slot_5() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.slot_5)
  return slot_5_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_slot_5(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00040000u;
  slot_5_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.slot_5)
}

// optional uint32 bench_slots = 24;
inline bool CMsgDOTAFantasyLeagueInfo::has_bench_slots() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_bench_slots() {
  bench_slots_ = 0u;
  _has_bits_[0] &= ~0x00080000u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::bench_slots() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.bench_slots)
  return bench_slots_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_bench_slots(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00080000u;
  bench_slots_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.bench_slots)
}

// repeated .proto.dota.CMsgDOTAFantasyLeagueInfo.OwnerInfo owner_info = 25;
inline int CMsgDOTAFantasyLeagueInfo::owner_info_size() const {
  return owner_info_.size();
}
inline void CMsgDOTAFantasyLeagueInfo::clear_owner_info() {
  owner_info_.Clear();
}
inline ::proto::dota::CMsgDOTAFantasyLeagueInfo_OwnerInfo* CMsgDOTAFantasyLeagueInfo::mutable_owner_info(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyLeagueInfo.owner_info)
  return owner_info_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyLeagueInfo_OwnerInfo >*
CMsgDOTAFantasyLeagueInfo::mutable_owner_info() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAFantasyLeagueInfo.owner_info)
  return &owner_info_;
}
inline const ::proto::dota::CMsgDOTAFantasyLeagueInfo_OwnerInfo& CMsgDOTAFantasyLeagueInfo::owner_info(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.owner_info)
  return owner_info_.Get(index);
}
inline ::proto::dota::CMsgDOTAFantasyLeagueInfo_OwnerInfo* CMsgDOTAFantasyLeagueInfo::add_owner_info() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAFantasyLeagueInfo.owner_info)
  return owner_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyLeagueInfo_OwnerInfo >&
CMsgDOTAFantasyLeagueInfo::owner_info() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAFantasyLeagueInfo.owner_info)
  return owner_info_;
}

// repeated uint32 players = 26;
inline int CMsgDOTAFantasyLeagueInfo::players_size() const {
  return players_.size();
}
inline void CMsgDOTAFantasyLeagueInfo::clear_players() {
  players_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::players(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.players)
  return players_.Get(index);
}
inline void CMsgDOTAFantasyLeagueInfo::set_players(int index, ::google::protobuf::uint32 value) {
  players_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.players)
}
inline void CMsgDOTAFantasyLeagueInfo::add_players(::google::protobuf::uint32 value) {
  players_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAFantasyLeagueInfo.players)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTAFantasyLeagueInfo::players() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAFantasyLeagueInfo.players)
  return players_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTAFantasyLeagueInfo::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAFantasyLeagueInfo.players)
  return &players_;
}

// optional uint32 time_zone = 27;
inline bool CMsgDOTAFantasyLeagueInfo::has_time_zone() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_time_zone() {
  time_zone_ = 0u;
  _has_bits_[0] &= ~0x00100000u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::time_zone() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.time_zone)
  return time_zone_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_time_zone(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00100000u;
  time_zone_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.time_zone)
}

// optional uint32 season = 28;
inline bool CMsgDOTAFantasyLeagueInfo::has_season() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_season() {
  season_ = 0u;
  _has_bits_[0] &= ~0x00200000u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfo::season() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.season)
  return season_;
}
inline void CMsgDOTAFantasyLeagueInfo::set_season(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00200000u;
  season_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.season)
}

// optional string password = 29;
inline bool CMsgDOTAFantasyLeagueInfo::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfo::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgDOTAFantasyLeagueInfo::password() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfo.password)
  return password_.GetNoArena();
}
inline void CMsgDOTAFantasyLeagueInfo::set_password(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfo.password)
}
#if LANG_CXX11
inline void CMsgDOTAFantasyLeagueInfo::set_password(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAFantasyLeagueInfo.password)
}
#endif
inline void CMsgDOTAFantasyLeagueInfo::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAFantasyLeagueInfo.password)
}
inline void CMsgDOTAFantasyLeagueInfo::set_password(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAFantasyLeagueInfo.password)
}
inline ::std::string* CMsgDOTAFantasyLeagueInfo::mutable_password() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyLeagueInfo.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAFantasyLeagueInfo::release_password() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAFantasyLeagueInfo.password)
  if (!has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return password_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAFantasyLeagueInfo::set_allocated_password(::std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAFantasyLeagueInfo.password)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueEditInfoRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyLeagueEditInfoRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueEditInfoRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueEditInfoRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueEditInfoRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyLeagueEditInfoRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueEditInfoRequest.fantasy_league_id)
}

// optional .proto.dota.CMsgDOTAFantasyLeagueInfo edit_info = 2;
inline bool CMsgDOTAFantasyLeagueEditInfoRequest::has_edit_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueEditInfoRequest::clear_edit_info() {
  if (edit_info_ != nullptr) edit_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::dota::CMsgDOTAFantasyLeagueInfo& CMsgDOTAFantasyLeagueEditInfoRequest::edit_info() const {
  const ::proto::dota::CMsgDOTAFantasyLeagueInfo* p = edit_info_;
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueEditInfoRequest.edit_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::dota::CMsgDOTAFantasyLeagueInfo*>(
      &::proto::dota::_CMsgDOTAFantasyLeagueInfo_default_instance_);
}
inline ::proto::dota::CMsgDOTAFantasyLeagueInfo* CMsgDOTAFantasyLeagueEditInfoRequest::release_edit_info() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAFantasyLeagueEditInfoRequest.edit_info)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::dota::CMsgDOTAFantasyLeagueInfo* temp = edit_info_;
  edit_info_ = nullptr;
  return temp;
}
inline ::proto::dota::CMsgDOTAFantasyLeagueInfo* CMsgDOTAFantasyLeagueEditInfoRequest::mutable_edit_info() {
  _has_bits_[0] |= 0x00000001u;
  if (edit_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyLeagueInfo>(GetArenaNoVirtual());
    edit_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyLeagueEditInfoRequest.edit_info)
  return edit_info_;
}
inline void CMsgDOTAFantasyLeagueEditInfoRequest::set_allocated_edit_info(::proto::dota::CMsgDOTAFantasyLeagueInfo* edit_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete edit_info_;
  }
  if (edit_info) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      edit_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, edit_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  edit_info_ = edit_info;
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAFantasyLeagueEditInfoRequest.edit_info)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueEditInfoResponse

// optional .proto.dota.CMsgDOTAFantasyLeagueEditInfoResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyLeagueEditInfoResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueEditInfoResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgDOTAFantasyLeagueEditInfoResponse_EResult CMsgDOTAFantasyLeagueEditInfoResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueEditInfoResponse.result)
  return static_cast< ::proto::dota::CMsgDOTAFantasyLeagueEditInfoResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyLeagueEditInfoResponse::set_result(::proto::dota::CMsgDOTAFantasyLeagueEditInfoResponse_EResult value) {
  assert(::proto::dota::CMsgDOTAFantasyLeagueEditInfoResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueEditInfoResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueFindRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyLeagueFindRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueFindRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueFindRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueFindRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyLeagueFindRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueFindRequest.fantasy_league_id)
}

// optional string password = 2;
inline bool CMsgDOTAFantasyLeagueFindRequest::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueFindRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTAFantasyLeagueFindRequest::password() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueFindRequest.password)
  return password_.GetNoArena();
}
inline void CMsgDOTAFantasyLeagueFindRequest::set_password(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueFindRequest.password)
}
#if LANG_CXX11
inline void CMsgDOTAFantasyLeagueFindRequest::set_password(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAFantasyLeagueFindRequest.password)
}
#endif
inline void CMsgDOTAFantasyLeagueFindRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAFantasyLeagueFindRequest.password)
}
inline void CMsgDOTAFantasyLeagueFindRequest::set_password(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAFantasyLeagueFindRequest.password)
}
inline ::std::string* CMsgDOTAFantasyLeagueFindRequest::mutable_password() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyLeagueFindRequest.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAFantasyLeagueFindRequest::release_password() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAFantasyLeagueFindRequest.password)
  if (!has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return password_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAFantasyLeagueFindRequest::set_allocated_password(::std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAFantasyLeagueFindRequest.password)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueFindResponse

// optional .proto.dota.CMsgDOTAFantasyLeagueFindResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyLeagueFindResponse::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyLeagueFindResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::proto::dota::CMsgDOTAFantasyLeagueFindResponse_EResult CMsgDOTAFantasyLeagueFindResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueFindResponse.result)
  return static_cast< ::proto::dota::CMsgDOTAFantasyLeagueFindResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyLeagueFindResponse::set_result(::proto::dota::CMsgDOTAFantasyLeagueFindResponse_EResult value) {
  assert(::proto::dota::CMsgDOTAFantasyLeagueFindResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueFindResponse.result)
}

// optional string fantasy_league_name = 2;
inline bool CMsgDOTAFantasyLeagueFindResponse::has_fantasy_league_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueFindResponse::clear_fantasy_league_name() {
  fantasy_league_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTAFantasyLeagueFindResponse::fantasy_league_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueFindResponse.fantasy_league_name)
  return fantasy_league_name_.GetNoArena();
}
inline void CMsgDOTAFantasyLeagueFindResponse::set_fantasy_league_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueFindResponse.fantasy_league_name)
}
#if LANG_CXX11
inline void CMsgDOTAFantasyLeagueFindResponse::set_fantasy_league_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAFantasyLeagueFindResponse.fantasy_league_name)
}
#endif
inline void CMsgDOTAFantasyLeagueFindResponse::set_fantasy_league_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAFantasyLeagueFindResponse.fantasy_league_name)
}
inline void CMsgDOTAFantasyLeagueFindResponse::set_fantasy_league_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAFantasyLeagueFindResponse.fantasy_league_name)
}
inline ::std::string* CMsgDOTAFantasyLeagueFindResponse::mutable_fantasy_league_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyLeagueFindResponse.fantasy_league_name)
  return fantasy_league_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAFantasyLeagueFindResponse::release_fantasy_league_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAFantasyLeagueFindResponse.fantasy_league_name)
  if (!has_fantasy_league_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return fantasy_league_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAFantasyLeagueFindResponse::set_allocated_fantasy_league_name(::std::string* fantasy_league_name) {
  if (fantasy_league_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  fantasy_league_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fantasy_league_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAFantasyLeagueFindResponse.fantasy_league_name)
}

// optional string commissioner_name = 3;
inline bool CMsgDOTAFantasyLeagueFindResponse::has_commissioner_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueFindResponse::clear_commissioner_name() {
  commissioner_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgDOTAFantasyLeagueFindResponse::commissioner_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueFindResponse.commissioner_name)
  return commissioner_name_.GetNoArena();
}
inline void CMsgDOTAFantasyLeagueFindResponse::set_commissioner_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  commissioner_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueFindResponse.commissioner_name)
}
#if LANG_CXX11
inline void CMsgDOTAFantasyLeagueFindResponse::set_commissioner_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  commissioner_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAFantasyLeagueFindResponse.commissioner_name)
}
#endif
inline void CMsgDOTAFantasyLeagueFindResponse::set_commissioner_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  commissioner_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAFantasyLeagueFindResponse.commissioner_name)
}
inline void CMsgDOTAFantasyLeagueFindResponse::set_commissioner_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  commissioner_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAFantasyLeagueFindResponse.commissioner_name)
}
inline ::std::string* CMsgDOTAFantasyLeagueFindResponse::mutable_commissioner_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyLeagueFindResponse.commissioner_name)
  return commissioner_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAFantasyLeagueFindResponse::release_commissioner_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAFantasyLeagueFindResponse.commissioner_name)
  if (!has_commissioner_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return commissioner_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAFantasyLeagueFindResponse::set_allocated_commissioner_name(::std::string* commissioner_name) {
  if (commissioner_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  commissioner_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), commissioner_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAFantasyLeagueFindResponse.commissioner_name)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueInfoRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyLeagueInfoRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfoRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueInfoRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfoRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyLeagueInfoRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfoRequest.fantasy_league_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueInfoResponse

// optional .proto.dota.CMsgDOTAFantasyLeagueInfoResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyLeagueInfoResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueInfoResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgDOTAFantasyLeagueInfoResponse_EResult CMsgDOTAFantasyLeagueInfoResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueInfoResponse.result)
  return static_cast< ::proto::dota::CMsgDOTAFantasyLeagueInfoResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyLeagueInfoResponse::set_result(::proto::dota::CMsgDOTAFantasyLeagueInfoResponse_EResult value) {
  assert(::proto::dota::CMsgDOTAFantasyLeagueInfoResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueInfoResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueMatchupsRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyLeagueMatchupsRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueMatchupsRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueMatchupsRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueMatchupsRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyLeagueMatchupsRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueMatchupsRequest.fantasy_league_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueMatchupsResponse_Matchup

// optional uint32 owner_account_id_1 = 1;
inline bool CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::has_owner_account_id_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::clear_owner_account_id_1() {
  owner_account_id_1_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::owner_account_id_1() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.Matchup.owner_account_id_1)
  return owner_account_id_1_;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::set_owner_account_id_1(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  owner_account_id_1_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.Matchup.owner_account_id_1)
}

// optional uint32 owner_account_id_2 = 2;
inline bool CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::has_owner_account_id_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::clear_owner_account_id_2() {
  owner_account_id_2_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::owner_account_id_2() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.Matchup.owner_account_id_2)
  return owner_account_id_2_;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::set_owner_account_id_2(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  owner_account_id_2_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.Matchup.owner_account_id_2)
}

// optional float score_1 = 3;
inline bool CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::has_score_1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::clear_score_1() {
  score_1_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::score_1() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.Matchup.score_1)
  return score_1_;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::set_score_1(float value) {
  _has_bits_[0] |= 0x00000004u;
  score_1_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.Matchup.score_1)
}

// optional float score_2 = 4;
inline bool CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::has_score_2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::clear_score_2() {
  score_2_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::score_2() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.Matchup.score_2)
  return score_2_;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::set_score_2(float value) {
  _has_bits_[0] |= 0x00000008u;
  score_2_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.Matchup.score_2)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups

// repeated .proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.Matchup matchup = 1;
inline int CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::matchup_size() const {
  return matchup_.size();
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::clear_matchup() {
  matchup_.Clear();
}
inline ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_Matchup* CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::mutable_matchup(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.matchup)
  return matchup_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_Matchup >*
CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::mutable_matchup() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.matchup)
  return &matchup_;
}
inline const ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_Matchup& CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::matchup(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.matchup)
  return matchup_.Get(index);
}
inline ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_Matchup* CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::add_matchup() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.matchup)
  return matchup_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_Matchup >&
CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::matchup() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.matchup)
  return matchup_;
}

// optional uint32 start_time = 2;
inline bool CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::has_start_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::clear_start_time() {
  start_time_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::start_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.start_time)
  return start_time_;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::set_start_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  start_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.start_time)
}

// optional uint32 end_time = 3;
inline bool CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::has_end_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::clear_end_time() {
  end_time_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::end_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.end_time)
  return end_time_;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::set_end_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  end_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups.end_time)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueMatchupsResponse

// optional .proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyLeagueMatchupsResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_EResult CMsgDOTAFantasyLeagueMatchupsResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.result)
  return static_cast< ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse::set_result(::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_EResult value) {
  assert(::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.result)
}

// optional uint32 fantasy_league_id = 2;
inline bool CMsgDOTAFantasyLeagueMatchupsResponse::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueMatchupsResponse::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.fantasy_league_id)
}

// repeated .proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups weekly_matchups = 3;
inline int CMsgDOTAFantasyLeagueMatchupsResponse::weekly_matchups_size() const {
  return weekly_matchups_.size();
}
inline void CMsgDOTAFantasyLeagueMatchupsResponse::clear_weekly_matchups() {
  weekly_matchups_.Clear();
}
inline ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups* CMsgDOTAFantasyLeagueMatchupsResponse::mutable_weekly_matchups(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.weekly_matchups)
  return weekly_matchups_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups >*
CMsgDOTAFantasyLeagueMatchupsResponse::mutable_weekly_matchups() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.weekly_matchups)
  return &weekly_matchups_;
}
inline const ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups& CMsgDOTAFantasyLeagueMatchupsResponse::weekly_matchups(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.weekly_matchups)
  return weekly_matchups_.Get(index);
}
inline ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups* CMsgDOTAFantasyLeagueMatchupsResponse::add_weekly_matchups() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.weekly_matchups)
  return weekly_matchups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups >&
CMsgDOTAFantasyLeagueMatchupsResponse::weekly_matchups() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAFantasyLeagueMatchupsResponse.weekly_matchups)
  return weekly_matchups_;
}

// -------------------------------------------------------------------

// CMsgDOTAEditFantasyTeamRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAEditFantasyTeamRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAEditFantasyTeamRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAEditFantasyTeamRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAEditFantasyTeamRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAEditFantasyTeamRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAEditFantasyTeamRequest.fantasy_league_id)
}

// optional uint32 team_index = 2;
inline bool CMsgDOTAEditFantasyTeamRequest::has_team_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAEditFantasyTeamRequest::clear_team_index() {
  team_index_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAEditFantasyTeamRequest::team_index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAEditFantasyTeamRequest.team_index)
  return team_index_;
}
inline void CMsgDOTAEditFantasyTeamRequest::set_team_index(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  team_index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAEditFantasyTeamRequest.team_index)
}

// optional string team_name = 3;
inline bool CMsgDOTAEditFantasyTeamRequest::has_team_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAEditFantasyTeamRequest::clear_team_name() {
  team_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTAEditFantasyTeamRequest::team_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAEditFantasyTeamRequest.team_name)
  return team_name_.GetNoArena();
}
inline void CMsgDOTAEditFantasyTeamRequest::set_team_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAEditFantasyTeamRequest.team_name)
}
#if LANG_CXX11
inline void CMsgDOTAEditFantasyTeamRequest::set_team_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAEditFantasyTeamRequest.team_name)
}
#endif
inline void CMsgDOTAEditFantasyTeamRequest::set_team_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAEditFantasyTeamRequest.team_name)
}
inline void CMsgDOTAEditFantasyTeamRequest::set_team_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAEditFantasyTeamRequest.team_name)
}
inline ::std::string* CMsgDOTAEditFantasyTeamRequest::mutable_team_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAEditFantasyTeamRequest.team_name)
  return team_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAEditFantasyTeamRequest::release_team_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAEditFantasyTeamRequest.team_name)
  if (!has_team_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return team_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAEditFantasyTeamRequest::set_allocated_team_name(::std::string* team_name) {
  if (team_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  team_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAEditFantasyTeamRequest.team_name)
}

// optional uint64 team_logo = 4;
inline bool CMsgDOTAEditFantasyTeamRequest::has_team_logo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAEditFantasyTeamRequest::clear_team_logo() {
  team_logo_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 CMsgDOTAEditFantasyTeamRequest::team_logo() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAEditFantasyTeamRequest.team_logo)
  return team_logo_;
}
inline void CMsgDOTAEditFantasyTeamRequest::set_team_logo(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  team_logo_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAEditFantasyTeamRequest.team_logo)
}

// -------------------------------------------------------------------

// CMsgDOTAEditFantasyTeamResponse

// optional .proto.dota.CMsgDOTAEditFantasyTeamResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAEditFantasyTeamResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAEditFantasyTeamResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgDOTAEditFantasyTeamResponse_EResult CMsgDOTAEditFantasyTeamResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAEditFantasyTeamResponse.result)
  return static_cast< ::proto::dota::CMsgDOTAEditFantasyTeamResponse_EResult >(result_);
}
inline void CMsgDOTAEditFantasyTeamResponse::set_result(::proto::dota::CMsgDOTAEditFantasyTeamResponse_EResult value) {
  assert(::proto::dota::CMsgDOTAEditFantasyTeamResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAEditFantasyTeamResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID.fantasy_league_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID

// optional uint32 owner_account_id = 1;
inline bool CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID::has_owner_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID::clear_owner_account_id() {
  owner_account_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID::owner_account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID.owner_account_id)
  return owner_account_id_;
}
inline void CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID::set_owner_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  owner_account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID.owner_account_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamInfoResponse

// repeated .proto.dota.CMsgDOTAFantasyTeamInfo results = 1;
inline int CMsgDOTAFantasyTeamInfoResponse::results_size() const {
  return results_.size();
}
inline void CMsgDOTAFantasyTeamInfoResponse::clear_results() {
  results_.Clear();
}
inline ::proto::dota::CMsgDOTAFantasyTeamInfo* CMsgDOTAFantasyTeamInfoResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyTeamInfoResponse.results)
  return results_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyTeamInfo >*
CMsgDOTAFantasyTeamInfoResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAFantasyTeamInfoResponse.results)
  return &results_;
}
inline const ::proto::dota::CMsgDOTAFantasyTeamInfo& CMsgDOTAFantasyTeamInfoResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamInfoResponse.results)
  return results_.Get(index);
}
inline ::proto::dota::CMsgDOTAFantasyTeamInfo* CMsgDOTAFantasyTeamInfoResponse::add_results() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAFantasyTeamInfoResponse.results)
  return results_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyTeamInfo >&
CMsgDOTAFantasyTeamInfoResponse::results() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAFantasyTeamInfoResponse.results)
  return results_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamInfo

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyTeamInfo::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamInfo::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamInfo::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamInfo.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyTeamInfo::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamInfo.fantasy_league_id)
}

// optional uint32 owner_account_id = 2;
inline bool CMsgDOTAFantasyTeamInfo::has_owner_account_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyTeamInfo::clear_owner_account_id() {
  owner_account_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamInfo::owner_account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamInfo.owner_account_id)
  return owner_account_id_;
}
inline void CMsgDOTAFantasyTeamInfo::set_owner_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  owner_account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamInfo.owner_account_id)
}

// optional uint32 fantasy_team_index = 3;
inline bool CMsgDOTAFantasyTeamInfo::has_fantasy_team_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyTeamInfo::clear_fantasy_team_index() {
  fantasy_team_index_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamInfo::fantasy_team_index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamInfo.fantasy_team_index)
  return fantasy_team_index_;
}
inline void CMsgDOTAFantasyTeamInfo::set_fantasy_team_index(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  fantasy_team_index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamInfo.fantasy_team_index)
}

// optional string team_name = 4;
inline bool CMsgDOTAFantasyTeamInfo::has_team_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamInfo::clear_team_name() {
  team_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTAFantasyTeamInfo::team_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamInfo.team_name)
  return team_name_.GetNoArena();
}
inline void CMsgDOTAFantasyTeamInfo::set_team_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamInfo.team_name)
}
#if LANG_CXX11
inline void CMsgDOTAFantasyTeamInfo::set_team_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAFantasyTeamInfo.team_name)
}
#endif
inline void CMsgDOTAFantasyTeamInfo::set_team_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAFantasyTeamInfo.team_name)
}
inline void CMsgDOTAFantasyTeamInfo::set_team_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAFantasyTeamInfo.team_name)
}
inline ::std::string* CMsgDOTAFantasyTeamInfo::mutable_team_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyTeamInfo.team_name)
  return team_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAFantasyTeamInfo::release_team_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAFantasyTeamInfo.team_name)
  if (!has_team_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return team_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAFantasyTeamInfo::set_allocated_team_name(::std::string* team_name) {
  if (team_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  team_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAFantasyTeamInfo.team_name)
}

// optional uint64 team_logo = 5;
inline bool CMsgDOTAFantasyTeamInfo::has_team_logo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAFantasyTeamInfo::clear_team_logo() {
  team_logo_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyTeamInfo::team_logo() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamInfo.team_logo)
  return team_logo_;
}
inline void CMsgDOTAFantasyTeamInfo::set_team_logo(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  team_logo_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamInfo.team_logo)
}

// optional uint32 wins = 6;
inline bool CMsgDOTAFantasyTeamInfo::has_wins() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyTeamInfo::clear_wins() {
  wins_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamInfo::wins() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamInfo.wins)
  return wins_;
}
inline void CMsgDOTAFantasyTeamInfo::set_wins(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  wins_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamInfo.wins)
}

// optional uint32 losses = 7;
inline bool CMsgDOTAFantasyTeamInfo::has_losses() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTAFantasyTeamInfo::clear_losses() {
  losses_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamInfo::losses() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamInfo.losses)
  return losses_;
}
inline void CMsgDOTAFantasyTeamInfo::set_losses(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  losses_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamInfo.losses)
}

// repeated uint32 current_roster = 8;
inline int CMsgDOTAFantasyTeamInfo::current_roster_size() const {
  return current_roster_.size();
}
inline void CMsgDOTAFantasyTeamInfo::clear_current_roster() {
  current_roster_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamInfo::current_roster(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamInfo.current_roster)
  return current_roster_.Get(index);
}
inline void CMsgDOTAFantasyTeamInfo::set_current_roster(int index, ::google::protobuf::uint32 value) {
  current_roster_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamInfo.current_roster)
}
inline void CMsgDOTAFantasyTeamInfo::add_current_roster(::google::protobuf::uint32 value) {
  current_roster_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAFantasyTeamInfo.current_roster)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTAFantasyTeamInfo::current_roster() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAFantasyTeamInfo.current_roster)
  return current_roster_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTAFantasyTeamInfo::mutable_current_roster() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAFantasyTeamInfo.current_roster)
  return &current_roster_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamScoreRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyTeamScoreRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamScoreRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamScoreRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamScoreRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyTeamScoreRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamScoreRequest.fantasy_league_id)
}

// optional uint32 owner_account_id = 2;
inline bool CMsgDOTAFantasyTeamScoreRequest::has_owner_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamScoreRequest::clear_owner_account_id() {
  owner_account_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamScoreRequest::owner_account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamScoreRequest.owner_account_id)
  return owner_account_id_;
}
inline void CMsgDOTAFantasyTeamScoreRequest::set_owner_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  owner_account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamScoreRequest.owner_account_id)
}

// optional uint32 fantasy_team_index = 3;
inline bool CMsgDOTAFantasyTeamScoreRequest::has_fantasy_team_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyTeamScoreRequest::clear_fantasy_team_index() {
  fantasy_team_index_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamScoreRequest::fantasy_team_index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamScoreRequest.fantasy_team_index)
  return fantasy_team_index_;
}
inline void CMsgDOTAFantasyTeamScoreRequest::set_fantasy_team_index(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  fantasy_team_index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamScoreRequest.fantasy_team_index)
}

// optional uint64 filter_match_id = 4;
inline bool CMsgDOTAFantasyTeamScoreRequest::has_filter_match_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyTeamScoreRequest::clear_filter_match_id() {
  filter_match_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyTeamScoreRequest::filter_match_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamScoreRequest.filter_match_id)
  return filter_match_id_;
}
inline void CMsgDOTAFantasyTeamScoreRequest::set_filter_match_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  filter_match_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamScoreRequest.filter_match_id)
}

// optional uint32 filter_start_time = 5;
inline bool CMsgDOTAFantasyTeamScoreRequest::has_filter_start_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyTeamScoreRequest::clear_filter_start_time() {
  filter_start_time_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamScoreRequest::filter_start_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamScoreRequest.filter_start_time)
  return filter_start_time_;
}
inline void CMsgDOTAFantasyTeamScoreRequest::set_filter_start_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  filter_start_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamScoreRequest.filter_start_time)
}

// optional uint32 filter_end_time = 6;
inline bool CMsgDOTAFantasyTeamScoreRequest::has_filter_end_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAFantasyTeamScoreRequest::clear_filter_end_time() {
  filter_end_time_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamScoreRequest::filter_end_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamScoreRequest.filter_end_time)
  return filter_end_time_;
}
inline void CMsgDOTAFantasyTeamScoreRequest::set_filter_end_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  filter_end_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamScoreRequest.filter_end_time)
}

// optional bool include_bench = 7;
inline bool CMsgDOTAFantasyTeamScoreRequest::has_include_bench() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTAFantasyTeamScoreRequest::clear_include_bench() {
  include_bench_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool CMsgDOTAFantasyTeamScoreRequest::include_bench() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamScoreRequest.include_bench)
  return include_bench_;
}
inline void CMsgDOTAFantasyTeamScoreRequest::set_include_bench(bool value) {
  _has_bits_[0] |= 0x00000040u;
  include_bench_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamScoreRequest.include_bench)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore

// optional uint32 account_id = 1;
inline bool CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::clear_account_id() {
  account_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore.account_id)
  return account_id_;
}
inline void CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::set_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore.account_id)
}

// optional float score = 2;
inline bool CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::has_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::clear_score() {
  score_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::score() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore.score)
  return score_;
}
inline void CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::set_score(float value) {
  _has_bits_[0] |= 0x00000002u;
  score_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore.score)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamScoreResponse

// optional .proto.dota.CMsgDOTAFantasyTeamScoreResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyTeamScoreResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamScoreResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgDOTAFantasyTeamScoreResponse_EResult CMsgDOTAFantasyTeamScoreResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamScoreResponse.result)
  return static_cast< ::proto::dota::CMsgDOTAFantasyTeamScoreResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyTeamScoreResponse::set_result(::proto::dota::CMsgDOTAFantasyTeamScoreResponse_EResult value) {
  assert(::proto::dota::CMsgDOTAFantasyTeamScoreResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamScoreResponse.result)
}

// optional float fantasy_team_score = 2;
inline bool CMsgDOTAFantasyTeamScoreResponse::has_fantasy_team_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamScoreResponse::clear_fantasy_team_score() {
  fantasy_team_score_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float CMsgDOTAFantasyTeamScoreResponse::fantasy_team_score() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamScoreResponse.fantasy_team_score)
  return fantasy_team_score_;
}
inline void CMsgDOTAFantasyTeamScoreResponse::set_fantasy_team_score(float value) {
  _has_bits_[0] |= 0x00000002u;
  fantasy_team_score_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamScoreResponse.fantasy_team_score)
}

// repeated .proto.dota.CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore fantasy_player_score = 3;
inline int CMsgDOTAFantasyTeamScoreResponse::fantasy_player_score_size() const {
  return fantasy_player_score_.size();
}
inline void CMsgDOTAFantasyTeamScoreResponse::clear_fantasy_player_score() {
  fantasy_player_score_.Clear();
}
inline ::proto::dota::CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore* CMsgDOTAFantasyTeamScoreResponse::mutable_fantasy_player_score(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyTeamScoreResponse.fantasy_player_score)
  return fantasy_player_score_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore >*
CMsgDOTAFantasyTeamScoreResponse::mutable_fantasy_player_score() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAFantasyTeamScoreResponse.fantasy_player_score)
  return &fantasy_player_score_;
}
inline const ::proto::dota::CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore& CMsgDOTAFantasyTeamScoreResponse::fantasy_player_score(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamScoreResponse.fantasy_player_score)
  return fantasy_player_score_.Get(index);
}
inline ::proto::dota::CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore* CMsgDOTAFantasyTeamScoreResponse::add_fantasy_player_score() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAFantasyTeamScoreResponse.fantasy_player_score)
  return fantasy_player_score_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore >&
CMsgDOTAFantasyTeamScoreResponse::fantasy_player_score() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAFantasyTeamScoreResponse.fantasy_player_score)
  return fantasy_player_score_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamStandingsRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyTeamStandingsRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamStandingsRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamStandingsRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamStandingsRequest.fantasy_league_id)
}

// optional uint32 count = 2;
inline bool CMsgDOTAFantasyTeamStandingsRequest::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::clear_count() {
  count_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamStandingsRequest::count() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamStandingsRequest.count)
  return count_;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::set_count(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  count_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamStandingsRequest.count)
}

// optional uint32 filter_start_time = 3;
inline bool CMsgDOTAFantasyTeamStandingsRequest::has_filter_start_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::clear_filter_start_time() {
  filter_start_time_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamStandingsRequest::filter_start_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamStandingsRequest.filter_start_time)
  return filter_start_time_;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::set_filter_start_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  filter_start_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamStandingsRequest.filter_start_time)
}

// optional uint32 filter_end_time = 4;
inline bool CMsgDOTAFantasyTeamStandingsRequest::has_filter_end_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::clear_filter_end_time() {
  filter_end_time_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamStandingsRequest::filter_end_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamStandingsRequest.filter_end_time)
  return filter_end_time_;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::set_filter_end_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  filter_end_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamStandingsRequest.filter_end_time)
}

// optional uint64 filter_match_id = 5;
inline bool CMsgDOTAFantasyTeamStandingsRequest::has_filter_match_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::clear_filter_match_id() {
  filter_match_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyTeamStandingsRequest::filter_match_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamStandingsRequest.filter_match_id)
  return filter_match_id_;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::set_filter_match_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  filter_match_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamStandingsRequest.filter_match_id)
}

// optional bool filter_last_match = 6;
inline bool CMsgDOTAFantasyTeamStandingsRequest::has_filter_last_match() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::clear_filter_last_match() {
  filter_last_match_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool CMsgDOTAFantasyTeamStandingsRequest::filter_last_match() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamStandingsRequest.filter_last_match)
  return filter_last_match_;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::set_filter_last_match(bool value) {
  _has_bits_[0] |= 0x00000020u;
  filter_last_match_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamStandingsRequest.filter_last_match)
}

// optional bool filter_in_hall = 7;
inline bool CMsgDOTAFantasyTeamStandingsRequest::has_filter_in_hall() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::clear_filter_in_hall() {
  filter_in_hall_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool CMsgDOTAFantasyTeamStandingsRequest::filter_in_hall() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamStandingsRequest.filter_in_hall)
  return filter_in_hall_;
}
inline void CMsgDOTAFantasyTeamStandingsRequest::set_filter_in_hall(bool value) {
  _has_bits_[0] |= 0x00000040u;
  filter_in_hall_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamStandingsRequest.filter_in_hall)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_league_id)
}

// optional uint32 owner_account_id = 2;
inline bool CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::has_owner_account_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_owner_account_id() {
  owner_account_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::owner_account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.owner_account_id)
  return owner_account_id_;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_owner_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  owner_account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.owner_account_id)
}

// optional uint32 fantasy_team_index = 3;
inline bool CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::has_fantasy_team_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_fantasy_team_index() {
  fantasy_team_index_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::fantasy_team_index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_team_index)
  return fantasy_team_index_;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_fantasy_team_index(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  fantasy_team_index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_team_index)
}

// optional uint64 fantasy_team_logo = 4;
inline bool CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::has_fantasy_team_logo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_fantasy_team_logo() {
  fantasy_team_logo_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::fantasy_team_logo() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_team_logo)
  return fantasy_team_logo_;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_fantasy_team_logo(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  fantasy_team_logo_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_team_logo)
}

// optional string owner_name = 5;
inline bool CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::has_owner_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_owner_name() {
  owner_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::owner_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.owner_name)
  return owner_name_.GetNoArena();
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_owner_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  owner_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.owner_name)
}
#if LANG_CXX11
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_owner_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  owner_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.owner_name)
}
#endif
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_owner_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  owner_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.owner_name)
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_owner_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  owner_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.owner_name)
}
inline ::std::string* CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::mutable_owner_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.owner_name)
  return owner_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::release_owner_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.owner_name)
  if (!has_owner_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return owner_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_allocated_owner_name(::std::string* owner_name) {
  if (owner_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  owner_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.owner_name)
}

// optional string fantasy_team_name = 6;
inline bool CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::has_fantasy_team_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_fantasy_team_name() {
  fantasy_team_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::fantasy_team_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_team_name)
  return fantasy_team_name_.GetNoArena();
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_fantasy_team_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  fantasy_team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_team_name)
}
#if LANG_CXX11
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_fantasy_team_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  fantasy_team_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_team_name)
}
#endif
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_fantasy_team_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  fantasy_team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_team_name)
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_fantasy_team_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  fantasy_team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_team_name)
}
inline ::std::string* CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::mutable_fantasy_team_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_team_name)
  return fantasy_team_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::release_fantasy_team_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_team_name)
  if (!has_fantasy_team_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return fantasy_team_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_allocated_fantasy_team_name(::std::string* fantasy_team_name) {
  if (fantasy_team_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  fantasy_team_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fantasy_team_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.fantasy_team_name)
}

// optional float score = 7;
inline bool CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::has_score() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_score() {
  score_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::score() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.score)
  return score_;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_score(float value) {
  _has_bits_[0] |= 0x00000040u;
  score_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.score)
}

// optional float score_against = 8;
inline bool CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::has_score_against() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_score_against() {
  score_against_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::score_against() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.score_against)
  return score_against_;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_score_against(float value) {
  _has_bits_[0] |= 0x00000080u;
  score_against_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.score_against)
}

// optional uint32 wins = 9;
inline bool CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::has_wins() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_wins() {
  wins_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::wins() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.wins)
  return wins_;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_wins(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  wins_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.wins)
}

// optional uint32 losses = 10;
inline bool CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::has_losses() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_losses() {
  losses_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::losses() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.losses)
  return losses_;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_losses(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  losses_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.losses)
}

// optional int32 streak = 11;
inline bool CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::has_streak() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::clear_streak() {
  streak_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::google::protobuf::int32 CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::streak() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.streak)
  return streak_;
}
inline void CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::set_streak(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000400u;
  streak_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore.streak)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamStandingsResponse

// optional .proto.dota.CMsgDOTAFantasyTeamStandingsResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyTeamStandingsResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamStandingsResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgDOTAFantasyTeamStandingsResponse_EResult CMsgDOTAFantasyTeamStandingsResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.result)
  return static_cast< ::proto::dota::CMsgDOTAFantasyTeamStandingsResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyTeamStandingsResponse::set_result(::proto::dota::CMsgDOTAFantasyTeamStandingsResponse_EResult value) {
  assert(::proto::dota::CMsgDOTAFantasyTeamStandingsResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.result)
}

// repeated .proto.dota.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore team_scores = 3;
inline int CMsgDOTAFantasyTeamStandingsResponse::team_scores_size() const {
  return team_scores_.size();
}
inline void CMsgDOTAFantasyTeamStandingsResponse::clear_team_scores() {
  team_scores_.Clear();
}
inline ::proto::dota::CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore* CMsgDOTAFantasyTeamStandingsResponse::mutable_team_scores(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.team_scores)
  return team_scores_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore >*
CMsgDOTAFantasyTeamStandingsResponse::mutable_team_scores() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.team_scores)
  return &team_scores_;
}
inline const ::proto::dota::CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore& CMsgDOTAFantasyTeamStandingsResponse::team_scores(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.team_scores)
  return team_scores_.Get(index);
}
inline ::proto::dota::CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore* CMsgDOTAFantasyTeamStandingsResponse::add_team_scores() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.team_scores)
  return team_scores_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore >&
CMsgDOTAFantasyTeamStandingsResponse::team_scores() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAFantasyTeamStandingsResponse.team_scores)
  return team_scores_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerScoreRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyPlayerScoreRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreRequest.fantasy_league_id)
}

// optional uint32 player_account_id = 2;
inline bool CMsgDOTAFantasyPlayerScoreRequest::has_player_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::clear_player_account_id() {
  player_account_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreRequest::player_account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreRequest.player_account_id)
  return player_account_id_;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::set_player_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  player_account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreRequest.player_account_id)
}

// optional uint32 filter_start_time = 3;
inline bool CMsgDOTAFantasyPlayerScoreRequest::has_filter_start_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::clear_filter_start_time() {
  filter_start_time_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreRequest::filter_start_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreRequest.filter_start_time)
  return filter_start_time_;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::set_filter_start_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  filter_start_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreRequest.filter_start_time)
}

// optional uint32 filter_end_time = 4;
inline bool CMsgDOTAFantasyPlayerScoreRequest::has_filter_end_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::clear_filter_end_time() {
  filter_end_time_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreRequest::filter_end_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreRequest.filter_end_time)
  return filter_end_time_;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::set_filter_end_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  filter_end_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreRequest.filter_end_time)
}

// optional uint64 filter_match_id = 5;
inline bool CMsgDOTAFantasyPlayerScoreRequest::has_filter_match_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::clear_filter_match_id() {
  filter_match_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyPlayerScoreRequest::filter_match_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreRequest.filter_match_id)
  return filter_match_id_;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::set_filter_match_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  filter_match_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreRequest.filter_match_id)
}

// optional bool filter_last_match = 6;
inline bool CMsgDOTAFantasyPlayerScoreRequest::has_filter_last_match() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::clear_filter_last_match() {
  filter_last_match_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool CMsgDOTAFantasyPlayerScoreRequest::filter_last_match() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreRequest.filter_last_match)
  return filter_last_match_;
}
inline void CMsgDOTAFantasyPlayerScoreRequest::set_filter_last_match(bool value) {
  _has_bits_[0] |= 0x00000020u;
  filter_last_match_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreRequest.filter_last_match)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerScoreResponse

// optional .proto.dota.CMsgDOTAFantasyPlayerScoreResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyPlayerScoreResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::proto::dota::CMsgDOTAFantasyPlayerScoreResponse_EResult CMsgDOTAFantasyPlayerScoreResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreResponse.result)
  return static_cast< ::proto::dota::CMsgDOTAFantasyPlayerScoreResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyPlayerScoreResponse::set_result(::proto::dota::CMsgDOTAFantasyPlayerScoreResponse_EResult value) {
  assert(::proto::dota::CMsgDOTAFantasyPlayerScoreResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreResponse.result)
}

// optional uint32 fantasy_league_id = 2;
inline bool CMsgDOTAFantasyPlayerScoreResponse::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreResponse::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreResponse.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreResponse.fantasy_league_id)
}

// optional uint32 player_account_id = 3;
inline bool CMsgDOTAFantasyPlayerScoreResponse::has_player_account_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::clear_player_account_id() {
  player_account_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreResponse::player_account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreResponse.player_account_id)
  return player_account_id_;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::set_player_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  player_account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreResponse.player_account_id)
}

// optional string player_name = 4;
inline bool CMsgDOTAFantasyPlayerScoreResponse::has_player_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::clear_player_name() {
  player_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTAFantasyPlayerScoreResponse::player_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreResponse.player_name)
  return player_name_.GetNoArena();
}
inline void CMsgDOTAFantasyPlayerScoreResponse::set_player_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  player_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreResponse.player_name)
}
#if LANG_CXX11
inline void CMsgDOTAFantasyPlayerScoreResponse::set_player_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  player_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAFantasyPlayerScoreResponse.player_name)
}
#endif
inline void CMsgDOTAFantasyPlayerScoreResponse::set_player_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  player_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAFantasyPlayerScoreResponse.player_name)
}
inline void CMsgDOTAFantasyPlayerScoreResponse::set_player_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  player_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAFantasyPlayerScoreResponse.player_name)
}
inline ::std::string* CMsgDOTAFantasyPlayerScoreResponse::mutable_player_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyPlayerScoreResponse.player_name)
  return player_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAFantasyPlayerScoreResponse::release_player_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAFantasyPlayerScoreResponse.player_name)
  if (!has_player_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return player_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAFantasyPlayerScoreResponse::set_allocated_player_name(::std::string* player_name) {
  if (player_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  player_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), player_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAFantasyPlayerScoreResponse.player_name)
}

// optional float score = 5;
inline bool CMsgDOTAFantasyPlayerScoreResponse::has_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::clear_score() {
  score_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float CMsgDOTAFantasyPlayerScoreResponse::score() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreResponse.score)
  return score_;
}
inline void CMsgDOTAFantasyPlayerScoreResponse::set_score(float value) {
  _has_bits_[0] |= 0x00000010u;
  score_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreResponse.score)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerStandingsRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyPlayerStandingsRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerStandingsRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerStandingsRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerStandingsRequest.fantasy_league_id)
}

// optional uint32 count = 2;
inline bool CMsgDOTAFantasyPlayerStandingsRequest::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::clear_count() {
  count_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerStandingsRequest::count() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerStandingsRequest.count)
  return count_;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::set_count(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  count_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerStandingsRequest.count)
}

// optional uint32 role = 3;
inline bool CMsgDOTAFantasyPlayerStandingsRequest::has_role() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::clear_role() {
  role_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerStandingsRequest::role() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerStandingsRequest.role)
  return role_;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::set_role(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  role_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerStandingsRequest.role)
}

// optional uint32 filter_start_time = 4;
inline bool CMsgDOTAFantasyPlayerStandingsRequest::has_filter_start_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::clear_filter_start_time() {
  filter_start_time_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerStandingsRequest::filter_start_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerStandingsRequest.filter_start_time)
  return filter_start_time_;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::set_filter_start_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  filter_start_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerStandingsRequest.filter_start_time)
}

// optional uint32 filter_end_time = 5;
inline bool CMsgDOTAFantasyPlayerStandingsRequest::has_filter_end_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::clear_filter_end_time() {
  filter_end_time_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerStandingsRequest::filter_end_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerStandingsRequest.filter_end_time)
  return filter_end_time_;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::set_filter_end_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  filter_end_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerStandingsRequest.filter_end_time)
}

// optional uint64 filter_match_id = 6;
inline bool CMsgDOTAFantasyPlayerStandingsRequest::has_filter_match_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::clear_filter_match_id() {
  filter_match_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyPlayerStandingsRequest::filter_match_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerStandingsRequest.filter_match_id)
  return filter_match_id_;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::set_filter_match_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  filter_match_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerStandingsRequest.filter_match_id)
}

// optional bool filter_last_match = 7;
inline bool CMsgDOTAFantasyPlayerStandingsRequest::has_filter_last_match() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::clear_filter_last_match() {
  filter_last_match_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool CMsgDOTAFantasyPlayerStandingsRequest::filter_last_match() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerStandingsRequest.filter_last_match)
  return filter_last_match_;
}
inline void CMsgDOTAFantasyPlayerStandingsRequest::set_filter_last_match(bool value) {
  _has_bits_[0] |= 0x00000040u;
  filter_last_match_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerStandingsRequest.filter_last_match)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore

// optional uint32 player_account_id = 1;
inline bool CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::has_player_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::clear_player_account_id() {
  player_account_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::player_account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.player_account_id)
  return player_account_id_;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::set_player_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  player_account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.player_account_id)
}

// optional string player_name = 2;
inline bool CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::has_player_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::clear_player_name() {
  player_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::player_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.player_name)
  return player_name_.GetNoArena();
}
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::set_player_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  player_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.player_name)
}
#if LANG_CXX11
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::set_player_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  player_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.player_name)
}
#endif
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::set_player_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  player_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.player_name)
}
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::set_player_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  player_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.player_name)
}
inline ::std::string* CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::mutable_player_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.player_name)
  return player_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::release_player_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.player_name)
  if (!has_player_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return player_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::set_allocated_player_name(::std::string* player_name) {
  if (player_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  player_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), player_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.player_name)
}

// optional float score = 3;
inline bool CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::clear_score() {
  score_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::score() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.score)
  return score_;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::set_score(float value) {
  _has_bits_[0] |= 0x00000004u;
  score_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore.score)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerStandingsResponse

// optional .proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyPlayerStandingsResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgDOTAFantasyPlayerStandingsResponse_EResult CMsgDOTAFantasyPlayerStandingsResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.result)
  return static_cast< ::proto::dota::CMsgDOTAFantasyPlayerStandingsResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyPlayerStandingsResponse::set_result(::proto::dota::CMsgDOTAFantasyPlayerStandingsResponse_EResult value) {
  assert(::proto::dota::CMsgDOTAFantasyPlayerStandingsResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.result)
}

// optional uint32 fantasy_league_id = 2;
inline bool CMsgDOTAFantasyPlayerStandingsResponse::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerStandingsResponse::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.fantasy_league_id)
}

// optional uint32 role = 3;
inline bool CMsgDOTAFantasyPlayerStandingsResponse::has_role() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse::clear_role() {
  role_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerStandingsResponse::role() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.role)
  return role_;
}
inline void CMsgDOTAFantasyPlayerStandingsResponse::set_role(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  role_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.role)
}

// repeated .proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore player_scores = 4;
inline int CMsgDOTAFantasyPlayerStandingsResponse::player_scores_size() const {
  return player_scores_.size();
}
inline void CMsgDOTAFantasyPlayerStandingsResponse::clear_player_scores() {
  player_scores_.Clear();
}
inline ::proto::dota::CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore* CMsgDOTAFantasyPlayerStandingsResponse::mutable_player_scores(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.player_scores)
  return player_scores_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore >*
CMsgDOTAFantasyPlayerStandingsResponse::mutable_player_scores() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.player_scores)
  return &player_scores_;
}
inline const ::proto::dota::CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore& CMsgDOTAFantasyPlayerStandingsResponse::player_scores(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.player_scores)
  return player_scores_.Get(index);
}
inline ::proto::dota::CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore* CMsgDOTAFantasyPlayerStandingsResponse::add_player_scores() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.player_scores)
  return player_scores_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore >&
CMsgDOTAFantasyPlayerStandingsResponse::player_scores() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAFantasyPlayerStandingsResponse.player_scores)
  return player_scores_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueCreateRequest

// optional uint32 season_id = 1;
inline bool CMsgDOTAFantasyLeagueCreateRequest::has_season_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::clear_season_id() {
  season_id_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueCreateRequest::season_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.season_id)
  return season_id_;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_season_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  season_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.season_id)
}

// optional string fantasy_league_name = 2;
inline bool CMsgDOTAFantasyLeagueCreateRequest::has_fantasy_league_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::clear_fantasy_league_name() {
  fantasy_league_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTAFantasyLeagueCreateRequest::fantasy_league_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.fantasy_league_name)
  return fantasy_league_name_.GetNoArena();
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_fantasy_league_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.fantasy_league_name)
}
#if LANG_CXX11
inline void CMsgDOTAFantasyLeagueCreateRequest::set_fantasy_league_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.fantasy_league_name)
}
#endif
inline void CMsgDOTAFantasyLeagueCreateRequest::set_fantasy_league_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.fantasy_league_name)
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_fantasy_league_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.fantasy_league_name)
}
inline ::std::string* CMsgDOTAFantasyLeagueCreateRequest::mutable_fantasy_league_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.fantasy_league_name)
  return fantasy_league_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAFantasyLeagueCreateRequest::release_fantasy_league_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.fantasy_league_name)
  if (!has_fantasy_league_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return fantasy_league_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_allocated_fantasy_league_name(::std::string* fantasy_league_name) {
  if (fantasy_league_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  fantasy_league_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fantasy_league_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.fantasy_league_name)
}

// optional string password = 3;
inline bool CMsgDOTAFantasyLeagueCreateRequest::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgDOTAFantasyLeagueCreateRequest::password() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.password)
  return password_.GetNoArena();
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_password(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.password)
}
#if LANG_CXX11
inline void CMsgDOTAFantasyLeagueCreateRequest::set_password(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.password)
}
#endif
inline void CMsgDOTAFantasyLeagueCreateRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.password)
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_password(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.password)
}
inline ::std::string* CMsgDOTAFantasyLeagueCreateRequest::mutable_password() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAFantasyLeagueCreateRequest::release_password() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.password)
  if (!has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return password_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_allocated_password(::std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.password)
}

// optional string team_name = 4;
inline bool CMsgDOTAFantasyLeagueCreateRequest::has_team_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::clear_team_name() {
  team_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& CMsgDOTAFantasyLeagueCreateRequest::team_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.team_name)
  return team_name_.GetNoArena();
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_team_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.team_name)
}
#if LANG_CXX11
inline void CMsgDOTAFantasyLeagueCreateRequest::set_team_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  team_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.team_name)
}
#endif
inline void CMsgDOTAFantasyLeagueCreateRequest::set_team_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.team_name)
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_team_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.team_name)
}
inline ::std::string* CMsgDOTAFantasyLeagueCreateRequest::mutable_team_name() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.team_name)
  return team_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAFantasyLeagueCreateRequest::release_team_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.team_name)
  if (!has_team_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return team_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_allocated_team_name(::std::string* team_name) {
  if (team_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  team_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.team_name)
}

// optional uint64 logo = 5;
inline bool CMsgDOTAFantasyLeagueCreateRequest::has_logo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::clear_logo() {
  logo_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyLeagueCreateRequest::logo() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.logo)
  return logo_;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_logo(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  logo_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.logo)
}

// optional uint64 ticket_item_id = 6;
inline bool CMsgDOTAFantasyLeagueCreateRequest::has_ticket_item_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::clear_ticket_item_id() {
  ticket_item_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyLeagueCreateRequest::ticket_item_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.ticket_item_id)
  return ticket_item_id_;
}
inline void CMsgDOTAFantasyLeagueCreateRequest::set_ticket_item_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  ticket_item_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueCreateRequest.ticket_item_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueCreateResponse

// optional .proto.dota.CMsgDOTAFantasyLeagueCreateResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyLeagueCreateResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueCreateResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgDOTAFantasyLeagueCreateResponse_EResult CMsgDOTAFantasyLeagueCreateResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueCreateResponse.result)
  return static_cast< ::proto::dota::CMsgDOTAFantasyLeagueCreateResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyLeagueCreateResponse::set_result(::proto::dota::CMsgDOTAFantasyLeagueCreateResponse_EResult value) {
  assert(::proto::dota::CMsgDOTAFantasyLeagueCreateResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueCreateResponse.result)
}

// optional uint32 fantasy_league_id = 2;
inline bool CMsgDOTAFantasyLeagueCreateResponse::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueCreateResponse::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueCreateResponse::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueCreateResponse.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyLeagueCreateResponse::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueCreateResponse.fantasy_league_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamCreateRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyTeamCreateRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyTeamCreateRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamCreateRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamCreateRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamCreateRequest.fantasy_league_id)
}

// optional string password = 2;
inline bool CMsgDOTAFantasyTeamCreateRequest::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamCreateRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTAFantasyTeamCreateRequest::password() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamCreateRequest.password)
  return password_.GetNoArena();
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_password(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamCreateRequest.password)
}
#if LANG_CXX11
inline void CMsgDOTAFantasyTeamCreateRequest::set_password(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAFantasyTeamCreateRequest.password)
}
#endif
inline void CMsgDOTAFantasyTeamCreateRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAFantasyTeamCreateRequest.password)
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_password(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAFantasyTeamCreateRequest.password)
}
inline ::std::string* CMsgDOTAFantasyTeamCreateRequest::mutable_password() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyTeamCreateRequest.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAFantasyTeamCreateRequest::release_password() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAFantasyTeamCreateRequest.password)
  if (!has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return password_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_allocated_password(::std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAFantasyTeamCreateRequest.password)
}

// optional string team_name = 3;
inline bool CMsgDOTAFantasyTeamCreateRequest::has_team_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamCreateRequest::clear_team_name() {
  team_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CMsgDOTAFantasyTeamCreateRequest::team_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamCreateRequest.team_name)
  return team_name_.GetNoArena();
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_team_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamCreateRequest.team_name)
}
#if LANG_CXX11
inline void CMsgDOTAFantasyTeamCreateRequest::set_team_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  team_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAFantasyTeamCreateRequest.team_name)
}
#endif
inline void CMsgDOTAFantasyTeamCreateRequest::set_team_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAFantasyTeamCreateRequest.team_name)
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_team_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAFantasyTeamCreateRequest.team_name)
}
inline ::std::string* CMsgDOTAFantasyTeamCreateRequest::mutable_team_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyTeamCreateRequest.team_name)
  return team_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAFantasyTeamCreateRequest::release_team_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAFantasyTeamCreateRequest.team_name)
  if (!has_team_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return team_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_allocated_team_name(::std::string* team_name) {
  if (team_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  team_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAFantasyTeamCreateRequest.team_name)
}

// optional uint64 logo = 4;
inline bool CMsgDOTAFantasyTeamCreateRequest::has_logo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyTeamCreateRequest::clear_logo() {
  logo_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyTeamCreateRequest::logo() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamCreateRequest.logo)
  return logo_;
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_logo(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  logo_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamCreateRequest.logo)
}

// optional uint64 ticket_item_id = 5;
inline bool CMsgDOTAFantasyTeamCreateRequest::has_ticket_item_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyTeamCreateRequest::clear_ticket_item_id() {
  ticket_item_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyTeamCreateRequest::ticket_item_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamCreateRequest.ticket_item_id)
  return ticket_item_id_;
}
inline void CMsgDOTAFantasyTeamCreateRequest::set_ticket_item_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  ticket_item_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamCreateRequest.ticket_item_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamCreateResponse

// optional .proto.dota.CMsgDOTAFantasyTeamCreateResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyTeamCreateResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamCreateResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgDOTAFantasyTeamCreateResponse_EResult CMsgDOTAFantasyTeamCreateResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamCreateResponse.result)
  return static_cast< ::proto::dota::CMsgDOTAFantasyTeamCreateResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyTeamCreateResponse::set_result(::proto::dota::CMsgDOTAFantasyTeamCreateResponse_EResult value) {
  assert(::proto::dota::CMsgDOTAFantasyTeamCreateResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamCreateResponse.result)
}

// optional uint32 fantasy_team_index = 2;
inline bool CMsgDOTAFantasyTeamCreateResponse::has_fantasy_team_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamCreateResponse::clear_fantasy_team_index() {
  fantasy_team_index_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamCreateResponse::fantasy_team_index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamCreateResponse.fantasy_team_index)
  return fantasy_team_index_;
}
inline void CMsgDOTAFantasyTeamCreateResponse::set_fantasy_team_index(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  fantasy_team_index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamCreateResponse.fantasy_team_index)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange

// optional uint32 account_id = 1;
inline bool CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::clear_account_id() {
  account_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange.account_id)
  return account_id_;
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::set_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange.account_id)
}

// optional bool invited = 2;
inline bool CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::has_invited() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::clear_invited() {
  invited_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::invited() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange.invited)
  return invited_;
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::set_invited(bool value) {
  _has_bits_[0] |= 0x00000002u;
  invited_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange.invited)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueEditInvitesRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyLeagueEditInvitesRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueEditInvitesRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest.fantasy_league_id)
}

// optional string password = 2;
inline bool CMsgDOTAFantasyLeagueEditInvitesRequest::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTAFantasyLeagueEditInvitesRequest::password() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest.password)
  return password_.GetNoArena();
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest::set_password(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest.password)
}
#if LANG_CXX11
inline void CMsgDOTAFantasyLeagueEditInvitesRequest::set_password(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest.password)
}
#endif
inline void CMsgDOTAFantasyLeagueEditInvitesRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest.password)
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest::set_password(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest.password)
}
inline ::std::string* CMsgDOTAFantasyLeagueEditInvitesRequest::mutable_password() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAFantasyLeagueEditInvitesRequest::release_password() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest.password)
  if (!has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return password_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest::set_allocated_password(::std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest.password)
}

// repeated .proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange invite_change = 3;
inline int CMsgDOTAFantasyLeagueEditInvitesRequest::invite_change_size() const {
  return invite_change_.size();
}
inline void CMsgDOTAFantasyLeagueEditInvitesRequest::clear_invite_change() {
  invite_change_.Clear();
}
inline ::proto::dota::CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange* CMsgDOTAFantasyLeagueEditInvitesRequest::mutable_invite_change(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest.invite_change)
  return invite_change_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange >*
CMsgDOTAFantasyLeagueEditInvitesRequest::mutable_invite_change() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest.invite_change)
  return &invite_change_;
}
inline const ::proto::dota::CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange& CMsgDOTAFantasyLeagueEditInvitesRequest::invite_change(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest.invite_change)
  return invite_change_.Get(index);
}
inline ::proto::dota::CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange* CMsgDOTAFantasyLeagueEditInvitesRequest::add_invite_change() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest.invite_change)
  return invite_change_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange >&
CMsgDOTAFantasyLeagueEditInvitesRequest::invite_change() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAFantasyLeagueEditInvitesRequest.invite_change)
  return invite_change_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueEditInvitesResponse

// optional .proto.dota.CMsgDOTAFantasyLeagueEditInvitesResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyLeagueEditInvitesResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueEditInvitesResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgDOTAFantasyLeagueEditInvitesResponse_EResult CMsgDOTAFantasyLeagueEditInvitesResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueEditInvitesResponse.result)
  return static_cast< ::proto::dota::CMsgDOTAFantasyLeagueEditInvitesResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyLeagueEditInvitesResponse::set_result(::proto::dota::CMsgDOTAFantasyLeagueEditInvitesResponse_EResult value) {
  assert(::proto::dota::CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueEditInvitesResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueDraftStatusRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyLeagueDraftStatusRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueDraftStatusRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueDraftStatusRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueDraftStatusRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyLeagueDraftStatusRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueDraftStatusRequest.fantasy_league_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueDraftStatus

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyLeagueDraftStatus::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueDraftStatus::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueDraftStatus.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueDraftStatus.fantasy_league_id)
}

// repeated uint32 draft_order = 2;
inline int CMsgDOTAFantasyLeagueDraftStatus::draft_order_size() const {
  return draft_order_.size();
}
inline void CMsgDOTAFantasyLeagueDraftStatus::clear_draft_order() {
  draft_order_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueDraftStatus::draft_order(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueDraftStatus.draft_order)
  return draft_order_.Get(index);
}
inline void CMsgDOTAFantasyLeagueDraftStatus::set_draft_order(int index, ::google::protobuf::uint32 value) {
  draft_order_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueDraftStatus.draft_order)
}
inline void CMsgDOTAFantasyLeagueDraftStatus::add_draft_order(::google::protobuf::uint32 value) {
  draft_order_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAFantasyLeagueDraftStatus.draft_order)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTAFantasyLeagueDraftStatus::draft_order() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAFantasyLeagueDraftStatus.draft_order)
  return draft_order_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTAFantasyLeagueDraftStatus::mutable_draft_order() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAFantasyLeagueDraftStatus.draft_order)
  return &draft_order_;
}

// optional uint32 current_pick = 3;
inline bool CMsgDOTAFantasyLeagueDraftStatus::has_current_pick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::clear_current_pick() {
  current_pick_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueDraftStatus::current_pick() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueDraftStatus.current_pick)
  return current_pick_;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::set_current_pick(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  current_pick_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueDraftStatus.current_pick)
}

// optional uint32 time_remaining = 4;
inline bool CMsgDOTAFantasyLeagueDraftStatus::has_time_remaining() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::clear_time_remaining() {
  time_remaining_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueDraftStatus::time_remaining() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueDraftStatus.time_remaining)
  return time_remaining_;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::set_time_remaining(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  time_remaining_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueDraftStatus.time_remaining)
}

// optional bool pending_resume = 5;
inline bool CMsgDOTAFantasyLeagueDraftStatus::has_pending_resume() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::clear_pending_resume() {
  pending_resume_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool CMsgDOTAFantasyLeagueDraftStatus::pending_resume() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueDraftStatus.pending_resume)
  return pending_resume_;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::set_pending_resume(bool value) {
  _has_bits_[0] |= 0x00000008u;
  pending_resume_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueDraftStatus.pending_resume)
}

// optional bool completed = 6;
inline bool CMsgDOTAFantasyLeagueDraftStatus::has_completed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::clear_completed() {
  completed_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool CMsgDOTAFantasyLeagueDraftStatus::completed() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueDraftStatus.completed)
  return completed_;
}
inline void CMsgDOTAFantasyLeagueDraftStatus::set_completed(bool value) {
  _has_bits_[0] |= 0x00000010u;
  completed_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueDraftStatus.completed)
}

// repeated uint32 available_players = 7;
inline int CMsgDOTAFantasyLeagueDraftStatus::available_players_size() const {
  return available_players_.size();
}
inline void CMsgDOTAFantasyLeagueDraftStatus::clear_available_players() {
  available_players_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueDraftStatus::available_players(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueDraftStatus.available_players)
  return available_players_.Get(index);
}
inline void CMsgDOTAFantasyLeagueDraftStatus::set_available_players(int index, ::google::protobuf::uint32 value) {
  available_players_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueDraftStatus.available_players)
}
inline void CMsgDOTAFantasyLeagueDraftStatus::add_available_players(::google::protobuf::uint32 value) {
  available_players_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAFantasyLeagueDraftStatus.available_players)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTAFantasyLeagueDraftStatus::available_players() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAFantasyLeagueDraftStatus.available_players)
  return available_players_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTAFantasyLeagueDraftStatus::mutable_available_players() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAFantasyLeagueDraftStatus.available_players)
  return &available_players_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueDraftPlayerRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyLeagueDraftPlayerRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueDraftPlayerRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueDraftPlayerRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueDraftPlayerRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyLeagueDraftPlayerRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueDraftPlayerRequest.fantasy_league_id)
}

// optional uint32 team_index = 2;
inline bool CMsgDOTAFantasyLeagueDraftPlayerRequest::has_team_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeagueDraftPlayerRequest::clear_team_index() {
  team_index_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueDraftPlayerRequest::team_index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueDraftPlayerRequest.team_index)
  return team_index_;
}
inline void CMsgDOTAFantasyLeagueDraftPlayerRequest::set_team_index(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  team_index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueDraftPlayerRequest.team_index)
}

// optional uint32 player_account_id = 3;
inline bool CMsgDOTAFantasyLeagueDraftPlayerRequest::has_player_account_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyLeagueDraftPlayerRequest::clear_player_account_id() {
  player_account_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeagueDraftPlayerRequest::player_account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueDraftPlayerRequest.player_account_id)
  return player_account_id_;
}
inline void CMsgDOTAFantasyLeagueDraftPlayerRequest::set_player_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  player_account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueDraftPlayerRequest.player_account_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeagueDraftPlayerResponse

// optional .proto.dota.CMsgDOTAFantasyLeagueDraftPlayerResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyLeagueDraftPlayerResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeagueDraftPlayerResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult CMsgDOTAFantasyLeagueDraftPlayerResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeagueDraftPlayerResponse.result)
  return static_cast< ::proto::dota::CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyLeagueDraftPlayerResponse::set_result(::proto::dota::CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult value) {
  assert(::proto::dota::CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeagueDraftPlayerResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamRosterSwapRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyTeamRosterSwapRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterSwapRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamRosterSwapRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamRosterSwapRequest.fantasy_league_id)
}

// optional uint32 team_index = 2;
inline bool CMsgDOTAFantasyTeamRosterSwapRequest::has_team_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::clear_team_index() {
  team_index_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterSwapRequest::team_index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamRosterSwapRequest.team_index)
  return team_index_;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::set_team_index(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  team_index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamRosterSwapRequest.team_index)
}

// optional uint32 timestamp = 3;
inline bool CMsgDOTAFantasyTeamRosterSwapRequest::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::clear_timestamp() {
  timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterSwapRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamRosterSwapRequest.timestamp)
  return timestamp_;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::set_timestamp(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamRosterSwapRequest.timestamp)
}

// optional uint32 slot_1 = 4;
inline bool CMsgDOTAFantasyTeamRosterSwapRequest::has_slot_1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::clear_slot_1() {
  slot_1_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterSwapRequest::slot_1() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamRosterSwapRequest.slot_1)
  return slot_1_;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::set_slot_1(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  slot_1_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamRosterSwapRequest.slot_1)
}

// optional uint32 slot_2 = 5;
inline bool CMsgDOTAFantasyTeamRosterSwapRequest::has_slot_2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::clear_slot_2() {
  slot_2_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterSwapRequest::slot_2() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamRosterSwapRequest.slot_2)
  return slot_2_;
}
inline void CMsgDOTAFantasyTeamRosterSwapRequest::set_slot_2(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  slot_2_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamRosterSwapRequest.slot_2)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamRosterSwapResponse

// optional .proto.dota.CMsgDOTAFantasyTeamRosterSwapResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyTeamRosterSwapResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterSwapResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgDOTAFantasyTeamRosterSwapResponse_EResult CMsgDOTAFantasyTeamRosterSwapResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamRosterSwapResponse.result)
  return static_cast< ::proto::dota::CMsgDOTAFantasyTeamRosterSwapResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyTeamRosterSwapResponse::set_result(::proto::dota::CMsgDOTAFantasyTeamRosterSwapResponse_EResult value) {
  assert(::proto::dota::CMsgDOTAFantasyTeamRosterSwapResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamRosterSwapResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamRosterAddDropRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyTeamRosterAddDropRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterAddDropRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterAddDropRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamRosterAddDropRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyTeamRosterAddDropRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamRosterAddDropRequest.fantasy_league_id)
}

// optional uint32 team_index = 2;
inline bool CMsgDOTAFantasyTeamRosterAddDropRequest::has_team_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterAddDropRequest::clear_team_index() {
  team_index_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterAddDropRequest::team_index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamRosterAddDropRequest.team_index)
  return team_index_;
}
inline void CMsgDOTAFantasyTeamRosterAddDropRequest::set_team_index(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  team_index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamRosterAddDropRequest.team_index)
}

// optional uint32 add_account_id = 5;
inline bool CMsgDOTAFantasyTeamRosterAddDropRequest::has_add_account_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterAddDropRequest::clear_add_account_id() {
  add_account_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterAddDropRequest::add_account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamRosterAddDropRequest.add_account_id)
  return add_account_id_;
}
inline void CMsgDOTAFantasyTeamRosterAddDropRequest::set_add_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  add_account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamRosterAddDropRequest.add_account_id)
}

// optional uint32 drop_account_id = 6;
inline bool CMsgDOTAFantasyTeamRosterAddDropRequest::has_drop_account_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterAddDropRequest::clear_drop_account_id() {
  drop_account_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterAddDropRequest::drop_account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamRosterAddDropRequest.drop_account_id)
  return drop_account_id_;
}
inline void CMsgDOTAFantasyTeamRosterAddDropRequest::set_drop_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  drop_account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamRosterAddDropRequest.drop_account_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamRosterAddDropResponse

// optional .proto.dota.CMsgDOTAFantasyTeamRosterAddDropResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyTeamRosterAddDropResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterAddDropResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgDOTAFantasyTeamRosterAddDropResponse_EResult CMsgDOTAFantasyTeamRosterAddDropResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamRosterAddDropResponse.result)
  return static_cast< ::proto::dota::CMsgDOTAFantasyTeamRosterAddDropResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyTeamRosterAddDropResponse::set_result(::proto::dota::CMsgDOTAFantasyTeamRosterAddDropResponse_EResult value) {
  assert(::proto::dota::CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamRosterAddDropResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamTradesRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyTeamTradesRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamTradesRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamTradesRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamTradesRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyTeamTradesRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamTradesRequest.fantasy_league_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamTradesResponse_Trade

// optional uint32 timestamp = 1;
inline bool CMsgDOTAFantasyTeamTradesResponse_Trade::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::clear_timestamp() {
  timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamTradesResponse_Trade::timestamp() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamTradesResponse.Trade.timestamp)
  return timestamp_;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::set_timestamp(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamTradesResponse.Trade.timestamp)
}

// optional uint32 owner_account_id_1 = 2;
inline bool CMsgDOTAFantasyTeamTradesResponse_Trade::has_owner_account_id_1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::clear_owner_account_id_1() {
  owner_account_id_1_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamTradesResponse_Trade::owner_account_id_1() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamTradesResponse.Trade.owner_account_id_1)
  return owner_account_id_1_;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::set_owner_account_id_1(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  owner_account_id_1_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamTradesResponse.Trade.owner_account_id_1)
}

// optional uint32 owner_account_id_2 = 3;
inline bool CMsgDOTAFantasyTeamTradesResponse_Trade::has_owner_account_id_2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::clear_owner_account_id_2() {
  owner_account_id_2_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamTradesResponse_Trade::owner_account_id_2() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamTradesResponse.Trade.owner_account_id_2)
  return owner_account_id_2_;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::set_owner_account_id_2(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  owner_account_id_2_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamTradesResponse.Trade.owner_account_id_2)
}

// optional uint32 player_account_id_1 = 4;
inline bool CMsgDOTAFantasyTeamTradesResponse_Trade::has_player_account_id_1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::clear_player_account_id_1() {
  player_account_id_1_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamTradesResponse_Trade::player_account_id_1() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamTradesResponse.Trade.player_account_id_1)
  return player_account_id_1_;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::set_player_account_id_1(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  player_account_id_1_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamTradesResponse.Trade.player_account_id_1)
}

// optional uint32 player_account_id_2 = 5;
inline bool CMsgDOTAFantasyTeamTradesResponse_Trade::has_player_account_id_2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::clear_player_account_id_2() {
  player_account_id_2_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamTradesResponse_Trade::player_account_id_2() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamTradesResponse.Trade.player_account_id_2)
  return player_account_id_2_;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::set_player_account_id_2(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  player_account_id_2_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamTradesResponse.Trade.player_account_id_2)
}

// optional uint32 status = 6;
inline bool CMsgDOTAFantasyTeamTradesResponse_Trade::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::clear_status() {
  status_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamTradesResponse_Trade::status() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamTradesResponse.Trade.status)
  return status_;
}
inline void CMsgDOTAFantasyTeamTradesResponse_Trade::set_status(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  status_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamTradesResponse.Trade.status)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamTradesResponse

// optional .proto.dota.CMsgDOTAFantasyTeamTradesResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyTeamTradesResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamTradesResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgDOTAFantasyTeamTradesResponse_EResult CMsgDOTAFantasyTeamTradesResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamTradesResponse.result)
  return static_cast< ::proto::dota::CMsgDOTAFantasyTeamTradesResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyTeamTradesResponse::set_result(::proto::dota::CMsgDOTAFantasyTeamTradesResponse_EResult value) {
  assert(::proto::dota::CMsgDOTAFantasyTeamTradesResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamTradesResponse.result)
}

// repeated .proto.dota.CMsgDOTAFantasyTeamTradesResponse.Trade trades = 2;
inline int CMsgDOTAFantasyTeamTradesResponse::trades_size() const {
  return trades_.size();
}
inline void CMsgDOTAFantasyTeamTradesResponse::clear_trades() {
  trades_.Clear();
}
inline ::proto::dota::CMsgDOTAFantasyTeamTradesResponse_Trade* CMsgDOTAFantasyTeamTradesResponse::mutable_trades(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyTeamTradesResponse.trades)
  return trades_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyTeamTradesResponse_Trade >*
CMsgDOTAFantasyTeamTradesResponse::mutable_trades() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAFantasyTeamTradesResponse.trades)
  return &trades_;
}
inline const ::proto::dota::CMsgDOTAFantasyTeamTradesResponse_Trade& CMsgDOTAFantasyTeamTradesResponse::trades(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamTradesResponse.trades)
  return trades_.Get(index);
}
inline ::proto::dota::CMsgDOTAFantasyTeamTradesResponse_Trade* CMsgDOTAFantasyTeamTradesResponse::add_trades() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAFantasyTeamTradesResponse.trades)
  return trades_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyTeamTradesResponse_Trade >&
CMsgDOTAFantasyTeamTradesResponse::trades() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAFantasyTeamTradesResponse.trades)
  return trades_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamTradeCancelRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyTeamTradeCancelRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamTradeCancelRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamTradeCancelRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamTradeCancelRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyTeamTradeCancelRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamTradeCancelRequest.fantasy_league_id)
}

// optional uint32 team_index_1 = 3;
inline bool CMsgDOTAFantasyTeamTradeCancelRequest::has_team_index_1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamTradeCancelRequest::clear_team_index_1() {
  team_index_1_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamTradeCancelRequest::team_index_1() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamTradeCancelRequest.team_index_1)
  return team_index_1_;
}
inline void CMsgDOTAFantasyTeamTradeCancelRequest::set_team_index_1(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  team_index_1_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamTradeCancelRequest.team_index_1)
}

// optional uint32 owner_account_id_2 = 4;
inline bool CMsgDOTAFantasyTeamTradeCancelRequest::has_owner_account_id_2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyTeamTradeCancelRequest::clear_owner_account_id_2() {
  owner_account_id_2_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamTradeCancelRequest::owner_account_id_2() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamTradeCancelRequest.owner_account_id_2)
  return owner_account_id_2_;
}
inline void CMsgDOTAFantasyTeamTradeCancelRequest::set_owner_account_id_2(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  owner_account_id_2_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamTradeCancelRequest.owner_account_id_2)
}

// optional uint32 team_index_2 = 5;
inline bool CMsgDOTAFantasyTeamTradeCancelRequest::has_team_index_2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyTeamTradeCancelRequest::clear_team_index_2() {
  team_index_2_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamTradeCancelRequest::team_index_2() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamTradeCancelRequest.team_index_2)
  return team_index_2_;
}
inline void CMsgDOTAFantasyTeamTradeCancelRequest::set_team_index_2(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  team_index_2_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamTradeCancelRequest.team_index_2)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamTradeCancelResponse

// optional .proto.dota.CMsgDOTAFantasyTeamTradeCancelResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyTeamTradeCancelResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamTradeCancelResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgDOTAFantasyTeamTradeCancelResponse_EResult CMsgDOTAFantasyTeamTradeCancelResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamTradeCancelResponse.result)
  return static_cast< ::proto::dota::CMsgDOTAFantasyTeamTradeCancelResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyTeamTradeCancelResponse::set_result(::proto::dota::CMsgDOTAFantasyTeamTradeCancelResponse_EResult value) {
  assert(::proto::dota::CMsgDOTAFantasyTeamTradeCancelResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamTradeCancelResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamRosterRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyTeamRosterRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamRosterRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyTeamRosterRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamRosterRequest.fantasy_league_id)
}

// optional uint32 team_index = 2;
inline bool CMsgDOTAFantasyTeamRosterRequest::has_team_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterRequest::clear_team_index() {
  team_index_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterRequest::team_index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamRosterRequest.team_index)
  return team_index_;
}
inline void CMsgDOTAFantasyTeamRosterRequest::set_team_index(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  team_index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamRosterRequest.team_index)
}

// optional uint32 owner_account_id = 3;
inline bool CMsgDOTAFantasyTeamRosterRequest::has_owner_account_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterRequest::clear_owner_account_id() {
  owner_account_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterRequest::owner_account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamRosterRequest.owner_account_id)
  return owner_account_id_;
}
inline void CMsgDOTAFantasyTeamRosterRequest::set_owner_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  owner_account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamRosterRequest.owner_account_id)
}

// optional uint32 timestamp = 4;
inline bool CMsgDOTAFantasyTeamRosterRequest::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterRequest::clear_timestamp() {
  timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamRosterRequest.timestamp)
  return timestamp_;
}
inline void CMsgDOTAFantasyTeamRosterRequest::set_timestamp(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamRosterRequest.timestamp)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyTeamRosterResponse

// optional .proto.dota.CMsgDOTAFantasyTeamRosterResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyTeamRosterResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyTeamRosterResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgDOTAFantasyTeamRosterResponse_EResult CMsgDOTAFantasyTeamRosterResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamRosterResponse.result)
  return static_cast< ::proto::dota::CMsgDOTAFantasyTeamRosterResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyTeamRosterResponse::set_result(::proto::dota::CMsgDOTAFantasyTeamRosterResponse_EResult value) {
  assert(::proto::dota::CMsgDOTAFantasyTeamRosterResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamRosterResponse.result)
}

// repeated uint32 player_account_ids = 2;
inline int CMsgDOTAFantasyTeamRosterResponse::player_account_ids_size() const {
  return player_account_ids_.size();
}
inline void CMsgDOTAFantasyTeamRosterResponse::clear_player_account_ids() {
  player_account_ids_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyTeamRosterResponse::player_account_ids(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamRosterResponse.player_account_ids)
  return player_account_ids_.Get(index);
}
inline void CMsgDOTAFantasyTeamRosterResponse::set_player_account_ids(int index, ::google::protobuf::uint32 value) {
  player_account_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamRosterResponse.player_account_ids)
}
inline void CMsgDOTAFantasyTeamRosterResponse::add_player_account_ids(::google::protobuf::uint32 value) {
  player_account_ids_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAFantasyTeamRosterResponse.player_account_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTAFantasyTeamRosterResponse::player_account_ids() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAFantasyTeamRosterResponse.player_account_ids)
  return player_account_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTAFantasyTeamRosterResponse::mutable_player_account_ids() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAFantasyTeamRosterResponse.player_account_ids)
  return &player_account_ids_;
}

// repeated bool player_locked = 3;
inline int CMsgDOTAFantasyTeamRosterResponse::player_locked_size() const {
  return player_locked_.size();
}
inline void CMsgDOTAFantasyTeamRosterResponse::clear_player_locked() {
  player_locked_.Clear();
}
inline bool CMsgDOTAFantasyTeamRosterResponse::player_locked(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyTeamRosterResponse.player_locked)
  return player_locked_.Get(index);
}
inline void CMsgDOTAFantasyTeamRosterResponse::set_player_locked(int index, bool value) {
  player_locked_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyTeamRosterResponse.player_locked)
}
inline void CMsgDOTAFantasyTeamRosterResponse::add_player_locked(bool value) {
  player_locked_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAFantasyTeamRosterResponse.player_locked)
}
inline const ::google::protobuf::RepeatedField< bool >&
CMsgDOTAFantasyTeamRosterResponse::player_locked() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAFantasyTeamRosterResponse.player_locked)
  return player_locked_;
}
inline ::google::protobuf::RepeatedField< bool >*
CMsgDOTAFantasyTeamRosterResponse::mutable_player_locked() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAFantasyTeamRosterResponse.player_locked)
  return &player_locked_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerHisoricalStatsRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerHisoricalStatsRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsRequest.fantasy_league_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator

// optional uint32 matches = 1;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_matches() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_matches() {
  matches_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::matches() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.matches)
  return matches_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_matches(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  matches_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.matches)
}

// optional float levels = 2;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_levels() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_levels() {
  levels_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::levels() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.levels)
  return levels_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_levels(float value) {
  _has_bits_[0] |= 0x00000002u;
  levels_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.levels)
}

// optional float kills = 3;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_kills() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_kills() {
  kills_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::kills() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.kills)
  return kills_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_kills(float value) {
  _has_bits_[0] |= 0x00000004u;
  kills_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.kills)
}

// optional float deaths = 4;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_deaths() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_deaths() {
  deaths_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::deaths() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.deaths)
  return deaths_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_deaths(float value) {
  _has_bits_[0] |= 0x00000008u;
  deaths_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.deaths)
}

// optional float assists = 5;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_assists() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_assists() {
  assists_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::assists() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.assists)
  return assists_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_assists(float value) {
  _has_bits_[0] |= 0x00000010u;
  assists_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.assists)
}

// optional float last_hits = 6;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_last_hits() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_last_hits() {
  last_hits_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::last_hits() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.last_hits)
  return last_hits_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_last_hits(float value) {
  _has_bits_[0] |= 0x00000020u;
  last_hits_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.last_hits)
}

// optional float denies = 7;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_denies() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_denies() {
  denies_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::denies() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.denies)
  return denies_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_denies(float value) {
  _has_bits_[0] |= 0x00000040u;
  denies_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.denies)
}

// optional float gpm = 8;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_gpm() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_gpm() {
  gpm_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::gpm() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.gpm)
  return gpm_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_gpm(float value) {
  _has_bits_[0] |= 0x00000080u;
  gpm_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.gpm)
}

// optional float xppm = 9;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_xppm() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_xppm() {
  xppm_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::xppm() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.xppm)
  return xppm_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_xppm(float value) {
  _has_bits_[0] |= 0x00000100u;
  xppm_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.xppm)
}

// optional float stuns = 10;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_stuns() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_stuns() {
  stuns_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::stuns() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.stuns)
  return stuns_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_stuns(float value) {
  _has_bits_[0] |= 0x00000200u;
  stuns_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.stuns)
}

// optional float healing = 11;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_healing() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_healing() {
  healing_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::healing() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.healing)
  return healing_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_healing(float value) {
  _has_bits_[0] |= 0x00000400u;
  healing_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.healing)
}

// optional float tower_kills = 12;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_tower_kills() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_tower_kills() {
  tower_kills_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::tower_kills() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.tower_kills)
  return tower_kills_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_tower_kills(float value) {
  _has_bits_[0] |= 0x00000800u;
  tower_kills_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.tower_kills)
}

// optional float roshan_kills = 13;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_roshan_kills() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_roshan_kills() {
  roshan_kills_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::roshan_kills() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.roshan_kills)
  return roshan_kills_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_roshan_kills(float value) {
  _has_bits_[0] |= 0x00001000u;
  roshan_kills_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.roshan_kills)
}

// optional float score = 14;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::has_score() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::clear_score() {
  score_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline float CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::score() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.score)
  return score_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::set_score(float value) {
  _has_bits_[0] |= 0x00002000u;
  score_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator.score)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats

// optional uint32 account_id = 1;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::has_account_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::clear_account_id() {
  account_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.account_id)
  return account_id_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::set_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.account_id)
}

// optional uint32 weeks = 2;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::has_weeks() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::clear_weeks() {
  weeks_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::weeks() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.weeks)
  return weeks_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::set_weeks(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  weeks_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.weeks)
}

// optional .proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator stats_premium = 4;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::has_stats_premium() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::clear_stats_premium() {
  if (stats_premium_ != nullptr) stats_premium_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator& CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::stats_premium() const {
  const ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* p = stats_premium_;
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.stats_premium)
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator*>(
      &::proto::dota::_CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator_default_instance_);
}
inline ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::release_stats_premium() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.stats_premium)
  _has_bits_[0] &= ~0x00000001u;
  ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* temp = stats_premium_;
  stats_premium_ = nullptr;
  return temp;
}
inline ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::mutable_stats_premium() {
  _has_bits_[0] |= 0x00000001u;
  if (stats_premium_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator>(GetArenaNoVirtual());
    stats_premium_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.stats_premium)
  return stats_premium_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::set_allocated_stats_premium(::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* stats_premium) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete stats_premium_;
  }
  if (stats_premium) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      stats_premium = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stats_premium, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  stats_premium_ = stats_premium;
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.stats_premium)
}

// optional .proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator stats_professional = 5;
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::has_stats_professional() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::clear_stats_professional() {
  if (stats_professional_ != nullptr) stats_professional_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator& CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::stats_professional() const {
  const ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* p = stats_professional_;
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.stats_professional)
  return p != nullptr ? *p : *reinterpret_cast<const ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator*>(
      &::proto::dota::_CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator_default_instance_);
}
inline ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::release_stats_professional() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.stats_professional)
  _has_bits_[0] &= ~0x00000002u;
  ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* temp = stats_professional_;
  stats_professional_ = nullptr;
  return temp;
}
inline ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::mutable_stats_professional() {
  _has_bits_[0] |= 0x00000002u;
  if (stats_professional_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator>(GetArenaNoVirtual());
    stats_professional_ = p;
  }
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.stats_professional)
  return stats_professional_;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::set_allocated_stats_professional(::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator* stats_professional) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete stats_professional_;
  }
  if (stats_professional) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      stats_professional = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stats_professional, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  stats_professional_ = stats_professional;
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats.stats_professional)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerHisoricalStatsResponse

// optional .proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyPlayerHisoricalStatsResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult CMsgDOTAFantasyPlayerHisoricalStatsResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.result)
  return static_cast< ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse::set_result(::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult value) {
  assert(::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.result)
}

// repeated .proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats stats = 2;
inline int CMsgDOTAFantasyPlayerHisoricalStatsResponse::stats_size() const {
  return stats_.size();
}
inline void CMsgDOTAFantasyPlayerHisoricalStatsResponse::clear_stats() {
  stats_.Clear();
}
inline ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats* CMsgDOTAFantasyPlayerHisoricalStatsResponse::mutable_stats(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.stats)
  return stats_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats >*
CMsgDOTAFantasyPlayerHisoricalStatsResponse::mutable_stats() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.stats)
  return &stats_;
}
inline const ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats& CMsgDOTAFantasyPlayerHisoricalStatsResponse::stats(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.stats)
  return stats_.Get(index);
}
inline ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats* CMsgDOTAFantasyPlayerHisoricalStatsResponse::add_stats() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.stats)
  return stats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats >&
CMsgDOTAFantasyPlayerHisoricalStatsResponse::stats() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAFantasyPlayerHisoricalStatsResponse.stats)
  return stats_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyMessageAdd

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyMessageAdd::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyMessageAdd::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyMessageAdd::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyMessageAdd.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyMessageAdd::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyMessageAdd.fantasy_league_id)
}

// optional string message = 2;
inline bool CMsgDOTAFantasyMessageAdd::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyMessageAdd::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTAFantasyMessageAdd::message() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyMessageAdd.message)
  return message_.GetNoArena();
}
inline void CMsgDOTAFantasyMessageAdd::set_message(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyMessageAdd.message)
}
#if LANG_CXX11
inline void CMsgDOTAFantasyMessageAdd::set_message(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAFantasyMessageAdd.message)
}
#endif
inline void CMsgDOTAFantasyMessageAdd::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAFantasyMessageAdd.message)
}
inline void CMsgDOTAFantasyMessageAdd::set_message(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAFantasyMessageAdd.message)
}
inline ::std::string* CMsgDOTAFantasyMessageAdd::mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyMessageAdd.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAFantasyMessageAdd::release_message() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAFantasyMessageAdd.message)
  if (!has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAFantasyMessageAdd::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAFantasyMessageAdd.message)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyMessagesRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyMessagesRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyMessagesRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyMessagesRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyMessagesRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyMessagesRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyMessagesRequest.fantasy_league_id)
}

// optional uint32 start_message = 2;
inline bool CMsgDOTAFantasyMessagesRequest::has_start_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyMessagesRequest::clear_start_message() {
  start_message_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyMessagesRequest::start_message() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyMessagesRequest.start_message)
  return start_message_;
}
inline void CMsgDOTAFantasyMessagesRequest::set_start_message(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  start_message_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyMessagesRequest.start_message)
}

// optional uint32 end_message = 3;
inline bool CMsgDOTAFantasyMessagesRequest::has_end_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyMessagesRequest::clear_end_message() {
  end_message_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyMessagesRequest::end_message() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyMessagesRequest.end_message)
  return end_message_;
}
inline void CMsgDOTAFantasyMessagesRequest::set_end_message(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  end_message_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyMessagesRequest.end_message)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyMessagesResponse_Message

// optional uint32 message_id = 1;
inline bool CMsgDOTAFantasyMessagesResponse_Message::has_message_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyMessagesResponse_Message::clear_message_id() {
  message_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyMessagesResponse_Message::message_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyMessagesResponse.Message.message_id)
  return message_id_;
}
inline void CMsgDOTAFantasyMessagesResponse_Message::set_message_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  message_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyMessagesResponse.Message.message_id)
}

// optional string message = 2;
inline bool CMsgDOTAFantasyMessagesResponse_Message::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyMessagesResponse_Message::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTAFantasyMessagesResponse_Message::message() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyMessagesResponse.Message.message)
  return message_.GetNoArena();
}
inline void CMsgDOTAFantasyMessagesResponse_Message::set_message(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyMessagesResponse.Message.message)
}
#if LANG_CXX11
inline void CMsgDOTAFantasyMessagesResponse_Message::set_message(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAFantasyMessagesResponse.Message.message)
}
#endif
inline void CMsgDOTAFantasyMessagesResponse_Message::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAFantasyMessagesResponse.Message.message)
}
inline void CMsgDOTAFantasyMessagesResponse_Message::set_message(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAFantasyMessagesResponse.Message.message)
}
inline ::std::string* CMsgDOTAFantasyMessagesResponse_Message::mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyMessagesResponse.Message.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAFantasyMessagesResponse_Message::release_message() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAFantasyMessagesResponse.Message.message)
  if (!has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAFantasyMessagesResponse_Message::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAFantasyMessagesResponse.Message.message)
}

// optional uint32 author_account_id = 3;
inline bool CMsgDOTAFantasyMessagesResponse_Message::has_author_account_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyMessagesResponse_Message::clear_author_account_id() {
  author_account_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyMessagesResponse_Message::author_account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyMessagesResponse.Message.author_account_id)
  return author_account_id_;
}
inline void CMsgDOTAFantasyMessagesResponse_Message::set_author_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  author_account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyMessagesResponse.Message.author_account_id)
}

// optional uint32 time = 4;
inline bool CMsgDOTAFantasyMessagesResponse_Message::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyMessagesResponse_Message::clear_time() {
  time_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyMessagesResponse_Message::time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyMessagesResponse.Message.time)
  return time_;
}
inline void CMsgDOTAFantasyMessagesResponse_Message::set_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyMessagesResponse.Message.time)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyMessagesResponse

// optional .proto.dota.CMsgDOTAFantasyMessagesResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyMessagesResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyMessagesResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgDOTAFantasyMessagesResponse_EResult CMsgDOTAFantasyMessagesResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyMessagesResponse.result)
  return static_cast< ::proto::dota::CMsgDOTAFantasyMessagesResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyMessagesResponse::set_result(::proto::dota::CMsgDOTAFantasyMessagesResponse_EResult value) {
  assert(::proto::dota::CMsgDOTAFantasyMessagesResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyMessagesResponse.result)
}

// repeated .proto.dota.CMsgDOTAFantasyMessagesResponse.Message messages = 2;
inline int CMsgDOTAFantasyMessagesResponse::messages_size() const {
  return messages_.size();
}
inline void CMsgDOTAFantasyMessagesResponse::clear_messages() {
  messages_.Clear();
}
inline ::proto::dota::CMsgDOTAFantasyMessagesResponse_Message* CMsgDOTAFantasyMessagesResponse::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyMessagesResponse.messages)
  return messages_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyMessagesResponse_Message >*
CMsgDOTAFantasyMessagesResponse::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAFantasyMessagesResponse.messages)
  return &messages_;
}
inline const ::proto::dota::CMsgDOTAFantasyMessagesResponse_Message& CMsgDOTAFantasyMessagesResponse::messages(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyMessagesResponse.messages)
  return messages_.Get(index);
}
inline ::proto::dota::CMsgDOTAFantasyMessagesResponse_Message* CMsgDOTAFantasyMessagesResponse::add_messages() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAFantasyMessagesResponse.messages)
  return messages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyMessagesResponse_Message >&
CMsgDOTAFantasyMessagesResponse::messages() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAFantasyMessagesResponse.messages)
  return messages_;
}

// optional uint32 num_total_messages = 3;
inline bool CMsgDOTAFantasyMessagesResponse::has_num_total_messages() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyMessagesResponse::clear_num_total_messages() {
  num_total_messages_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyMessagesResponse::num_total_messages() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyMessagesResponse.num_total_messages)
  return num_total_messages_;
}
inline void CMsgDOTAFantasyMessagesResponse::set_num_total_messages(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  num_total_messages_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyMessagesResponse.num_total_messages)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyRemoveOwner

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyRemoveOwner::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyRemoveOwner::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyRemoveOwner::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyRemoveOwner.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyRemoveOwner::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyRemoveOwner.fantasy_league_id)
}

// optional uint32 owner_account_id = 2;
inline bool CMsgDOTAFantasyRemoveOwner::has_owner_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyRemoveOwner::clear_owner_account_id() {
  owner_account_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyRemoveOwner::owner_account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyRemoveOwner.owner_account_id)
  return owner_account_id_;
}
inline void CMsgDOTAFantasyRemoveOwner::set_owner_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  owner_account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyRemoveOwner.owner_account_id)
}

// optional uint32 team_index = 3;
inline bool CMsgDOTAFantasyRemoveOwner::has_team_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyRemoveOwner::clear_team_index() {
  team_index_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyRemoveOwner::team_index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyRemoveOwner.team_index)
  return team_index_;
}
inline void CMsgDOTAFantasyRemoveOwner::set_team_index(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  team_index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyRemoveOwner.team_index)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyRemoveOwnerResponse

// optional .proto.dota.CMsgDOTAFantasyRemoveOwnerResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyRemoveOwnerResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyRemoveOwnerResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgDOTAFantasyRemoveOwnerResponse_EResult CMsgDOTAFantasyRemoveOwnerResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyRemoveOwnerResponse.result)
  return static_cast< ::proto::dota::CMsgDOTAFantasyRemoveOwnerResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyRemoveOwnerResponse::set_result(::proto::dota::CMsgDOTAFantasyRemoveOwnerResponse_EResult value) {
  assert(::proto::dota::CMsgDOTAFantasyRemoveOwnerResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyRemoveOwnerResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyScheduledMatchesRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyScheduledMatchesRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyScheduledMatchesRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyScheduledMatchesRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyScheduledMatchesRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyScheduledMatchesRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyScheduledMatchesRequest.fantasy_league_id)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays

// optional uint32 timestamp = 1;
inline bool CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::clear_timestamp() {
  timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::timestamp() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.timestamp)
  return timestamp_;
}
inline void CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::set_timestamp(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.timestamp)
}

// repeated uint32 team_ids = 2;
inline int CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::team_ids_size() const {
  return team_ids_.size();
}
inline void CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::clear_team_ids() {
  team_ids_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::team_ids(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.team_ids)
  return team_ids_.Get(index);
}
inline void CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::set_team_ids(int index, ::google::protobuf::uint32 value) {
  team_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.team_ids)
}
inline void CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::add_team_ids(::google::protobuf::uint32 value) {
  team_ids_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.team_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::team_ids() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.team_ids)
  return team_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::mutable_team_ids() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.team_ids)
  return &team_ids_;
}

// repeated uint32 league_ids = 3;
inline int CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::league_ids_size() const {
  return league_ids_.size();
}
inline void CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::clear_league_ids() {
  league_ids_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::league_ids(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.league_ids)
  return league_ids_.Get(index);
}
inline void CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::set_league_ids(int index, ::google::protobuf::uint32 value) {
  league_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.league_ids)
}
inline void CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::add_league_ids(::google::protobuf::uint32 value) {
  league_ids_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.league_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::league_ids() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.league_ids)
  return league_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::mutable_league_ids() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays.league_ids)
  return &league_ids_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyScheduledMatchesResponse

// optional .proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyScheduledMatchesResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyScheduledMatchesResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgDOTAFantasyScheduledMatchesResponse_EResult CMsgDOTAFantasyScheduledMatchesResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.result)
  return static_cast< ::proto::dota::CMsgDOTAFantasyScheduledMatchesResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyScheduledMatchesResponse::set_result(::proto::dota::CMsgDOTAFantasyScheduledMatchesResponse_EResult value) {
  assert(::proto::dota::CMsgDOTAFantasyScheduledMatchesResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.result)
}

// repeated .proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays scheduled_match_days = 2;
inline int CMsgDOTAFantasyScheduledMatchesResponse::scheduled_match_days_size() const {
  return scheduled_match_days_.size();
}
inline void CMsgDOTAFantasyScheduledMatchesResponse::clear_scheduled_match_days() {
  scheduled_match_days_.Clear();
}
inline ::proto::dota::CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays* CMsgDOTAFantasyScheduledMatchesResponse::mutable_scheduled_match_days(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.scheduled_match_days)
  return scheduled_match_days_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays >*
CMsgDOTAFantasyScheduledMatchesResponse::mutable_scheduled_match_days() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.scheduled_match_days)
  return &scheduled_match_days_;
}
inline const ::proto::dota::CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays& CMsgDOTAFantasyScheduledMatchesResponse::scheduled_match_days(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.scheduled_match_days)
  return scheduled_match_days_.Get(index);
}
inline ::proto::dota::CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays* CMsgDOTAFantasyScheduledMatchesResponse::add_scheduled_match_days() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.scheduled_match_days)
  return scheduled_match_days_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays >&
CMsgDOTAFantasyScheduledMatchesResponse::scheduled_match_days() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAFantasyScheduledMatchesResponse.scheduled_match_days)
  return scheduled_match_days_;
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeaveLeagueRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyLeaveLeagueRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeaveLeagueRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeaveLeagueRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeaveLeagueRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyLeaveLeagueRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeaveLeagueRequest.fantasy_league_id)
}

// optional uint32 fantasy_team_index = 2;
inline bool CMsgDOTAFantasyLeaveLeagueRequest::has_fantasy_team_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyLeaveLeagueRequest::clear_fantasy_team_index() {
  fantasy_team_index_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyLeaveLeagueRequest::fantasy_team_index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeaveLeagueRequest.fantasy_team_index)
  return fantasy_team_index_;
}
inline void CMsgDOTAFantasyLeaveLeagueRequest::set_fantasy_team_index(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  fantasy_team_index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeaveLeagueRequest.fantasy_team_index)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyLeaveLeagueResponse

// optional .proto.dota.CMsgDOTAFantasyLeaveLeagueResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyLeaveLeagueResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyLeaveLeagueResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgDOTAFantasyLeaveLeagueResponse_EResult CMsgDOTAFantasyLeaveLeagueResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyLeaveLeagueResponse.result)
  return static_cast< ::proto::dota::CMsgDOTAFantasyLeaveLeagueResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyLeaveLeagueResponse::set_result(::proto::dota::CMsgDOTAFantasyLeaveLeagueResponse_EResult value) {
  assert(::proto::dota::CMsgDOTAFantasyLeaveLeagueResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyLeaveLeagueResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerScoreDetailsRequest

// optional uint32 fantasy_league_id = 1;
inline bool CMsgDOTAFantasyPlayerScoreDetailsRequest::has_fantasy_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsRequest::clear_fantasy_league_id() {
  fantasy_league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreDetailsRequest::fantasy_league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsRequest.fantasy_league_id)
  return fantasy_league_id_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsRequest::set_fantasy_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsRequest.fantasy_league_id)
}

// optional uint32 player_account_id = 2;
inline bool CMsgDOTAFantasyPlayerScoreDetailsRequest::has_player_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsRequest::clear_player_account_id() {
  player_account_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreDetailsRequest::player_account_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsRequest.player_account_id)
  return player_account_id_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsRequest::set_player_account_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  player_account_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsRequest.player_account_id)
}

// optional uint32 start_time = 3;
inline bool CMsgDOTAFantasyPlayerScoreDetailsRequest::has_start_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsRequest::clear_start_time() {
  start_time_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreDetailsRequest::start_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsRequest.start_time)
  return start_time_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsRequest::set_start_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  start_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsRequest.start_time)
}

// optional uint32 end_time = 4;
inline bool CMsgDOTAFantasyPlayerScoreDetailsRequest::has_end_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsRequest::clear_end_time() {
  end_time_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreDetailsRequest::end_time() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsRequest.end_time)
  return end_time_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsRequest::set_end_time(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  end_time_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsRequest.end_time)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData

// optional uint64 match_id = 1;
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::has_match_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_match_id() {
  match_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::match_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.match_id)
  return match_id_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_match_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  match_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.match_id)
}

// optional uint32 series_id = 2;
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::has_series_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_series_id() {
  series_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::series_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.series_id)
  return series_id_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_series_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  series_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.series_id)
}

// optional uint32 series_num = 3;
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::has_series_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_series_num() {
  series_num_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::series_num() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.series_num)
  return series_num_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_series_num(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  series_num_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.series_num)
}

// optional uint32 series_type = 4;
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::has_series_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_series_type() {
  series_type_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::series_type() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.series_type)
  return series_type_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_series_type(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  series_type_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.series_type)
}

// optional uint32 league_tier = 5;
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::has_league_tier() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_league_tier() {
  league_tier_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::league_tier() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.league_tier)
  return league_tier_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_league_tier(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  league_tier_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.league_tier)
}

// optional uint32 league_id = 6;
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::has_league_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_league_id() {
  league_id_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.league_id)
  return league_id_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.league_id)
}

// optional uint32 opposing_team_id = 7;
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::has_opposing_team_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_opposing_team_id() {
  opposing_team_id_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::opposing_team_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.opposing_team_id)
  return opposing_team_id_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_opposing_team_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  opposing_team_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.opposing_team_id)
}

// optional uint64 opposing_team_logo = 8;
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::has_opposing_team_logo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_opposing_team_logo() {
  opposing_team_logo_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint64 CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::opposing_team_logo() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.opposing_team_logo)
  return opposing_team_logo_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_opposing_team_logo(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000100u;
  opposing_team_logo_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.opposing_team_logo)
}

// optional string opposing_team_name = 9;
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::has_opposing_team_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_opposing_team_name() {
  opposing_team_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::opposing_team_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.opposing_team_name)
  return opposing_team_name_.GetNoArena();
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_opposing_team_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  opposing_team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.opposing_team_name)
}
#if LANG_CXX11
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_opposing_team_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  opposing_team_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.opposing_team_name)
}
#endif
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_opposing_team_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  opposing_team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.opposing_team_name)
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_opposing_team_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  opposing_team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.opposing_team_name)
}
inline ::std::string* CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::mutable_opposing_team_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.opposing_team_name)
  return opposing_team_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::release_opposing_team_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.opposing_team_name)
  if (!has_opposing_team_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return opposing_team_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_allocated_opposing_team_name(::std::string* opposing_team_name) {
  if (opposing_team_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  opposing_team_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), opposing_team_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.opposing_team_name)
}

// optional uint32 owned_by = 11;
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::has_owned_by() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_owned_by() {
  owned_by_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::owned_by() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.owned_by)
  return owned_by_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_owned_by(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  owned_by_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.owned_by)
}

// optional bool benched = 12;
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::has_benched() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::clear_benched() {
  benched_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::benched() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.benched)
  return benched_;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::set_benched(bool value) {
  _has_bits_[0] |= 0x00000400u;
  benched_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData.benched)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyPlayerScoreDetailsResponse

// optional .proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.EResult result = 1 [default = SUCCESS];
inline bool CMsgDOTAFantasyPlayerScoreDetailsResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult CMsgDOTAFantasyPlayerScoreDetailsResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.result)
  return static_cast< ::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult >(result_);
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse::set_result(::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult value) {
  assert(::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.result)
}

// repeated .proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData data = 2;
inline int CMsgDOTAFantasyPlayerScoreDetailsResponse::data_size() const {
  return data_.size();
}
inline void CMsgDOTAFantasyPlayerScoreDetailsResponse::clear_data() {
  data_.Clear();
}
inline ::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData* CMsgDOTAFantasyPlayerScoreDetailsResponse::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.data)
  return data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData >*
CMsgDOTAFantasyPlayerScoreDetailsResponse::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.data)
  return &data_;
}
inline const ::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData& CMsgDOTAFantasyPlayerScoreDetailsResponse::data(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.data)
  return data_.Get(index);
}
inline ::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData* CMsgDOTAFantasyPlayerScoreDetailsResponse::add_data() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData >&
CMsgDOTAFantasyPlayerScoreDetailsResponse::data() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAFantasyPlayerScoreDetailsResponse.data)
  return data_;
}

// -------------------------------------------------------------------

// CMsgDOTAPassportVoteTeamGuess

// optional uint32 league_id = 1;
inline bool CMsgDOTAPassportVoteTeamGuess::has_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAPassportVoteTeamGuess::clear_league_id() {
  league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAPassportVoteTeamGuess::league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPassportVoteTeamGuess.league_id)
  return league_id_;
}
inline void CMsgDOTAPassportVoteTeamGuess::set_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPassportVoteTeamGuess.league_id)
}

// optional uint32 winner_id = 2;
inline bool CMsgDOTAPassportVoteTeamGuess::has_winner_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAPassportVoteTeamGuess::clear_winner_id() {
  winner_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAPassportVoteTeamGuess::winner_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPassportVoteTeamGuess.winner_id)
  return winner_id_;
}
inline void CMsgDOTAPassportVoteTeamGuess::set_winner_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  winner_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPassportVoteTeamGuess.winner_id)
}

// optional uint32 runnerup_id = 3;
inline bool CMsgDOTAPassportVoteTeamGuess::has_runnerup_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAPassportVoteTeamGuess::clear_runnerup_id() {
  runnerup_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAPassportVoteTeamGuess::runnerup_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPassportVoteTeamGuess.runnerup_id)
  return runnerup_id_;
}
inline void CMsgDOTAPassportVoteTeamGuess::set_runnerup_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  runnerup_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPassportVoteTeamGuess.runnerup_id)
}

// -------------------------------------------------------------------

// CMsgDOTAPassportVoteGenericSelection

// optional .proto.dota.DOTA_2013PassportSelectionIndices selection_index = 1 [default = PP13_SEL_ALLSTAR_PLAYER_0];
inline bool CMsgDOTAPassportVoteGenericSelection::has_selection_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAPassportVoteGenericSelection::clear_selection_index() {
  selection_index_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::DOTA_2013PassportSelectionIndices CMsgDOTAPassportVoteGenericSelection::selection_index() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPassportVoteGenericSelection.selection_index)
  return static_cast< ::proto::dota::DOTA_2013PassportSelectionIndices >(selection_index_);
}
inline void CMsgDOTAPassportVoteGenericSelection::set_selection_index(::proto::dota::DOTA_2013PassportSelectionIndices value) {
  assert(::proto::dota::DOTA_2013PassportSelectionIndices_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  selection_index_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPassportVoteGenericSelection.selection_index)
}

// optional uint32 selection = 2;
inline bool CMsgDOTAPassportVoteGenericSelection::has_selection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAPassportVoteGenericSelection::clear_selection() {
  selection_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAPassportVoteGenericSelection::selection() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPassportVoteGenericSelection.selection)
  return selection_;
}
inline void CMsgDOTAPassportVoteGenericSelection::set_selection(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  selection_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPassportVoteGenericSelection.selection)
}

// -------------------------------------------------------------------

// CMsgDOTAPassportStampedPlayer

// optional uint64 steam_id = 1;
inline bool CMsgDOTAPassportStampedPlayer::has_steam_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAPassportStampedPlayer::clear_steam_id() {
  steam_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 CMsgDOTAPassportStampedPlayer::steam_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPassportStampedPlayer.steam_id)
  return steam_id_;
}
inline void CMsgDOTAPassportStampedPlayer::set_steam_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  steam_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPassportStampedPlayer.steam_id)
}

// optional uint32 stamp_level = 2;
inline bool CMsgDOTAPassportStampedPlayer::has_stamp_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAPassportStampedPlayer::clear_stamp_level() {
  stamp_level_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAPassportStampedPlayer::stamp_level() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPassportStampedPlayer.stamp_level)
  return stamp_level_;
}
inline void CMsgDOTAPassportStampedPlayer::set_stamp_level(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  stamp_level_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPassportStampedPlayer.stamp_level)
}

// -------------------------------------------------------------------

// CMsgDOTAPassportPlayerCardChallenge

// optional uint32 challenge_id = 1;
inline bool CMsgDOTAPassportPlayerCardChallenge::has_challenge_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAPassportPlayerCardChallenge::clear_challenge_id() {
  challenge_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgDOTAPassportPlayerCardChallenge::challenge_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPassportPlayerCardChallenge.challenge_id)
  return challenge_id_;
}
inline void CMsgDOTAPassportPlayerCardChallenge::set_challenge_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  challenge_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAPassportPlayerCardChallenge.challenge_id)
}

// -------------------------------------------------------------------

// CMsgDOTAPassportVote

// repeated .proto.dota.CMsgDOTAPassportVoteTeamGuess team_votes = 1;
inline int CMsgDOTAPassportVote::team_votes_size() const {
  return team_votes_.size();
}
inline void CMsgDOTAPassportVote::clear_team_votes() {
  team_votes_.Clear();
}
inline ::proto::dota::CMsgDOTAPassportVoteTeamGuess* CMsgDOTAPassportVote::mutable_team_votes(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAPassportVote.team_votes)
  return team_votes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPassportVoteTeamGuess >*
CMsgDOTAPassportVote::mutable_team_votes() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAPassportVote.team_votes)
  return &team_votes_;
}
inline const ::proto::dota::CMsgDOTAPassportVoteTeamGuess& CMsgDOTAPassportVote::team_votes(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPassportVote.team_votes)
  return team_votes_.Get(index);
}
inline ::proto::dota::CMsgDOTAPassportVoteTeamGuess* CMsgDOTAPassportVote::add_team_votes() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAPassportVote.team_votes)
  return team_votes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPassportVoteTeamGuess >&
CMsgDOTAPassportVote::team_votes() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAPassportVote.team_votes)
  return team_votes_;
}

// repeated .proto.dota.CMsgDOTAPassportVoteGenericSelection generic_selections = 2;
inline int CMsgDOTAPassportVote::generic_selections_size() const {
  return generic_selections_.size();
}
inline void CMsgDOTAPassportVote::clear_generic_selections() {
  generic_selections_.Clear();
}
inline ::proto::dota::CMsgDOTAPassportVoteGenericSelection* CMsgDOTAPassportVote::mutable_generic_selections(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAPassportVote.generic_selections)
  return generic_selections_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPassportVoteGenericSelection >*
CMsgDOTAPassportVote::mutable_generic_selections() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAPassportVote.generic_selections)
  return &generic_selections_;
}
inline const ::proto::dota::CMsgDOTAPassportVoteGenericSelection& CMsgDOTAPassportVote::generic_selections(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPassportVote.generic_selections)
  return generic_selections_.Get(index);
}
inline ::proto::dota::CMsgDOTAPassportVoteGenericSelection* CMsgDOTAPassportVote::add_generic_selections() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAPassportVote.generic_selections)
  return generic_selections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPassportVoteGenericSelection >&
CMsgDOTAPassportVote::generic_selections() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAPassportVote.generic_selections)
  return generic_selections_;
}

// repeated .proto.dota.CMsgDOTAPassportStampedPlayer stamped_players = 3;
inline int CMsgDOTAPassportVote::stamped_players_size() const {
  return stamped_players_.size();
}
inline void CMsgDOTAPassportVote::clear_stamped_players() {
  stamped_players_.Clear();
}
inline ::proto::dota::CMsgDOTAPassportStampedPlayer* CMsgDOTAPassportVote::mutable_stamped_players(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAPassportVote.stamped_players)
  return stamped_players_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPassportStampedPlayer >*
CMsgDOTAPassportVote::mutable_stamped_players() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAPassportVote.stamped_players)
  return &stamped_players_;
}
inline const ::proto::dota::CMsgDOTAPassportStampedPlayer& CMsgDOTAPassportVote::stamped_players(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPassportVote.stamped_players)
  return stamped_players_.Get(index);
}
inline ::proto::dota::CMsgDOTAPassportStampedPlayer* CMsgDOTAPassportVote::add_stamped_players() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAPassportVote.stamped_players)
  return stamped_players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPassportStampedPlayer >&
CMsgDOTAPassportVote::stamped_players() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAPassportVote.stamped_players)
  return stamped_players_;
}

// repeated .proto.dota.CMsgDOTAPassportPlayerCardChallenge player_card_challenges = 4;
inline int CMsgDOTAPassportVote::player_card_challenges_size() const {
  return player_card_challenges_.size();
}
inline void CMsgDOTAPassportVote::clear_player_card_challenges() {
  player_card_challenges_.Clear();
}
inline ::proto::dota::CMsgDOTAPassportPlayerCardChallenge* CMsgDOTAPassportVote::mutable_player_card_challenges(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAPassportVote.player_card_challenges)
  return player_card_challenges_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPassportPlayerCardChallenge >*
CMsgDOTAPassportVote::mutable_player_card_challenges() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAPassportVote.player_card_challenges)
  return &player_card_challenges_;
}
inline const ::proto::dota::CMsgDOTAPassportPlayerCardChallenge& CMsgDOTAPassportVote::player_card_challenges(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAPassportVote.player_card_challenges)
  return player_card_challenges_.Get(index);
}
inline ::proto::dota::CMsgDOTAPassportPlayerCardChallenge* CMsgDOTAPassportVote::add_player_card_challenges() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAPassportVote.player_card_challenges)
  return player_card_challenges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAPassportPlayerCardChallenge >&
CMsgDOTAPassportVote::player_card_challenges() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAPassportVote.player_card_challenges)
  return player_card_challenges_;
}

// -------------------------------------------------------------------

// CMsgClientToGCGetPlayerCardRosterRequest

// optional uint32 league_id = 1;
inline bool CMsgClientToGCGetPlayerCardRosterRequest::has_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientToGCGetPlayerCardRosterRequest::clear_league_id() {
  league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgClientToGCGetPlayerCardRosterRequest::league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgClientToGCGetPlayerCardRosterRequest.league_id)
  return league_id_;
}
inline void CMsgClientToGCGetPlayerCardRosterRequest::set_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgClientToGCGetPlayerCardRosterRequest.league_id)
}

// optional uint32 timestamp = 2;
inline bool CMsgClientToGCGetPlayerCardRosterRequest::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientToGCGetPlayerCardRosterRequest::clear_timestamp() {
  timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgClientToGCGetPlayerCardRosterRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgClientToGCGetPlayerCardRosterRequest.timestamp)
  return timestamp_;
}
inline void CMsgClientToGCGetPlayerCardRosterRequest::set_timestamp(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgClientToGCGetPlayerCardRosterRequest.timestamp)
}

// -------------------------------------------------------------------

// CMsgClientToGCGetPlayerCardRosterResponse

// optional .proto.dota.CMsgClientToGCGetPlayerCardRosterResponse.Result result = 1 [default = SUCCESS];
inline bool CMsgClientToGCGetPlayerCardRosterResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgClientToGCGetPlayerCardRosterResponse_Result CMsgClientToGCGetPlayerCardRosterResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgClientToGCGetPlayerCardRosterResponse.result)
  return static_cast< ::proto::dota::CMsgClientToGCGetPlayerCardRosterResponse_Result >(result_);
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::set_result(::proto::dota::CMsgClientToGCGetPlayerCardRosterResponse_Result value) {
  assert(::proto::dota::CMsgClientToGCGetPlayerCardRosterResponse_Result_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgClientToGCGetPlayerCardRosterResponse.result)
}

// repeated uint64 player_card_item_id = 2;
inline int CMsgClientToGCGetPlayerCardRosterResponse::player_card_item_id_size() const {
  return player_card_item_id_.size();
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::clear_player_card_item_id() {
  player_card_item_id_.Clear();
}
inline ::google::protobuf::uint64 CMsgClientToGCGetPlayerCardRosterResponse::player_card_item_id(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgClientToGCGetPlayerCardRosterResponse.player_card_item_id)
  return player_card_item_id_.Get(index);
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::set_player_card_item_id(int index, ::google::protobuf::uint64 value) {
  player_card_item_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgClientToGCGetPlayerCardRosterResponse.player_card_item_id)
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::add_player_card_item_id(::google::protobuf::uint64 value) {
  player_card_item_id_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgClientToGCGetPlayerCardRosterResponse.player_card_item_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CMsgClientToGCGetPlayerCardRosterResponse::player_card_item_id() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgClientToGCGetPlayerCardRosterResponse.player_card_item_id)
  return player_card_item_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CMsgClientToGCGetPlayerCardRosterResponse::mutable_player_card_item_id() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgClientToGCGetPlayerCardRosterResponse.player_card_item_id)
  return &player_card_item_id_;
}

// optional float score = 3;
inline bool CMsgClientToGCGetPlayerCardRosterResponse::has_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::clear_score() {
  score_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float CMsgClientToGCGetPlayerCardRosterResponse::score() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgClientToGCGetPlayerCardRosterResponse.score)
  return score_;
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::set_score(float value) {
  _has_bits_[0] |= 0x00000002u;
  score_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgClientToGCGetPlayerCardRosterResponse.score)
}

// optional bool finalized = 4;
inline bool CMsgClientToGCGetPlayerCardRosterResponse::has_finalized() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::clear_finalized() {
  finalized_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CMsgClientToGCGetPlayerCardRosterResponse::finalized() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgClientToGCGetPlayerCardRosterResponse.finalized)
  return finalized_;
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::set_finalized(bool value) {
  _has_bits_[0] |= 0x00000004u;
  finalized_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgClientToGCGetPlayerCardRosterResponse.finalized)
}

// optional float percentile = 5;
inline bool CMsgClientToGCGetPlayerCardRosterResponse::has_percentile() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::clear_percentile() {
  percentile_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float CMsgClientToGCGetPlayerCardRosterResponse::percentile() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgClientToGCGetPlayerCardRosterResponse.percentile)
  return percentile_;
}
inline void CMsgClientToGCGetPlayerCardRosterResponse::set_percentile(float value) {
  _has_bits_[0] |= 0x00000008u;
  percentile_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgClientToGCGetPlayerCardRosterResponse.percentile)
}

// -------------------------------------------------------------------

// CMsgClientToGCSetPlayerCardRosterRequest

// optional uint32 league_id = 1;
inline bool CMsgClientToGCSetPlayerCardRosterRequest::has_league_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::clear_league_id() {
  league_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CMsgClientToGCSetPlayerCardRosterRequest::league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgClientToGCSetPlayerCardRosterRequest.league_id)
  return league_id_;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::set_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgClientToGCSetPlayerCardRosterRequest.league_id)
}

// optional uint32 timestamp = 2;
inline bool CMsgClientToGCSetPlayerCardRosterRequest::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::clear_timestamp() {
  timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgClientToGCSetPlayerCardRosterRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgClientToGCSetPlayerCardRosterRequest.timestamp)
  return timestamp_;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::set_timestamp(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgClientToGCSetPlayerCardRosterRequest.timestamp)
}

// optional uint32 slot = 3;
inline bool CMsgClientToGCSetPlayerCardRosterRequest::has_slot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::clear_slot() {
  slot_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgClientToGCSetPlayerCardRosterRequest::slot() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgClientToGCSetPlayerCardRosterRequest.slot)
  return slot_;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::set_slot(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  slot_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgClientToGCSetPlayerCardRosterRequest.slot)
}

// optional uint64 player_card_item_id = 4;
inline bool CMsgClientToGCSetPlayerCardRosterRequest::has_player_card_item_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::clear_player_card_item_id() {
  player_card_item_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 CMsgClientToGCSetPlayerCardRosterRequest::player_card_item_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgClientToGCSetPlayerCardRosterRequest.player_card_item_id)
  return player_card_item_id_;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::set_player_card_item_id(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  player_card_item_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgClientToGCSetPlayerCardRosterRequest.player_card_item_id)
}

// optional uint32 event_id = 5;
inline bool CMsgClientToGCSetPlayerCardRosterRequest::has_event_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::clear_event_id() {
  event_id_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 CMsgClientToGCSetPlayerCardRosterRequest::event_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgClientToGCSetPlayerCardRosterRequest.event_id)
  return event_id_;
}
inline void CMsgClientToGCSetPlayerCardRosterRequest::set_event_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  event_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgClientToGCSetPlayerCardRosterRequest.event_id)
}

// -------------------------------------------------------------------

// CMsgClientToGCSetPlayerCardRosterResponse

// optional .proto.dota.CMsgClientToGCSetPlayerCardRosterResponse.Result result = 1 [default = SUCCESS];
inline bool CMsgClientToGCSetPlayerCardRosterResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientToGCSetPlayerCardRosterResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::proto::dota::CMsgClientToGCSetPlayerCardRosterResponse_Result CMsgClientToGCSetPlayerCardRosterResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgClientToGCSetPlayerCardRosterResponse.result)
  return static_cast< ::proto::dota::CMsgClientToGCSetPlayerCardRosterResponse_Result >(result_);
}
inline void CMsgClientToGCSetPlayerCardRosterResponse::set_result(::proto::dota::CMsgClientToGCSetPlayerCardRosterResponse_Result value) {
  assert(::proto::dota::CMsgClientToGCSetPlayerCardRosterResponse_Result_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgClientToGCSetPlayerCardRosterResponse.result)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo

// optional uint32 league_id = 1;
inline bool CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::has_league_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::clear_league_id() {
  league_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::league_id() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.league_id)
  return league_id_;
}
inline void CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::set_league_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  league_id_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.league_id)
}

// optional string league_name = 2;
inline bool CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::has_league_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::clear_league_name() {
  league_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::league_name() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.league_name)
  return league_name_.GetNoArena();
}
inline void CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::set_league_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  league_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.league_name)
}
#if LANG_CXX11
inline void CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::set_league_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  league_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.league_name)
}
#endif
inline void CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::set_league_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  league_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.league_name)
}
inline void CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::set_league_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  league_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.league_name)
}
inline ::std::string* CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::mutable_league_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.league_name)
  return league_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::release_league_name() {
  // @@protoc_insertion_point(field_release:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.league_name)
  if (!has_league_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return league_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::set_allocated_league_name(::std::string* league_name) {
  if (league_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  league_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), league_name);
  // @@protoc_insertion_point(field_set_allocated:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.league_name)
}

// optional uint32 start_timestamp = 3;
inline bool CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::has_start_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::clear_start_timestamp() {
  start_timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::start_timestamp() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.start_timestamp)
  return start_timestamp_;
}
inline void CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::set_start_timestamp(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  start_timestamp_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.start_timestamp)
}

// optional uint32 end_timestamp = 4;
inline bool CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::has_end_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::clear_end_timestamp() {
  end_timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::end_timestamp() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.end_timestamp)
  return end_timestamp_;
}
inline void CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::set_end_timestamp(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  end_timestamp_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.end_timestamp)
}

// repeated uint32 day_timestamps = 5;
inline int CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::day_timestamps_size() const {
  return day_timestamps_.size();
}
inline void CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::clear_day_timestamps() {
  day_timestamps_.Clear();
}
inline ::google::protobuf::uint32 CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::day_timestamps(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.day_timestamps)
  return day_timestamps_.Get(index);
}
inline void CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::set_day_timestamps(int index, ::google::protobuf::uint32 value) {
  day_timestamps_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.day_timestamps)
}
inline void CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::add_day_timestamps(::google::protobuf::uint32 value) {
  day_timestamps_.Add(value);
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.day_timestamps)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::day_timestamps() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.day_timestamps)
  return day_timestamps_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::mutable_day_timestamps() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.day_timestamps)
  return &day_timestamps_;
}

// optional bool is_qualifier = 6;
inline bool CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::has_is_qualifier() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::clear_is_qualifier() {
  is_qualifier_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::is_qualifier() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.is_qualifier)
  return is_qualifier_;
}
inline void CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::set_is_qualifier(bool value) {
  _has_bits_[0] |= 0x00000010u;
  is_qualifier_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.is_qualifier)
}

// optional .proto.dota.ELeagueFantasyPhase phase = 7 [default = LEAGUE_FANTASY_PHASE_UNSET];
inline bool CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::has_phase() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::clear_phase() {
  phase_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::proto::dota::ELeagueFantasyPhase CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::phase() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.phase)
  return static_cast< ::proto::dota::ELeagueFantasyPhase >(phase_);
}
inline void CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::set_phase(::proto::dota::ELeagueFantasyPhase value) {
  assert(::proto::dota::ELeagueFantasyPhase_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  phase_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.phase)
}

// optional .proto.dota.CMsgDOTAFantasyDPCLeagueStatus.ERosterStatus status = 8 [default = UNSET];
inline bool CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::proto::dota::CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::status() const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.status)
  return static_cast< ::proto::dota::CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus >(status_);
}
inline void CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo::set_status(::proto::dota::CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus value) {
  assert(::proto::dota::CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  status_ = value;
  // @@protoc_insertion_point(field_set:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo.status)
}

// -------------------------------------------------------------------

// CMsgDOTAFantasyDPCLeagueStatus

// repeated .proto.dota.CMsgDOTAFantasyDPCLeagueStatus.LeagueInfo league_infos = 1;
inline int CMsgDOTAFantasyDPCLeagueStatus::league_infos_size() const {
  return league_infos_.size();
}
inline void CMsgDOTAFantasyDPCLeagueStatus::clear_league_infos() {
  league_infos_.Clear();
}
inline ::proto::dota::CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo* CMsgDOTAFantasyDPCLeagueStatus::mutable_league_infos(int index) {
  // @@protoc_insertion_point(field_mutable:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.league_infos)
  return league_infos_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo >*
CMsgDOTAFantasyDPCLeagueStatus::mutable_league_infos() {
  // @@protoc_insertion_point(field_mutable_list:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.league_infos)
  return &league_infos_;
}
inline const ::proto::dota::CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo& CMsgDOTAFantasyDPCLeagueStatus::league_infos(int index) const {
  // @@protoc_insertion_point(field_get:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.league_infos)
  return league_infos_.Get(index);
}
inline ::proto::dota::CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo* CMsgDOTAFantasyDPCLeagueStatus::add_league_infos() {
  // @@protoc_insertion_point(field_add:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.league_infos)
  return league_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::dota::CMsgDOTAFantasyDPCLeagueStatus_LeagueInfo >&
CMsgDOTAFantasyDPCLeagueStatus::league_infos() const {
  // @@protoc_insertion_point(field_list:proto.dota.CMsgDOTAFantasyDPCLeagueStatus.league_infos)
  return league_infos_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace dota
}  // namespace proto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::proto::dota::CMsgDOTACreateFantasyLeagueResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTACreateFantasyLeagueResponse_EResult>() {
  return ::proto::dota::CMsgDOTACreateFantasyLeagueResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAFantasyLeagueEditInfoResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAFantasyLeagueEditInfoResponse_EResult>() {
  return ::proto::dota::CMsgDOTAFantasyLeagueEditInfoResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAFantasyLeagueFindResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAFantasyLeagueFindResponse_EResult>() {
  return ::proto::dota::CMsgDOTAFantasyLeagueFindResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAFantasyLeagueInfoResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAFantasyLeagueInfoResponse_EResult>() {
  return ::proto::dota::CMsgDOTAFantasyLeagueInfoResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_EResult>() {
  return ::proto::dota::CMsgDOTAFantasyLeagueMatchupsResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAEditFantasyTeamResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAEditFantasyTeamResponse_EResult>() {
  return ::proto::dota::CMsgDOTAEditFantasyTeamResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAFantasyTeamScoreResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAFantasyTeamScoreResponse_EResult>() {
  return ::proto::dota::CMsgDOTAFantasyTeamScoreResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAFantasyTeamStandingsResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAFantasyTeamStandingsResponse_EResult>() {
  return ::proto::dota::CMsgDOTAFantasyTeamStandingsResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAFantasyPlayerScoreResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAFantasyPlayerScoreResponse_EResult>() {
  return ::proto::dota::CMsgDOTAFantasyPlayerScoreResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAFantasyPlayerStandingsResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAFantasyPlayerStandingsResponse_EResult>() {
  return ::proto::dota::CMsgDOTAFantasyPlayerStandingsResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAFantasyLeagueCreateResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAFantasyLeagueCreateResponse_EResult>() {
  return ::proto::dota::CMsgDOTAFantasyLeagueCreateResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAFantasyTeamCreateResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAFantasyTeamCreateResponse_EResult>() {
  return ::proto::dota::CMsgDOTAFantasyTeamCreateResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAFantasyLeagueEditInvitesResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAFantasyLeagueEditInvitesResponse_EResult>() {
  return ::proto::dota::CMsgDOTAFantasyLeagueEditInvitesResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult>() {
  return ::proto::dota::CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAFantasyTeamRosterSwapResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAFantasyTeamRosterSwapResponse_EResult>() {
  return ::proto::dota::CMsgDOTAFantasyTeamRosterSwapResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAFantasyTeamRosterAddDropResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAFantasyTeamRosterAddDropResponse_EResult>() {
  return ::proto::dota::CMsgDOTAFantasyTeamRosterAddDropResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAFantasyTeamTradesResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAFantasyTeamTradesResponse_EResult>() {
  return ::proto::dota::CMsgDOTAFantasyTeamTradesResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAFantasyTeamTradeCancelResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAFantasyTeamTradeCancelResponse_EResult>() {
  return ::proto::dota::CMsgDOTAFantasyTeamTradeCancelResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAFantasyTeamRosterResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAFantasyTeamRosterResponse_EResult>() {
  return ::proto::dota::CMsgDOTAFantasyTeamRosterResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult>() {
  return ::proto::dota::CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAFantasyMessagesResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAFantasyMessagesResponse_EResult>() {
  return ::proto::dota::CMsgDOTAFantasyMessagesResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAFantasyRemoveOwnerResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAFantasyRemoveOwnerResponse_EResult>() {
  return ::proto::dota::CMsgDOTAFantasyRemoveOwnerResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAFantasyScheduledMatchesResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAFantasyScheduledMatchesResponse_EResult>() {
  return ::proto::dota::CMsgDOTAFantasyScheduledMatchesResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAFantasyLeaveLeagueResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAFantasyLeaveLeagueResponse_EResult>() {
  return ::proto::dota::CMsgDOTAFantasyLeaveLeagueResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult>() {
  return ::proto::dota::CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgClientToGCGetPlayerCardRosterResponse_Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgClientToGCGetPlayerCardRosterResponse_Result>() {
  return ::proto::dota::CMsgClientToGCGetPlayerCardRosterResponse_Result_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgClientToGCSetPlayerCardRosterResponse_Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgClientToGCSetPlayerCardRosterResponse_Result>() {
  return ::proto::dota::CMsgClientToGCSetPlayerCardRosterResponse_Result_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus>() {
  return ::proto::dota::CMsgDOTAFantasyDPCLeagueStatus_ERosterStatus_descriptor();
}
template <> struct is_proto_enum< ::proto::dota::DOTA_2013PassportSelectionIndices> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::dota::DOTA_2013PassportSelectionIndices>() {
  return ::proto::dota::DOTA_2013PassportSelectionIndices_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_dota_5fgcmessages_5fclient_5ffantasy_2eproto
